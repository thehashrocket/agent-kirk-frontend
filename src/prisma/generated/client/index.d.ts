
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model ClientSatisfaction
 * 
 */
export type ClientSatisfaction = $Result.DefaultSelection<Prisma.$ClientSatisfactionPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model GaAccount
 * 
 */
export type GaAccount = $Result.DefaultSelection<Prisma.$GaAccountPayload>
/**
 * Model GaProperty
 * 
 */
export type GaProperty = $Result.DefaultSelection<Prisma.$GaPropertyPayload>
/**
 * Model GaImportRun
 * 
 */
export type GaImportRun = $Result.DefaultSelection<Prisma.$GaImportRunPayload>
/**
 * Model GaKpiDaily
 * 
 */
export type GaKpiDaily = $Result.DefaultSelection<Prisma.$GaKpiDailyPayload>
/**
 * Model GaKpiMonthly
 * 
 */
export type GaKpiMonthly = $Result.DefaultSelection<Prisma.$GaKpiMonthlyPayload>
/**
 * Model GaChannelDaily
 * 
 */
export type GaChannelDaily = $Result.DefaultSelection<Prisma.$GaChannelDailyPayload>
/**
 * Model GaSourceDaily
 * 
 */
export type GaSourceDaily = $Result.DefaultSelection<Prisma.$GaSourceDailyPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ParsedPieGraphData
 * 
 */
export type ParsedPieGraphData = $Result.DefaultSelection<Prisma.$ParsedPieGraphDataPayload>
/**
 * Model ParsedQueryData
 * 
 */
export type ParsedQueryData = $Result.DefaultSelection<Prisma.$ParsedQueryDataPayload>
/**
 * Model ParsedQuerySummary
 * 
 */
export type ParsedQuerySummary = $Result.DefaultSelection<Prisma.$ParsedQuerySummaryPayload>
/**
 * Model Query
 * 
 */
export type Query = $Result.DefaultSelection<Prisma.$QueryPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketAttachment
 * 
 */
export type TicketAttachment = $Result.DefaultSelection<Prisma.$TicketAttachmentPayload>
/**
 * Model TicketComment
 * 
 */
export type TicketComment = $Result.DefaultSelection<Prisma.$TicketCommentPayload>
/**
 * Model TicketTag
 * 
 */
export type TicketTag = $Result.DefaultSelection<Prisma.$TicketTagPayload>
/**
 * Model MessageAttachment
 * 
 */
export type MessageAttachment = $Result.DefaultSelection<Prisma.$MessageAttachmentPayload>
/**
 * Model ClientActivity
 * 
 */
export type ClientActivity = $Result.DefaultSelection<Prisma.$ClientActivityPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ImportStatus: {
  queued: 'queued',
  ok: 'ok',
  error: 'error'
};

export type ImportStatus = (typeof ImportStatus)[keyof typeof ImportStatus]


export const TicketStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const TicketPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const ActivityStatus: {
  SUCCESS: 'SUCCESS',
  ERROR: 'ERROR',
  PENDING: 'PENDING'
};

export type ActivityStatus = (typeof ActivityStatus)[keyof typeof ActivityStatus]


export const QueryStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type QueryStatus = (typeof QueryStatus)[keyof typeof QueryStatus]


export const NotificationType: {
  SYSTEM: 'SYSTEM',
  MESSAGE: 'MESSAGE',
  QUERY_COMPLETE: 'QUERY_COMPLETE',
  REPORT_GENERATED: 'REPORT_GENERATED'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type ImportStatus = $Enums.ImportStatus

export const ImportStatus: typeof $Enums.ImportStatus

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type ActivityStatus = $Enums.ActivityStatus

export const ActivityStatus: typeof $Enums.ActivityStatus

export type QueryStatus = $Enums.QueryStatus

export const QueryStatus: typeof $Enums.QueryStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientSatisfaction`: Exposes CRUD operations for the **ClientSatisfaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientSatisfactions
    * const clientSatisfactions = await prisma.clientSatisfaction.findMany()
    * ```
    */
  get clientSatisfaction(): Prisma.ClientSatisfactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaAccount`: Exposes CRUD operations for the **GaAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaAccounts
    * const gaAccounts = await prisma.gaAccount.findMany()
    * ```
    */
  get gaAccount(): Prisma.GaAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaProperty`: Exposes CRUD operations for the **GaProperty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaProperties
    * const gaProperties = await prisma.gaProperty.findMany()
    * ```
    */
  get gaProperty(): Prisma.GaPropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaImportRun`: Exposes CRUD operations for the **GaImportRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaImportRuns
    * const gaImportRuns = await prisma.gaImportRun.findMany()
    * ```
    */
  get gaImportRun(): Prisma.GaImportRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaKpiDaily`: Exposes CRUD operations for the **GaKpiDaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaKpiDailies
    * const gaKpiDailies = await prisma.gaKpiDaily.findMany()
    * ```
    */
  get gaKpiDaily(): Prisma.GaKpiDailyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaKpiMonthly`: Exposes CRUD operations for the **GaKpiMonthly** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaKpiMonthlies
    * const gaKpiMonthlies = await prisma.gaKpiMonthly.findMany()
    * ```
    */
  get gaKpiMonthly(): Prisma.GaKpiMonthlyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaChannelDaily`: Exposes CRUD operations for the **GaChannelDaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaChannelDailies
    * const gaChannelDailies = await prisma.gaChannelDaily.findMany()
    * ```
    */
  get gaChannelDaily(): Prisma.GaChannelDailyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaSourceDaily`: Exposes CRUD operations for the **GaSourceDaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaSourceDailies
    * const gaSourceDailies = await prisma.gaSourceDaily.findMany()
    * ```
    */
  get gaSourceDaily(): Prisma.GaSourceDailyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parsedPieGraphData`: Exposes CRUD operations for the **ParsedPieGraphData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParsedPieGraphData
    * const parsedPieGraphData = await prisma.parsedPieGraphData.findMany()
    * ```
    */
  get parsedPieGraphData(): Prisma.ParsedPieGraphDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parsedQueryData`: Exposes CRUD operations for the **ParsedQueryData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParsedQueryData
    * const parsedQueryData = await prisma.parsedQueryData.findMany()
    * ```
    */
  get parsedQueryData(): Prisma.ParsedQueryDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parsedQuerySummary`: Exposes CRUD operations for the **ParsedQuerySummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParsedQuerySummaries
    * const parsedQuerySummaries = await prisma.parsedQuerySummary.findMany()
    * ```
    */
  get parsedQuerySummary(): Prisma.ParsedQuerySummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.query`: Exposes CRUD operations for the **Query** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Queries
    * const queries = await prisma.query.findMany()
    * ```
    */
  get query(): Prisma.QueryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketAttachment`: Exposes CRUD operations for the **TicketAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketAttachments
    * const ticketAttachments = await prisma.ticketAttachment.findMany()
    * ```
    */
  get ticketAttachment(): Prisma.TicketAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketComment`: Exposes CRUD operations for the **TicketComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketComments
    * const ticketComments = await prisma.ticketComment.findMany()
    * ```
    */
  get ticketComment(): Prisma.TicketCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketTag`: Exposes CRUD operations for the **TicketTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketTags
    * const ticketTags = await prisma.ticketTag.findMany()
    * ```
    */
  get ticketTag(): Prisma.TicketTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageAttachment`: Exposes CRUD operations for the **MessageAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageAttachments
    * const messageAttachments = await prisma.messageAttachment.findMany()
    * ```
    */
  get messageAttachment(): Prisma.MessageAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientActivity`: Exposes CRUD operations for the **ClientActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientActivities
    * const clientActivities = await prisma.clientActivity.findMany()
    * ```
    */
  get clientActivity(): Prisma.ClientActivityDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    ClientSatisfaction: 'ClientSatisfaction',
    Conversation: 'Conversation',
    GaAccount: 'GaAccount',
    GaProperty: 'GaProperty',
    GaImportRun: 'GaImportRun',
    GaKpiDaily: 'GaKpiDaily',
    GaKpiMonthly: 'GaKpiMonthly',
    GaChannelDaily: 'GaChannelDaily',
    GaSourceDaily: 'GaSourceDaily',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Role: 'Role',
    Message: 'Message',
    Notification: 'Notification',
    ParsedPieGraphData: 'ParsedPieGraphData',
    ParsedQueryData: 'ParsedQueryData',
    ParsedQuerySummary: 'ParsedQuerySummary',
    Query: 'Query',
    User: 'User',
    UserSettings: 'UserSettings',
    Ticket: 'Ticket',
    TicketAttachment: 'TicketAttachment',
    TicketComment: 'TicketComment',
    TicketTag: 'TicketTag',
    MessageAttachment: 'MessageAttachment',
    ClientActivity: 'ClientActivity'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "clientSatisfaction" | "conversation" | "gaAccount" | "gaProperty" | "gaImportRun" | "gaKpiDaily" | "gaKpiMonthly" | "gaChannelDaily" | "gaSourceDaily" | "session" | "verificationToken" | "role" | "message" | "notification" | "parsedPieGraphData" | "parsedQueryData" | "parsedQuerySummary" | "query" | "user" | "userSettings" | "ticket" | "ticketAttachment" | "ticketComment" | "ticketTag" | "messageAttachment" | "clientActivity"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      ClientSatisfaction: {
        payload: Prisma.$ClientSatisfactionPayload<ExtArgs>
        fields: Prisma.ClientSatisfactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientSatisfactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientSatisfactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          findFirst: {
            args: Prisma.ClientSatisfactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientSatisfactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          findMany: {
            args: Prisma.ClientSatisfactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>[]
          }
          create: {
            args: Prisma.ClientSatisfactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          createMany: {
            args: Prisma.ClientSatisfactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientSatisfactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>[]
          }
          delete: {
            args: Prisma.ClientSatisfactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          update: {
            args: Prisma.ClientSatisfactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          deleteMany: {
            args: Prisma.ClientSatisfactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientSatisfactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientSatisfactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>[]
          }
          upsert: {
            args: Prisma.ClientSatisfactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          aggregate: {
            args: Prisma.ClientSatisfactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientSatisfaction>
          }
          groupBy: {
            args: Prisma.ClientSatisfactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientSatisfactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientSatisfactionCountArgs<ExtArgs>
            result: $Utils.Optional<ClientSatisfactionCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      GaAccount: {
        payload: Prisma.$GaAccountPayload<ExtArgs>
        fields: Prisma.GaAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          findFirst: {
            args: Prisma.GaAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          findMany: {
            args: Prisma.GaAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>[]
          }
          create: {
            args: Prisma.GaAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          createMany: {
            args: Prisma.GaAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>[]
          }
          delete: {
            args: Prisma.GaAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          update: {
            args: Prisma.GaAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          deleteMany: {
            args: Prisma.GaAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>[]
          }
          upsert: {
            args: Prisma.GaAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          aggregate: {
            args: Prisma.GaAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaAccount>
          }
          groupBy: {
            args: Prisma.GaAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaAccountCountArgs<ExtArgs>
            result: $Utils.Optional<GaAccountCountAggregateOutputType> | number
          }
        }
      }
      GaProperty: {
        payload: Prisma.$GaPropertyPayload<ExtArgs>
        fields: Prisma.GaPropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaPropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaPropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          findFirst: {
            args: Prisma.GaPropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaPropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          findMany: {
            args: Prisma.GaPropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>[]
          }
          create: {
            args: Prisma.GaPropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          createMany: {
            args: Prisma.GaPropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaPropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>[]
          }
          delete: {
            args: Prisma.GaPropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          update: {
            args: Prisma.GaPropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          deleteMany: {
            args: Prisma.GaPropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaPropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaPropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>[]
          }
          upsert: {
            args: Prisma.GaPropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          aggregate: {
            args: Prisma.GaPropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaProperty>
          }
          groupBy: {
            args: Prisma.GaPropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaPropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaPropertyCountArgs<ExtArgs>
            result: $Utils.Optional<GaPropertyCountAggregateOutputType> | number
          }
        }
      }
      GaImportRun: {
        payload: Prisma.$GaImportRunPayload<ExtArgs>
        fields: Prisma.GaImportRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaImportRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaImportRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          findFirst: {
            args: Prisma.GaImportRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaImportRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          findMany: {
            args: Prisma.GaImportRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>[]
          }
          create: {
            args: Prisma.GaImportRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          createMany: {
            args: Prisma.GaImportRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaImportRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>[]
          }
          delete: {
            args: Prisma.GaImportRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          update: {
            args: Prisma.GaImportRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          deleteMany: {
            args: Prisma.GaImportRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaImportRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaImportRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>[]
          }
          upsert: {
            args: Prisma.GaImportRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          aggregate: {
            args: Prisma.GaImportRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaImportRun>
          }
          groupBy: {
            args: Prisma.GaImportRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaImportRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaImportRunCountArgs<ExtArgs>
            result: $Utils.Optional<GaImportRunCountAggregateOutputType> | number
          }
        }
      }
      GaKpiDaily: {
        payload: Prisma.$GaKpiDailyPayload<ExtArgs>
        fields: Prisma.GaKpiDailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaKpiDailyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaKpiDailyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          findFirst: {
            args: Prisma.GaKpiDailyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaKpiDailyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          findMany: {
            args: Prisma.GaKpiDailyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>[]
          }
          create: {
            args: Prisma.GaKpiDailyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          createMany: {
            args: Prisma.GaKpiDailyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaKpiDailyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>[]
          }
          delete: {
            args: Prisma.GaKpiDailyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          update: {
            args: Prisma.GaKpiDailyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          deleteMany: {
            args: Prisma.GaKpiDailyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaKpiDailyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaKpiDailyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>[]
          }
          upsert: {
            args: Prisma.GaKpiDailyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          aggregate: {
            args: Prisma.GaKpiDailyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaKpiDaily>
          }
          groupBy: {
            args: Prisma.GaKpiDailyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaKpiDailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaKpiDailyCountArgs<ExtArgs>
            result: $Utils.Optional<GaKpiDailyCountAggregateOutputType> | number
          }
        }
      }
      GaKpiMonthly: {
        payload: Prisma.$GaKpiMonthlyPayload<ExtArgs>
        fields: Prisma.GaKpiMonthlyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaKpiMonthlyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaKpiMonthlyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          findFirst: {
            args: Prisma.GaKpiMonthlyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaKpiMonthlyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          findMany: {
            args: Prisma.GaKpiMonthlyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>[]
          }
          create: {
            args: Prisma.GaKpiMonthlyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          createMany: {
            args: Prisma.GaKpiMonthlyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaKpiMonthlyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>[]
          }
          delete: {
            args: Prisma.GaKpiMonthlyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          update: {
            args: Prisma.GaKpiMonthlyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          deleteMany: {
            args: Prisma.GaKpiMonthlyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaKpiMonthlyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaKpiMonthlyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>[]
          }
          upsert: {
            args: Prisma.GaKpiMonthlyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          aggregate: {
            args: Prisma.GaKpiMonthlyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaKpiMonthly>
          }
          groupBy: {
            args: Prisma.GaKpiMonthlyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaKpiMonthlyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaKpiMonthlyCountArgs<ExtArgs>
            result: $Utils.Optional<GaKpiMonthlyCountAggregateOutputType> | number
          }
        }
      }
      GaChannelDaily: {
        payload: Prisma.$GaChannelDailyPayload<ExtArgs>
        fields: Prisma.GaChannelDailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaChannelDailyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaChannelDailyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          findFirst: {
            args: Prisma.GaChannelDailyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaChannelDailyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          findMany: {
            args: Prisma.GaChannelDailyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>[]
          }
          create: {
            args: Prisma.GaChannelDailyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          createMany: {
            args: Prisma.GaChannelDailyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaChannelDailyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>[]
          }
          delete: {
            args: Prisma.GaChannelDailyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          update: {
            args: Prisma.GaChannelDailyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          deleteMany: {
            args: Prisma.GaChannelDailyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaChannelDailyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaChannelDailyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>[]
          }
          upsert: {
            args: Prisma.GaChannelDailyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          aggregate: {
            args: Prisma.GaChannelDailyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaChannelDaily>
          }
          groupBy: {
            args: Prisma.GaChannelDailyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaChannelDailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaChannelDailyCountArgs<ExtArgs>
            result: $Utils.Optional<GaChannelDailyCountAggregateOutputType> | number
          }
        }
      }
      GaSourceDaily: {
        payload: Prisma.$GaSourceDailyPayload<ExtArgs>
        fields: Prisma.GaSourceDailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaSourceDailyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaSourceDailyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          findFirst: {
            args: Prisma.GaSourceDailyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaSourceDailyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          findMany: {
            args: Prisma.GaSourceDailyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>[]
          }
          create: {
            args: Prisma.GaSourceDailyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          createMany: {
            args: Prisma.GaSourceDailyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaSourceDailyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>[]
          }
          delete: {
            args: Prisma.GaSourceDailyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          update: {
            args: Prisma.GaSourceDailyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          deleteMany: {
            args: Prisma.GaSourceDailyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaSourceDailyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaSourceDailyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>[]
          }
          upsert: {
            args: Prisma.GaSourceDailyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          aggregate: {
            args: Prisma.GaSourceDailyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaSourceDaily>
          }
          groupBy: {
            args: Prisma.GaSourceDailyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaSourceDailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaSourceDailyCountArgs<ExtArgs>
            result: $Utils.Optional<GaSourceDailyCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ParsedPieGraphData: {
        payload: Prisma.$ParsedPieGraphDataPayload<ExtArgs>
        fields: Prisma.ParsedPieGraphDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParsedPieGraphDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParsedPieGraphDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          findFirst: {
            args: Prisma.ParsedPieGraphDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParsedPieGraphDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          findMany: {
            args: Prisma.ParsedPieGraphDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>[]
          }
          create: {
            args: Prisma.ParsedPieGraphDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          createMany: {
            args: Prisma.ParsedPieGraphDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParsedPieGraphDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>[]
          }
          delete: {
            args: Prisma.ParsedPieGraphDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          update: {
            args: Prisma.ParsedPieGraphDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          deleteMany: {
            args: Prisma.ParsedPieGraphDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParsedPieGraphDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParsedPieGraphDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>[]
          }
          upsert: {
            args: Prisma.ParsedPieGraphDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          aggregate: {
            args: Prisma.ParsedPieGraphDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParsedPieGraphData>
          }
          groupBy: {
            args: Prisma.ParsedPieGraphDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParsedPieGraphDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParsedPieGraphDataCountArgs<ExtArgs>
            result: $Utils.Optional<ParsedPieGraphDataCountAggregateOutputType> | number
          }
        }
      }
      ParsedQueryData: {
        payload: Prisma.$ParsedQueryDataPayload<ExtArgs>
        fields: Prisma.ParsedQueryDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParsedQueryDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParsedQueryDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          findFirst: {
            args: Prisma.ParsedQueryDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParsedQueryDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          findMany: {
            args: Prisma.ParsedQueryDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>[]
          }
          create: {
            args: Prisma.ParsedQueryDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          createMany: {
            args: Prisma.ParsedQueryDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParsedQueryDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>[]
          }
          delete: {
            args: Prisma.ParsedQueryDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          update: {
            args: Prisma.ParsedQueryDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          deleteMany: {
            args: Prisma.ParsedQueryDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParsedQueryDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParsedQueryDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>[]
          }
          upsert: {
            args: Prisma.ParsedQueryDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          aggregate: {
            args: Prisma.ParsedQueryDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParsedQueryData>
          }
          groupBy: {
            args: Prisma.ParsedQueryDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParsedQueryDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParsedQueryDataCountArgs<ExtArgs>
            result: $Utils.Optional<ParsedQueryDataCountAggregateOutputType> | number
          }
        }
      }
      ParsedQuerySummary: {
        payload: Prisma.$ParsedQuerySummaryPayload<ExtArgs>
        fields: Prisma.ParsedQuerySummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParsedQuerySummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParsedQuerySummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          findFirst: {
            args: Prisma.ParsedQuerySummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParsedQuerySummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          findMany: {
            args: Prisma.ParsedQuerySummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>[]
          }
          create: {
            args: Prisma.ParsedQuerySummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          createMany: {
            args: Prisma.ParsedQuerySummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParsedQuerySummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>[]
          }
          delete: {
            args: Prisma.ParsedQuerySummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          update: {
            args: Prisma.ParsedQuerySummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          deleteMany: {
            args: Prisma.ParsedQuerySummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParsedQuerySummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParsedQuerySummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>[]
          }
          upsert: {
            args: Prisma.ParsedQuerySummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          aggregate: {
            args: Prisma.ParsedQuerySummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParsedQuerySummary>
          }
          groupBy: {
            args: Prisma.ParsedQuerySummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParsedQuerySummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParsedQuerySummaryCountArgs<ExtArgs>
            result: $Utils.Optional<ParsedQuerySummaryCountAggregateOutputType> | number
          }
        }
      }
      Query: {
        payload: Prisma.$QueryPayload<ExtArgs>
        fields: Prisma.QueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          findFirst: {
            args: Prisma.QueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          findMany: {
            args: Prisma.QueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          create: {
            args: Prisma.QueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          createMany: {
            args: Prisma.QueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          delete: {
            args: Prisma.QueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          update: {
            args: Prisma.QueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          deleteMany: {
            args: Prisma.QueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          upsert: {
            args: Prisma.QueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          aggregate: {
            args: Prisma.QueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuery>
          }
          groupBy: {
            args: Prisma.QueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueryCountArgs<ExtArgs>
            result: $Utils.Optional<QueryCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketAttachment: {
        payload: Prisma.$TicketAttachmentPayload<ExtArgs>
        fields: Prisma.TicketAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findFirst: {
            args: Prisma.TicketAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findMany: {
            args: Prisma.TicketAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          create: {
            args: Prisma.TicketAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          createMany: {
            args: Prisma.TicketAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          delete: {
            args: Prisma.TicketAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          update: {
            args: Prisma.TicketAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.TicketAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.TicketAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          aggregate: {
            args: Prisma.TicketAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketAttachment>
          }
          groupBy: {
            args: Prisma.TicketAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentCountAggregateOutputType> | number
          }
        }
      }
      TicketComment: {
        payload: Prisma.$TicketCommentPayload<ExtArgs>
        fields: Prisma.TicketCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findFirst: {
            args: Prisma.TicketCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findMany: {
            args: Prisma.TicketCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          create: {
            args: Prisma.TicketCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          createMany: {
            args: Prisma.TicketCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          delete: {
            args: Prisma.TicketCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          update: {
            args: Prisma.TicketCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          deleteMany: {
            args: Prisma.TicketCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          upsert: {
            args: Prisma.TicketCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          aggregate: {
            args: Prisma.TicketCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketComment>
          }
          groupBy: {
            args: Prisma.TicketCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCommentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentCountAggregateOutputType> | number
          }
        }
      }
      TicketTag: {
        payload: Prisma.$TicketTagPayload<ExtArgs>
        fields: Prisma.TicketTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          findFirst: {
            args: Prisma.TicketTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          findMany: {
            args: Prisma.TicketTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>[]
          }
          create: {
            args: Prisma.TicketTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          createMany: {
            args: Prisma.TicketTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>[]
          }
          delete: {
            args: Prisma.TicketTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          update: {
            args: Prisma.TicketTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          deleteMany: {
            args: Prisma.TicketTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>[]
          }
          upsert: {
            args: Prisma.TicketTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          aggregate: {
            args: Prisma.TicketTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketTag>
          }
          groupBy: {
            args: Prisma.TicketTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketTagCountArgs<ExtArgs>
            result: $Utils.Optional<TicketTagCountAggregateOutputType> | number
          }
        }
      }
      MessageAttachment: {
        payload: Prisma.$MessageAttachmentPayload<ExtArgs>
        fields: Prisma.MessageAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findFirst: {
            args: Prisma.MessageAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findMany: {
            args: Prisma.MessageAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          create: {
            args: Prisma.MessageAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          createMany: {
            args: Prisma.MessageAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          delete: {
            args: Prisma.MessageAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          update: {
            args: Prisma.MessageAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.MessageAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.MessageAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          aggregate: {
            args: Prisma.MessageAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageAttachment>
          }
          groupBy: {
            args: Prisma.MessageAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<MessageAttachmentCountAggregateOutputType> | number
          }
        }
      }
      ClientActivity: {
        payload: Prisma.$ClientActivityPayload<ExtArgs>
        fields: Prisma.ClientActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          findFirst: {
            args: Prisma.ClientActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          findMany: {
            args: Prisma.ClientActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>[]
          }
          create: {
            args: Prisma.ClientActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          createMany: {
            args: Prisma.ClientActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>[]
          }
          delete: {
            args: Prisma.ClientActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          update: {
            args: Prisma.ClientActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          deleteMany: {
            args: Prisma.ClientActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>[]
          }
          upsert: {
            args: Prisma.ClientActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          aggregate: {
            args: Prisma.ClientActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientActivity>
          }
          groupBy: {
            args: Prisma.ClientActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ClientActivityCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    clientSatisfaction?: ClientSatisfactionOmit
    conversation?: ConversationOmit
    gaAccount?: GaAccountOmit
    gaProperty?: GaPropertyOmit
    gaImportRun?: GaImportRunOmit
    gaKpiDaily?: GaKpiDailyOmit
    gaKpiMonthly?: GaKpiMonthlyOmit
    gaChannelDaily?: GaChannelDailyOmit
    gaSourceDaily?: GaSourceDailyOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    role?: RoleOmit
    message?: MessageOmit
    notification?: NotificationOmit
    parsedPieGraphData?: ParsedPieGraphDataOmit
    parsedQueryData?: ParsedQueryDataOmit
    parsedQuerySummary?: ParsedQuerySummaryOmit
    query?: QueryOmit
    user?: UserOmit
    userSettings?: UserSettingsOmit
    ticket?: TicketOmit
    ticketAttachment?: TicketAttachmentOmit
    ticketComment?: TicketCommentOmit
    ticketTag?: TicketTagOmit
    messageAttachment?: MessageAttachmentOmit
    clientActivity?: ClientActivityOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    queries: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    queries?: boolean | ConversationCountOutputTypeCountQueriesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
  }


  /**
   * Count Type GaAccountCountOutputType
   */

  export type GaAccountCountOutputType = {
    gaProperties: number
    conversations: number
  }

  export type GaAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperties?: boolean | GaAccountCountOutputTypeCountGaPropertiesArgs
    conversations?: boolean | GaAccountCountOutputTypeCountConversationsArgs
  }

  // Custom InputTypes
  /**
   * GaAccountCountOutputType without action
   */
  export type GaAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccountCountOutputType
     */
    select?: GaAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GaAccountCountOutputType without action
   */
  export type GaAccountCountOutputTypeCountGaPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaPropertyWhereInput
  }

  /**
   * GaAccountCountOutputType without action
   */
  export type GaAccountCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * Count Type GaPropertyCountOutputType
   */

  export type GaPropertyCountOutputType = {
    conversations: number
    imports: number
    kpiDaily: number
    kpiMonthly: number
    channelDaily: number
    sourceDaily: number
  }

  export type GaPropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | GaPropertyCountOutputTypeCountConversationsArgs
    imports?: boolean | GaPropertyCountOutputTypeCountImportsArgs
    kpiDaily?: boolean | GaPropertyCountOutputTypeCountKpiDailyArgs
    kpiMonthly?: boolean | GaPropertyCountOutputTypeCountKpiMonthlyArgs
    channelDaily?: boolean | GaPropertyCountOutputTypeCountChannelDailyArgs
    sourceDaily?: boolean | GaPropertyCountOutputTypeCountSourceDailyArgs
  }

  // Custom InputTypes
  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaPropertyCountOutputType
     */
    select?: GaPropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaImportRunWhereInput
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountKpiDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaKpiDailyWhereInput
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountKpiMonthlyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaKpiMonthlyWhereInput
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountChannelDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaChannelDailyWhereInput
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountSourceDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaSourceDailyWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    replies: number
    attachments: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | MessageCountOutputTypeCountRepliesArgs
    attachments?: boolean | MessageCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
  }


  /**
   * Count Type QueryCountOutputType
   */

  export type QueryCountOutputType = {
    parsedData: number
    parsedPieData: number
    parsedSummary: number
  }

  export type QueryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parsedData?: boolean | QueryCountOutputTypeCountParsedDataArgs
    parsedPieData?: boolean | QueryCountOutputTypeCountParsedPieDataArgs
    parsedSummary?: boolean | QueryCountOutputTypeCountParsedSummaryArgs
  }

  // Custom InputTypes
  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryCountOutputType
     */
    select?: QueryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeCountParsedDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedQueryDataWhereInput
  }

  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeCountParsedPieDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedPieGraphDataWhereInput
  }

  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeCountParsedSummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedQuerySummaryWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    clients: number
    accounts: number
    sessions: number
    queries: number
    conversations: number
    sentMessages: number
    receivedMessages: number
    notifications: number
    givenRatings: number
    receivedRatings: number
    assignedTickets: number
    clientTickets: number
    ticketComments: number
    activities: number
    gaAccounts: number
    gaImportRuns: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | UserCountOutputTypeCountClientsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    queries?: boolean | UserCountOutputTypeCountQueriesArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    givenRatings?: boolean | UserCountOutputTypeCountGivenRatingsArgs
    receivedRatings?: boolean | UserCountOutputTypeCountReceivedRatingsArgs
    assignedTickets?: boolean | UserCountOutputTypeCountAssignedTicketsArgs
    clientTickets?: boolean | UserCountOutputTypeCountClientTicketsArgs
    ticketComments?: boolean | UserCountOutputTypeCountTicketCommentsArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    gaAccounts?: boolean | UserCountOutputTypeCountGaAccountsArgs
    gaImportRuns?: boolean | UserCountOutputTypeCountGaImportRunsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGivenRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSatisfactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSatisfactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGaAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGaImportRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaImportRunWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    attachments: number
    comments: number
    tags: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | TicketCountOutputTypeCountAttachmentsArgs
    comments?: boolean | TicketCountOutputTypeCountCommentsArgs
    tags?: boolean | TicketCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTagWhereInput
  }


  /**
   * Count Type TicketTagCountOutputType
   */

  export type TicketTagCountOutputType = {
    tickets: number
  }

  export type TicketTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | TicketTagCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * TicketTagCountOutputType without action
   */
  export type TicketTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTagCountOutputType
     */
    select?: TicketTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketTagCountOutputType without action
   */
  export type TicketTagCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model ClientSatisfaction
   */

  export type AggregateClientSatisfaction = {
    _count: ClientSatisfactionCountAggregateOutputType | null
    _avg: ClientSatisfactionAvgAggregateOutputType | null
    _sum: ClientSatisfactionSumAggregateOutputType | null
    _min: ClientSatisfactionMinAggregateOutputType | null
    _max: ClientSatisfactionMaxAggregateOutputType | null
  }

  export type ClientSatisfactionAvgAggregateOutputType = {
    rating: number | null
  }

  export type ClientSatisfactionSumAggregateOutputType = {
    rating: number | null
  }

  export type ClientSatisfactionMinAggregateOutputType = {
    id: string | null
    rating: number | null
    feedback: string | null
    createdAt: Date | null
    userId: string | null
    accountRepId: string | null
  }

  export type ClientSatisfactionMaxAggregateOutputType = {
    id: string | null
    rating: number | null
    feedback: string | null
    createdAt: Date | null
    userId: string | null
    accountRepId: string | null
  }

  export type ClientSatisfactionCountAggregateOutputType = {
    id: number
    rating: number
    feedback: number
    createdAt: number
    userId: number
    accountRepId: number
    _all: number
  }


  export type ClientSatisfactionAvgAggregateInputType = {
    rating?: true
  }

  export type ClientSatisfactionSumAggregateInputType = {
    rating?: true
  }

  export type ClientSatisfactionMinAggregateInputType = {
    id?: true
    rating?: true
    feedback?: true
    createdAt?: true
    userId?: true
    accountRepId?: true
  }

  export type ClientSatisfactionMaxAggregateInputType = {
    id?: true
    rating?: true
    feedback?: true
    createdAt?: true
    userId?: true
    accountRepId?: true
  }

  export type ClientSatisfactionCountAggregateInputType = {
    id?: true
    rating?: true
    feedback?: true
    createdAt?: true
    userId?: true
    accountRepId?: true
    _all?: true
  }

  export type ClientSatisfactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientSatisfaction to aggregate.
     */
    where?: ClientSatisfactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSatisfactions to fetch.
     */
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientSatisfactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSatisfactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSatisfactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientSatisfactions
    **/
    _count?: true | ClientSatisfactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientSatisfactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSatisfactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientSatisfactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientSatisfactionMaxAggregateInputType
  }

  export type GetClientSatisfactionAggregateType<T extends ClientSatisfactionAggregateArgs> = {
        [P in keyof T & keyof AggregateClientSatisfaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientSatisfaction[P]>
      : GetScalarType<T[P], AggregateClientSatisfaction[P]>
  }




  export type ClientSatisfactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSatisfactionWhereInput
    orderBy?: ClientSatisfactionOrderByWithAggregationInput | ClientSatisfactionOrderByWithAggregationInput[]
    by: ClientSatisfactionScalarFieldEnum[] | ClientSatisfactionScalarFieldEnum
    having?: ClientSatisfactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientSatisfactionCountAggregateInputType | true
    _avg?: ClientSatisfactionAvgAggregateInputType
    _sum?: ClientSatisfactionSumAggregateInputType
    _min?: ClientSatisfactionMinAggregateInputType
    _max?: ClientSatisfactionMaxAggregateInputType
  }

  export type ClientSatisfactionGroupByOutputType = {
    id: string
    rating: number
    feedback: string | null
    createdAt: Date
    userId: string
    accountRepId: string
    _count: ClientSatisfactionCountAggregateOutputType | null
    _avg: ClientSatisfactionAvgAggregateOutputType | null
    _sum: ClientSatisfactionSumAggregateOutputType | null
    _min: ClientSatisfactionMinAggregateOutputType | null
    _max: ClientSatisfactionMaxAggregateOutputType | null
  }

  type GetClientSatisfactionGroupByPayload<T extends ClientSatisfactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientSatisfactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientSatisfactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientSatisfactionGroupByOutputType[P]>
            : GetScalarType<T[P], ClientSatisfactionGroupByOutputType[P]>
        }
      >
    >


  export type ClientSatisfactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    userId?: boolean
    accountRepId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSatisfaction"]>

  export type ClientSatisfactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    userId?: boolean
    accountRepId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSatisfaction"]>

  export type ClientSatisfactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    userId?: boolean
    accountRepId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSatisfaction"]>

  export type ClientSatisfactionSelectScalar = {
    id?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    userId?: boolean
    accountRepId?: boolean
  }

  export type ClientSatisfactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rating" | "feedback" | "createdAt" | "userId" | "accountRepId", ExtArgs["result"]["clientSatisfaction"]>
  export type ClientSatisfactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientSatisfactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientSatisfactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientSatisfactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientSatisfaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      accountRep: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rating: number
      feedback: string | null
      createdAt: Date
      userId: string
      accountRepId: string
    }, ExtArgs["result"]["clientSatisfaction"]>
    composites: {}
  }

  type ClientSatisfactionGetPayload<S extends boolean | null | undefined | ClientSatisfactionDefaultArgs> = $Result.GetResult<Prisma.$ClientSatisfactionPayload, S>

  type ClientSatisfactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientSatisfactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientSatisfactionCountAggregateInputType | true
    }

  export interface ClientSatisfactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientSatisfaction'], meta: { name: 'ClientSatisfaction' } }
    /**
     * Find zero or one ClientSatisfaction that matches the filter.
     * @param {ClientSatisfactionFindUniqueArgs} args - Arguments to find a ClientSatisfaction
     * @example
     * // Get one ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientSatisfactionFindUniqueArgs>(args: SelectSubset<T, ClientSatisfactionFindUniqueArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientSatisfaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientSatisfactionFindUniqueOrThrowArgs} args - Arguments to find a ClientSatisfaction
     * @example
     * // Get one ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientSatisfactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientSatisfactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientSatisfaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionFindFirstArgs} args - Arguments to find a ClientSatisfaction
     * @example
     * // Get one ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientSatisfactionFindFirstArgs>(args?: SelectSubset<T, ClientSatisfactionFindFirstArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientSatisfaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionFindFirstOrThrowArgs} args - Arguments to find a ClientSatisfaction
     * @example
     * // Get one ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientSatisfactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientSatisfactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientSatisfactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientSatisfactions
     * const clientSatisfactions = await prisma.clientSatisfaction.findMany()
     * 
     * // Get first 10 ClientSatisfactions
     * const clientSatisfactions = await prisma.clientSatisfaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientSatisfactionWithIdOnly = await prisma.clientSatisfaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientSatisfactionFindManyArgs>(args?: SelectSubset<T, ClientSatisfactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientSatisfaction.
     * @param {ClientSatisfactionCreateArgs} args - Arguments to create a ClientSatisfaction.
     * @example
     * // Create one ClientSatisfaction
     * const ClientSatisfaction = await prisma.clientSatisfaction.create({
     *   data: {
     *     // ... data to create a ClientSatisfaction
     *   }
     * })
     * 
     */
    create<T extends ClientSatisfactionCreateArgs>(args: SelectSubset<T, ClientSatisfactionCreateArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientSatisfactions.
     * @param {ClientSatisfactionCreateManyArgs} args - Arguments to create many ClientSatisfactions.
     * @example
     * // Create many ClientSatisfactions
     * const clientSatisfaction = await prisma.clientSatisfaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientSatisfactionCreateManyArgs>(args?: SelectSubset<T, ClientSatisfactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientSatisfactions and returns the data saved in the database.
     * @param {ClientSatisfactionCreateManyAndReturnArgs} args - Arguments to create many ClientSatisfactions.
     * @example
     * // Create many ClientSatisfactions
     * const clientSatisfaction = await prisma.clientSatisfaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientSatisfactions and only return the `id`
     * const clientSatisfactionWithIdOnly = await prisma.clientSatisfaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientSatisfactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientSatisfactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientSatisfaction.
     * @param {ClientSatisfactionDeleteArgs} args - Arguments to delete one ClientSatisfaction.
     * @example
     * // Delete one ClientSatisfaction
     * const ClientSatisfaction = await prisma.clientSatisfaction.delete({
     *   where: {
     *     // ... filter to delete one ClientSatisfaction
     *   }
     * })
     * 
     */
    delete<T extends ClientSatisfactionDeleteArgs>(args: SelectSubset<T, ClientSatisfactionDeleteArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientSatisfaction.
     * @param {ClientSatisfactionUpdateArgs} args - Arguments to update one ClientSatisfaction.
     * @example
     * // Update one ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientSatisfactionUpdateArgs>(args: SelectSubset<T, ClientSatisfactionUpdateArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientSatisfactions.
     * @param {ClientSatisfactionDeleteManyArgs} args - Arguments to filter ClientSatisfactions to delete.
     * @example
     * // Delete a few ClientSatisfactions
     * const { count } = await prisma.clientSatisfaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientSatisfactionDeleteManyArgs>(args?: SelectSubset<T, ClientSatisfactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientSatisfactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientSatisfactions
     * const clientSatisfaction = await prisma.clientSatisfaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientSatisfactionUpdateManyArgs>(args: SelectSubset<T, ClientSatisfactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientSatisfactions and returns the data updated in the database.
     * @param {ClientSatisfactionUpdateManyAndReturnArgs} args - Arguments to update many ClientSatisfactions.
     * @example
     * // Update many ClientSatisfactions
     * const clientSatisfaction = await prisma.clientSatisfaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientSatisfactions and only return the `id`
     * const clientSatisfactionWithIdOnly = await prisma.clientSatisfaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientSatisfactionUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientSatisfactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientSatisfaction.
     * @param {ClientSatisfactionUpsertArgs} args - Arguments to update or create a ClientSatisfaction.
     * @example
     * // Update or create a ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.upsert({
     *   create: {
     *     // ... data to create a ClientSatisfaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientSatisfaction we want to update
     *   }
     * })
     */
    upsert<T extends ClientSatisfactionUpsertArgs>(args: SelectSubset<T, ClientSatisfactionUpsertArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientSatisfactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionCountArgs} args - Arguments to filter ClientSatisfactions to count.
     * @example
     * // Count the number of ClientSatisfactions
     * const count = await prisma.clientSatisfaction.count({
     *   where: {
     *     // ... the filter for the ClientSatisfactions we want to count
     *   }
     * })
    **/
    count<T extends ClientSatisfactionCountArgs>(
      args?: Subset<T, ClientSatisfactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientSatisfactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientSatisfaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientSatisfactionAggregateArgs>(args: Subset<T, ClientSatisfactionAggregateArgs>): Prisma.PrismaPromise<GetClientSatisfactionAggregateType<T>>

    /**
     * Group by ClientSatisfaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientSatisfactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientSatisfactionGroupByArgs['orderBy'] }
        : { orderBy?: ClientSatisfactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientSatisfactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientSatisfactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientSatisfaction model
   */
  readonly fields: ClientSatisfactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientSatisfaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientSatisfactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    accountRep<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientSatisfaction model
   */
  interface ClientSatisfactionFieldRefs {
    readonly id: FieldRef<"ClientSatisfaction", 'String'>
    readonly rating: FieldRef<"ClientSatisfaction", 'Float'>
    readonly feedback: FieldRef<"ClientSatisfaction", 'String'>
    readonly createdAt: FieldRef<"ClientSatisfaction", 'DateTime'>
    readonly userId: FieldRef<"ClientSatisfaction", 'String'>
    readonly accountRepId: FieldRef<"ClientSatisfaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientSatisfaction findUnique
   */
  export type ClientSatisfactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSatisfaction to fetch.
     */
    where: ClientSatisfactionWhereUniqueInput
  }

  /**
   * ClientSatisfaction findUniqueOrThrow
   */
  export type ClientSatisfactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSatisfaction to fetch.
     */
    where: ClientSatisfactionWhereUniqueInput
  }

  /**
   * ClientSatisfaction findFirst
   */
  export type ClientSatisfactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSatisfaction to fetch.
     */
    where?: ClientSatisfactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSatisfactions to fetch.
     */
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientSatisfactions.
     */
    cursor?: ClientSatisfactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSatisfactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSatisfactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientSatisfactions.
     */
    distinct?: ClientSatisfactionScalarFieldEnum | ClientSatisfactionScalarFieldEnum[]
  }

  /**
   * ClientSatisfaction findFirstOrThrow
   */
  export type ClientSatisfactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSatisfaction to fetch.
     */
    where?: ClientSatisfactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSatisfactions to fetch.
     */
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientSatisfactions.
     */
    cursor?: ClientSatisfactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSatisfactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSatisfactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientSatisfactions.
     */
    distinct?: ClientSatisfactionScalarFieldEnum | ClientSatisfactionScalarFieldEnum[]
  }

  /**
   * ClientSatisfaction findMany
   */
  export type ClientSatisfactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSatisfactions to fetch.
     */
    where?: ClientSatisfactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSatisfactions to fetch.
     */
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientSatisfactions.
     */
    cursor?: ClientSatisfactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSatisfactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSatisfactions.
     */
    skip?: number
    distinct?: ClientSatisfactionScalarFieldEnum | ClientSatisfactionScalarFieldEnum[]
  }

  /**
   * ClientSatisfaction create
   */
  export type ClientSatisfactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientSatisfaction.
     */
    data: XOR<ClientSatisfactionCreateInput, ClientSatisfactionUncheckedCreateInput>
  }

  /**
   * ClientSatisfaction createMany
   */
  export type ClientSatisfactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientSatisfactions.
     */
    data: ClientSatisfactionCreateManyInput | ClientSatisfactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientSatisfaction createManyAndReturn
   */
  export type ClientSatisfactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * The data used to create many ClientSatisfactions.
     */
    data: ClientSatisfactionCreateManyInput | ClientSatisfactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientSatisfaction update
   */
  export type ClientSatisfactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientSatisfaction.
     */
    data: XOR<ClientSatisfactionUpdateInput, ClientSatisfactionUncheckedUpdateInput>
    /**
     * Choose, which ClientSatisfaction to update.
     */
    where: ClientSatisfactionWhereUniqueInput
  }

  /**
   * ClientSatisfaction updateMany
   */
  export type ClientSatisfactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientSatisfactions.
     */
    data: XOR<ClientSatisfactionUpdateManyMutationInput, ClientSatisfactionUncheckedUpdateManyInput>
    /**
     * Filter which ClientSatisfactions to update
     */
    where?: ClientSatisfactionWhereInput
    /**
     * Limit how many ClientSatisfactions to update.
     */
    limit?: number
  }

  /**
   * ClientSatisfaction updateManyAndReturn
   */
  export type ClientSatisfactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * The data used to update ClientSatisfactions.
     */
    data: XOR<ClientSatisfactionUpdateManyMutationInput, ClientSatisfactionUncheckedUpdateManyInput>
    /**
     * Filter which ClientSatisfactions to update
     */
    where?: ClientSatisfactionWhereInput
    /**
     * Limit how many ClientSatisfactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientSatisfaction upsert
   */
  export type ClientSatisfactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientSatisfaction to update in case it exists.
     */
    where: ClientSatisfactionWhereUniqueInput
    /**
     * In case the ClientSatisfaction found by the `where` argument doesn't exist, create a new ClientSatisfaction with this data.
     */
    create: XOR<ClientSatisfactionCreateInput, ClientSatisfactionUncheckedCreateInput>
    /**
     * In case the ClientSatisfaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientSatisfactionUpdateInput, ClientSatisfactionUncheckedUpdateInput>
  }

  /**
   * ClientSatisfaction delete
   */
  export type ClientSatisfactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter which ClientSatisfaction to delete.
     */
    where: ClientSatisfactionWhereUniqueInput
  }

  /**
   * ClientSatisfaction deleteMany
   */
  export type ClientSatisfactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientSatisfactions to delete
     */
    where?: ClientSatisfactionWhereInput
    /**
     * Limit how many ClientSatisfactions to delete.
     */
    limit?: number
  }

  /**
   * ClientSatisfaction without action
   */
  export type ClientSatisfactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    isStarred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    gaAccountId: string | null
    gaPropertyId: string | null
    userId: string | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    isStarred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    gaAccountId: string | null
    gaPropertyId: string | null
    userId: string | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    title: number
    description: number
    isStarred: number
    createdAt: number
    updatedAt: number
    gaAccountId: number
    gaPropertyId: number
    userId: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isStarred?: true
    createdAt?: true
    updatedAt?: true
    gaAccountId?: true
    gaPropertyId?: true
    userId?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isStarred?: true
    createdAt?: true
    updatedAt?: true
    gaAccountId?: true
    gaPropertyId?: true
    userId?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isStarred?: true
    createdAt?: true
    updatedAt?: true
    gaAccountId?: true
    gaPropertyId?: true
    userId?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    title: string
    description: string | null
    isStarred: boolean
    createdAt: Date
    updatedAt: Date
    gaAccountId: string | null
    gaPropertyId: string | null
    userId: string
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isStarred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaAccountId?: boolean
    gaPropertyId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    queries?: boolean | Conversation$queriesArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isStarred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaAccountId?: boolean
    gaPropertyId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isStarred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaAccountId?: boolean
    gaPropertyId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    isStarred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaAccountId?: boolean
    gaPropertyId?: boolean
    userId?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "isStarred" | "createdAt" | "updatedAt" | "gaAccountId" | "gaPropertyId" | "userId", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    queries?: boolean | Conversation$queriesArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      queries: Prisma.$QueryPayload<ExtArgs>[]
      gaAccount: Prisma.$GaAccountPayload<ExtArgs> | null
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      isStarred: boolean
      createdAt: Date
      updatedAt: Date
      gaAccountId: string | null
      gaPropertyId: string | null
      userId: string
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    queries<T extends Conversation$queriesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$queriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gaAccount<T extends Conversation$gaAccountArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$gaAccountArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gaProperty<T extends Conversation$gaPropertyArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$gaPropertyArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly description: FieldRef<"Conversation", 'String'>
    readonly isStarred: FieldRef<"Conversation", 'Boolean'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
    readonly gaAccountId: FieldRef<"Conversation", 'String'>
    readonly gaPropertyId: FieldRef<"Conversation", 'String'>
    readonly userId: FieldRef<"Conversation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.queries
   */
  export type Conversation$queriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    cursor?: QueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Conversation.gaAccount
   */
  export type Conversation$gaAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    where?: GaAccountWhereInput
  }

  /**
   * Conversation.gaProperty
   */
  export type Conversation$gaPropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    where?: GaPropertyWhereInput
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model GaAccount
   */

  export type AggregateGaAccount = {
    _count: GaAccountCountAggregateOutputType | null
    _min: GaAccountMinAggregateOutputType | null
    _max: GaAccountMaxAggregateOutputType | null
  }

  export type GaAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gaAccountId: string | null
    gaAccountName: string | null
  }

  export type GaAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gaAccountId: string | null
    gaAccountName: string | null
  }

  export type GaAccountCountAggregateOutputType = {
    id: number
    userId: number
    gaAccountId: number
    gaAccountName: number
    _all: number
  }


  export type GaAccountMinAggregateInputType = {
    id?: true
    userId?: true
    gaAccountId?: true
    gaAccountName?: true
  }

  export type GaAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    gaAccountId?: true
    gaAccountName?: true
  }

  export type GaAccountCountAggregateInputType = {
    id?: true
    userId?: true
    gaAccountId?: true
    gaAccountName?: true
    _all?: true
  }

  export type GaAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaAccount to aggregate.
     */
    where?: GaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaAccounts to fetch.
     */
    orderBy?: GaAccountOrderByWithRelationInput | GaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaAccounts
    **/
    _count?: true | GaAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaAccountMaxAggregateInputType
  }

  export type GetGaAccountAggregateType<T extends GaAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateGaAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaAccount[P]>
      : GetScalarType<T[P], AggregateGaAccount[P]>
  }




  export type GaAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaAccountWhereInput
    orderBy?: GaAccountOrderByWithAggregationInput | GaAccountOrderByWithAggregationInput[]
    by: GaAccountScalarFieldEnum[] | GaAccountScalarFieldEnum
    having?: GaAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaAccountCountAggregateInputType | true
    _min?: GaAccountMinAggregateInputType
    _max?: GaAccountMaxAggregateInputType
  }

  export type GaAccountGroupByOutputType = {
    id: string
    userId: string
    gaAccountId: string
    gaAccountName: string
    _count: GaAccountCountAggregateOutputType | null
    _min: GaAccountMinAggregateOutputType | null
    _max: GaAccountMaxAggregateOutputType | null
  }

  type GetGaAccountGroupByPayload<T extends GaAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaAccountGroupByOutputType[P]>
            : GetScalarType<T[P], GaAccountGroupByOutputType[P]>
        }
      >
    >


  export type GaAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gaAccountId?: boolean
    gaAccountName?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    gaProperties?: boolean | GaAccount$gaPropertiesArgs<ExtArgs>
    conversations?: boolean | GaAccount$conversationsArgs<ExtArgs>
    _count?: boolean | GaAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaAccount"]>

  export type GaAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gaAccountId?: boolean
    gaAccountName?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaAccount"]>

  export type GaAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gaAccountId?: boolean
    gaAccountName?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaAccount"]>

  export type GaAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    gaAccountId?: boolean
    gaAccountName?: boolean
  }

  export type GaAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "gaAccountId" | "gaAccountName", ExtArgs["result"]["gaAccount"]>
  export type GaAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    gaProperties?: boolean | GaAccount$gaPropertiesArgs<ExtArgs>
    conversations?: boolean | GaAccount$conversationsArgs<ExtArgs>
    _count?: boolean | GaAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GaAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GaAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GaAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      gaProperties: Prisma.$GaPropertyPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      gaAccountId: string
      gaAccountName: string
    }, ExtArgs["result"]["gaAccount"]>
    composites: {}
  }

  type GaAccountGetPayload<S extends boolean | null | undefined | GaAccountDefaultArgs> = $Result.GetResult<Prisma.$GaAccountPayload, S>

  type GaAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaAccountCountAggregateInputType | true
    }

  export interface GaAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaAccount'], meta: { name: 'GaAccount' } }
    /**
     * Find zero or one GaAccount that matches the filter.
     * @param {GaAccountFindUniqueArgs} args - Arguments to find a GaAccount
     * @example
     * // Get one GaAccount
     * const gaAccount = await prisma.gaAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaAccountFindUniqueArgs>(args: SelectSubset<T, GaAccountFindUniqueArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaAccountFindUniqueOrThrowArgs} args - Arguments to find a GaAccount
     * @example
     * // Get one GaAccount
     * const gaAccount = await prisma.gaAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, GaAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountFindFirstArgs} args - Arguments to find a GaAccount
     * @example
     * // Get one GaAccount
     * const gaAccount = await prisma.gaAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaAccountFindFirstArgs>(args?: SelectSubset<T, GaAccountFindFirstArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountFindFirstOrThrowArgs} args - Arguments to find a GaAccount
     * @example
     * // Get one GaAccount
     * const gaAccount = await prisma.gaAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, GaAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaAccounts
     * const gaAccounts = await prisma.gaAccount.findMany()
     * 
     * // Get first 10 GaAccounts
     * const gaAccounts = await prisma.gaAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaAccountWithIdOnly = await prisma.gaAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaAccountFindManyArgs>(args?: SelectSubset<T, GaAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaAccount.
     * @param {GaAccountCreateArgs} args - Arguments to create a GaAccount.
     * @example
     * // Create one GaAccount
     * const GaAccount = await prisma.gaAccount.create({
     *   data: {
     *     // ... data to create a GaAccount
     *   }
     * })
     * 
     */
    create<T extends GaAccountCreateArgs>(args: SelectSubset<T, GaAccountCreateArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaAccounts.
     * @param {GaAccountCreateManyArgs} args - Arguments to create many GaAccounts.
     * @example
     * // Create many GaAccounts
     * const gaAccount = await prisma.gaAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaAccountCreateManyArgs>(args?: SelectSubset<T, GaAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaAccounts and returns the data saved in the database.
     * @param {GaAccountCreateManyAndReturnArgs} args - Arguments to create many GaAccounts.
     * @example
     * // Create many GaAccounts
     * const gaAccount = await prisma.gaAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaAccounts and only return the `id`
     * const gaAccountWithIdOnly = await prisma.gaAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, GaAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaAccount.
     * @param {GaAccountDeleteArgs} args - Arguments to delete one GaAccount.
     * @example
     * // Delete one GaAccount
     * const GaAccount = await prisma.gaAccount.delete({
     *   where: {
     *     // ... filter to delete one GaAccount
     *   }
     * })
     * 
     */
    delete<T extends GaAccountDeleteArgs>(args: SelectSubset<T, GaAccountDeleteArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaAccount.
     * @param {GaAccountUpdateArgs} args - Arguments to update one GaAccount.
     * @example
     * // Update one GaAccount
     * const gaAccount = await prisma.gaAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaAccountUpdateArgs>(args: SelectSubset<T, GaAccountUpdateArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaAccounts.
     * @param {GaAccountDeleteManyArgs} args - Arguments to filter GaAccounts to delete.
     * @example
     * // Delete a few GaAccounts
     * const { count } = await prisma.gaAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaAccountDeleteManyArgs>(args?: SelectSubset<T, GaAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaAccounts
     * const gaAccount = await prisma.gaAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaAccountUpdateManyArgs>(args: SelectSubset<T, GaAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaAccounts and returns the data updated in the database.
     * @param {GaAccountUpdateManyAndReturnArgs} args - Arguments to update many GaAccounts.
     * @example
     * // Update many GaAccounts
     * const gaAccount = await prisma.gaAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaAccounts and only return the `id`
     * const gaAccountWithIdOnly = await prisma.gaAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, GaAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaAccount.
     * @param {GaAccountUpsertArgs} args - Arguments to update or create a GaAccount.
     * @example
     * // Update or create a GaAccount
     * const gaAccount = await prisma.gaAccount.upsert({
     *   create: {
     *     // ... data to create a GaAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaAccount we want to update
     *   }
     * })
     */
    upsert<T extends GaAccountUpsertArgs>(args: SelectSubset<T, GaAccountUpsertArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountCountArgs} args - Arguments to filter GaAccounts to count.
     * @example
     * // Count the number of GaAccounts
     * const count = await prisma.gaAccount.count({
     *   where: {
     *     // ... the filter for the GaAccounts we want to count
     *   }
     * })
    **/
    count<T extends GaAccountCountArgs>(
      args?: Subset<T, GaAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaAccountAggregateArgs>(args: Subset<T, GaAccountAggregateArgs>): Prisma.PrismaPromise<GetGaAccountAggregateType<T>>

    /**
     * Group by GaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaAccountGroupByArgs['orderBy'] }
        : { orderBy?: GaAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaAccount model
   */
  readonly fields: GaAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    gaProperties<T extends GaAccount$gaPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, GaAccount$gaPropertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends GaAccount$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, GaAccount$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaAccount model
   */
  interface GaAccountFieldRefs {
    readonly id: FieldRef<"GaAccount", 'String'>
    readonly userId: FieldRef<"GaAccount", 'String'>
    readonly gaAccountId: FieldRef<"GaAccount", 'String'>
    readonly gaAccountName: FieldRef<"GaAccount", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GaAccount findUnique
   */
  export type GaAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter, which GaAccount to fetch.
     */
    where: GaAccountWhereUniqueInput
  }

  /**
   * GaAccount findUniqueOrThrow
   */
  export type GaAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter, which GaAccount to fetch.
     */
    where: GaAccountWhereUniqueInput
  }

  /**
   * GaAccount findFirst
   */
  export type GaAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter, which GaAccount to fetch.
     */
    where?: GaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaAccounts to fetch.
     */
    orderBy?: GaAccountOrderByWithRelationInput | GaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaAccounts.
     */
    cursor?: GaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaAccounts.
     */
    distinct?: GaAccountScalarFieldEnum | GaAccountScalarFieldEnum[]
  }

  /**
   * GaAccount findFirstOrThrow
   */
  export type GaAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter, which GaAccount to fetch.
     */
    where?: GaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaAccounts to fetch.
     */
    orderBy?: GaAccountOrderByWithRelationInput | GaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaAccounts.
     */
    cursor?: GaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaAccounts.
     */
    distinct?: GaAccountScalarFieldEnum | GaAccountScalarFieldEnum[]
  }

  /**
   * GaAccount findMany
   */
  export type GaAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter, which GaAccounts to fetch.
     */
    where?: GaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaAccounts to fetch.
     */
    orderBy?: GaAccountOrderByWithRelationInput | GaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaAccounts.
     */
    cursor?: GaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaAccounts.
     */
    skip?: number
    distinct?: GaAccountScalarFieldEnum | GaAccountScalarFieldEnum[]
  }

  /**
   * GaAccount create
   */
  export type GaAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a GaAccount.
     */
    data: XOR<GaAccountCreateInput, GaAccountUncheckedCreateInput>
  }

  /**
   * GaAccount createMany
   */
  export type GaAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaAccounts.
     */
    data: GaAccountCreateManyInput | GaAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaAccount createManyAndReturn
   */
  export type GaAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * The data used to create many GaAccounts.
     */
    data: GaAccountCreateManyInput | GaAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaAccount update
   */
  export type GaAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a GaAccount.
     */
    data: XOR<GaAccountUpdateInput, GaAccountUncheckedUpdateInput>
    /**
     * Choose, which GaAccount to update.
     */
    where: GaAccountWhereUniqueInput
  }

  /**
   * GaAccount updateMany
   */
  export type GaAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaAccounts.
     */
    data: XOR<GaAccountUpdateManyMutationInput, GaAccountUncheckedUpdateManyInput>
    /**
     * Filter which GaAccounts to update
     */
    where?: GaAccountWhereInput
    /**
     * Limit how many GaAccounts to update.
     */
    limit?: number
  }

  /**
   * GaAccount updateManyAndReturn
   */
  export type GaAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * The data used to update GaAccounts.
     */
    data: XOR<GaAccountUpdateManyMutationInput, GaAccountUncheckedUpdateManyInput>
    /**
     * Filter which GaAccounts to update
     */
    where?: GaAccountWhereInput
    /**
     * Limit how many GaAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaAccount upsert
   */
  export type GaAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the GaAccount to update in case it exists.
     */
    where: GaAccountWhereUniqueInput
    /**
     * In case the GaAccount found by the `where` argument doesn't exist, create a new GaAccount with this data.
     */
    create: XOR<GaAccountCreateInput, GaAccountUncheckedCreateInput>
    /**
     * In case the GaAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaAccountUpdateInput, GaAccountUncheckedUpdateInput>
  }

  /**
   * GaAccount delete
   */
  export type GaAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter which GaAccount to delete.
     */
    where: GaAccountWhereUniqueInput
  }

  /**
   * GaAccount deleteMany
   */
  export type GaAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaAccounts to delete
     */
    where?: GaAccountWhereInput
    /**
     * Limit how many GaAccounts to delete.
     */
    limit?: number
  }

  /**
   * GaAccount.gaProperties
   */
  export type GaAccount$gaPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    where?: GaPropertyWhereInput
    orderBy?: GaPropertyOrderByWithRelationInput | GaPropertyOrderByWithRelationInput[]
    cursor?: GaPropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaPropertyScalarFieldEnum | GaPropertyScalarFieldEnum[]
  }

  /**
   * GaAccount.conversations
   */
  export type GaAccount$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * GaAccount without action
   */
  export type GaAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
  }


  /**
   * Model GaProperty
   */

  export type AggregateGaProperty = {
    _count: GaPropertyCountAggregateOutputType | null
    _min: GaPropertyMinAggregateOutputType | null
    _max: GaPropertyMaxAggregateOutputType | null
  }

  export type GaPropertyMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    gaPropertyName: string | null
    gaAccountId: string | null
  }

  export type GaPropertyMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    gaPropertyName: string | null
    gaAccountId: string | null
  }

  export type GaPropertyCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    gaPropertyName: number
    gaAccountId: number
    _all: number
  }


  export type GaPropertyMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    gaPropertyName?: true
    gaAccountId?: true
  }

  export type GaPropertyMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    gaPropertyName?: true
    gaAccountId?: true
  }

  export type GaPropertyCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    gaPropertyName?: true
    gaAccountId?: true
    _all?: true
  }

  export type GaPropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaProperty to aggregate.
     */
    where?: GaPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaProperties to fetch.
     */
    orderBy?: GaPropertyOrderByWithRelationInput | GaPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaProperties
    **/
    _count?: true | GaPropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaPropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaPropertyMaxAggregateInputType
  }

  export type GetGaPropertyAggregateType<T extends GaPropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateGaProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaProperty[P]>
      : GetScalarType<T[P], AggregateGaProperty[P]>
  }




  export type GaPropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaPropertyWhereInput
    orderBy?: GaPropertyOrderByWithAggregationInput | GaPropertyOrderByWithAggregationInput[]
    by: GaPropertyScalarFieldEnum[] | GaPropertyScalarFieldEnum
    having?: GaPropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaPropertyCountAggregateInputType | true
    _min?: GaPropertyMinAggregateInputType
    _max?: GaPropertyMaxAggregateInputType
  }

  export type GaPropertyGroupByOutputType = {
    id: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    _count: GaPropertyCountAggregateOutputType | null
    _min: GaPropertyMinAggregateOutputType | null
    _max: GaPropertyMaxAggregateOutputType | null
  }

  type GetGaPropertyGroupByPayload<T extends GaPropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaPropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaPropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaPropertyGroupByOutputType[P]>
            : GetScalarType<T[P], GaPropertyGroupByOutputType[P]>
        }
      >
    >


  export type GaPropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    gaPropertyName?: boolean
    gaAccountId?: boolean
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
    conversations?: boolean | GaProperty$conversationsArgs<ExtArgs>
    imports?: boolean | GaProperty$importsArgs<ExtArgs>
    kpiDaily?: boolean | GaProperty$kpiDailyArgs<ExtArgs>
    kpiMonthly?: boolean | GaProperty$kpiMonthlyArgs<ExtArgs>
    channelDaily?: boolean | GaProperty$channelDailyArgs<ExtArgs>
    sourceDaily?: boolean | GaProperty$sourceDailyArgs<ExtArgs>
    _count?: boolean | GaPropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaProperty"]>

  export type GaPropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    gaPropertyName?: boolean
    gaAccountId?: boolean
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaProperty"]>

  export type GaPropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    gaPropertyName?: boolean
    gaAccountId?: boolean
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaProperty"]>

  export type GaPropertySelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    gaPropertyName?: boolean
    gaAccountId?: boolean
  }

  export type GaPropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "gaPropertyName" | "gaAccountId", ExtArgs["result"]["gaProperty"]>
  export type GaPropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
    conversations?: boolean | GaProperty$conversationsArgs<ExtArgs>
    imports?: boolean | GaProperty$importsArgs<ExtArgs>
    kpiDaily?: boolean | GaProperty$kpiDailyArgs<ExtArgs>
    kpiMonthly?: boolean | GaProperty$kpiMonthlyArgs<ExtArgs>
    channelDaily?: boolean | GaProperty$channelDailyArgs<ExtArgs>
    sourceDaily?: boolean | GaProperty$sourceDailyArgs<ExtArgs>
    _count?: boolean | GaPropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GaPropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
  }
  export type GaPropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
  }

  export type $GaPropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaProperty"
    objects: {
      gaAccount: Prisma.$GaAccountPayload<ExtArgs>
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      imports: Prisma.$GaImportRunPayload<ExtArgs>[]
      kpiDaily: Prisma.$GaKpiDailyPayload<ExtArgs>[]
      kpiMonthly: Prisma.$GaKpiMonthlyPayload<ExtArgs>[]
      channelDaily: Prisma.$GaChannelDailyPayload<ExtArgs>[]
      sourceDaily: Prisma.$GaSourceDailyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      gaPropertyName: string
      gaAccountId: string
    }, ExtArgs["result"]["gaProperty"]>
    composites: {}
  }

  type GaPropertyGetPayload<S extends boolean | null | undefined | GaPropertyDefaultArgs> = $Result.GetResult<Prisma.$GaPropertyPayload, S>

  type GaPropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaPropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaPropertyCountAggregateInputType | true
    }

  export interface GaPropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaProperty'], meta: { name: 'GaProperty' } }
    /**
     * Find zero or one GaProperty that matches the filter.
     * @param {GaPropertyFindUniqueArgs} args - Arguments to find a GaProperty
     * @example
     * // Get one GaProperty
     * const gaProperty = await prisma.gaProperty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaPropertyFindUniqueArgs>(args: SelectSubset<T, GaPropertyFindUniqueArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaProperty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaPropertyFindUniqueOrThrowArgs} args - Arguments to find a GaProperty
     * @example
     * // Get one GaProperty
     * const gaProperty = await prisma.gaProperty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaPropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, GaPropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaProperty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyFindFirstArgs} args - Arguments to find a GaProperty
     * @example
     * // Get one GaProperty
     * const gaProperty = await prisma.gaProperty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaPropertyFindFirstArgs>(args?: SelectSubset<T, GaPropertyFindFirstArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaProperty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyFindFirstOrThrowArgs} args - Arguments to find a GaProperty
     * @example
     * // Get one GaProperty
     * const gaProperty = await prisma.gaProperty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaPropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, GaPropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaProperties
     * const gaProperties = await prisma.gaProperty.findMany()
     * 
     * // Get first 10 GaProperties
     * const gaProperties = await prisma.gaProperty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaPropertyWithIdOnly = await prisma.gaProperty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaPropertyFindManyArgs>(args?: SelectSubset<T, GaPropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaProperty.
     * @param {GaPropertyCreateArgs} args - Arguments to create a GaProperty.
     * @example
     * // Create one GaProperty
     * const GaProperty = await prisma.gaProperty.create({
     *   data: {
     *     // ... data to create a GaProperty
     *   }
     * })
     * 
     */
    create<T extends GaPropertyCreateArgs>(args: SelectSubset<T, GaPropertyCreateArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaProperties.
     * @param {GaPropertyCreateManyArgs} args - Arguments to create many GaProperties.
     * @example
     * // Create many GaProperties
     * const gaProperty = await prisma.gaProperty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaPropertyCreateManyArgs>(args?: SelectSubset<T, GaPropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaProperties and returns the data saved in the database.
     * @param {GaPropertyCreateManyAndReturnArgs} args - Arguments to create many GaProperties.
     * @example
     * // Create many GaProperties
     * const gaProperty = await prisma.gaProperty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaProperties and only return the `id`
     * const gaPropertyWithIdOnly = await prisma.gaProperty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaPropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, GaPropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaProperty.
     * @param {GaPropertyDeleteArgs} args - Arguments to delete one GaProperty.
     * @example
     * // Delete one GaProperty
     * const GaProperty = await prisma.gaProperty.delete({
     *   where: {
     *     // ... filter to delete one GaProperty
     *   }
     * })
     * 
     */
    delete<T extends GaPropertyDeleteArgs>(args: SelectSubset<T, GaPropertyDeleteArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaProperty.
     * @param {GaPropertyUpdateArgs} args - Arguments to update one GaProperty.
     * @example
     * // Update one GaProperty
     * const gaProperty = await prisma.gaProperty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaPropertyUpdateArgs>(args: SelectSubset<T, GaPropertyUpdateArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaProperties.
     * @param {GaPropertyDeleteManyArgs} args - Arguments to filter GaProperties to delete.
     * @example
     * // Delete a few GaProperties
     * const { count } = await prisma.gaProperty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaPropertyDeleteManyArgs>(args?: SelectSubset<T, GaPropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaProperties
     * const gaProperty = await prisma.gaProperty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaPropertyUpdateManyArgs>(args: SelectSubset<T, GaPropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaProperties and returns the data updated in the database.
     * @param {GaPropertyUpdateManyAndReturnArgs} args - Arguments to update many GaProperties.
     * @example
     * // Update many GaProperties
     * const gaProperty = await prisma.gaProperty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaProperties and only return the `id`
     * const gaPropertyWithIdOnly = await prisma.gaProperty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaPropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, GaPropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaProperty.
     * @param {GaPropertyUpsertArgs} args - Arguments to update or create a GaProperty.
     * @example
     * // Update or create a GaProperty
     * const gaProperty = await prisma.gaProperty.upsert({
     *   create: {
     *     // ... data to create a GaProperty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaProperty we want to update
     *   }
     * })
     */
    upsert<T extends GaPropertyUpsertArgs>(args: SelectSubset<T, GaPropertyUpsertArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyCountArgs} args - Arguments to filter GaProperties to count.
     * @example
     * // Count the number of GaProperties
     * const count = await prisma.gaProperty.count({
     *   where: {
     *     // ... the filter for the GaProperties we want to count
     *   }
     * })
    **/
    count<T extends GaPropertyCountArgs>(
      args?: Subset<T, GaPropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaPropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaProperty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaPropertyAggregateArgs>(args: Subset<T, GaPropertyAggregateArgs>): Prisma.PrismaPromise<GetGaPropertyAggregateType<T>>

    /**
     * Group by GaProperty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaPropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaPropertyGroupByArgs['orderBy'] }
        : { orderBy?: GaPropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaPropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaProperty model
   */
  readonly fields: GaPropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaProperty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaPropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaAccount<T extends GaAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaAccountDefaultArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversations<T extends GaProperty$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imports<T extends GaProperty$importsArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$importsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kpiDaily<T extends GaProperty$kpiDailyArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$kpiDailyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kpiMonthly<T extends GaProperty$kpiMonthlyArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$kpiMonthlyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    channelDaily<T extends GaProperty$channelDailyArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$channelDailyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourceDaily<T extends GaProperty$sourceDailyArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$sourceDailyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaProperty model
   */
  interface GaPropertyFieldRefs {
    readonly id: FieldRef<"GaProperty", 'String'>
    readonly gaPropertyId: FieldRef<"GaProperty", 'String'>
    readonly gaPropertyName: FieldRef<"GaProperty", 'String'>
    readonly gaAccountId: FieldRef<"GaProperty", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GaProperty findUnique
   */
  export type GaPropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter, which GaProperty to fetch.
     */
    where: GaPropertyWhereUniqueInput
  }

  /**
   * GaProperty findUniqueOrThrow
   */
  export type GaPropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter, which GaProperty to fetch.
     */
    where: GaPropertyWhereUniqueInput
  }

  /**
   * GaProperty findFirst
   */
  export type GaPropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter, which GaProperty to fetch.
     */
    where?: GaPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaProperties to fetch.
     */
    orderBy?: GaPropertyOrderByWithRelationInput | GaPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaProperties.
     */
    cursor?: GaPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaProperties.
     */
    distinct?: GaPropertyScalarFieldEnum | GaPropertyScalarFieldEnum[]
  }

  /**
   * GaProperty findFirstOrThrow
   */
  export type GaPropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter, which GaProperty to fetch.
     */
    where?: GaPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaProperties to fetch.
     */
    orderBy?: GaPropertyOrderByWithRelationInput | GaPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaProperties.
     */
    cursor?: GaPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaProperties.
     */
    distinct?: GaPropertyScalarFieldEnum | GaPropertyScalarFieldEnum[]
  }

  /**
   * GaProperty findMany
   */
  export type GaPropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter, which GaProperties to fetch.
     */
    where?: GaPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaProperties to fetch.
     */
    orderBy?: GaPropertyOrderByWithRelationInput | GaPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaProperties.
     */
    cursor?: GaPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaProperties.
     */
    skip?: number
    distinct?: GaPropertyScalarFieldEnum | GaPropertyScalarFieldEnum[]
  }

  /**
   * GaProperty create
   */
  export type GaPropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a GaProperty.
     */
    data: XOR<GaPropertyCreateInput, GaPropertyUncheckedCreateInput>
  }

  /**
   * GaProperty createMany
   */
  export type GaPropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaProperties.
     */
    data: GaPropertyCreateManyInput | GaPropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaProperty createManyAndReturn
   */
  export type GaPropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * The data used to create many GaProperties.
     */
    data: GaPropertyCreateManyInput | GaPropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaProperty update
   */
  export type GaPropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a GaProperty.
     */
    data: XOR<GaPropertyUpdateInput, GaPropertyUncheckedUpdateInput>
    /**
     * Choose, which GaProperty to update.
     */
    where: GaPropertyWhereUniqueInput
  }

  /**
   * GaProperty updateMany
   */
  export type GaPropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaProperties.
     */
    data: XOR<GaPropertyUpdateManyMutationInput, GaPropertyUncheckedUpdateManyInput>
    /**
     * Filter which GaProperties to update
     */
    where?: GaPropertyWhereInput
    /**
     * Limit how many GaProperties to update.
     */
    limit?: number
  }

  /**
   * GaProperty updateManyAndReturn
   */
  export type GaPropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * The data used to update GaProperties.
     */
    data: XOR<GaPropertyUpdateManyMutationInput, GaPropertyUncheckedUpdateManyInput>
    /**
     * Filter which GaProperties to update
     */
    where?: GaPropertyWhereInput
    /**
     * Limit how many GaProperties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaProperty upsert
   */
  export type GaPropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the GaProperty to update in case it exists.
     */
    where: GaPropertyWhereUniqueInput
    /**
     * In case the GaProperty found by the `where` argument doesn't exist, create a new GaProperty with this data.
     */
    create: XOR<GaPropertyCreateInput, GaPropertyUncheckedCreateInput>
    /**
     * In case the GaProperty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaPropertyUpdateInput, GaPropertyUncheckedUpdateInput>
  }

  /**
   * GaProperty delete
   */
  export type GaPropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter which GaProperty to delete.
     */
    where: GaPropertyWhereUniqueInput
  }

  /**
   * GaProperty deleteMany
   */
  export type GaPropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaProperties to delete
     */
    where?: GaPropertyWhereInput
    /**
     * Limit how many GaProperties to delete.
     */
    limit?: number
  }

  /**
   * GaProperty.conversations
   */
  export type GaProperty$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * GaProperty.imports
   */
  export type GaProperty$importsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    where?: GaImportRunWhereInput
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    cursor?: GaImportRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaImportRunScalarFieldEnum | GaImportRunScalarFieldEnum[]
  }

  /**
   * GaProperty.kpiDaily
   */
  export type GaProperty$kpiDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    where?: GaKpiDailyWhereInput
    orderBy?: GaKpiDailyOrderByWithRelationInput | GaKpiDailyOrderByWithRelationInput[]
    cursor?: GaKpiDailyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaKpiDailyScalarFieldEnum | GaKpiDailyScalarFieldEnum[]
  }

  /**
   * GaProperty.kpiMonthly
   */
  export type GaProperty$kpiMonthlyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    where?: GaKpiMonthlyWhereInput
    orderBy?: GaKpiMonthlyOrderByWithRelationInput | GaKpiMonthlyOrderByWithRelationInput[]
    cursor?: GaKpiMonthlyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaKpiMonthlyScalarFieldEnum | GaKpiMonthlyScalarFieldEnum[]
  }

  /**
   * GaProperty.channelDaily
   */
  export type GaProperty$channelDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    where?: GaChannelDailyWhereInput
    orderBy?: GaChannelDailyOrderByWithRelationInput | GaChannelDailyOrderByWithRelationInput[]
    cursor?: GaChannelDailyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaChannelDailyScalarFieldEnum | GaChannelDailyScalarFieldEnum[]
  }

  /**
   * GaProperty.sourceDaily
   */
  export type GaProperty$sourceDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    where?: GaSourceDailyWhereInput
    orderBy?: GaSourceDailyOrderByWithRelationInput | GaSourceDailyOrderByWithRelationInput[]
    cursor?: GaSourceDailyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaSourceDailyScalarFieldEnum | GaSourceDailyScalarFieldEnum[]
  }

  /**
   * GaProperty without action
   */
  export type GaPropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
  }


  /**
   * Model GaImportRun
   */

  export type AggregateGaImportRun = {
    _count: GaImportRunCountAggregateOutputType | null
    _min: GaImportRunMinAggregateOutputType | null
    _max: GaImportRunMaxAggregateOutputType | null
  }

  export type GaImportRunMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    dateStart: Date | null
    dateEnd: Date | null
    status: $Enums.ImportStatus | null
    errorMessage: string | null
    requestedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaImportRunMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    dateStart: Date | null
    dateEnd: Date | null
    status: $Enums.ImportStatus | null
    errorMessage: string | null
    requestedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaImportRunCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    dateStart: number
    dateEnd: number
    status: number
    errorMessage: number
    requestedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GaImportRunMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    dateStart?: true
    dateEnd?: true
    status?: true
    errorMessage?: true
    requestedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaImportRunMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    dateStart?: true
    dateEnd?: true
    status?: true
    errorMessage?: true
    requestedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaImportRunCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    dateStart?: true
    dateEnd?: true
    status?: true
    errorMessage?: true
    requestedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GaImportRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaImportRun to aggregate.
     */
    where?: GaImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaImportRuns to fetch.
     */
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaImportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaImportRuns
    **/
    _count?: true | GaImportRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaImportRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaImportRunMaxAggregateInputType
  }

  export type GetGaImportRunAggregateType<T extends GaImportRunAggregateArgs> = {
        [P in keyof T & keyof AggregateGaImportRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaImportRun[P]>
      : GetScalarType<T[P], AggregateGaImportRun[P]>
  }




  export type GaImportRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaImportRunWhereInput
    orderBy?: GaImportRunOrderByWithAggregationInput | GaImportRunOrderByWithAggregationInput[]
    by: GaImportRunScalarFieldEnum[] | GaImportRunScalarFieldEnum
    having?: GaImportRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaImportRunCountAggregateInputType | true
    _min?: GaImportRunMinAggregateInputType
    _max?: GaImportRunMaxAggregateInputType
  }

  export type GaImportRunGroupByOutputType = {
    id: string
    gaPropertyId: string
    dateStart: Date
    dateEnd: Date
    status: $Enums.ImportStatus
    errorMessage: string | null
    requestedByUserId: string
    createdAt: Date
    updatedAt: Date
    _count: GaImportRunCountAggregateOutputType | null
    _min: GaImportRunMinAggregateOutputType | null
    _max: GaImportRunMaxAggregateOutputType | null
  }

  type GetGaImportRunGroupByPayload<T extends GaImportRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaImportRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaImportRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaImportRunGroupByOutputType[P]>
            : GetScalarType<T[P], GaImportRunGroupByOutputType[P]>
        }
      >
    >


  export type GaImportRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    errorMessage?: boolean
    requestedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaImportRun"]>

  export type GaImportRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    errorMessage?: boolean
    requestedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaImportRun"]>

  export type GaImportRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    errorMessage?: boolean
    requestedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaImportRun"]>

  export type GaImportRunSelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    errorMessage?: boolean
    requestedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GaImportRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "dateStart" | "dateEnd" | "status" | "errorMessage" | "requestedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["gaImportRun"]>
  export type GaImportRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GaImportRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GaImportRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GaImportRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaImportRun"
    objects: {
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs>
      requestedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      dateStart: Date
      dateEnd: Date
      status: $Enums.ImportStatus
      errorMessage: string | null
      requestedByUserId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gaImportRun"]>
    composites: {}
  }

  type GaImportRunGetPayload<S extends boolean | null | undefined | GaImportRunDefaultArgs> = $Result.GetResult<Prisma.$GaImportRunPayload, S>

  type GaImportRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaImportRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaImportRunCountAggregateInputType | true
    }

  export interface GaImportRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaImportRun'], meta: { name: 'GaImportRun' } }
    /**
     * Find zero or one GaImportRun that matches the filter.
     * @param {GaImportRunFindUniqueArgs} args - Arguments to find a GaImportRun
     * @example
     * // Get one GaImportRun
     * const gaImportRun = await prisma.gaImportRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaImportRunFindUniqueArgs>(args: SelectSubset<T, GaImportRunFindUniqueArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaImportRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaImportRunFindUniqueOrThrowArgs} args - Arguments to find a GaImportRun
     * @example
     * // Get one GaImportRun
     * const gaImportRun = await prisma.gaImportRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaImportRunFindUniqueOrThrowArgs>(args: SelectSubset<T, GaImportRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaImportRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunFindFirstArgs} args - Arguments to find a GaImportRun
     * @example
     * // Get one GaImportRun
     * const gaImportRun = await prisma.gaImportRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaImportRunFindFirstArgs>(args?: SelectSubset<T, GaImportRunFindFirstArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaImportRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunFindFirstOrThrowArgs} args - Arguments to find a GaImportRun
     * @example
     * // Get one GaImportRun
     * const gaImportRun = await prisma.gaImportRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaImportRunFindFirstOrThrowArgs>(args?: SelectSubset<T, GaImportRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaImportRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaImportRuns
     * const gaImportRuns = await prisma.gaImportRun.findMany()
     * 
     * // Get first 10 GaImportRuns
     * const gaImportRuns = await prisma.gaImportRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaImportRunWithIdOnly = await prisma.gaImportRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaImportRunFindManyArgs>(args?: SelectSubset<T, GaImportRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaImportRun.
     * @param {GaImportRunCreateArgs} args - Arguments to create a GaImportRun.
     * @example
     * // Create one GaImportRun
     * const GaImportRun = await prisma.gaImportRun.create({
     *   data: {
     *     // ... data to create a GaImportRun
     *   }
     * })
     * 
     */
    create<T extends GaImportRunCreateArgs>(args: SelectSubset<T, GaImportRunCreateArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaImportRuns.
     * @param {GaImportRunCreateManyArgs} args - Arguments to create many GaImportRuns.
     * @example
     * // Create many GaImportRuns
     * const gaImportRun = await prisma.gaImportRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaImportRunCreateManyArgs>(args?: SelectSubset<T, GaImportRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaImportRuns and returns the data saved in the database.
     * @param {GaImportRunCreateManyAndReturnArgs} args - Arguments to create many GaImportRuns.
     * @example
     * // Create many GaImportRuns
     * const gaImportRun = await prisma.gaImportRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaImportRuns and only return the `id`
     * const gaImportRunWithIdOnly = await prisma.gaImportRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaImportRunCreateManyAndReturnArgs>(args?: SelectSubset<T, GaImportRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaImportRun.
     * @param {GaImportRunDeleteArgs} args - Arguments to delete one GaImportRun.
     * @example
     * // Delete one GaImportRun
     * const GaImportRun = await prisma.gaImportRun.delete({
     *   where: {
     *     // ... filter to delete one GaImportRun
     *   }
     * })
     * 
     */
    delete<T extends GaImportRunDeleteArgs>(args: SelectSubset<T, GaImportRunDeleteArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaImportRun.
     * @param {GaImportRunUpdateArgs} args - Arguments to update one GaImportRun.
     * @example
     * // Update one GaImportRun
     * const gaImportRun = await prisma.gaImportRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaImportRunUpdateArgs>(args: SelectSubset<T, GaImportRunUpdateArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaImportRuns.
     * @param {GaImportRunDeleteManyArgs} args - Arguments to filter GaImportRuns to delete.
     * @example
     * // Delete a few GaImportRuns
     * const { count } = await prisma.gaImportRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaImportRunDeleteManyArgs>(args?: SelectSubset<T, GaImportRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaImportRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaImportRuns
     * const gaImportRun = await prisma.gaImportRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaImportRunUpdateManyArgs>(args: SelectSubset<T, GaImportRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaImportRuns and returns the data updated in the database.
     * @param {GaImportRunUpdateManyAndReturnArgs} args - Arguments to update many GaImportRuns.
     * @example
     * // Update many GaImportRuns
     * const gaImportRun = await prisma.gaImportRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaImportRuns and only return the `id`
     * const gaImportRunWithIdOnly = await prisma.gaImportRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaImportRunUpdateManyAndReturnArgs>(args: SelectSubset<T, GaImportRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaImportRun.
     * @param {GaImportRunUpsertArgs} args - Arguments to update or create a GaImportRun.
     * @example
     * // Update or create a GaImportRun
     * const gaImportRun = await prisma.gaImportRun.upsert({
     *   create: {
     *     // ... data to create a GaImportRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaImportRun we want to update
     *   }
     * })
     */
    upsert<T extends GaImportRunUpsertArgs>(args: SelectSubset<T, GaImportRunUpsertArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaImportRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunCountArgs} args - Arguments to filter GaImportRuns to count.
     * @example
     * // Count the number of GaImportRuns
     * const count = await prisma.gaImportRun.count({
     *   where: {
     *     // ... the filter for the GaImportRuns we want to count
     *   }
     * })
    **/
    count<T extends GaImportRunCountArgs>(
      args?: Subset<T, GaImportRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaImportRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaImportRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaImportRunAggregateArgs>(args: Subset<T, GaImportRunAggregateArgs>): Prisma.PrismaPromise<GetGaImportRunAggregateType<T>>

    /**
     * Group by GaImportRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaImportRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaImportRunGroupByArgs['orderBy'] }
        : { orderBy?: GaImportRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaImportRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaImportRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaImportRun model
   */
  readonly fields: GaImportRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaImportRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaImportRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaProperty<T extends GaPropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaPropertyDefaultArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requestedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaImportRun model
   */
  interface GaImportRunFieldRefs {
    readonly id: FieldRef<"GaImportRun", 'String'>
    readonly gaPropertyId: FieldRef<"GaImportRun", 'String'>
    readonly dateStart: FieldRef<"GaImportRun", 'DateTime'>
    readonly dateEnd: FieldRef<"GaImportRun", 'DateTime'>
    readonly status: FieldRef<"GaImportRun", 'ImportStatus'>
    readonly errorMessage: FieldRef<"GaImportRun", 'String'>
    readonly requestedByUserId: FieldRef<"GaImportRun", 'String'>
    readonly createdAt: FieldRef<"GaImportRun", 'DateTime'>
    readonly updatedAt: FieldRef<"GaImportRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaImportRun findUnique
   */
  export type GaImportRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter, which GaImportRun to fetch.
     */
    where: GaImportRunWhereUniqueInput
  }

  /**
   * GaImportRun findUniqueOrThrow
   */
  export type GaImportRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter, which GaImportRun to fetch.
     */
    where: GaImportRunWhereUniqueInput
  }

  /**
   * GaImportRun findFirst
   */
  export type GaImportRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter, which GaImportRun to fetch.
     */
    where?: GaImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaImportRuns to fetch.
     */
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaImportRuns.
     */
    cursor?: GaImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaImportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaImportRuns.
     */
    distinct?: GaImportRunScalarFieldEnum | GaImportRunScalarFieldEnum[]
  }

  /**
   * GaImportRun findFirstOrThrow
   */
  export type GaImportRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter, which GaImportRun to fetch.
     */
    where?: GaImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaImportRuns to fetch.
     */
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaImportRuns.
     */
    cursor?: GaImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaImportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaImportRuns.
     */
    distinct?: GaImportRunScalarFieldEnum | GaImportRunScalarFieldEnum[]
  }

  /**
   * GaImportRun findMany
   */
  export type GaImportRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter, which GaImportRuns to fetch.
     */
    where?: GaImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaImportRuns to fetch.
     */
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaImportRuns.
     */
    cursor?: GaImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaImportRuns.
     */
    skip?: number
    distinct?: GaImportRunScalarFieldEnum | GaImportRunScalarFieldEnum[]
  }

  /**
   * GaImportRun create
   */
  export type GaImportRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * The data needed to create a GaImportRun.
     */
    data: XOR<GaImportRunCreateInput, GaImportRunUncheckedCreateInput>
  }

  /**
   * GaImportRun createMany
   */
  export type GaImportRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaImportRuns.
     */
    data: GaImportRunCreateManyInput | GaImportRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaImportRun createManyAndReturn
   */
  export type GaImportRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * The data used to create many GaImportRuns.
     */
    data: GaImportRunCreateManyInput | GaImportRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaImportRun update
   */
  export type GaImportRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * The data needed to update a GaImportRun.
     */
    data: XOR<GaImportRunUpdateInput, GaImportRunUncheckedUpdateInput>
    /**
     * Choose, which GaImportRun to update.
     */
    where: GaImportRunWhereUniqueInput
  }

  /**
   * GaImportRun updateMany
   */
  export type GaImportRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaImportRuns.
     */
    data: XOR<GaImportRunUpdateManyMutationInput, GaImportRunUncheckedUpdateManyInput>
    /**
     * Filter which GaImportRuns to update
     */
    where?: GaImportRunWhereInput
    /**
     * Limit how many GaImportRuns to update.
     */
    limit?: number
  }

  /**
   * GaImportRun updateManyAndReturn
   */
  export type GaImportRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * The data used to update GaImportRuns.
     */
    data: XOR<GaImportRunUpdateManyMutationInput, GaImportRunUncheckedUpdateManyInput>
    /**
     * Filter which GaImportRuns to update
     */
    where?: GaImportRunWhereInput
    /**
     * Limit how many GaImportRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaImportRun upsert
   */
  export type GaImportRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * The filter to search for the GaImportRun to update in case it exists.
     */
    where: GaImportRunWhereUniqueInput
    /**
     * In case the GaImportRun found by the `where` argument doesn't exist, create a new GaImportRun with this data.
     */
    create: XOR<GaImportRunCreateInput, GaImportRunUncheckedCreateInput>
    /**
     * In case the GaImportRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaImportRunUpdateInput, GaImportRunUncheckedUpdateInput>
  }

  /**
   * GaImportRun delete
   */
  export type GaImportRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter which GaImportRun to delete.
     */
    where: GaImportRunWhereUniqueInput
  }

  /**
   * GaImportRun deleteMany
   */
  export type GaImportRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaImportRuns to delete
     */
    where?: GaImportRunWhereInput
    /**
     * Limit how many GaImportRuns to delete.
     */
    limit?: number
  }

  /**
   * GaImportRun without action
   */
  export type GaImportRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
  }


  /**
   * Model GaKpiDaily
   */

  export type AggregateGaKpiDaily = {
    _count: GaKpiDailyCountAggregateOutputType | null
    _avg: GaKpiDailyAvgAggregateOutputType | null
    _sum: GaKpiDailySumAggregateOutputType | null
    _min: GaKpiDailyMinAggregateOutputType | null
    _max: GaKpiDailyMaxAggregateOutputType | null
  }

  export type GaKpiDailyAvgAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaKpiDailySumAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaKpiDailyMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
  }

  export type GaKpiDailyMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
  }

  export type GaKpiDailyCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    date: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: number
    _all: number
  }


  export type GaKpiDailyAvgAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaKpiDailySumAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaKpiDailyMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
  }

  export type GaKpiDailyMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
  }

  export type GaKpiDailyCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    _all?: true
  }

  export type GaKpiDailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaKpiDaily to aggregate.
     */
    where?: GaKpiDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiDailies to fetch.
     */
    orderBy?: GaKpiDailyOrderByWithRelationInput | GaKpiDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaKpiDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaKpiDailies
    **/
    _count?: true | GaKpiDailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GaKpiDailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GaKpiDailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaKpiDailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaKpiDailyMaxAggregateInputType
  }

  export type GetGaKpiDailyAggregateType<T extends GaKpiDailyAggregateArgs> = {
        [P in keyof T & keyof AggregateGaKpiDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaKpiDaily[P]>
      : GetScalarType<T[P], AggregateGaKpiDaily[P]>
  }




  export type GaKpiDailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaKpiDailyWhereInput
    orderBy?: GaKpiDailyOrderByWithAggregationInput | GaKpiDailyOrderByWithAggregationInput[]
    by: GaKpiDailyScalarFieldEnum[] | GaKpiDailyScalarFieldEnum
    having?: GaKpiDailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaKpiDailyCountAggregateInputType | true
    _avg?: GaKpiDailyAvgAggregateInputType
    _sum?: GaKpiDailySumAggregateInputType
    _min?: GaKpiDailyMinAggregateInputType
    _max?: GaKpiDailyMaxAggregateInputType
  }

  export type GaKpiDailyGroupByOutputType = {
    id: string
    gaPropertyId: string
    date: Date
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: Date
    _count: GaKpiDailyCountAggregateOutputType | null
    _avg: GaKpiDailyAvgAggregateOutputType | null
    _sum: GaKpiDailySumAggregateOutputType | null
    _min: GaKpiDailyMinAggregateOutputType | null
    _max: GaKpiDailyMaxAggregateOutputType | null
  }

  type GetGaKpiDailyGroupByPayload<T extends GaKpiDailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaKpiDailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaKpiDailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaKpiDailyGroupByOutputType[P]>
            : GetScalarType<T[P], GaKpiDailyGroupByOutputType[P]>
        }
      >
    >


  export type GaKpiDailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiDaily"]>

  export type GaKpiDailySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiDaily"]>

  export type GaKpiDailySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiDaily"]>

  export type GaKpiDailySelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
  }

  export type GaKpiDailyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "date" | "sessions" | "screenPageViewsPerSession" | "engagementRate" | "avgSessionDurationSec" | "goalCompletions" | "goalCompletionRate" | "createdAt", ExtArgs["result"]["gaKpiDaily"]>
  export type GaKpiDailyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaKpiDailyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaKpiDailyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }

  export type $GaKpiDailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaKpiDaily"
    objects: {
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      date: Date
      sessions: number
      screenPageViewsPerSession: number
      engagementRate: number
      avgSessionDurationSec: number
      goalCompletions: number
      goalCompletionRate: number
      createdAt: Date
    }, ExtArgs["result"]["gaKpiDaily"]>
    composites: {}
  }

  type GaKpiDailyGetPayload<S extends boolean | null | undefined | GaKpiDailyDefaultArgs> = $Result.GetResult<Prisma.$GaKpiDailyPayload, S>

  type GaKpiDailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaKpiDailyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaKpiDailyCountAggregateInputType | true
    }

  export interface GaKpiDailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaKpiDaily'], meta: { name: 'GaKpiDaily' } }
    /**
     * Find zero or one GaKpiDaily that matches the filter.
     * @param {GaKpiDailyFindUniqueArgs} args - Arguments to find a GaKpiDaily
     * @example
     * // Get one GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaKpiDailyFindUniqueArgs>(args: SelectSubset<T, GaKpiDailyFindUniqueArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaKpiDaily that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaKpiDailyFindUniqueOrThrowArgs} args - Arguments to find a GaKpiDaily
     * @example
     * // Get one GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaKpiDailyFindUniqueOrThrowArgs>(args: SelectSubset<T, GaKpiDailyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaKpiDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyFindFirstArgs} args - Arguments to find a GaKpiDaily
     * @example
     * // Get one GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaKpiDailyFindFirstArgs>(args?: SelectSubset<T, GaKpiDailyFindFirstArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaKpiDaily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyFindFirstOrThrowArgs} args - Arguments to find a GaKpiDaily
     * @example
     * // Get one GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaKpiDailyFindFirstOrThrowArgs>(args?: SelectSubset<T, GaKpiDailyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaKpiDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaKpiDailies
     * const gaKpiDailies = await prisma.gaKpiDaily.findMany()
     * 
     * // Get first 10 GaKpiDailies
     * const gaKpiDailies = await prisma.gaKpiDaily.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaKpiDailyWithIdOnly = await prisma.gaKpiDaily.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaKpiDailyFindManyArgs>(args?: SelectSubset<T, GaKpiDailyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaKpiDaily.
     * @param {GaKpiDailyCreateArgs} args - Arguments to create a GaKpiDaily.
     * @example
     * // Create one GaKpiDaily
     * const GaKpiDaily = await prisma.gaKpiDaily.create({
     *   data: {
     *     // ... data to create a GaKpiDaily
     *   }
     * })
     * 
     */
    create<T extends GaKpiDailyCreateArgs>(args: SelectSubset<T, GaKpiDailyCreateArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaKpiDailies.
     * @param {GaKpiDailyCreateManyArgs} args - Arguments to create many GaKpiDailies.
     * @example
     * // Create many GaKpiDailies
     * const gaKpiDaily = await prisma.gaKpiDaily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaKpiDailyCreateManyArgs>(args?: SelectSubset<T, GaKpiDailyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaKpiDailies and returns the data saved in the database.
     * @param {GaKpiDailyCreateManyAndReturnArgs} args - Arguments to create many GaKpiDailies.
     * @example
     * // Create many GaKpiDailies
     * const gaKpiDaily = await prisma.gaKpiDaily.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaKpiDailies and only return the `id`
     * const gaKpiDailyWithIdOnly = await prisma.gaKpiDaily.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaKpiDailyCreateManyAndReturnArgs>(args?: SelectSubset<T, GaKpiDailyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaKpiDaily.
     * @param {GaKpiDailyDeleteArgs} args - Arguments to delete one GaKpiDaily.
     * @example
     * // Delete one GaKpiDaily
     * const GaKpiDaily = await prisma.gaKpiDaily.delete({
     *   where: {
     *     // ... filter to delete one GaKpiDaily
     *   }
     * })
     * 
     */
    delete<T extends GaKpiDailyDeleteArgs>(args: SelectSubset<T, GaKpiDailyDeleteArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaKpiDaily.
     * @param {GaKpiDailyUpdateArgs} args - Arguments to update one GaKpiDaily.
     * @example
     * // Update one GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaKpiDailyUpdateArgs>(args: SelectSubset<T, GaKpiDailyUpdateArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaKpiDailies.
     * @param {GaKpiDailyDeleteManyArgs} args - Arguments to filter GaKpiDailies to delete.
     * @example
     * // Delete a few GaKpiDailies
     * const { count } = await prisma.gaKpiDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaKpiDailyDeleteManyArgs>(args?: SelectSubset<T, GaKpiDailyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaKpiDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaKpiDailies
     * const gaKpiDaily = await prisma.gaKpiDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaKpiDailyUpdateManyArgs>(args: SelectSubset<T, GaKpiDailyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaKpiDailies and returns the data updated in the database.
     * @param {GaKpiDailyUpdateManyAndReturnArgs} args - Arguments to update many GaKpiDailies.
     * @example
     * // Update many GaKpiDailies
     * const gaKpiDaily = await prisma.gaKpiDaily.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaKpiDailies and only return the `id`
     * const gaKpiDailyWithIdOnly = await prisma.gaKpiDaily.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaKpiDailyUpdateManyAndReturnArgs>(args: SelectSubset<T, GaKpiDailyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaKpiDaily.
     * @param {GaKpiDailyUpsertArgs} args - Arguments to update or create a GaKpiDaily.
     * @example
     * // Update or create a GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.upsert({
     *   create: {
     *     // ... data to create a GaKpiDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaKpiDaily we want to update
     *   }
     * })
     */
    upsert<T extends GaKpiDailyUpsertArgs>(args: SelectSubset<T, GaKpiDailyUpsertArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaKpiDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyCountArgs} args - Arguments to filter GaKpiDailies to count.
     * @example
     * // Count the number of GaKpiDailies
     * const count = await prisma.gaKpiDaily.count({
     *   where: {
     *     // ... the filter for the GaKpiDailies we want to count
     *   }
     * })
    **/
    count<T extends GaKpiDailyCountArgs>(
      args?: Subset<T, GaKpiDailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaKpiDailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaKpiDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaKpiDailyAggregateArgs>(args: Subset<T, GaKpiDailyAggregateArgs>): Prisma.PrismaPromise<GetGaKpiDailyAggregateType<T>>

    /**
     * Group by GaKpiDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaKpiDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaKpiDailyGroupByArgs['orderBy'] }
        : { orderBy?: GaKpiDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaKpiDailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaKpiDailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaKpiDaily model
   */
  readonly fields: GaKpiDailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaKpiDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaKpiDailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaProperty<T extends GaPropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaPropertyDefaultArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaKpiDaily model
   */
  interface GaKpiDailyFieldRefs {
    readonly id: FieldRef<"GaKpiDaily", 'String'>
    readonly gaPropertyId: FieldRef<"GaKpiDaily", 'String'>
    readonly date: FieldRef<"GaKpiDaily", 'DateTime'>
    readonly sessions: FieldRef<"GaKpiDaily", 'Int'>
    readonly screenPageViewsPerSession: FieldRef<"GaKpiDaily", 'Float'>
    readonly engagementRate: FieldRef<"GaKpiDaily", 'Float'>
    readonly avgSessionDurationSec: FieldRef<"GaKpiDaily", 'Int'>
    readonly goalCompletions: FieldRef<"GaKpiDaily", 'Int'>
    readonly goalCompletionRate: FieldRef<"GaKpiDaily", 'Float'>
    readonly createdAt: FieldRef<"GaKpiDaily", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaKpiDaily findUnique
   */
  export type GaKpiDailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiDaily to fetch.
     */
    where: GaKpiDailyWhereUniqueInput
  }

  /**
   * GaKpiDaily findUniqueOrThrow
   */
  export type GaKpiDailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiDaily to fetch.
     */
    where: GaKpiDailyWhereUniqueInput
  }

  /**
   * GaKpiDaily findFirst
   */
  export type GaKpiDailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiDaily to fetch.
     */
    where?: GaKpiDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiDailies to fetch.
     */
    orderBy?: GaKpiDailyOrderByWithRelationInput | GaKpiDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaKpiDailies.
     */
    cursor?: GaKpiDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaKpiDailies.
     */
    distinct?: GaKpiDailyScalarFieldEnum | GaKpiDailyScalarFieldEnum[]
  }

  /**
   * GaKpiDaily findFirstOrThrow
   */
  export type GaKpiDailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiDaily to fetch.
     */
    where?: GaKpiDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiDailies to fetch.
     */
    orderBy?: GaKpiDailyOrderByWithRelationInput | GaKpiDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaKpiDailies.
     */
    cursor?: GaKpiDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaKpiDailies.
     */
    distinct?: GaKpiDailyScalarFieldEnum | GaKpiDailyScalarFieldEnum[]
  }

  /**
   * GaKpiDaily findMany
   */
  export type GaKpiDailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiDailies to fetch.
     */
    where?: GaKpiDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiDailies to fetch.
     */
    orderBy?: GaKpiDailyOrderByWithRelationInput | GaKpiDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaKpiDailies.
     */
    cursor?: GaKpiDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiDailies.
     */
    skip?: number
    distinct?: GaKpiDailyScalarFieldEnum | GaKpiDailyScalarFieldEnum[]
  }

  /**
   * GaKpiDaily create
   */
  export type GaKpiDailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * The data needed to create a GaKpiDaily.
     */
    data: XOR<GaKpiDailyCreateInput, GaKpiDailyUncheckedCreateInput>
  }

  /**
   * GaKpiDaily createMany
   */
  export type GaKpiDailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaKpiDailies.
     */
    data: GaKpiDailyCreateManyInput | GaKpiDailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaKpiDaily createManyAndReturn
   */
  export type GaKpiDailyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * The data used to create many GaKpiDailies.
     */
    data: GaKpiDailyCreateManyInput | GaKpiDailyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaKpiDaily update
   */
  export type GaKpiDailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * The data needed to update a GaKpiDaily.
     */
    data: XOR<GaKpiDailyUpdateInput, GaKpiDailyUncheckedUpdateInput>
    /**
     * Choose, which GaKpiDaily to update.
     */
    where: GaKpiDailyWhereUniqueInput
  }

  /**
   * GaKpiDaily updateMany
   */
  export type GaKpiDailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaKpiDailies.
     */
    data: XOR<GaKpiDailyUpdateManyMutationInput, GaKpiDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaKpiDailies to update
     */
    where?: GaKpiDailyWhereInput
    /**
     * Limit how many GaKpiDailies to update.
     */
    limit?: number
  }

  /**
   * GaKpiDaily updateManyAndReturn
   */
  export type GaKpiDailyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * The data used to update GaKpiDailies.
     */
    data: XOR<GaKpiDailyUpdateManyMutationInput, GaKpiDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaKpiDailies to update
     */
    where?: GaKpiDailyWhereInput
    /**
     * Limit how many GaKpiDailies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaKpiDaily upsert
   */
  export type GaKpiDailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * The filter to search for the GaKpiDaily to update in case it exists.
     */
    where: GaKpiDailyWhereUniqueInput
    /**
     * In case the GaKpiDaily found by the `where` argument doesn't exist, create a new GaKpiDaily with this data.
     */
    create: XOR<GaKpiDailyCreateInput, GaKpiDailyUncheckedCreateInput>
    /**
     * In case the GaKpiDaily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaKpiDailyUpdateInput, GaKpiDailyUncheckedUpdateInput>
  }

  /**
   * GaKpiDaily delete
   */
  export type GaKpiDailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter which GaKpiDaily to delete.
     */
    where: GaKpiDailyWhereUniqueInput
  }

  /**
   * GaKpiDaily deleteMany
   */
  export type GaKpiDailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaKpiDailies to delete
     */
    where?: GaKpiDailyWhereInput
    /**
     * Limit how many GaKpiDailies to delete.
     */
    limit?: number
  }

  /**
   * GaKpiDaily without action
   */
  export type GaKpiDailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
  }


  /**
   * Model GaKpiMonthly
   */

  export type AggregateGaKpiMonthly = {
    _count: GaKpiMonthlyCountAggregateOutputType | null
    _avg: GaKpiMonthlyAvgAggregateOutputType | null
    _sum: GaKpiMonthlySumAggregateOutputType | null
    _min: GaKpiMonthlyMinAggregateOutputType | null
    _max: GaKpiMonthlyMaxAggregateOutputType | null
  }

  export type GaKpiMonthlyAvgAggregateOutputType = {
    month: number | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaKpiMonthlySumAggregateOutputType = {
    month: number | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaKpiMonthlyMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    month: number | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
  }

  export type GaKpiMonthlyMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    month: number | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
  }

  export type GaKpiMonthlyCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: number
    _all: number
  }


  export type GaKpiMonthlyAvgAggregateInputType = {
    month?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaKpiMonthlySumAggregateInputType = {
    month?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaKpiMonthlyMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    month?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
  }

  export type GaKpiMonthlyMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    month?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
  }

  export type GaKpiMonthlyCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    month?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    _all?: true
  }

  export type GaKpiMonthlyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaKpiMonthly to aggregate.
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiMonthlies to fetch.
     */
    orderBy?: GaKpiMonthlyOrderByWithRelationInput | GaKpiMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaKpiMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiMonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaKpiMonthlies
    **/
    _count?: true | GaKpiMonthlyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GaKpiMonthlyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GaKpiMonthlySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaKpiMonthlyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaKpiMonthlyMaxAggregateInputType
  }

  export type GetGaKpiMonthlyAggregateType<T extends GaKpiMonthlyAggregateArgs> = {
        [P in keyof T & keyof AggregateGaKpiMonthly]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaKpiMonthly[P]>
      : GetScalarType<T[P], AggregateGaKpiMonthly[P]>
  }




  export type GaKpiMonthlyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaKpiMonthlyWhereInput
    orderBy?: GaKpiMonthlyOrderByWithAggregationInput | GaKpiMonthlyOrderByWithAggregationInput[]
    by: GaKpiMonthlyScalarFieldEnum[] | GaKpiMonthlyScalarFieldEnum
    having?: GaKpiMonthlyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaKpiMonthlyCountAggregateInputType | true
    _avg?: GaKpiMonthlyAvgAggregateInputType
    _sum?: GaKpiMonthlySumAggregateInputType
    _min?: GaKpiMonthlyMinAggregateInputType
    _max?: GaKpiMonthlyMaxAggregateInputType
  }

  export type GaKpiMonthlyGroupByOutputType = {
    id: string
    gaPropertyId: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: Date
    _count: GaKpiMonthlyCountAggregateOutputType | null
    _avg: GaKpiMonthlyAvgAggregateOutputType | null
    _sum: GaKpiMonthlySumAggregateOutputType | null
    _min: GaKpiMonthlyMinAggregateOutputType | null
    _max: GaKpiMonthlyMaxAggregateOutputType | null
  }

  type GetGaKpiMonthlyGroupByPayload<T extends GaKpiMonthlyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaKpiMonthlyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaKpiMonthlyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaKpiMonthlyGroupByOutputType[P]>
            : GetScalarType<T[P], GaKpiMonthlyGroupByOutputType[P]>
        }
      >
    >


  export type GaKpiMonthlySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    month?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiMonthly"]>

  export type GaKpiMonthlySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    month?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiMonthly"]>

  export type GaKpiMonthlySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    month?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiMonthly"]>

  export type GaKpiMonthlySelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    month?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
  }

  export type GaKpiMonthlyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "month" | "sessions" | "screenPageViewsPerSession" | "engagementRate" | "avgSessionDurationSec" | "goalCompletions" | "goalCompletionRate" | "createdAt", ExtArgs["result"]["gaKpiMonthly"]>
  export type GaKpiMonthlyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaKpiMonthlyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaKpiMonthlyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }

  export type $GaKpiMonthlyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaKpiMonthly"
    objects: {
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      month: number
      sessions: number
      screenPageViewsPerSession: number
      engagementRate: number
      avgSessionDurationSec: number
      goalCompletions: number
      goalCompletionRate: number
      createdAt: Date
    }, ExtArgs["result"]["gaKpiMonthly"]>
    composites: {}
  }

  type GaKpiMonthlyGetPayload<S extends boolean | null | undefined | GaKpiMonthlyDefaultArgs> = $Result.GetResult<Prisma.$GaKpiMonthlyPayload, S>

  type GaKpiMonthlyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaKpiMonthlyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaKpiMonthlyCountAggregateInputType | true
    }

  export interface GaKpiMonthlyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaKpiMonthly'], meta: { name: 'GaKpiMonthly' } }
    /**
     * Find zero or one GaKpiMonthly that matches the filter.
     * @param {GaKpiMonthlyFindUniqueArgs} args - Arguments to find a GaKpiMonthly
     * @example
     * // Get one GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaKpiMonthlyFindUniqueArgs>(args: SelectSubset<T, GaKpiMonthlyFindUniqueArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaKpiMonthly that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaKpiMonthlyFindUniqueOrThrowArgs} args - Arguments to find a GaKpiMonthly
     * @example
     * // Get one GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaKpiMonthlyFindUniqueOrThrowArgs>(args: SelectSubset<T, GaKpiMonthlyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaKpiMonthly that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyFindFirstArgs} args - Arguments to find a GaKpiMonthly
     * @example
     * // Get one GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaKpiMonthlyFindFirstArgs>(args?: SelectSubset<T, GaKpiMonthlyFindFirstArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaKpiMonthly that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyFindFirstOrThrowArgs} args - Arguments to find a GaKpiMonthly
     * @example
     * // Get one GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaKpiMonthlyFindFirstOrThrowArgs>(args?: SelectSubset<T, GaKpiMonthlyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaKpiMonthlies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaKpiMonthlies
     * const gaKpiMonthlies = await prisma.gaKpiMonthly.findMany()
     * 
     * // Get first 10 GaKpiMonthlies
     * const gaKpiMonthlies = await prisma.gaKpiMonthly.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaKpiMonthlyWithIdOnly = await prisma.gaKpiMonthly.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaKpiMonthlyFindManyArgs>(args?: SelectSubset<T, GaKpiMonthlyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaKpiMonthly.
     * @param {GaKpiMonthlyCreateArgs} args - Arguments to create a GaKpiMonthly.
     * @example
     * // Create one GaKpiMonthly
     * const GaKpiMonthly = await prisma.gaKpiMonthly.create({
     *   data: {
     *     // ... data to create a GaKpiMonthly
     *   }
     * })
     * 
     */
    create<T extends GaKpiMonthlyCreateArgs>(args: SelectSubset<T, GaKpiMonthlyCreateArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaKpiMonthlies.
     * @param {GaKpiMonthlyCreateManyArgs} args - Arguments to create many GaKpiMonthlies.
     * @example
     * // Create many GaKpiMonthlies
     * const gaKpiMonthly = await prisma.gaKpiMonthly.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaKpiMonthlyCreateManyArgs>(args?: SelectSubset<T, GaKpiMonthlyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaKpiMonthlies and returns the data saved in the database.
     * @param {GaKpiMonthlyCreateManyAndReturnArgs} args - Arguments to create many GaKpiMonthlies.
     * @example
     * // Create many GaKpiMonthlies
     * const gaKpiMonthly = await prisma.gaKpiMonthly.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaKpiMonthlies and only return the `id`
     * const gaKpiMonthlyWithIdOnly = await prisma.gaKpiMonthly.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaKpiMonthlyCreateManyAndReturnArgs>(args?: SelectSubset<T, GaKpiMonthlyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaKpiMonthly.
     * @param {GaKpiMonthlyDeleteArgs} args - Arguments to delete one GaKpiMonthly.
     * @example
     * // Delete one GaKpiMonthly
     * const GaKpiMonthly = await prisma.gaKpiMonthly.delete({
     *   where: {
     *     // ... filter to delete one GaKpiMonthly
     *   }
     * })
     * 
     */
    delete<T extends GaKpiMonthlyDeleteArgs>(args: SelectSubset<T, GaKpiMonthlyDeleteArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaKpiMonthly.
     * @param {GaKpiMonthlyUpdateArgs} args - Arguments to update one GaKpiMonthly.
     * @example
     * // Update one GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaKpiMonthlyUpdateArgs>(args: SelectSubset<T, GaKpiMonthlyUpdateArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaKpiMonthlies.
     * @param {GaKpiMonthlyDeleteManyArgs} args - Arguments to filter GaKpiMonthlies to delete.
     * @example
     * // Delete a few GaKpiMonthlies
     * const { count } = await prisma.gaKpiMonthly.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaKpiMonthlyDeleteManyArgs>(args?: SelectSubset<T, GaKpiMonthlyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaKpiMonthlies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaKpiMonthlies
     * const gaKpiMonthly = await prisma.gaKpiMonthly.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaKpiMonthlyUpdateManyArgs>(args: SelectSubset<T, GaKpiMonthlyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaKpiMonthlies and returns the data updated in the database.
     * @param {GaKpiMonthlyUpdateManyAndReturnArgs} args - Arguments to update many GaKpiMonthlies.
     * @example
     * // Update many GaKpiMonthlies
     * const gaKpiMonthly = await prisma.gaKpiMonthly.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaKpiMonthlies and only return the `id`
     * const gaKpiMonthlyWithIdOnly = await prisma.gaKpiMonthly.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaKpiMonthlyUpdateManyAndReturnArgs>(args: SelectSubset<T, GaKpiMonthlyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaKpiMonthly.
     * @param {GaKpiMonthlyUpsertArgs} args - Arguments to update or create a GaKpiMonthly.
     * @example
     * // Update or create a GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.upsert({
     *   create: {
     *     // ... data to create a GaKpiMonthly
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaKpiMonthly we want to update
     *   }
     * })
     */
    upsert<T extends GaKpiMonthlyUpsertArgs>(args: SelectSubset<T, GaKpiMonthlyUpsertArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaKpiMonthlies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyCountArgs} args - Arguments to filter GaKpiMonthlies to count.
     * @example
     * // Count the number of GaKpiMonthlies
     * const count = await prisma.gaKpiMonthly.count({
     *   where: {
     *     // ... the filter for the GaKpiMonthlies we want to count
     *   }
     * })
    **/
    count<T extends GaKpiMonthlyCountArgs>(
      args?: Subset<T, GaKpiMonthlyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaKpiMonthlyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaKpiMonthly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaKpiMonthlyAggregateArgs>(args: Subset<T, GaKpiMonthlyAggregateArgs>): Prisma.PrismaPromise<GetGaKpiMonthlyAggregateType<T>>

    /**
     * Group by GaKpiMonthly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaKpiMonthlyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaKpiMonthlyGroupByArgs['orderBy'] }
        : { orderBy?: GaKpiMonthlyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaKpiMonthlyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaKpiMonthlyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaKpiMonthly model
   */
  readonly fields: GaKpiMonthlyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaKpiMonthly.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaKpiMonthlyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaProperty<T extends GaPropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaPropertyDefaultArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaKpiMonthly model
   */
  interface GaKpiMonthlyFieldRefs {
    readonly id: FieldRef<"GaKpiMonthly", 'String'>
    readonly gaPropertyId: FieldRef<"GaKpiMonthly", 'String'>
    readonly month: FieldRef<"GaKpiMonthly", 'Int'>
    readonly sessions: FieldRef<"GaKpiMonthly", 'Int'>
    readonly screenPageViewsPerSession: FieldRef<"GaKpiMonthly", 'Float'>
    readonly engagementRate: FieldRef<"GaKpiMonthly", 'Float'>
    readonly avgSessionDurationSec: FieldRef<"GaKpiMonthly", 'Int'>
    readonly goalCompletions: FieldRef<"GaKpiMonthly", 'Int'>
    readonly goalCompletionRate: FieldRef<"GaKpiMonthly", 'Float'>
    readonly createdAt: FieldRef<"GaKpiMonthly", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaKpiMonthly findUnique
   */
  export type GaKpiMonthlyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiMonthly to fetch.
     */
    where: GaKpiMonthlyWhereUniqueInput
  }

  /**
   * GaKpiMonthly findUniqueOrThrow
   */
  export type GaKpiMonthlyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiMonthly to fetch.
     */
    where: GaKpiMonthlyWhereUniqueInput
  }

  /**
   * GaKpiMonthly findFirst
   */
  export type GaKpiMonthlyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiMonthly to fetch.
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiMonthlies to fetch.
     */
    orderBy?: GaKpiMonthlyOrderByWithRelationInput | GaKpiMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaKpiMonthlies.
     */
    cursor?: GaKpiMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiMonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaKpiMonthlies.
     */
    distinct?: GaKpiMonthlyScalarFieldEnum | GaKpiMonthlyScalarFieldEnum[]
  }

  /**
   * GaKpiMonthly findFirstOrThrow
   */
  export type GaKpiMonthlyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiMonthly to fetch.
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiMonthlies to fetch.
     */
    orderBy?: GaKpiMonthlyOrderByWithRelationInput | GaKpiMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaKpiMonthlies.
     */
    cursor?: GaKpiMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiMonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaKpiMonthlies.
     */
    distinct?: GaKpiMonthlyScalarFieldEnum | GaKpiMonthlyScalarFieldEnum[]
  }

  /**
   * GaKpiMonthly findMany
   */
  export type GaKpiMonthlyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiMonthlies to fetch.
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiMonthlies to fetch.
     */
    orderBy?: GaKpiMonthlyOrderByWithRelationInput | GaKpiMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaKpiMonthlies.
     */
    cursor?: GaKpiMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiMonthlies.
     */
    skip?: number
    distinct?: GaKpiMonthlyScalarFieldEnum | GaKpiMonthlyScalarFieldEnum[]
  }

  /**
   * GaKpiMonthly create
   */
  export type GaKpiMonthlyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * The data needed to create a GaKpiMonthly.
     */
    data: XOR<GaKpiMonthlyCreateInput, GaKpiMonthlyUncheckedCreateInput>
  }

  /**
   * GaKpiMonthly createMany
   */
  export type GaKpiMonthlyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaKpiMonthlies.
     */
    data: GaKpiMonthlyCreateManyInput | GaKpiMonthlyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaKpiMonthly createManyAndReturn
   */
  export type GaKpiMonthlyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * The data used to create many GaKpiMonthlies.
     */
    data: GaKpiMonthlyCreateManyInput | GaKpiMonthlyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaKpiMonthly update
   */
  export type GaKpiMonthlyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * The data needed to update a GaKpiMonthly.
     */
    data: XOR<GaKpiMonthlyUpdateInput, GaKpiMonthlyUncheckedUpdateInput>
    /**
     * Choose, which GaKpiMonthly to update.
     */
    where: GaKpiMonthlyWhereUniqueInput
  }

  /**
   * GaKpiMonthly updateMany
   */
  export type GaKpiMonthlyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaKpiMonthlies.
     */
    data: XOR<GaKpiMonthlyUpdateManyMutationInput, GaKpiMonthlyUncheckedUpdateManyInput>
    /**
     * Filter which GaKpiMonthlies to update
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * Limit how many GaKpiMonthlies to update.
     */
    limit?: number
  }

  /**
   * GaKpiMonthly updateManyAndReturn
   */
  export type GaKpiMonthlyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * The data used to update GaKpiMonthlies.
     */
    data: XOR<GaKpiMonthlyUpdateManyMutationInput, GaKpiMonthlyUncheckedUpdateManyInput>
    /**
     * Filter which GaKpiMonthlies to update
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * Limit how many GaKpiMonthlies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaKpiMonthly upsert
   */
  export type GaKpiMonthlyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * The filter to search for the GaKpiMonthly to update in case it exists.
     */
    where: GaKpiMonthlyWhereUniqueInput
    /**
     * In case the GaKpiMonthly found by the `where` argument doesn't exist, create a new GaKpiMonthly with this data.
     */
    create: XOR<GaKpiMonthlyCreateInput, GaKpiMonthlyUncheckedCreateInput>
    /**
     * In case the GaKpiMonthly was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaKpiMonthlyUpdateInput, GaKpiMonthlyUncheckedUpdateInput>
  }

  /**
   * GaKpiMonthly delete
   */
  export type GaKpiMonthlyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter which GaKpiMonthly to delete.
     */
    where: GaKpiMonthlyWhereUniqueInput
  }

  /**
   * GaKpiMonthly deleteMany
   */
  export type GaKpiMonthlyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaKpiMonthlies to delete
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * Limit how many GaKpiMonthlies to delete.
     */
    limit?: number
  }

  /**
   * GaKpiMonthly without action
   */
  export type GaKpiMonthlyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
  }


  /**
   * Model GaChannelDaily
   */

  export type AggregateGaChannelDaily = {
    _count: GaChannelDailyCountAggregateOutputType | null
    _avg: GaChannelDailyAvgAggregateOutputType | null
    _sum: GaChannelDailySumAggregateOutputType | null
    _min: GaChannelDailyMinAggregateOutputType | null
    _max: GaChannelDailyMaxAggregateOutputType | null
  }

  export type GaChannelDailyAvgAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaChannelDailySumAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaChannelDailyMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    channelGroup: string | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
  }

  export type GaChannelDailyMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    channelGroup: string | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
  }

  export type GaChannelDailyCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    date: number
    channelGroup: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: number
    _all: number
  }


  export type GaChannelDailyAvgAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaChannelDailySumAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaChannelDailyMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    channelGroup?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
  }

  export type GaChannelDailyMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    channelGroup?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
  }

  export type GaChannelDailyCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    channelGroup?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    _all?: true
  }

  export type GaChannelDailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaChannelDaily to aggregate.
     */
    where?: GaChannelDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaChannelDailies to fetch.
     */
    orderBy?: GaChannelDailyOrderByWithRelationInput | GaChannelDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaChannelDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaChannelDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaChannelDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaChannelDailies
    **/
    _count?: true | GaChannelDailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GaChannelDailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GaChannelDailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaChannelDailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaChannelDailyMaxAggregateInputType
  }

  export type GetGaChannelDailyAggregateType<T extends GaChannelDailyAggregateArgs> = {
        [P in keyof T & keyof AggregateGaChannelDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaChannelDaily[P]>
      : GetScalarType<T[P], AggregateGaChannelDaily[P]>
  }




  export type GaChannelDailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaChannelDailyWhereInput
    orderBy?: GaChannelDailyOrderByWithAggregationInput | GaChannelDailyOrderByWithAggregationInput[]
    by: GaChannelDailyScalarFieldEnum[] | GaChannelDailyScalarFieldEnum
    having?: GaChannelDailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaChannelDailyCountAggregateInputType | true
    _avg?: GaChannelDailyAvgAggregateInputType
    _sum?: GaChannelDailySumAggregateInputType
    _min?: GaChannelDailyMinAggregateInputType
    _max?: GaChannelDailyMaxAggregateInputType
  }

  export type GaChannelDailyGroupByOutputType = {
    id: string
    gaPropertyId: string
    date: Date
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: Date
    _count: GaChannelDailyCountAggregateOutputType | null
    _avg: GaChannelDailyAvgAggregateOutputType | null
    _sum: GaChannelDailySumAggregateOutputType | null
    _min: GaChannelDailyMinAggregateOutputType | null
    _max: GaChannelDailyMaxAggregateOutputType | null
  }

  type GetGaChannelDailyGroupByPayload<T extends GaChannelDailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaChannelDailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaChannelDailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaChannelDailyGroupByOutputType[P]>
            : GetScalarType<T[P], GaChannelDailyGroupByOutputType[P]>
        }
      >
    >


  export type GaChannelDailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    channelGroup?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaChannelDaily"]>

  export type GaChannelDailySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    channelGroup?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaChannelDaily"]>

  export type GaChannelDailySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    channelGroup?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaChannelDaily"]>

  export type GaChannelDailySelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    channelGroup?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
  }

  export type GaChannelDailyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "date" | "channelGroup" | "sessions" | "screenPageViewsPerSession" | "engagementRate" | "avgSessionDurationSec" | "goalCompletions" | "goalCompletionRate" | "createdAt", ExtArgs["result"]["gaChannelDaily"]>
  export type GaChannelDailyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaChannelDailyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaChannelDailyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }

  export type $GaChannelDailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaChannelDaily"
    objects: {
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      date: Date
      channelGroup: string
      sessions: number
      screenPageViewsPerSession: number
      engagementRate: number
      avgSessionDurationSec: number
      goalCompletions: number
      goalCompletionRate: number
      createdAt: Date
    }, ExtArgs["result"]["gaChannelDaily"]>
    composites: {}
  }

  type GaChannelDailyGetPayload<S extends boolean | null | undefined | GaChannelDailyDefaultArgs> = $Result.GetResult<Prisma.$GaChannelDailyPayload, S>

  type GaChannelDailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaChannelDailyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaChannelDailyCountAggregateInputType | true
    }

  export interface GaChannelDailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaChannelDaily'], meta: { name: 'GaChannelDaily' } }
    /**
     * Find zero or one GaChannelDaily that matches the filter.
     * @param {GaChannelDailyFindUniqueArgs} args - Arguments to find a GaChannelDaily
     * @example
     * // Get one GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaChannelDailyFindUniqueArgs>(args: SelectSubset<T, GaChannelDailyFindUniqueArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaChannelDaily that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaChannelDailyFindUniqueOrThrowArgs} args - Arguments to find a GaChannelDaily
     * @example
     * // Get one GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaChannelDailyFindUniqueOrThrowArgs>(args: SelectSubset<T, GaChannelDailyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaChannelDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyFindFirstArgs} args - Arguments to find a GaChannelDaily
     * @example
     * // Get one GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaChannelDailyFindFirstArgs>(args?: SelectSubset<T, GaChannelDailyFindFirstArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaChannelDaily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyFindFirstOrThrowArgs} args - Arguments to find a GaChannelDaily
     * @example
     * // Get one GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaChannelDailyFindFirstOrThrowArgs>(args?: SelectSubset<T, GaChannelDailyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaChannelDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaChannelDailies
     * const gaChannelDailies = await prisma.gaChannelDaily.findMany()
     * 
     * // Get first 10 GaChannelDailies
     * const gaChannelDailies = await prisma.gaChannelDaily.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaChannelDailyWithIdOnly = await prisma.gaChannelDaily.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaChannelDailyFindManyArgs>(args?: SelectSubset<T, GaChannelDailyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaChannelDaily.
     * @param {GaChannelDailyCreateArgs} args - Arguments to create a GaChannelDaily.
     * @example
     * // Create one GaChannelDaily
     * const GaChannelDaily = await prisma.gaChannelDaily.create({
     *   data: {
     *     // ... data to create a GaChannelDaily
     *   }
     * })
     * 
     */
    create<T extends GaChannelDailyCreateArgs>(args: SelectSubset<T, GaChannelDailyCreateArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaChannelDailies.
     * @param {GaChannelDailyCreateManyArgs} args - Arguments to create many GaChannelDailies.
     * @example
     * // Create many GaChannelDailies
     * const gaChannelDaily = await prisma.gaChannelDaily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaChannelDailyCreateManyArgs>(args?: SelectSubset<T, GaChannelDailyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaChannelDailies and returns the data saved in the database.
     * @param {GaChannelDailyCreateManyAndReturnArgs} args - Arguments to create many GaChannelDailies.
     * @example
     * // Create many GaChannelDailies
     * const gaChannelDaily = await prisma.gaChannelDaily.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaChannelDailies and only return the `id`
     * const gaChannelDailyWithIdOnly = await prisma.gaChannelDaily.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaChannelDailyCreateManyAndReturnArgs>(args?: SelectSubset<T, GaChannelDailyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaChannelDaily.
     * @param {GaChannelDailyDeleteArgs} args - Arguments to delete one GaChannelDaily.
     * @example
     * // Delete one GaChannelDaily
     * const GaChannelDaily = await prisma.gaChannelDaily.delete({
     *   where: {
     *     // ... filter to delete one GaChannelDaily
     *   }
     * })
     * 
     */
    delete<T extends GaChannelDailyDeleteArgs>(args: SelectSubset<T, GaChannelDailyDeleteArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaChannelDaily.
     * @param {GaChannelDailyUpdateArgs} args - Arguments to update one GaChannelDaily.
     * @example
     * // Update one GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaChannelDailyUpdateArgs>(args: SelectSubset<T, GaChannelDailyUpdateArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaChannelDailies.
     * @param {GaChannelDailyDeleteManyArgs} args - Arguments to filter GaChannelDailies to delete.
     * @example
     * // Delete a few GaChannelDailies
     * const { count } = await prisma.gaChannelDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaChannelDailyDeleteManyArgs>(args?: SelectSubset<T, GaChannelDailyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaChannelDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaChannelDailies
     * const gaChannelDaily = await prisma.gaChannelDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaChannelDailyUpdateManyArgs>(args: SelectSubset<T, GaChannelDailyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaChannelDailies and returns the data updated in the database.
     * @param {GaChannelDailyUpdateManyAndReturnArgs} args - Arguments to update many GaChannelDailies.
     * @example
     * // Update many GaChannelDailies
     * const gaChannelDaily = await prisma.gaChannelDaily.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaChannelDailies and only return the `id`
     * const gaChannelDailyWithIdOnly = await prisma.gaChannelDaily.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaChannelDailyUpdateManyAndReturnArgs>(args: SelectSubset<T, GaChannelDailyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaChannelDaily.
     * @param {GaChannelDailyUpsertArgs} args - Arguments to update or create a GaChannelDaily.
     * @example
     * // Update or create a GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.upsert({
     *   create: {
     *     // ... data to create a GaChannelDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaChannelDaily we want to update
     *   }
     * })
     */
    upsert<T extends GaChannelDailyUpsertArgs>(args: SelectSubset<T, GaChannelDailyUpsertArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaChannelDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyCountArgs} args - Arguments to filter GaChannelDailies to count.
     * @example
     * // Count the number of GaChannelDailies
     * const count = await prisma.gaChannelDaily.count({
     *   where: {
     *     // ... the filter for the GaChannelDailies we want to count
     *   }
     * })
    **/
    count<T extends GaChannelDailyCountArgs>(
      args?: Subset<T, GaChannelDailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaChannelDailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaChannelDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaChannelDailyAggregateArgs>(args: Subset<T, GaChannelDailyAggregateArgs>): Prisma.PrismaPromise<GetGaChannelDailyAggregateType<T>>

    /**
     * Group by GaChannelDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaChannelDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaChannelDailyGroupByArgs['orderBy'] }
        : { orderBy?: GaChannelDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaChannelDailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaChannelDailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaChannelDaily model
   */
  readonly fields: GaChannelDailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaChannelDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaChannelDailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaProperty<T extends GaPropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaPropertyDefaultArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaChannelDaily model
   */
  interface GaChannelDailyFieldRefs {
    readonly id: FieldRef<"GaChannelDaily", 'String'>
    readonly gaPropertyId: FieldRef<"GaChannelDaily", 'String'>
    readonly date: FieldRef<"GaChannelDaily", 'DateTime'>
    readonly channelGroup: FieldRef<"GaChannelDaily", 'String'>
    readonly sessions: FieldRef<"GaChannelDaily", 'Int'>
    readonly screenPageViewsPerSession: FieldRef<"GaChannelDaily", 'Float'>
    readonly engagementRate: FieldRef<"GaChannelDaily", 'Float'>
    readonly avgSessionDurationSec: FieldRef<"GaChannelDaily", 'Int'>
    readonly goalCompletions: FieldRef<"GaChannelDaily", 'Int'>
    readonly goalCompletionRate: FieldRef<"GaChannelDaily", 'Float'>
    readonly createdAt: FieldRef<"GaChannelDaily", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaChannelDaily findUnique
   */
  export type GaChannelDailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaChannelDaily to fetch.
     */
    where: GaChannelDailyWhereUniqueInput
  }

  /**
   * GaChannelDaily findUniqueOrThrow
   */
  export type GaChannelDailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaChannelDaily to fetch.
     */
    where: GaChannelDailyWhereUniqueInput
  }

  /**
   * GaChannelDaily findFirst
   */
  export type GaChannelDailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaChannelDaily to fetch.
     */
    where?: GaChannelDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaChannelDailies to fetch.
     */
    orderBy?: GaChannelDailyOrderByWithRelationInput | GaChannelDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaChannelDailies.
     */
    cursor?: GaChannelDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaChannelDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaChannelDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaChannelDailies.
     */
    distinct?: GaChannelDailyScalarFieldEnum | GaChannelDailyScalarFieldEnum[]
  }

  /**
   * GaChannelDaily findFirstOrThrow
   */
  export type GaChannelDailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaChannelDaily to fetch.
     */
    where?: GaChannelDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaChannelDailies to fetch.
     */
    orderBy?: GaChannelDailyOrderByWithRelationInput | GaChannelDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaChannelDailies.
     */
    cursor?: GaChannelDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaChannelDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaChannelDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaChannelDailies.
     */
    distinct?: GaChannelDailyScalarFieldEnum | GaChannelDailyScalarFieldEnum[]
  }

  /**
   * GaChannelDaily findMany
   */
  export type GaChannelDailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaChannelDailies to fetch.
     */
    where?: GaChannelDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaChannelDailies to fetch.
     */
    orderBy?: GaChannelDailyOrderByWithRelationInput | GaChannelDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaChannelDailies.
     */
    cursor?: GaChannelDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaChannelDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaChannelDailies.
     */
    skip?: number
    distinct?: GaChannelDailyScalarFieldEnum | GaChannelDailyScalarFieldEnum[]
  }

  /**
   * GaChannelDaily create
   */
  export type GaChannelDailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * The data needed to create a GaChannelDaily.
     */
    data: XOR<GaChannelDailyCreateInput, GaChannelDailyUncheckedCreateInput>
  }

  /**
   * GaChannelDaily createMany
   */
  export type GaChannelDailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaChannelDailies.
     */
    data: GaChannelDailyCreateManyInput | GaChannelDailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaChannelDaily createManyAndReturn
   */
  export type GaChannelDailyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * The data used to create many GaChannelDailies.
     */
    data: GaChannelDailyCreateManyInput | GaChannelDailyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaChannelDaily update
   */
  export type GaChannelDailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * The data needed to update a GaChannelDaily.
     */
    data: XOR<GaChannelDailyUpdateInput, GaChannelDailyUncheckedUpdateInput>
    /**
     * Choose, which GaChannelDaily to update.
     */
    where: GaChannelDailyWhereUniqueInput
  }

  /**
   * GaChannelDaily updateMany
   */
  export type GaChannelDailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaChannelDailies.
     */
    data: XOR<GaChannelDailyUpdateManyMutationInput, GaChannelDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaChannelDailies to update
     */
    where?: GaChannelDailyWhereInput
    /**
     * Limit how many GaChannelDailies to update.
     */
    limit?: number
  }

  /**
   * GaChannelDaily updateManyAndReturn
   */
  export type GaChannelDailyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * The data used to update GaChannelDailies.
     */
    data: XOR<GaChannelDailyUpdateManyMutationInput, GaChannelDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaChannelDailies to update
     */
    where?: GaChannelDailyWhereInput
    /**
     * Limit how many GaChannelDailies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaChannelDaily upsert
   */
  export type GaChannelDailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * The filter to search for the GaChannelDaily to update in case it exists.
     */
    where: GaChannelDailyWhereUniqueInput
    /**
     * In case the GaChannelDaily found by the `where` argument doesn't exist, create a new GaChannelDaily with this data.
     */
    create: XOR<GaChannelDailyCreateInput, GaChannelDailyUncheckedCreateInput>
    /**
     * In case the GaChannelDaily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaChannelDailyUpdateInput, GaChannelDailyUncheckedUpdateInput>
  }

  /**
   * GaChannelDaily delete
   */
  export type GaChannelDailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter which GaChannelDaily to delete.
     */
    where: GaChannelDailyWhereUniqueInput
  }

  /**
   * GaChannelDaily deleteMany
   */
  export type GaChannelDailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaChannelDailies to delete
     */
    where?: GaChannelDailyWhereInput
    /**
     * Limit how many GaChannelDailies to delete.
     */
    limit?: number
  }

  /**
   * GaChannelDaily without action
   */
  export type GaChannelDailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
  }


  /**
   * Model GaSourceDaily
   */

  export type AggregateGaSourceDaily = {
    _count: GaSourceDailyCountAggregateOutputType | null
    _avg: GaSourceDailyAvgAggregateOutputType | null
    _sum: GaSourceDailySumAggregateOutputType | null
    _min: GaSourceDailyMinAggregateOutputType | null
    _max: GaSourceDailyMaxAggregateOutputType | null
  }

  export type GaSourceDailyAvgAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaSourceDailySumAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaSourceDailyMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    trafficSource: string | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
  }

  export type GaSourceDailyMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    trafficSource: string | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
  }

  export type GaSourceDailyCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    date: number
    trafficSource: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: number
    _all: number
  }


  export type GaSourceDailyAvgAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaSourceDailySumAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaSourceDailyMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    trafficSource?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
  }

  export type GaSourceDailyMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    trafficSource?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
  }

  export type GaSourceDailyCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    trafficSource?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    _all?: true
  }

  export type GaSourceDailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaSourceDaily to aggregate.
     */
    where?: GaSourceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaSourceDailies to fetch.
     */
    orderBy?: GaSourceDailyOrderByWithRelationInput | GaSourceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaSourceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaSourceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaSourceDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaSourceDailies
    **/
    _count?: true | GaSourceDailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GaSourceDailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GaSourceDailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaSourceDailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaSourceDailyMaxAggregateInputType
  }

  export type GetGaSourceDailyAggregateType<T extends GaSourceDailyAggregateArgs> = {
        [P in keyof T & keyof AggregateGaSourceDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaSourceDaily[P]>
      : GetScalarType<T[P], AggregateGaSourceDaily[P]>
  }




  export type GaSourceDailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaSourceDailyWhereInput
    orderBy?: GaSourceDailyOrderByWithAggregationInput | GaSourceDailyOrderByWithAggregationInput[]
    by: GaSourceDailyScalarFieldEnum[] | GaSourceDailyScalarFieldEnum
    having?: GaSourceDailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaSourceDailyCountAggregateInputType | true
    _avg?: GaSourceDailyAvgAggregateInputType
    _sum?: GaSourceDailySumAggregateInputType
    _min?: GaSourceDailyMinAggregateInputType
    _max?: GaSourceDailyMaxAggregateInputType
  }

  export type GaSourceDailyGroupByOutputType = {
    id: string
    gaPropertyId: string
    date: Date
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: Date
    _count: GaSourceDailyCountAggregateOutputType | null
    _avg: GaSourceDailyAvgAggregateOutputType | null
    _sum: GaSourceDailySumAggregateOutputType | null
    _min: GaSourceDailyMinAggregateOutputType | null
    _max: GaSourceDailyMaxAggregateOutputType | null
  }

  type GetGaSourceDailyGroupByPayload<T extends GaSourceDailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaSourceDailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaSourceDailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaSourceDailyGroupByOutputType[P]>
            : GetScalarType<T[P], GaSourceDailyGroupByOutputType[P]>
        }
      >
    >


  export type GaSourceDailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    trafficSource?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaSourceDaily"]>

  export type GaSourceDailySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    trafficSource?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaSourceDaily"]>

  export type GaSourceDailySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    trafficSource?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaSourceDaily"]>

  export type GaSourceDailySelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    trafficSource?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
  }

  export type GaSourceDailyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "date" | "trafficSource" | "sessions" | "screenPageViewsPerSession" | "engagementRate" | "avgSessionDurationSec" | "goalCompletions" | "goalCompletionRate" | "createdAt", ExtArgs["result"]["gaSourceDaily"]>
  export type GaSourceDailyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaSourceDailyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaSourceDailyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }

  export type $GaSourceDailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaSourceDaily"
    objects: {
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      date: Date
      trafficSource: string
      sessions: number
      screenPageViewsPerSession: number
      engagementRate: number
      avgSessionDurationSec: number
      goalCompletions: number
      goalCompletionRate: number
      createdAt: Date
    }, ExtArgs["result"]["gaSourceDaily"]>
    composites: {}
  }

  type GaSourceDailyGetPayload<S extends boolean | null | undefined | GaSourceDailyDefaultArgs> = $Result.GetResult<Prisma.$GaSourceDailyPayload, S>

  type GaSourceDailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaSourceDailyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaSourceDailyCountAggregateInputType | true
    }

  export interface GaSourceDailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaSourceDaily'], meta: { name: 'GaSourceDaily' } }
    /**
     * Find zero or one GaSourceDaily that matches the filter.
     * @param {GaSourceDailyFindUniqueArgs} args - Arguments to find a GaSourceDaily
     * @example
     * // Get one GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaSourceDailyFindUniqueArgs>(args: SelectSubset<T, GaSourceDailyFindUniqueArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaSourceDaily that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaSourceDailyFindUniqueOrThrowArgs} args - Arguments to find a GaSourceDaily
     * @example
     * // Get one GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaSourceDailyFindUniqueOrThrowArgs>(args: SelectSubset<T, GaSourceDailyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaSourceDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyFindFirstArgs} args - Arguments to find a GaSourceDaily
     * @example
     * // Get one GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaSourceDailyFindFirstArgs>(args?: SelectSubset<T, GaSourceDailyFindFirstArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaSourceDaily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyFindFirstOrThrowArgs} args - Arguments to find a GaSourceDaily
     * @example
     * // Get one GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaSourceDailyFindFirstOrThrowArgs>(args?: SelectSubset<T, GaSourceDailyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaSourceDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaSourceDailies
     * const gaSourceDailies = await prisma.gaSourceDaily.findMany()
     * 
     * // Get first 10 GaSourceDailies
     * const gaSourceDailies = await prisma.gaSourceDaily.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaSourceDailyWithIdOnly = await prisma.gaSourceDaily.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaSourceDailyFindManyArgs>(args?: SelectSubset<T, GaSourceDailyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaSourceDaily.
     * @param {GaSourceDailyCreateArgs} args - Arguments to create a GaSourceDaily.
     * @example
     * // Create one GaSourceDaily
     * const GaSourceDaily = await prisma.gaSourceDaily.create({
     *   data: {
     *     // ... data to create a GaSourceDaily
     *   }
     * })
     * 
     */
    create<T extends GaSourceDailyCreateArgs>(args: SelectSubset<T, GaSourceDailyCreateArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaSourceDailies.
     * @param {GaSourceDailyCreateManyArgs} args - Arguments to create many GaSourceDailies.
     * @example
     * // Create many GaSourceDailies
     * const gaSourceDaily = await prisma.gaSourceDaily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaSourceDailyCreateManyArgs>(args?: SelectSubset<T, GaSourceDailyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaSourceDailies and returns the data saved in the database.
     * @param {GaSourceDailyCreateManyAndReturnArgs} args - Arguments to create many GaSourceDailies.
     * @example
     * // Create many GaSourceDailies
     * const gaSourceDaily = await prisma.gaSourceDaily.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaSourceDailies and only return the `id`
     * const gaSourceDailyWithIdOnly = await prisma.gaSourceDaily.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaSourceDailyCreateManyAndReturnArgs>(args?: SelectSubset<T, GaSourceDailyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaSourceDaily.
     * @param {GaSourceDailyDeleteArgs} args - Arguments to delete one GaSourceDaily.
     * @example
     * // Delete one GaSourceDaily
     * const GaSourceDaily = await prisma.gaSourceDaily.delete({
     *   where: {
     *     // ... filter to delete one GaSourceDaily
     *   }
     * })
     * 
     */
    delete<T extends GaSourceDailyDeleteArgs>(args: SelectSubset<T, GaSourceDailyDeleteArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaSourceDaily.
     * @param {GaSourceDailyUpdateArgs} args - Arguments to update one GaSourceDaily.
     * @example
     * // Update one GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaSourceDailyUpdateArgs>(args: SelectSubset<T, GaSourceDailyUpdateArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaSourceDailies.
     * @param {GaSourceDailyDeleteManyArgs} args - Arguments to filter GaSourceDailies to delete.
     * @example
     * // Delete a few GaSourceDailies
     * const { count } = await prisma.gaSourceDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaSourceDailyDeleteManyArgs>(args?: SelectSubset<T, GaSourceDailyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaSourceDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaSourceDailies
     * const gaSourceDaily = await prisma.gaSourceDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaSourceDailyUpdateManyArgs>(args: SelectSubset<T, GaSourceDailyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaSourceDailies and returns the data updated in the database.
     * @param {GaSourceDailyUpdateManyAndReturnArgs} args - Arguments to update many GaSourceDailies.
     * @example
     * // Update many GaSourceDailies
     * const gaSourceDaily = await prisma.gaSourceDaily.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaSourceDailies and only return the `id`
     * const gaSourceDailyWithIdOnly = await prisma.gaSourceDaily.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaSourceDailyUpdateManyAndReturnArgs>(args: SelectSubset<T, GaSourceDailyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaSourceDaily.
     * @param {GaSourceDailyUpsertArgs} args - Arguments to update or create a GaSourceDaily.
     * @example
     * // Update or create a GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.upsert({
     *   create: {
     *     // ... data to create a GaSourceDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaSourceDaily we want to update
     *   }
     * })
     */
    upsert<T extends GaSourceDailyUpsertArgs>(args: SelectSubset<T, GaSourceDailyUpsertArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaSourceDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyCountArgs} args - Arguments to filter GaSourceDailies to count.
     * @example
     * // Count the number of GaSourceDailies
     * const count = await prisma.gaSourceDaily.count({
     *   where: {
     *     // ... the filter for the GaSourceDailies we want to count
     *   }
     * })
    **/
    count<T extends GaSourceDailyCountArgs>(
      args?: Subset<T, GaSourceDailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaSourceDailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaSourceDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaSourceDailyAggregateArgs>(args: Subset<T, GaSourceDailyAggregateArgs>): Prisma.PrismaPromise<GetGaSourceDailyAggregateType<T>>

    /**
     * Group by GaSourceDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaSourceDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaSourceDailyGroupByArgs['orderBy'] }
        : { orderBy?: GaSourceDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaSourceDailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaSourceDailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaSourceDaily model
   */
  readonly fields: GaSourceDailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaSourceDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaSourceDailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaProperty<T extends GaPropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaPropertyDefaultArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaSourceDaily model
   */
  interface GaSourceDailyFieldRefs {
    readonly id: FieldRef<"GaSourceDaily", 'String'>
    readonly gaPropertyId: FieldRef<"GaSourceDaily", 'String'>
    readonly date: FieldRef<"GaSourceDaily", 'DateTime'>
    readonly trafficSource: FieldRef<"GaSourceDaily", 'String'>
    readonly sessions: FieldRef<"GaSourceDaily", 'Int'>
    readonly screenPageViewsPerSession: FieldRef<"GaSourceDaily", 'Float'>
    readonly engagementRate: FieldRef<"GaSourceDaily", 'Float'>
    readonly avgSessionDurationSec: FieldRef<"GaSourceDaily", 'Int'>
    readonly goalCompletions: FieldRef<"GaSourceDaily", 'Int'>
    readonly goalCompletionRate: FieldRef<"GaSourceDaily", 'Float'>
    readonly createdAt: FieldRef<"GaSourceDaily", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaSourceDaily findUnique
   */
  export type GaSourceDailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaSourceDaily to fetch.
     */
    where: GaSourceDailyWhereUniqueInput
  }

  /**
   * GaSourceDaily findUniqueOrThrow
   */
  export type GaSourceDailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaSourceDaily to fetch.
     */
    where: GaSourceDailyWhereUniqueInput
  }

  /**
   * GaSourceDaily findFirst
   */
  export type GaSourceDailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaSourceDaily to fetch.
     */
    where?: GaSourceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaSourceDailies to fetch.
     */
    orderBy?: GaSourceDailyOrderByWithRelationInput | GaSourceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaSourceDailies.
     */
    cursor?: GaSourceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaSourceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaSourceDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaSourceDailies.
     */
    distinct?: GaSourceDailyScalarFieldEnum | GaSourceDailyScalarFieldEnum[]
  }

  /**
   * GaSourceDaily findFirstOrThrow
   */
  export type GaSourceDailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaSourceDaily to fetch.
     */
    where?: GaSourceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaSourceDailies to fetch.
     */
    orderBy?: GaSourceDailyOrderByWithRelationInput | GaSourceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaSourceDailies.
     */
    cursor?: GaSourceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaSourceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaSourceDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaSourceDailies.
     */
    distinct?: GaSourceDailyScalarFieldEnum | GaSourceDailyScalarFieldEnum[]
  }

  /**
   * GaSourceDaily findMany
   */
  export type GaSourceDailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaSourceDailies to fetch.
     */
    where?: GaSourceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaSourceDailies to fetch.
     */
    orderBy?: GaSourceDailyOrderByWithRelationInput | GaSourceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaSourceDailies.
     */
    cursor?: GaSourceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaSourceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaSourceDailies.
     */
    skip?: number
    distinct?: GaSourceDailyScalarFieldEnum | GaSourceDailyScalarFieldEnum[]
  }

  /**
   * GaSourceDaily create
   */
  export type GaSourceDailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * The data needed to create a GaSourceDaily.
     */
    data: XOR<GaSourceDailyCreateInput, GaSourceDailyUncheckedCreateInput>
  }

  /**
   * GaSourceDaily createMany
   */
  export type GaSourceDailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaSourceDailies.
     */
    data: GaSourceDailyCreateManyInput | GaSourceDailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaSourceDaily createManyAndReturn
   */
  export type GaSourceDailyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * The data used to create many GaSourceDailies.
     */
    data: GaSourceDailyCreateManyInput | GaSourceDailyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaSourceDaily update
   */
  export type GaSourceDailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * The data needed to update a GaSourceDaily.
     */
    data: XOR<GaSourceDailyUpdateInput, GaSourceDailyUncheckedUpdateInput>
    /**
     * Choose, which GaSourceDaily to update.
     */
    where: GaSourceDailyWhereUniqueInput
  }

  /**
   * GaSourceDaily updateMany
   */
  export type GaSourceDailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaSourceDailies.
     */
    data: XOR<GaSourceDailyUpdateManyMutationInput, GaSourceDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaSourceDailies to update
     */
    where?: GaSourceDailyWhereInput
    /**
     * Limit how many GaSourceDailies to update.
     */
    limit?: number
  }

  /**
   * GaSourceDaily updateManyAndReturn
   */
  export type GaSourceDailyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * The data used to update GaSourceDailies.
     */
    data: XOR<GaSourceDailyUpdateManyMutationInput, GaSourceDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaSourceDailies to update
     */
    where?: GaSourceDailyWhereInput
    /**
     * Limit how many GaSourceDailies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaSourceDaily upsert
   */
  export type GaSourceDailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * The filter to search for the GaSourceDaily to update in case it exists.
     */
    where: GaSourceDailyWhereUniqueInput
    /**
     * In case the GaSourceDaily found by the `where` argument doesn't exist, create a new GaSourceDaily with this data.
     */
    create: XOR<GaSourceDailyCreateInput, GaSourceDailyUncheckedCreateInput>
    /**
     * In case the GaSourceDaily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaSourceDailyUpdateInput, GaSourceDailyUncheckedUpdateInput>
  }

  /**
   * GaSourceDaily delete
   */
  export type GaSourceDailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter which GaSourceDaily to delete.
     */
    where: GaSourceDailyWhereUniqueInput
  }

  /**
   * GaSourceDaily deleteMany
   */
  export type GaSourceDailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaSourceDailies to delete
     */
    where?: GaSourceDailyWhereInput
    /**
     * Limit how many GaSourceDailies to delete.
     */
    limit?: number
  }

  /**
   * GaSourceDaily without action
   */
  export type GaSourceDailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    isRead: boolean | null
    archived: boolean | null
    isThreadStart: boolean | null
    threadId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    senderId: string | null
    recipientId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    isRead: boolean | null
    archived: boolean | null
    isThreadStart: boolean | null
    threadId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    senderId: string | null
    recipientId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    isRead: number
    archived: number
    isThreadStart: number
    threadId: number
    parentId: number
    createdAt: number
    updatedAt: number
    senderId: number
    recipientId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    isRead?: true
    archived?: true
    isThreadStart?: true
    threadId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    senderId?: true
    recipientId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    isRead?: true
    archived?: true
    isThreadStart?: true
    threadId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    senderId?: true
    recipientId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    isRead?: true
    archived?: true
    isThreadStart?: true
    threadId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    senderId?: true
    recipientId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string
    isRead: boolean
    archived: boolean
    isThreadStart: boolean
    threadId: string | null
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    senderId: string
    recipientId: string
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    senderId?: boolean
    recipientId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Message$parentArgs<ExtArgs>
    replies?: boolean | Message$repliesArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    senderId?: boolean
    recipientId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Message$parentArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    senderId?: boolean
    recipientId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Message$parentArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    senderId?: boolean
    recipientId?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "isRead" | "archived" | "isThreadStart" | "threadId" | "parentId" | "createdAt" | "updatedAt" | "senderId" | "recipientId", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Message$parentArgs<ExtArgs>
    replies?: boolean | Message$repliesArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Message$parentArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Message$parentArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      recipient: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$MessagePayload<ExtArgs> | null
      replies: Prisma.$MessagePayload<ExtArgs>[]
      attachments: Prisma.$MessageAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      isRead: boolean
      archived: boolean
      isThreadStart: boolean
      threadId: string | null
      parentId: string | null
      createdAt: Date
      updatedAt: Date
      senderId: string
      recipientId: string
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Message$parentArgs<ExtArgs> = {}>(args?: Subset<T, Message$parentArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Message$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Message$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Message$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly archived: FieldRef<"Message", 'Boolean'>
    readonly isThreadStart: FieldRef<"Message", 'Boolean'>
    readonly threadId: FieldRef<"Message", 'String'>
    readonly parentId: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly recipientId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.parent
   */
  export type Message$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Message.replies
   */
  export type Message$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message.attachments
   */
  export type Message$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    cursor?: MessageAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    content: number
    isRead: number
    createdAt: number
    userId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead: boolean
    createdAt: Date
    userId: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "content" | "isRead" | "createdAt" | "userId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      title: string
      content: string
      isRead: boolean
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly userId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ParsedPieGraphData
   */

  export type AggregateParsedPieGraphData = {
    _count: ParsedPieGraphDataCountAggregateOutputType | null
    _avg: ParsedPieGraphDataAvgAggregateOutputType | null
    _sum: ParsedPieGraphDataSumAggregateOutputType | null
    _min: ParsedPieGraphDataMinAggregateOutputType | null
    _max: ParsedPieGraphDataMaxAggregateOutputType | null
  }

  export type ParsedPieGraphDataAvgAggregateOutputType = {
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    prevSessionsDiff: number | null
    prevConversionRateDiff: number | null
    prevConversionsDiff: number | null
    prevBouncesDiff: number | null
    yearSessionsDiff: number | null
    yearConversionRateDiff: number | null
    yearConversionsDiff: number | null
    yearBouncesDiff: number | null
  }

  export type ParsedPieGraphDataSumAggregateOutputType = {
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    prevSessionsDiff: number | null
    prevConversionRateDiff: number | null
    prevConversionsDiff: number | null
    prevBouncesDiff: number | null
    yearSessionsDiff: number | null
    yearConversionRateDiff: number | null
    yearConversionsDiff: number | null
    yearBouncesDiff: number | null
  }

  export type ParsedPieGraphDataMinAggregateOutputType = {
    id: string | null
    queryId: string | null
    channel: string | null
    source: string | null
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    prevSessionsDiff: number | null
    prevConversionRateDiff: number | null
    prevConversionsDiff: number | null
    prevBouncesDiff: number | null
    yearSessionsDiff: number | null
    yearConversionRateDiff: number | null
    yearConversionsDiff: number | null
    yearBouncesDiff: number | null
    createdAt: Date | null
  }

  export type ParsedPieGraphDataMaxAggregateOutputType = {
    id: string | null
    queryId: string | null
    channel: string | null
    source: string | null
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    prevSessionsDiff: number | null
    prevConversionRateDiff: number | null
    prevConversionsDiff: number | null
    prevBouncesDiff: number | null
    yearSessionsDiff: number | null
    yearConversionRateDiff: number | null
    yearConversionsDiff: number | null
    yearBouncesDiff: number | null
    createdAt: Date | null
  }

  export type ParsedPieGraphDataCountAggregateOutputType = {
    id: number
    queryId: number
    channel: number
    source: number
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt: number
    _all: number
  }


  export type ParsedPieGraphDataAvgAggregateInputType = {
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    prevSessionsDiff?: true
    prevConversionRateDiff?: true
    prevConversionsDiff?: true
    prevBouncesDiff?: true
    yearSessionsDiff?: true
    yearConversionRateDiff?: true
    yearConversionsDiff?: true
    yearBouncesDiff?: true
  }

  export type ParsedPieGraphDataSumAggregateInputType = {
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    prevSessionsDiff?: true
    prevConversionRateDiff?: true
    prevConversionsDiff?: true
    prevBouncesDiff?: true
    yearSessionsDiff?: true
    yearConversionRateDiff?: true
    yearConversionsDiff?: true
    yearBouncesDiff?: true
  }

  export type ParsedPieGraphDataMinAggregateInputType = {
    id?: true
    queryId?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    prevSessionsDiff?: true
    prevConversionRateDiff?: true
    prevConversionsDiff?: true
    prevBouncesDiff?: true
    yearSessionsDiff?: true
    yearConversionRateDiff?: true
    yearConversionsDiff?: true
    yearBouncesDiff?: true
    createdAt?: true
  }

  export type ParsedPieGraphDataMaxAggregateInputType = {
    id?: true
    queryId?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    prevSessionsDiff?: true
    prevConversionRateDiff?: true
    prevConversionsDiff?: true
    prevBouncesDiff?: true
    yearSessionsDiff?: true
    yearConversionRateDiff?: true
    yearConversionsDiff?: true
    yearBouncesDiff?: true
    createdAt?: true
  }

  export type ParsedPieGraphDataCountAggregateInputType = {
    id?: true
    queryId?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    prevSessionsDiff?: true
    prevConversionRateDiff?: true
    prevConversionsDiff?: true
    prevBouncesDiff?: true
    yearSessionsDiff?: true
    yearConversionRateDiff?: true
    yearConversionsDiff?: true
    yearBouncesDiff?: true
    createdAt?: true
    _all?: true
  }

  export type ParsedPieGraphDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedPieGraphData to aggregate.
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedPieGraphData to fetch.
     */
    orderBy?: ParsedPieGraphDataOrderByWithRelationInput | ParsedPieGraphDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParsedPieGraphDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedPieGraphData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedPieGraphData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParsedPieGraphData
    **/
    _count?: true | ParsedPieGraphDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParsedPieGraphDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParsedPieGraphDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParsedPieGraphDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParsedPieGraphDataMaxAggregateInputType
  }

  export type GetParsedPieGraphDataAggregateType<T extends ParsedPieGraphDataAggregateArgs> = {
        [P in keyof T & keyof AggregateParsedPieGraphData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsedPieGraphData[P]>
      : GetScalarType<T[P], AggregateParsedPieGraphData[P]>
  }




  export type ParsedPieGraphDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedPieGraphDataWhereInput
    orderBy?: ParsedPieGraphDataOrderByWithAggregationInput | ParsedPieGraphDataOrderByWithAggregationInput[]
    by: ParsedPieGraphDataScalarFieldEnum[] | ParsedPieGraphDataScalarFieldEnum
    having?: ParsedPieGraphDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParsedPieGraphDataCountAggregateInputType | true
    _avg?: ParsedPieGraphDataAvgAggregateInputType
    _sum?: ParsedPieGraphDataSumAggregateInputType
    _min?: ParsedPieGraphDataMinAggregateInputType
    _max?: ParsedPieGraphDataMaxAggregateInputType
  }

  export type ParsedPieGraphDataGroupByOutputType = {
    id: string
    queryId: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt: Date
    _count: ParsedPieGraphDataCountAggregateOutputType | null
    _avg: ParsedPieGraphDataAvgAggregateOutputType | null
    _sum: ParsedPieGraphDataSumAggregateOutputType | null
    _min: ParsedPieGraphDataMinAggregateOutputType | null
    _max: ParsedPieGraphDataMaxAggregateOutputType | null
  }

  type GetParsedPieGraphDataGroupByPayload<T extends ParsedPieGraphDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParsedPieGraphDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParsedPieGraphDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParsedPieGraphDataGroupByOutputType[P]>
            : GetScalarType<T[P], ParsedPieGraphDataGroupByOutputType[P]>
        }
      >
    >


  export type ParsedPieGraphDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    prevSessionsDiff?: boolean
    prevConversionRateDiff?: boolean
    prevConversionsDiff?: boolean
    prevBouncesDiff?: boolean
    yearSessionsDiff?: boolean
    yearConversionRateDiff?: boolean
    yearConversionsDiff?: boolean
    yearBouncesDiff?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedPieGraphData"]>

  export type ParsedPieGraphDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    prevSessionsDiff?: boolean
    prevConversionRateDiff?: boolean
    prevConversionsDiff?: boolean
    prevBouncesDiff?: boolean
    yearSessionsDiff?: boolean
    yearConversionRateDiff?: boolean
    yearConversionsDiff?: boolean
    yearBouncesDiff?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedPieGraphData"]>

  export type ParsedPieGraphDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    prevSessionsDiff?: boolean
    prevConversionRateDiff?: boolean
    prevConversionsDiff?: boolean
    prevBouncesDiff?: boolean
    yearSessionsDiff?: boolean
    yearConversionRateDiff?: boolean
    yearConversionsDiff?: boolean
    yearBouncesDiff?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedPieGraphData"]>

  export type ParsedPieGraphDataSelectScalar = {
    id?: boolean
    queryId?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    prevSessionsDiff?: boolean
    prevConversionRateDiff?: boolean
    prevConversionsDiff?: boolean
    prevBouncesDiff?: boolean
    yearSessionsDiff?: boolean
    yearConversionRateDiff?: boolean
    yearConversionsDiff?: boolean
    yearBouncesDiff?: boolean
    createdAt?: boolean
  }

  export type ParsedPieGraphDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queryId" | "channel" | "source" | "sessions" | "conversionRate" | "conversions" | "bounces" | "prevSessionsDiff" | "prevConversionRateDiff" | "prevConversionsDiff" | "prevBouncesDiff" | "yearSessionsDiff" | "yearConversionRateDiff" | "yearConversionsDiff" | "yearBouncesDiff" | "createdAt", ExtArgs["result"]["parsedPieGraphData"]>
  export type ParsedPieGraphDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedPieGraphDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedPieGraphDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }

  export type $ParsedPieGraphDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParsedPieGraphData"
    objects: {
      query: Prisma.$QueryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queryId: string
      channel: string
      source: string
      sessions: number
      conversionRate: number
      conversions: number
      bounces: number
      prevSessionsDiff: number
      prevConversionRateDiff: number
      prevConversionsDiff: number
      prevBouncesDiff: number
      yearSessionsDiff: number
      yearConversionRateDiff: number
      yearConversionsDiff: number
      yearBouncesDiff: number
      createdAt: Date
    }, ExtArgs["result"]["parsedPieGraphData"]>
    composites: {}
  }

  type ParsedPieGraphDataGetPayload<S extends boolean | null | undefined | ParsedPieGraphDataDefaultArgs> = $Result.GetResult<Prisma.$ParsedPieGraphDataPayload, S>

  type ParsedPieGraphDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParsedPieGraphDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParsedPieGraphDataCountAggregateInputType | true
    }

  export interface ParsedPieGraphDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParsedPieGraphData'], meta: { name: 'ParsedPieGraphData' } }
    /**
     * Find zero or one ParsedPieGraphData that matches the filter.
     * @param {ParsedPieGraphDataFindUniqueArgs} args - Arguments to find a ParsedPieGraphData
     * @example
     * // Get one ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParsedPieGraphDataFindUniqueArgs>(args: SelectSubset<T, ParsedPieGraphDataFindUniqueArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParsedPieGraphData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParsedPieGraphDataFindUniqueOrThrowArgs} args - Arguments to find a ParsedPieGraphData
     * @example
     * // Get one ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParsedPieGraphDataFindUniqueOrThrowArgs>(args: SelectSubset<T, ParsedPieGraphDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedPieGraphData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataFindFirstArgs} args - Arguments to find a ParsedPieGraphData
     * @example
     * // Get one ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParsedPieGraphDataFindFirstArgs>(args?: SelectSubset<T, ParsedPieGraphDataFindFirstArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedPieGraphData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataFindFirstOrThrowArgs} args - Arguments to find a ParsedPieGraphData
     * @example
     * // Get one ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParsedPieGraphDataFindFirstOrThrowArgs>(args?: SelectSubset<T, ParsedPieGraphDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParsedPieGraphData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findMany()
     * 
     * // Get first 10 ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsedPieGraphDataWithIdOnly = await prisma.parsedPieGraphData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParsedPieGraphDataFindManyArgs>(args?: SelectSubset<T, ParsedPieGraphDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParsedPieGraphData.
     * @param {ParsedPieGraphDataCreateArgs} args - Arguments to create a ParsedPieGraphData.
     * @example
     * // Create one ParsedPieGraphData
     * const ParsedPieGraphData = await prisma.parsedPieGraphData.create({
     *   data: {
     *     // ... data to create a ParsedPieGraphData
     *   }
     * })
     * 
     */
    create<T extends ParsedPieGraphDataCreateArgs>(args: SelectSubset<T, ParsedPieGraphDataCreateArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParsedPieGraphData.
     * @param {ParsedPieGraphDataCreateManyArgs} args - Arguments to create many ParsedPieGraphData.
     * @example
     * // Create many ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParsedPieGraphDataCreateManyArgs>(args?: SelectSubset<T, ParsedPieGraphDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParsedPieGraphData and returns the data saved in the database.
     * @param {ParsedPieGraphDataCreateManyAndReturnArgs} args - Arguments to create many ParsedPieGraphData.
     * @example
     * // Create many ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParsedPieGraphData and only return the `id`
     * const parsedPieGraphDataWithIdOnly = await prisma.parsedPieGraphData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParsedPieGraphDataCreateManyAndReturnArgs>(args?: SelectSubset<T, ParsedPieGraphDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParsedPieGraphData.
     * @param {ParsedPieGraphDataDeleteArgs} args - Arguments to delete one ParsedPieGraphData.
     * @example
     * // Delete one ParsedPieGraphData
     * const ParsedPieGraphData = await prisma.parsedPieGraphData.delete({
     *   where: {
     *     // ... filter to delete one ParsedPieGraphData
     *   }
     * })
     * 
     */
    delete<T extends ParsedPieGraphDataDeleteArgs>(args: SelectSubset<T, ParsedPieGraphDataDeleteArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParsedPieGraphData.
     * @param {ParsedPieGraphDataUpdateArgs} args - Arguments to update one ParsedPieGraphData.
     * @example
     * // Update one ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParsedPieGraphDataUpdateArgs>(args: SelectSubset<T, ParsedPieGraphDataUpdateArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParsedPieGraphData.
     * @param {ParsedPieGraphDataDeleteManyArgs} args - Arguments to filter ParsedPieGraphData to delete.
     * @example
     * // Delete a few ParsedPieGraphData
     * const { count } = await prisma.parsedPieGraphData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParsedPieGraphDataDeleteManyArgs>(args?: SelectSubset<T, ParsedPieGraphDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedPieGraphData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParsedPieGraphDataUpdateManyArgs>(args: SelectSubset<T, ParsedPieGraphDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedPieGraphData and returns the data updated in the database.
     * @param {ParsedPieGraphDataUpdateManyAndReturnArgs} args - Arguments to update many ParsedPieGraphData.
     * @example
     * // Update many ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParsedPieGraphData and only return the `id`
     * const parsedPieGraphDataWithIdOnly = await prisma.parsedPieGraphData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParsedPieGraphDataUpdateManyAndReturnArgs>(args: SelectSubset<T, ParsedPieGraphDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParsedPieGraphData.
     * @param {ParsedPieGraphDataUpsertArgs} args - Arguments to update or create a ParsedPieGraphData.
     * @example
     * // Update or create a ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.upsert({
     *   create: {
     *     // ... data to create a ParsedPieGraphData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParsedPieGraphData we want to update
     *   }
     * })
     */
    upsert<T extends ParsedPieGraphDataUpsertArgs>(args: SelectSubset<T, ParsedPieGraphDataUpsertArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParsedPieGraphData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataCountArgs} args - Arguments to filter ParsedPieGraphData to count.
     * @example
     * // Count the number of ParsedPieGraphData
     * const count = await prisma.parsedPieGraphData.count({
     *   where: {
     *     // ... the filter for the ParsedPieGraphData we want to count
     *   }
     * })
    **/
    count<T extends ParsedPieGraphDataCountArgs>(
      args?: Subset<T, ParsedPieGraphDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParsedPieGraphDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParsedPieGraphData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParsedPieGraphDataAggregateArgs>(args: Subset<T, ParsedPieGraphDataAggregateArgs>): Prisma.PrismaPromise<GetParsedPieGraphDataAggregateType<T>>

    /**
     * Group by ParsedPieGraphData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParsedPieGraphDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParsedPieGraphDataGroupByArgs['orderBy'] }
        : { orderBy?: ParsedPieGraphDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParsedPieGraphDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsedPieGraphDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParsedPieGraphData model
   */
  readonly fields: ParsedPieGraphDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParsedPieGraphData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParsedPieGraphDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    query<T extends QueryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueryDefaultArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParsedPieGraphData model
   */
  interface ParsedPieGraphDataFieldRefs {
    readonly id: FieldRef<"ParsedPieGraphData", 'String'>
    readonly queryId: FieldRef<"ParsedPieGraphData", 'String'>
    readonly channel: FieldRef<"ParsedPieGraphData", 'String'>
    readonly source: FieldRef<"ParsedPieGraphData", 'String'>
    readonly sessions: FieldRef<"ParsedPieGraphData", 'Int'>
    readonly conversionRate: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly conversions: FieldRef<"ParsedPieGraphData", 'Int'>
    readonly bounces: FieldRef<"ParsedPieGraphData", 'Int'>
    readonly prevSessionsDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly prevConversionRateDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly prevConversionsDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly prevBouncesDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly yearSessionsDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly yearConversionRateDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly yearConversionsDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly yearBouncesDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly createdAt: FieldRef<"ParsedPieGraphData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParsedPieGraphData findUnique
   */
  export type ParsedPieGraphDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedPieGraphData to fetch.
     */
    where: ParsedPieGraphDataWhereUniqueInput
  }

  /**
   * ParsedPieGraphData findUniqueOrThrow
   */
  export type ParsedPieGraphDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedPieGraphData to fetch.
     */
    where: ParsedPieGraphDataWhereUniqueInput
  }

  /**
   * ParsedPieGraphData findFirst
   */
  export type ParsedPieGraphDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedPieGraphData to fetch.
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedPieGraphData to fetch.
     */
    orderBy?: ParsedPieGraphDataOrderByWithRelationInput | ParsedPieGraphDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedPieGraphData.
     */
    cursor?: ParsedPieGraphDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedPieGraphData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedPieGraphData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedPieGraphData.
     */
    distinct?: ParsedPieGraphDataScalarFieldEnum | ParsedPieGraphDataScalarFieldEnum[]
  }

  /**
   * ParsedPieGraphData findFirstOrThrow
   */
  export type ParsedPieGraphDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedPieGraphData to fetch.
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedPieGraphData to fetch.
     */
    orderBy?: ParsedPieGraphDataOrderByWithRelationInput | ParsedPieGraphDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedPieGraphData.
     */
    cursor?: ParsedPieGraphDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedPieGraphData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedPieGraphData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedPieGraphData.
     */
    distinct?: ParsedPieGraphDataScalarFieldEnum | ParsedPieGraphDataScalarFieldEnum[]
  }

  /**
   * ParsedPieGraphData findMany
   */
  export type ParsedPieGraphDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedPieGraphData to fetch.
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedPieGraphData to fetch.
     */
    orderBy?: ParsedPieGraphDataOrderByWithRelationInput | ParsedPieGraphDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParsedPieGraphData.
     */
    cursor?: ParsedPieGraphDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedPieGraphData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedPieGraphData.
     */
    skip?: number
    distinct?: ParsedPieGraphDataScalarFieldEnum | ParsedPieGraphDataScalarFieldEnum[]
  }

  /**
   * ParsedPieGraphData create
   */
  export type ParsedPieGraphDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * The data needed to create a ParsedPieGraphData.
     */
    data: XOR<ParsedPieGraphDataCreateInput, ParsedPieGraphDataUncheckedCreateInput>
  }

  /**
   * ParsedPieGraphData createMany
   */
  export type ParsedPieGraphDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParsedPieGraphData.
     */
    data: ParsedPieGraphDataCreateManyInput | ParsedPieGraphDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParsedPieGraphData createManyAndReturn
   */
  export type ParsedPieGraphDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * The data used to create many ParsedPieGraphData.
     */
    data: ParsedPieGraphDataCreateManyInput | ParsedPieGraphDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedPieGraphData update
   */
  export type ParsedPieGraphDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * The data needed to update a ParsedPieGraphData.
     */
    data: XOR<ParsedPieGraphDataUpdateInput, ParsedPieGraphDataUncheckedUpdateInput>
    /**
     * Choose, which ParsedPieGraphData to update.
     */
    where: ParsedPieGraphDataWhereUniqueInput
  }

  /**
   * ParsedPieGraphData updateMany
   */
  export type ParsedPieGraphDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParsedPieGraphData.
     */
    data: XOR<ParsedPieGraphDataUpdateManyMutationInput, ParsedPieGraphDataUncheckedUpdateManyInput>
    /**
     * Filter which ParsedPieGraphData to update
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * Limit how many ParsedPieGraphData to update.
     */
    limit?: number
  }

  /**
   * ParsedPieGraphData updateManyAndReturn
   */
  export type ParsedPieGraphDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * The data used to update ParsedPieGraphData.
     */
    data: XOR<ParsedPieGraphDataUpdateManyMutationInput, ParsedPieGraphDataUncheckedUpdateManyInput>
    /**
     * Filter which ParsedPieGraphData to update
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * Limit how many ParsedPieGraphData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedPieGraphData upsert
   */
  export type ParsedPieGraphDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * The filter to search for the ParsedPieGraphData to update in case it exists.
     */
    where: ParsedPieGraphDataWhereUniqueInput
    /**
     * In case the ParsedPieGraphData found by the `where` argument doesn't exist, create a new ParsedPieGraphData with this data.
     */
    create: XOR<ParsedPieGraphDataCreateInput, ParsedPieGraphDataUncheckedCreateInput>
    /**
     * In case the ParsedPieGraphData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParsedPieGraphDataUpdateInput, ParsedPieGraphDataUncheckedUpdateInput>
  }

  /**
   * ParsedPieGraphData delete
   */
  export type ParsedPieGraphDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter which ParsedPieGraphData to delete.
     */
    where: ParsedPieGraphDataWhereUniqueInput
  }

  /**
   * ParsedPieGraphData deleteMany
   */
  export type ParsedPieGraphDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedPieGraphData to delete
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * Limit how many ParsedPieGraphData to delete.
     */
    limit?: number
  }

  /**
   * ParsedPieGraphData without action
   */
  export type ParsedPieGraphDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
  }


  /**
   * Model ParsedQueryData
   */

  export type AggregateParsedQueryData = {
    _count: ParsedQueryDataCountAggregateOutputType | null
    _avg: ParsedQueryDataAvgAggregateOutputType | null
    _sum: ParsedQueryDataSumAggregateOutputType | null
    _min: ParsedQueryDataMinAggregateOutputType | null
    _max: ParsedQueryDataMaxAggregateOutputType | null
  }

  export type ParsedQueryDataAvgAggregateOutputType = {
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    engagedSessions: number | null
    bounceRate: number | null
    newUsers: number | null
  }

  export type ParsedQueryDataSumAggregateOutputType = {
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    engagedSessions: number | null
    bounceRate: number | null
    newUsers: number | null
  }

  export type ParsedQueryDataMinAggregateOutputType = {
    id: string | null
    queryId: string | null
    date: Date | null
    channel: string | null
    source: string | null
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    createdAt: Date | null
    engagedSessions: number | null
    bounceRate: number | null
    newUsers: number | null
  }

  export type ParsedQueryDataMaxAggregateOutputType = {
    id: string | null
    queryId: string | null
    date: Date | null
    channel: string | null
    source: string | null
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    createdAt: Date | null
    engagedSessions: number | null
    bounceRate: number | null
    newUsers: number | null
  }

  export type ParsedQueryDataCountAggregateOutputType = {
    id: number
    queryId: number
    date: number
    channel: number
    source: number
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt: number
    engagedSessions: number
    bounceRate: number
    newUsers: number
    _all: number
  }


  export type ParsedQueryDataAvgAggregateInputType = {
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    engagedSessions?: true
    bounceRate?: true
    newUsers?: true
  }

  export type ParsedQueryDataSumAggregateInputType = {
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    engagedSessions?: true
    bounceRate?: true
    newUsers?: true
  }

  export type ParsedQueryDataMinAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    createdAt?: true
    engagedSessions?: true
    bounceRate?: true
    newUsers?: true
  }

  export type ParsedQueryDataMaxAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    createdAt?: true
    engagedSessions?: true
    bounceRate?: true
    newUsers?: true
  }

  export type ParsedQueryDataCountAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    createdAt?: true
    engagedSessions?: true
    bounceRate?: true
    newUsers?: true
    _all?: true
  }

  export type ParsedQueryDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedQueryData to aggregate.
     */
    where?: ParsedQueryDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQueryData to fetch.
     */
    orderBy?: ParsedQueryDataOrderByWithRelationInput | ParsedQueryDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParsedQueryDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQueryData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQueryData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParsedQueryData
    **/
    _count?: true | ParsedQueryDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParsedQueryDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParsedQueryDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParsedQueryDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParsedQueryDataMaxAggregateInputType
  }

  export type GetParsedQueryDataAggregateType<T extends ParsedQueryDataAggregateArgs> = {
        [P in keyof T & keyof AggregateParsedQueryData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsedQueryData[P]>
      : GetScalarType<T[P], AggregateParsedQueryData[P]>
  }




  export type ParsedQueryDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedQueryDataWhereInput
    orderBy?: ParsedQueryDataOrderByWithAggregationInput | ParsedQueryDataOrderByWithAggregationInput[]
    by: ParsedQueryDataScalarFieldEnum[] | ParsedQueryDataScalarFieldEnum
    having?: ParsedQueryDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParsedQueryDataCountAggregateInputType | true
    _avg?: ParsedQueryDataAvgAggregateInputType
    _sum?: ParsedQueryDataSumAggregateInputType
    _min?: ParsedQueryDataMinAggregateInputType
    _max?: ParsedQueryDataMaxAggregateInputType
  }

  export type ParsedQueryDataGroupByOutputType = {
    id: string
    queryId: string
    date: Date
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt: Date
    engagedSessions: number | null
    bounceRate: number | null
    newUsers: number | null
    _count: ParsedQueryDataCountAggregateOutputType | null
    _avg: ParsedQueryDataAvgAggregateOutputType | null
    _sum: ParsedQueryDataSumAggregateOutputType | null
    _min: ParsedQueryDataMinAggregateOutputType | null
    _max: ParsedQueryDataMaxAggregateOutputType | null
  }

  type GetParsedQueryDataGroupByPayload<T extends ParsedQueryDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParsedQueryDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParsedQueryDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParsedQueryDataGroupByOutputType[P]>
            : GetScalarType<T[P], ParsedQueryDataGroupByOutputType[P]>
        }
      >
    >


  export type ParsedQueryDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    createdAt?: boolean
    engagedSessions?: boolean
    bounceRate?: boolean
    newUsers?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQueryData"]>

  export type ParsedQueryDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    createdAt?: boolean
    engagedSessions?: boolean
    bounceRate?: boolean
    newUsers?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQueryData"]>

  export type ParsedQueryDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    createdAt?: boolean
    engagedSessions?: boolean
    bounceRate?: boolean
    newUsers?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQueryData"]>

  export type ParsedQueryDataSelectScalar = {
    id?: boolean
    queryId?: boolean
    date?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    createdAt?: boolean
    engagedSessions?: boolean
    bounceRate?: boolean
    newUsers?: boolean
  }

  export type ParsedQueryDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queryId" | "date" | "channel" | "source" | "sessions" | "conversionRate" | "conversions" | "bounces" | "createdAt" | "engagedSessions" | "bounceRate" | "newUsers", ExtArgs["result"]["parsedQueryData"]>
  export type ParsedQueryDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedQueryDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedQueryDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }

  export type $ParsedQueryDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParsedQueryData"
    objects: {
      query: Prisma.$QueryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queryId: string
      date: Date
      channel: string
      source: string
      sessions: number
      conversionRate: number
      conversions: number
      bounces: number
      createdAt: Date
      engagedSessions: number | null
      bounceRate: number | null
      newUsers: number | null
    }, ExtArgs["result"]["parsedQueryData"]>
    composites: {}
  }

  type ParsedQueryDataGetPayload<S extends boolean | null | undefined | ParsedQueryDataDefaultArgs> = $Result.GetResult<Prisma.$ParsedQueryDataPayload, S>

  type ParsedQueryDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParsedQueryDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParsedQueryDataCountAggregateInputType | true
    }

  export interface ParsedQueryDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParsedQueryData'], meta: { name: 'ParsedQueryData' } }
    /**
     * Find zero or one ParsedQueryData that matches the filter.
     * @param {ParsedQueryDataFindUniqueArgs} args - Arguments to find a ParsedQueryData
     * @example
     * // Get one ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParsedQueryDataFindUniqueArgs>(args: SelectSubset<T, ParsedQueryDataFindUniqueArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParsedQueryData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParsedQueryDataFindUniqueOrThrowArgs} args - Arguments to find a ParsedQueryData
     * @example
     * // Get one ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParsedQueryDataFindUniqueOrThrowArgs>(args: SelectSubset<T, ParsedQueryDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedQueryData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataFindFirstArgs} args - Arguments to find a ParsedQueryData
     * @example
     * // Get one ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParsedQueryDataFindFirstArgs>(args?: SelectSubset<T, ParsedQueryDataFindFirstArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedQueryData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataFindFirstOrThrowArgs} args - Arguments to find a ParsedQueryData
     * @example
     * // Get one ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParsedQueryDataFindFirstOrThrowArgs>(args?: SelectSubset<T, ParsedQueryDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParsedQueryData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findMany()
     * 
     * // Get first 10 ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsedQueryDataWithIdOnly = await prisma.parsedQueryData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParsedQueryDataFindManyArgs>(args?: SelectSubset<T, ParsedQueryDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParsedQueryData.
     * @param {ParsedQueryDataCreateArgs} args - Arguments to create a ParsedQueryData.
     * @example
     * // Create one ParsedQueryData
     * const ParsedQueryData = await prisma.parsedQueryData.create({
     *   data: {
     *     // ... data to create a ParsedQueryData
     *   }
     * })
     * 
     */
    create<T extends ParsedQueryDataCreateArgs>(args: SelectSubset<T, ParsedQueryDataCreateArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParsedQueryData.
     * @param {ParsedQueryDataCreateManyArgs} args - Arguments to create many ParsedQueryData.
     * @example
     * // Create many ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParsedQueryDataCreateManyArgs>(args?: SelectSubset<T, ParsedQueryDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParsedQueryData and returns the data saved in the database.
     * @param {ParsedQueryDataCreateManyAndReturnArgs} args - Arguments to create many ParsedQueryData.
     * @example
     * // Create many ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParsedQueryData and only return the `id`
     * const parsedQueryDataWithIdOnly = await prisma.parsedQueryData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParsedQueryDataCreateManyAndReturnArgs>(args?: SelectSubset<T, ParsedQueryDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParsedQueryData.
     * @param {ParsedQueryDataDeleteArgs} args - Arguments to delete one ParsedQueryData.
     * @example
     * // Delete one ParsedQueryData
     * const ParsedQueryData = await prisma.parsedQueryData.delete({
     *   where: {
     *     // ... filter to delete one ParsedQueryData
     *   }
     * })
     * 
     */
    delete<T extends ParsedQueryDataDeleteArgs>(args: SelectSubset<T, ParsedQueryDataDeleteArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParsedQueryData.
     * @param {ParsedQueryDataUpdateArgs} args - Arguments to update one ParsedQueryData.
     * @example
     * // Update one ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParsedQueryDataUpdateArgs>(args: SelectSubset<T, ParsedQueryDataUpdateArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParsedQueryData.
     * @param {ParsedQueryDataDeleteManyArgs} args - Arguments to filter ParsedQueryData to delete.
     * @example
     * // Delete a few ParsedQueryData
     * const { count } = await prisma.parsedQueryData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParsedQueryDataDeleteManyArgs>(args?: SelectSubset<T, ParsedQueryDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedQueryData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParsedQueryDataUpdateManyArgs>(args: SelectSubset<T, ParsedQueryDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedQueryData and returns the data updated in the database.
     * @param {ParsedQueryDataUpdateManyAndReturnArgs} args - Arguments to update many ParsedQueryData.
     * @example
     * // Update many ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParsedQueryData and only return the `id`
     * const parsedQueryDataWithIdOnly = await prisma.parsedQueryData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParsedQueryDataUpdateManyAndReturnArgs>(args: SelectSubset<T, ParsedQueryDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParsedQueryData.
     * @param {ParsedQueryDataUpsertArgs} args - Arguments to update or create a ParsedQueryData.
     * @example
     * // Update or create a ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.upsert({
     *   create: {
     *     // ... data to create a ParsedQueryData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParsedQueryData we want to update
     *   }
     * })
     */
    upsert<T extends ParsedQueryDataUpsertArgs>(args: SelectSubset<T, ParsedQueryDataUpsertArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParsedQueryData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataCountArgs} args - Arguments to filter ParsedQueryData to count.
     * @example
     * // Count the number of ParsedQueryData
     * const count = await prisma.parsedQueryData.count({
     *   where: {
     *     // ... the filter for the ParsedQueryData we want to count
     *   }
     * })
    **/
    count<T extends ParsedQueryDataCountArgs>(
      args?: Subset<T, ParsedQueryDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParsedQueryDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParsedQueryData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParsedQueryDataAggregateArgs>(args: Subset<T, ParsedQueryDataAggregateArgs>): Prisma.PrismaPromise<GetParsedQueryDataAggregateType<T>>

    /**
     * Group by ParsedQueryData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParsedQueryDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParsedQueryDataGroupByArgs['orderBy'] }
        : { orderBy?: ParsedQueryDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParsedQueryDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsedQueryDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParsedQueryData model
   */
  readonly fields: ParsedQueryDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParsedQueryData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParsedQueryDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    query<T extends QueryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueryDefaultArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParsedQueryData model
   */
  interface ParsedQueryDataFieldRefs {
    readonly id: FieldRef<"ParsedQueryData", 'String'>
    readonly queryId: FieldRef<"ParsedQueryData", 'String'>
    readonly date: FieldRef<"ParsedQueryData", 'DateTime'>
    readonly channel: FieldRef<"ParsedQueryData", 'String'>
    readonly source: FieldRef<"ParsedQueryData", 'String'>
    readonly sessions: FieldRef<"ParsedQueryData", 'Int'>
    readonly conversionRate: FieldRef<"ParsedQueryData", 'Float'>
    readonly conversions: FieldRef<"ParsedQueryData", 'Int'>
    readonly bounces: FieldRef<"ParsedQueryData", 'Int'>
    readonly createdAt: FieldRef<"ParsedQueryData", 'DateTime'>
    readonly engagedSessions: FieldRef<"ParsedQueryData", 'Int'>
    readonly bounceRate: FieldRef<"ParsedQueryData", 'Float'>
    readonly newUsers: FieldRef<"ParsedQueryData", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ParsedQueryData findUnique
   */
  export type ParsedQueryDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQueryData to fetch.
     */
    where: ParsedQueryDataWhereUniqueInput
  }

  /**
   * ParsedQueryData findUniqueOrThrow
   */
  export type ParsedQueryDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQueryData to fetch.
     */
    where: ParsedQueryDataWhereUniqueInput
  }

  /**
   * ParsedQueryData findFirst
   */
  export type ParsedQueryDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQueryData to fetch.
     */
    where?: ParsedQueryDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQueryData to fetch.
     */
    orderBy?: ParsedQueryDataOrderByWithRelationInput | ParsedQueryDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedQueryData.
     */
    cursor?: ParsedQueryDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQueryData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQueryData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedQueryData.
     */
    distinct?: ParsedQueryDataScalarFieldEnum | ParsedQueryDataScalarFieldEnum[]
  }

  /**
   * ParsedQueryData findFirstOrThrow
   */
  export type ParsedQueryDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQueryData to fetch.
     */
    where?: ParsedQueryDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQueryData to fetch.
     */
    orderBy?: ParsedQueryDataOrderByWithRelationInput | ParsedQueryDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedQueryData.
     */
    cursor?: ParsedQueryDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQueryData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQueryData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedQueryData.
     */
    distinct?: ParsedQueryDataScalarFieldEnum | ParsedQueryDataScalarFieldEnum[]
  }

  /**
   * ParsedQueryData findMany
   */
  export type ParsedQueryDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQueryData to fetch.
     */
    where?: ParsedQueryDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQueryData to fetch.
     */
    orderBy?: ParsedQueryDataOrderByWithRelationInput | ParsedQueryDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParsedQueryData.
     */
    cursor?: ParsedQueryDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQueryData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQueryData.
     */
    skip?: number
    distinct?: ParsedQueryDataScalarFieldEnum | ParsedQueryDataScalarFieldEnum[]
  }

  /**
   * ParsedQueryData create
   */
  export type ParsedQueryDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * The data needed to create a ParsedQueryData.
     */
    data: XOR<ParsedQueryDataCreateInput, ParsedQueryDataUncheckedCreateInput>
  }

  /**
   * ParsedQueryData createMany
   */
  export type ParsedQueryDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParsedQueryData.
     */
    data: ParsedQueryDataCreateManyInput | ParsedQueryDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParsedQueryData createManyAndReturn
   */
  export type ParsedQueryDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * The data used to create many ParsedQueryData.
     */
    data: ParsedQueryDataCreateManyInput | ParsedQueryDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedQueryData update
   */
  export type ParsedQueryDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * The data needed to update a ParsedQueryData.
     */
    data: XOR<ParsedQueryDataUpdateInput, ParsedQueryDataUncheckedUpdateInput>
    /**
     * Choose, which ParsedQueryData to update.
     */
    where: ParsedQueryDataWhereUniqueInput
  }

  /**
   * ParsedQueryData updateMany
   */
  export type ParsedQueryDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParsedQueryData.
     */
    data: XOR<ParsedQueryDataUpdateManyMutationInput, ParsedQueryDataUncheckedUpdateManyInput>
    /**
     * Filter which ParsedQueryData to update
     */
    where?: ParsedQueryDataWhereInput
    /**
     * Limit how many ParsedQueryData to update.
     */
    limit?: number
  }

  /**
   * ParsedQueryData updateManyAndReturn
   */
  export type ParsedQueryDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * The data used to update ParsedQueryData.
     */
    data: XOR<ParsedQueryDataUpdateManyMutationInput, ParsedQueryDataUncheckedUpdateManyInput>
    /**
     * Filter which ParsedQueryData to update
     */
    where?: ParsedQueryDataWhereInput
    /**
     * Limit how many ParsedQueryData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedQueryData upsert
   */
  export type ParsedQueryDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * The filter to search for the ParsedQueryData to update in case it exists.
     */
    where: ParsedQueryDataWhereUniqueInput
    /**
     * In case the ParsedQueryData found by the `where` argument doesn't exist, create a new ParsedQueryData with this data.
     */
    create: XOR<ParsedQueryDataCreateInput, ParsedQueryDataUncheckedCreateInput>
    /**
     * In case the ParsedQueryData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParsedQueryDataUpdateInput, ParsedQueryDataUncheckedUpdateInput>
  }

  /**
   * ParsedQueryData delete
   */
  export type ParsedQueryDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter which ParsedQueryData to delete.
     */
    where: ParsedQueryDataWhereUniqueInput
  }

  /**
   * ParsedQueryData deleteMany
   */
  export type ParsedQueryDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedQueryData to delete
     */
    where?: ParsedQueryDataWhereInput
    /**
     * Limit how many ParsedQueryData to delete.
     */
    limit?: number
  }

  /**
   * ParsedQueryData without action
   */
  export type ParsedQueryDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
  }


  /**
   * Model ParsedQuerySummary
   */

  export type AggregateParsedQuerySummary = {
    _count: ParsedQuerySummaryCountAggregateOutputType | null
    _avg: ParsedQuerySummaryAvgAggregateOutputType | null
    _sum: ParsedQuerySummarySumAggregateOutputType | null
    _min: ParsedQuerySummaryMinAggregateOutputType | null
    _max: ParsedQuerySummaryMaxAggregateOutputType | null
  }

  export type ParsedQuerySummaryAvgAggregateOutputType = {
    totalEngagedSessions: number | null
    averageBounceRate: number | null
    totalNewUsers: number | null
    totalConversions: number | null
  }

  export type ParsedQuerySummarySumAggregateOutputType = {
    totalEngagedSessions: number | null
    averageBounceRate: number | null
    totalNewUsers: number | null
    totalConversions: number | null
  }

  export type ParsedQuerySummaryMinAggregateOutputType = {
    id: string | null
    queryId: string | null
    date: Date | null
    totalEngagedSessions: number | null
    averageBounceRate: number | null
    totalNewUsers: number | null
    totalConversions: number | null
    createdAt: Date | null
  }

  export type ParsedQuerySummaryMaxAggregateOutputType = {
    id: string | null
    queryId: string | null
    date: Date | null
    totalEngagedSessions: number | null
    averageBounceRate: number | null
    totalNewUsers: number | null
    totalConversions: number | null
    createdAt: Date | null
  }

  export type ParsedQuerySummaryCountAggregateOutputType = {
    id: number
    queryId: number
    date: number
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt: number
    _all: number
  }


  export type ParsedQuerySummaryAvgAggregateInputType = {
    totalEngagedSessions?: true
    averageBounceRate?: true
    totalNewUsers?: true
    totalConversions?: true
  }

  export type ParsedQuerySummarySumAggregateInputType = {
    totalEngagedSessions?: true
    averageBounceRate?: true
    totalNewUsers?: true
    totalConversions?: true
  }

  export type ParsedQuerySummaryMinAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    totalEngagedSessions?: true
    averageBounceRate?: true
    totalNewUsers?: true
    totalConversions?: true
    createdAt?: true
  }

  export type ParsedQuerySummaryMaxAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    totalEngagedSessions?: true
    averageBounceRate?: true
    totalNewUsers?: true
    totalConversions?: true
    createdAt?: true
  }

  export type ParsedQuerySummaryCountAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    totalEngagedSessions?: true
    averageBounceRate?: true
    totalNewUsers?: true
    totalConversions?: true
    createdAt?: true
    _all?: true
  }

  export type ParsedQuerySummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedQuerySummary to aggregate.
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQuerySummaries to fetch.
     */
    orderBy?: ParsedQuerySummaryOrderByWithRelationInput | ParsedQuerySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParsedQuerySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQuerySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQuerySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParsedQuerySummaries
    **/
    _count?: true | ParsedQuerySummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParsedQuerySummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParsedQuerySummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParsedQuerySummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParsedQuerySummaryMaxAggregateInputType
  }

  export type GetParsedQuerySummaryAggregateType<T extends ParsedQuerySummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateParsedQuerySummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsedQuerySummary[P]>
      : GetScalarType<T[P], AggregateParsedQuerySummary[P]>
  }




  export type ParsedQuerySummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedQuerySummaryWhereInput
    orderBy?: ParsedQuerySummaryOrderByWithAggregationInput | ParsedQuerySummaryOrderByWithAggregationInput[]
    by: ParsedQuerySummaryScalarFieldEnum[] | ParsedQuerySummaryScalarFieldEnum
    having?: ParsedQuerySummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParsedQuerySummaryCountAggregateInputType | true
    _avg?: ParsedQuerySummaryAvgAggregateInputType
    _sum?: ParsedQuerySummarySumAggregateInputType
    _min?: ParsedQuerySummaryMinAggregateInputType
    _max?: ParsedQuerySummaryMaxAggregateInputType
  }

  export type ParsedQuerySummaryGroupByOutputType = {
    id: string
    queryId: string
    date: Date
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt: Date
    _count: ParsedQuerySummaryCountAggregateOutputType | null
    _avg: ParsedQuerySummaryAvgAggregateOutputType | null
    _sum: ParsedQuerySummarySumAggregateOutputType | null
    _min: ParsedQuerySummaryMinAggregateOutputType | null
    _max: ParsedQuerySummaryMaxAggregateOutputType | null
  }

  type GetParsedQuerySummaryGroupByPayload<T extends ParsedQuerySummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParsedQuerySummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParsedQuerySummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParsedQuerySummaryGroupByOutputType[P]>
            : GetScalarType<T[P], ParsedQuerySummaryGroupByOutputType[P]>
        }
      >
    >


  export type ParsedQuerySummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    totalEngagedSessions?: boolean
    averageBounceRate?: boolean
    totalNewUsers?: boolean
    totalConversions?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQuerySummary"]>

  export type ParsedQuerySummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    totalEngagedSessions?: boolean
    averageBounceRate?: boolean
    totalNewUsers?: boolean
    totalConversions?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQuerySummary"]>

  export type ParsedQuerySummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    totalEngagedSessions?: boolean
    averageBounceRate?: boolean
    totalNewUsers?: boolean
    totalConversions?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQuerySummary"]>

  export type ParsedQuerySummarySelectScalar = {
    id?: boolean
    queryId?: boolean
    date?: boolean
    totalEngagedSessions?: boolean
    averageBounceRate?: boolean
    totalNewUsers?: boolean
    totalConversions?: boolean
    createdAt?: boolean
  }

  export type ParsedQuerySummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queryId" | "date" | "totalEngagedSessions" | "averageBounceRate" | "totalNewUsers" | "totalConversions" | "createdAt", ExtArgs["result"]["parsedQuerySummary"]>
  export type ParsedQuerySummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedQuerySummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedQuerySummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }

  export type $ParsedQuerySummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParsedQuerySummary"
    objects: {
      query: Prisma.$QueryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queryId: string
      date: Date
      totalEngagedSessions: number
      averageBounceRate: number
      totalNewUsers: number
      totalConversions: number
      createdAt: Date
    }, ExtArgs["result"]["parsedQuerySummary"]>
    composites: {}
  }

  type ParsedQuerySummaryGetPayload<S extends boolean | null | undefined | ParsedQuerySummaryDefaultArgs> = $Result.GetResult<Prisma.$ParsedQuerySummaryPayload, S>

  type ParsedQuerySummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParsedQuerySummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParsedQuerySummaryCountAggregateInputType | true
    }

  export interface ParsedQuerySummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParsedQuerySummary'], meta: { name: 'ParsedQuerySummary' } }
    /**
     * Find zero or one ParsedQuerySummary that matches the filter.
     * @param {ParsedQuerySummaryFindUniqueArgs} args - Arguments to find a ParsedQuerySummary
     * @example
     * // Get one ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParsedQuerySummaryFindUniqueArgs>(args: SelectSubset<T, ParsedQuerySummaryFindUniqueArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParsedQuerySummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParsedQuerySummaryFindUniqueOrThrowArgs} args - Arguments to find a ParsedQuerySummary
     * @example
     * // Get one ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParsedQuerySummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, ParsedQuerySummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedQuerySummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryFindFirstArgs} args - Arguments to find a ParsedQuerySummary
     * @example
     * // Get one ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParsedQuerySummaryFindFirstArgs>(args?: SelectSubset<T, ParsedQuerySummaryFindFirstArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedQuerySummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryFindFirstOrThrowArgs} args - Arguments to find a ParsedQuerySummary
     * @example
     * // Get one ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParsedQuerySummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, ParsedQuerySummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParsedQuerySummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParsedQuerySummaries
     * const parsedQuerySummaries = await prisma.parsedQuerySummary.findMany()
     * 
     * // Get first 10 ParsedQuerySummaries
     * const parsedQuerySummaries = await prisma.parsedQuerySummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsedQuerySummaryWithIdOnly = await prisma.parsedQuerySummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParsedQuerySummaryFindManyArgs>(args?: SelectSubset<T, ParsedQuerySummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParsedQuerySummary.
     * @param {ParsedQuerySummaryCreateArgs} args - Arguments to create a ParsedQuerySummary.
     * @example
     * // Create one ParsedQuerySummary
     * const ParsedQuerySummary = await prisma.parsedQuerySummary.create({
     *   data: {
     *     // ... data to create a ParsedQuerySummary
     *   }
     * })
     * 
     */
    create<T extends ParsedQuerySummaryCreateArgs>(args: SelectSubset<T, ParsedQuerySummaryCreateArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParsedQuerySummaries.
     * @param {ParsedQuerySummaryCreateManyArgs} args - Arguments to create many ParsedQuerySummaries.
     * @example
     * // Create many ParsedQuerySummaries
     * const parsedQuerySummary = await prisma.parsedQuerySummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParsedQuerySummaryCreateManyArgs>(args?: SelectSubset<T, ParsedQuerySummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParsedQuerySummaries and returns the data saved in the database.
     * @param {ParsedQuerySummaryCreateManyAndReturnArgs} args - Arguments to create many ParsedQuerySummaries.
     * @example
     * // Create many ParsedQuerySummaries
     * const parsedQuerySummary = await prisma.parsedQuerySummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParsedQuerySummaries and only return the `id`
     * const parsedQuerySummaryWithIdOnly = await prisma.parsedQuerySummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParsedQuerySummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, ParsedQuerySummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParsedQuerySummary.
     * @param {ParsedQuerySummaryDeleteArgs} args - Arguments to delete one ParsedQuerySummary.
     * @example
     * // Delete one ParsedQuerySummary
     * const ParsedQuerySummary = await prisma.parsedQuerySummary.delete({
     *   where: {
     *     // ... filter to delete one ParsedQuerySummary
     *   }
     * })
     * 
     */
    delete<T extends ParsedQuerySummaryDeleteArgs>(args: SelectSubset<T, ParsedQuerySummaryDeleteArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParsedQuerySummary.
     * @param {ParsedQuerySummaryUpdateArgs} args - Arguments to update one ParsedQuerySummary.
     * @example
     * // Update one ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParsedQuerySummaryUpdateArgs>(args: SelectSubset<T, ParsedQuerySummaryUpdateArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParsedQuerySummaries.
     * @param {ParsedQuerySummaryDeleteManyArgs} args - Arguments to filter ParsedQuerySummaries to delete.
     * @example
     * // Delete a few ParsedQuerySummaries
     * const { count } = await prisma.parsedQuerySummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParsedQuerySummaryDeleteManyArgs>(args?: SelectSubset<T, ParsedQuerySummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedQuerySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParsedQuerySummaries
     * const parsedQuerySummary = await prisma.parsedQuerySummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParsedQuerySummaryUpdateManyArgs>(args: SelectSubset<T, ParsedQuerySummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedQuerySummaries and returns the data updated in the database.
     * @param {ParsedQuerySummaryUpdateManyAndReturnArgs} args - Arguments to update many ParsedQuerySummaries.
     * @example
     * // Update many ParsedQuerySummaries
     * const parsedQuerySummary = await prisma.parsedQuerySummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParsedQuerySummaries and only return the `id`
     * const parsedQuerySummaryWithIdOnly = await prisma.parsedQuerySummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParsedQuerySummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, ParsedQuerySummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParsedQuerySummary.
     * @param {ParsedQuerySummaryUpsertArgs} args - Arguments to update or create a ParsedQuerySummary.
     * @example
     * // Update or create a ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.upsert({
     *   create: {
     *     // ... data to create a ParsedQuerySummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParsedQuerySummary we want to update
     *   }
     * })
     */
    upsert<T extends ParsedQuerySummaryUpsertArgs>(args: SelectSubset<T, ParsedQuerySummaryUpsertArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParsedQuerySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryCountArgs} args - Arguments to filter ParsedQuerySummaries to count.
     * @example
     * // Count the number of ParsedQuerySummaries
     * const count = await prisma.parsedQuerySummary.count({
     *   where: {
     *     // ... the filter for the ParsedQuerySummaries we want to count
     *   }
     * })
    **/
    count<T extends ParsedQuerySummaryCountArgs>(
      args?: Subset<T, ParsedQuerySummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParsedQuerySummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParsedQuerySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParsedQuerySummaryAggregateArgs>(args: Subset<T, ParsedQuerySummaryAggregateArgs>): Prisma.PrismaPromise<GetParsedQuerySummaryAggregateType<T>>

    /**
     * Group by ParsedQuerySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParsedQuerySummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParsedQuerySummaryGroupByArgs['orderBy'] }
        : { orderBy?: ParsedQuerySummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParsedQuerySummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsedQuerySummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParsedQuerySummary model
   */
  readonly fields: ParsedQuerySummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParsedQuerySummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParsedQuerySummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    query<T extends QueryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueryDefaultArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParsedQuerySummary model
   */
  interface ParsedQuerySummaryFieldRefs {
    readonly id: FieldRef<"ParsedQuerySummary", 'String'>
    readonly queryId: FieldRef<"ParsedQuerySummary", 'String'>
    readonly date: FieldRef<"ParsedQuerySummary", 'DateTime'>
    readonly totalEngagedSessions: FieldRef<"ParsedQuerySummary", 'Int'>
    readonly averageBounceRate: FieldRef<"ParsedQuerySummary", 'Float'>
    readonly totalNewUsers: FieldRef<"ParsedQuerySummary", 'Int'>
    readonly totalConversions: FieldRef<"ParsedQuerySummary", 'Int'>
    readonly createdAt: FieldRef<"ParsedQuerySummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParsedQuerySummary findUnique
   */
  export type ParsedQuerySummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQuerySummary to fetch.
     */
    where: ParsedQuerySummaryWhereUniqueInput
  }

  /**
   * ParsedQuerySummary findUniqueOrThrow
   */
  export type ParsedQuerySummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQuerySummary to fetch.
     */
    where: ParsedQuerySummaryWhereUniqueInput
  }

  /**
   * ParsedQuerySummary findFirst
   */
  export type ParsedQuerySummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQuerySummary to fetch.
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQuerySummaries to fetch.
     */
    orderBy?: ParsedQuerySummaryOrderByWithRelationInput | ParsedQuerySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedQuerySummaries.
     */
    cursor?: ParsedQuerySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQuerySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQuerySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedQuerySummaries.
     */
    distinct?: ParsedQuerySummaryScalarFieldEnum | ParsedQuerySummaryScalarFieldEnum[]
  }

  /**
   * ParsedQuerySummary findFirstOrThrow
   */
  export type ParsedQuerySummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQuerySummary to fetch.
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQuerySummaries to fetch.
     */
    orderBy?: ParsedQuerySummaryOrderByWithRelationInput | ParsedQuerySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedQuerySummaries.
     */
    cursor?: ParsedQuerySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQuerySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQuerySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedQuerySummaries.
     */
    distinct?: ParsedQuerySummaryScalarFieldEnum | ParsedQuerySummaryScalarFieldEnum[]
  }

  /**
   * ParsedQuerySummary findMany
   */
  export type ParsedQuerySummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQuerySummaries to fetch.
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQuerySummaries to fetch.
     */
    orderBy?: ParsedQuerySummaryOrderByWithRelationInput | ParsedQuerySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParsedQuerySummaries.
     */
    cursor?: ParsedQuerySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQuerySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQuerySummaries.
     */
    skip?: number
    distinct?: ParsedQuerySummaryScalarFieldEnum | ParsedQuerySummaryScalarFieldEnum[]
  }

  /**
   * ParsedQuerySummary create
   */
  export type ParsedQuerySummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a ParsedQuerySummary.
     */
    data: XOR<ParsedQuerySummaryCreateInput, ParsedQuerySummaryUncheckedCreateInput>
  }

  /**
   * ParsedQuerySummary createMany
   */
  export type ParsedQuerySummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParsedQuerySummaries.
     */
    data: ParsedQuerySummaryCreateManyInput | ParsedQuerySummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParsedQuerySummary createManyAndReturn
   */
  export type ParsedQuerySummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * The data used to create many ParsedQuerySummaries.
     */
    data: ParsedQuerySummaryCreateManyInput | ParsedQuerySummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedQuerySummary update
   */
  export type ParsedQuerySummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a ParsedQuerySummary.
     */
    data: XOR<ParsedQuerySummaryUpdateInput, ParsedQuerySummaryUncheckedUpdateInput>
    /**
     * Choose, which ParsedQuerySummary to update.
     */
    where: ParsedQuerySummaryWhereUniqueInput
  }

  /**
   * ParsedQuerySummary updateMany
   */
  export type ParsedQuerySummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParsedQuerySummaries.
     */
    data: XOR<ParsedQuerySummaryUpdateManyMutationInput, ParsedQuerySummaryUncheckedUpdateManyInput>
    /**
     * Filter which ParsedQuerySummaries to update
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * Limit how many ParsedQuerySummaries to update.
     */
    limit?: number
  }

  /**
   * ParsedQuerySummary updateManyAndReturn
   */
  export type ParsedQuerySummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * The data used to update ParsedQuerySummaries.
     */
    data: XOR<ParsedQuerySummaryUpdateManyMutationInput, ParsedQuerySummaryUncheckedUpdateManyInput>
    /**
     * Filter which ParsedQuerySummaries to update
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * Limit how many ParsedQuerySummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedQuerySummary upsert
   */
  export type ParsedQuerySummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the ParsedQuerySummary to update in case it exists.
     */
    where: ParsedQuerySummaryWhereUniqueInput
    /**
     * In case the ParsedQuerySummary found by the `where` argument doesn't exist, create a new ParsedQuerySummary with this data.
     */
    create: XOR<ParsedQuerySummaryCreateInput, ParsedQuerySummaryUncheckedCreateInput>
    /**
     * In case the ParsedQuerySummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParsedQuerySummaryUpdateInput, ParsedQuerySummaryUncheckedUpdateInput>
  }

  /**
   * ParsedQuerySummary delete
   */
  export type ParsedQuerySummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter which ParsedQuerySummary to delete.
     */
    where: ParsedQuerySummaryWhereUniqueInput
  }

  /**
   * ParsedQuerySummary deleteMany
   */
  export type ParsedQuerySummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedQuerySummaries to delete
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * Limit how many ParsedQuerySummaries to delete.
     */
    limit?: number
  }

  /**
   * ParsedQuerySummary without action
   */
  export type ParsedQuerySummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
  }


  /**
   * Model Query
   */

  export type AggregateQuery = {
    _count: QueryCountAggregateOutputType | null
    _avg: QueryAvgAggregateOutputType | null
    _sum: QuerySumAggregateOutputType | null
    _min: QueryMinAggregateOutputType | null
    _max: QueryMaxAggregateOutputType | null
  }

  export type QueryAvgAggregateOutputType = {
    rating: number | null
  }

  export type QuerySumAggregateOutputType = {
    rating: number | null
  }

  export type QueryMinAggregateOutputType = {
    id: string | null
    content: string | null
    response: string | null
    status: $Enums.QueryStatus | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    conversationId: string | null
  }

  export type QueryMaxAggregateOutputType = {
    id: string | null
    content: string | null
    response: string | null
    status: $Enums.QueryStatus | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    conversationId: string | null
  }

  export type QueryCountAggregateOutputType = {
    id: number
    content: number
    response: number
    status: number
    rating: number
    metadata: number
    lineGraphData: number
    pieGraphData: number
    createdAt: number
    updatedAt: number
    userId: number
    conversationId: number
    _all: number
  }


  export type QueryAvgAggregateInputType = {
    rating?: true
  }

  export type QuerySumAggregateInputType = {
    rating?: true
  }

  export type QueryMinAggregateInputType = {
    id?: true
    content?: true
    response?: true
    status?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    conversationId?: true
  }

  export type QueryMaxAggregateInputType = {
    id?: true
    content?: true
    response?: true
    status?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    conversationId?: true
  }

  export type QueryCountAggregateInputType = {
    id?: true
    content?: true
    response?: true
    status?: true
    rating?: true
    metadata?: true
    lineGraphData?: true
    pieGraphData?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    conversationId?: true
    _all?: true
  }

  export type QueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Query to aggregate.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Queries
    **/
    _count?: true | QueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueryMaxAggregateInputType
  }

  export type GetQueryAggregateType<T extends QueryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuery[P]>
      : GetScalarType<T[P], AggregateQuery[P]>
  }




  export type QueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithAggregationInput | QueryOrderByWithAggregationInput[]
    by: QueryScalarFieldEnum[] | QueryScalarFieldEnum
    having?: QueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueryCountAggregateInputType | true
    _avg?: QueryAvgAggregateInputType
    _sum?: QuerySumAggregateInputType
    _min?: QueryMinAggregateInputType
    _max?: QueryMaxAggregateInputType
  }

  export type QueryGroupByOutputType = {
    id: string
    content: string
    response: string | null
    status: $Enums.QueryStatus
    rating: number
    metadata: JsonValue | null
    lineGraphData: JsonValue | null
    pieGraphData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    userId: string
    conversationId: string | null
    _count: QueryCountAggregateOutputType | null
    _avg: QueryAvgAggregateOutputType | null
    _sum: QuerySumAggregateOutputType | null
    _min: QueryMinAggregateOutputType | null
    _max: QueryMaxAggregateOutputType | null
  }

  type GetQueryGroupByPayload<T extends QueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueryGroupByOutputType[P]>
            : GetScalarType<T[P], QueryGroupByOutputType[P]>
        }
      >
    >


  export type QuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    response?: boolean
    status?: boolean
    rating?: boolean
    metadata?: boolean
    lineGraphData?: boolean
    pieGraphData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    conversationId?: boolean
    parsedData?: boolean | Query$parsedDataArgs<ExtArgs>
    parsedPieData?: boolean | Query$parsedPieDataArgs<ExtArgs>
    parsedSummary?: boolean | Query$parsedSummaryArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | Query$conversationArgs<ExtArgs>
    _count?: boolean | QueryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["query"]>

  export type QuerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    response?: boolean
    status?: boolean
    rating?: boolean
    metadata?: boolean
    lineGraphData?: boolean
    pieGraphData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    conversationId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | Query$conversationArgs<ExtArgs>
  }, ExtArgs["result"]["query"]>

  export type QuerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    response?: boolean
    status?: boolean
    rating?: boolean
    metadata?: boolean
    lineGraphData?: boolean
    pieGraphData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    conversationId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | Query$conversationArgs<ExtArgs>
  }, ExtArgs["result"]["query"]>

  export type QuerySelectScalar = {
    id?: boolean
    content?: boolean
    response?: boolean
    status?: boolean
    rating?: boolean
    metadata?: boolean
    lineGraphData?: boolean
    pieGraphData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    conversationId?: boolean
  }

  export type QueryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "response" | "status" | "rating" | "metadata" | "lineGraphData" | "pieGraphData" | "createdAt" | "updatedAt" | "userId" | "conversationId", ExtArgs["result"]["query"]>
  export type QueryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parsedData?: boolean | Query$parsedDataArgs<ExtArgs>
    parsedPieData?: boolean | Query$parsedPieDataArgs<ExtArgs>
    parsedSummary?: boolean | Query$parsedSummaryArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | Query$conversationArgs<ExtArgs>
    _count?: boolean | QueryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QueryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | Query$conversationArgs<ExtArgs>
  }
  export type QueryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | Query$conversationArgs<ExtArgs>
  }

  export type $QueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Query"
    objects: {
      parsedData: Prisma.$ParsedQueryDataPayload<ExtArgs>[]
      parsedPieData: Prisma.$ParsedPieGraphDataPayload<ExtArgs>[]
      parsedSummary: Prisma.$ParsedQuerySummaryPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      conversation: Prisma.$ConversationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      response: string | null
      status: $Enums.QueryStatus
      rating: number
      metadata: Prisma.JsonValue | null
      lineGraphData: Prisma.JsonValue | null
      pieGraphData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      userId: string
      conversationId: string | null
    }, ExtArgs["result"]["query"]>
    composites: {}
  }

  type QueryGetPayload<S extends boolean | null | undefined | QueryDefaultArgs> = $Result.GetResult<Prisma.$QueryPayload, S>

  type QueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueryCountAggregateInputType | true
    }

  export interface QueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Query'], meta: { name: 'Query' } }
    /**
     * Find zero or one Query that matches the filter.
     * @param {QueryFindUniqueArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueryFindUniqueArgs>(args: SelectSubset<T, QueryFindUniqueArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Query that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueryFindUniqueOrThrowArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueryFindUniqueOrThrowArgs>(args: SelectSubset<T, QueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Query that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindFirstArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueryFindFirstArgs>(args?: SelectSubset<T, QueryFindFirstArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Query that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindFirstOrThrowArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueryFindFirstOrThrowArgs>(args?: SelectSubset<T, QueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Queries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Queries
     * const queries = await prisma.query.findMany()
     * 
     * // Get first 10 Queries
     * const queries = await prisma.query.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queryWithIdOnly = await prisma.query.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueryFindManyArgs>(args?: SelectSubset<T, QueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Query.
     * @param {QueryCreateArgs} args - Arguments to create a Query.
     * @example
     * // Create one Query
     * const Query = await prisma.query.create({
     *   data: {
     *     // ... data to create a Query
     *   }
     * })
     * 
     */
    create<T extends QueryCreateArgs>(args: SelectSubset<T, QueryCreateArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Queries.
     * @param {QueryCreateManyArgs} args - Arguments to create many Queries.
     * @example
     * // Create many Queries
     * const query = await prisma.query.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueryCreateManyArgs>(args?: SelectSubset<T, QueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Queries and returns the data saved in the database.
     * @param {QueryCreateManyAndReturnArgs} args - Arguments to create many Queries.
     * @example
     * // Create many Queries
     * const query = await prisma.query.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Queries and only return the `id`
     * const queryWithIdOnly = await prisma.query.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueryCreateManyAndReturnArgs>(args?: SelectSubset<T, QueryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Query.
     * @param {QueryDeleteArgs} args - Arguments to delete one Query.
     * @example
     * // Delete one Query
     * const Query = await prisma.query.delete({
     *   where: {
     *     // ... filter to delete one Query
     *   }
     * })
     * 
     */
    delete<T extends QueryDeleteArgs>(args: SelectSubset<T, QueryDeleteArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Query.
     * @param {QueryUpdateArgs} args - Arguments to update one Query.
     * @example
     * // Update one Query
     * const query = await prisma.query.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueryUpdateArgs>(args: SelectSubset<T, QueryUpdateArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Queries.
     * @param {QueryDeleteManyArgs} args - Arguments to filter Queries to delete.
     * @example
     * // Delete a few Queries
     * const { count } = await prisma.query.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueryDeleteManyArgs>(args?: SelectSubset<T, QueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Queries
     * const query = await prisma.query.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueryUpdateManyArgs>(args: SelectSubset<T, QueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queries and returns the data updated in the database.
     * @param {QueryUpdateManyAndReturnArgs} args - Arguments to update many Queries.
     * @example
     * // Update many Queries
     * const query = await prisma.query.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Queries and only return the `id`
     * const queryWithIdOnly = await prisma.query.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueryUpdateManyAndReturnArgs>(args: SelectSubset<T, QueryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Query.
     * @param {QueryUpsertArgs} args - Arguments to update or create a Query.
     * @example
     * // Update or create a Query
     * const query = await prisma.query.upsert({
     *   create: {
     *     // ... data to create a Query
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Query we want to update
     *   }
     * })
     */
    upsert<T extends QueryUpsertArgs>(args: SelectSubset<T, QueryUpsertArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryCountArgs} args - Arguments to filter Queries to count.
     * @example
     * // Count the number of Queries
     * const count = await prisma.query.count({
     *   where: {
     *     // ... the filter for the Queries we want to count
     *   }
     * })
    **/
    count<T extends QueryCountArgs>(
      args?: Subset<T, QueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Query.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueryAggregateArgs>(args: Subset<T, QueryAggregateArgs>): Prisma.PrismaPromise<GetQueryAggregateType<T>>

    /**
     * Group by Query.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueryGroupByArgs['orderBy'] }
        : { orderBy?: QueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Query model
   */
  readonly fields: QueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Query.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parsedData<T extends Query$parsedDataArgs<ExtArgs> = {}>(args?: Subset<T, Query$parsedDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parsedPieData<T extends Query$parsedPieDataArgs<ExtArgs> = {}>(args?: Subset<T, Query$parsedPieDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parsedSummary<T extends Query$parsedSummaryArgs<ExtArgs> = {}>(args?: Subset<T, Query$parsedSummaryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversation<T extends Query$conversationArgs<ExtArgs> = {}>(args?: Subset<T, Query$conversationArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Query model
   */
  interface QueryFieldRefs {
    readonly id: FieldRef<"Query", 'String'>
    readonly content: FieldRef<"Query", 'String'>
    readonly response: FieldRef<"Query", 'String'>
    readonly status: FieldRef<"Query", 'QueryStatus'>
    readonly rating: FieldRef<"Query", 'Int'>
    readonly metadata: FieldRef<"Query", 'Json'>
    readonly lineGraphData: FieldRef<"Query", 'Json'>
    readonly pieGraphData: FieldRef<"Query", 'Json'>
    readonly createdAt: FieldRef<"Query", 'DateTime'>
    readonly updatedAt: FieldRef<"Query", 'DateTime'>
    readonly userId: FieldRef<"Query", 'String'>
    readonly conversationId: FieldRef<"Query", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Query findUnique
   */
  export type QueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query findUniqueOrThrow
   */
  export type QueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query findFirst
   */
  export type QueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queries.
     */
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query findFirstOrThrow
   */
  export type QueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queries.
     */
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query findMany
   */
  export type QueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Queries to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query create
   */
  export type QueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The data needed to create a Query.
     */
    data: XOR<QueryCreateInput, QueryUncheckedCreateInput>
  }

  /**
   * Query createMany
   */
  export type QueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Queries.
     */
    data: QueryCreateManyInput | QueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Query createManyAndReturn
   */
  export type QueryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * The data used to create many Queries.
     */
    data: QueryCreateManyInput | QueryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Query update
   */
  export type QueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The data needed to update a Query.
     */
    data: XOR<QueryUpdateInput, QueryUncheckedUpdateInput>
    /**
     * Choose, which Query to update.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query updateMany
   */
  export type QueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Queries.
     */
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyInput>
    /**
     * Filter which Queries to update
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to update.
     */
    limit?: number
  }

  /**
   * Query updateManyAndReturn
   */
  export type QueryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * The data used to update Queries.
     */
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyInput>
    /**
     * Filter which Queries to update
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Query upsert
   */
  export type QueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The filter to search for the Query to update in case it exists.
     */
    where: QueryWhereUniqueInput
    /**
     * In case the Query found by the `where` argument doesn't exist, create a new Query with this data.
     */
    create: XOR<QueryCreateInput, QueryUncheckedCreateInput>
    /**
     * In case the Query was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueryUpdateInput, QueryUncheckedUpdateInput>
  }

  /**
   * Query delete
   */
  export type QueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter which Query to delete.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query deleteMany
   */
  export type QueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Queries to delete
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to delete.
     */
    limit?: number
  }

  /**
   * Query.parsedData
   */
  export type Query$parsedDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    where?: ParsedQueryDataWhereInput
    orderBy?: ParsedQueryDataOrderByWithRelationInput | ParsedQueryDataOrderByWithRelationInput[]
    cursor?: ParsedQueryDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParsedQueryDataScalarFieldEnum | ParsedQueryDataScalarFieldEnum[]
  }

  /**
   * Query.parsedPieData
   */
  export type Query$parsedPieDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    where?: ParsedPieGraphDataWhereInput
    orderBy?: ParsedPieGraphDataOrderByWithRelationInput | ParsedPieGraphDataOrderByWithRelationInput[]
    cursor?: ParsedPieGraphDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParsedPieGraphDataScalarFieldEnum | ParsedPieGraphDataScalarFieldEnum[]
  }

  /**
   * Query.parsedSummary
   */
  export type Query$parsedSummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    where?: ParsedQuerySummaryWhereInput
    orderBy?: ParsedQuerySummaryOrderByWithRelationInput | ParsedQuerySummaryOrderByWithRelationInput[]
    cursor?: ParsedQuerySummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParsedQuerySummaryScalarFieldEnum | ParsedQuerySummaryScalarFieldEnum[]
  }

  /**
   * Query.conversation
   */
  export type Query$conversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
  }

  /**
   * Query without action
   */
  export type QueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    emailVerified: Date | null
    image: string | null
    roleId: string | null
    isActive: boolean | null
    accountRepId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    emailVerified: Date | null
    image: string | null
    roleId: string | null
    isActive: boolean | null
    accountRepId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    emailVerified: number
    image: number
    roleId: number
    isActive: number
    accountRepId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    emailVerified?: true
    image?: true
    roleId?: true
    isActive?: true
    accountRepId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    emailVerified?: true
    image?: true
    roleId?: true
    isActive?: true
    accountRepId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    emailVerified?: true
    image?: true
    roleId?: true
    isActive?: true
    accountRepId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    password: string | null
    emailVerified: Date | null
    image: string | null
    roleId: string
    isActive: boolean
    accountRepId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    emailVerified?: boolean
    image?: boolean
    roleId?: boolean
    isActive?: boolean
    accountRepId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
    clients?: boolean | User$clientsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    queries?: boolean | User$queriesArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    givenRatings?: boolean | User$givenRatingsArgs<ExtArgs>
    receivedRatings?: boolean | User$receivedRatingsArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    clientTickets?: boolean | User$clientTicketsArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    gaAccounts?: boolean | User$gaAccountsArgs<ExtArgs>
    gaImportRuns?: boolean | User$gaImportRunsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    emailVerified?: boolean
    image?: boolean
    roleId?: boolean
    isActive?: boolean
    accountRepId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    emailVerified?: boolean
    image?: boolean
    roleId?: boolean
    isActive?: boolean
    accountRepId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    emailVerified?: boolean
    image?: boolean
    roleId?: boolean
    isActive?: boolean
    accountRepId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "emailVerified" | "image" | "roleId" | "isActive" | "accountRepId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
    clients?: boolean | User$clientsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    queries?: boolean | User$queriesArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    givenRatings?: boolean | User$givenRatingsArgs<ExtArgs>
    receivedRatings?: boolean | User$receivedRatingsArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    clientTickets?: boolean | User$clientTicketsArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    gaAccounts?: boolean | User$gaAccountsArgs<ExtArgs>
    gaImportRuns?: boolean | User$gaImportRunsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      accountRep: Prisma.$UserPayload<ExtArgs> | null
      clients: Prisma.$UserPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      queries: Prisma.$QueryPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      givenRatings: Prisma.$ClientSatisfactionPayload<ExtArgs>[]
      receivedRatings: Prisma.$ClientSatisfactionPayload<ExtArgs>[]
      assignedTickets: Prisma.$TicketPayload<ExtArgs>[]
      clientTickets: Prisma.$TicketPayload<ExtArgs>[]
      ticketComments: Prisma.$TicketCommentPayload<ExtArgs>[]
      activities: Prisma.$ClientActivityPayload<ExtArgs>[]
      gaAccounts: Prisma.$GaAccountPayload<ExtArgs>[]
      gaImportRuns: Prisma.$GaImportRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      password: string | null
      emailVerified: Date | null
      image: string | null
      roleId: string
      isActive: boolean
      accountRepId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    accountRep<T extends User$accountRepArgs<ExtArgs> = {}>(args?: Subset<T, User$accountRepArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clients<T extends User$clientsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    queries<T extends User$queriesArgs<ExtArgs> = {}>(args?: Subset<T, User$queriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    givenRatings<T extends User$givenRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$givenRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedRatings<T extends User$receivedRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTickets<T extends User$assignedTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientTickets<T extends User$clientTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketComments<T extends User$ticketCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gaAccounts<T extends User$gaAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$gaAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gaImportRuns<T extends User$gaImportRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$gaImportRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly accountRepId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accountRep
   */
  export type User$accountRepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.clients
   */
  export type User$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.queries
   */
  export type User$queriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    cursor?: QueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.givenRatings
   */
  export type User$givenRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    where?: ClientSatisfactionWhereInput
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    cursor?: ClientSatisfactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientSatisfactionScalarFieldEnum | ClientSatisfactionScalarFieldEnum[]
  }

  /**
   * User.receivedRatings
   */
  export type User$receivedRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    where?: ClientSatisfactionWhereInput
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    cursor?: ClientSatisfactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientSatisfactionScalarFieldEnum | ClientSatisfactionScalarFieldEnum[]
  }

  /**
   * User.assignedTickets
   */
  export type User$assignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.clientTickets
   */
  export type User$clientTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.ticketComments
   */
  export type User$ticketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    where?: ClientActivityWhereInput
    orderBy?: ClientActivityOrderByWithRelationInput | ClientActivityOrderByWithRelationInput[]
    cursor?: ClientActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientActivityScalarFieldEnum | ClientActivityScalarFieldEnum[]
  }

  /**
   * User.gaAccounts
   */
  export type User$gaAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    where?: GaAccountWhereInput
    orderBy?: GaAccountOrderByWithRelationInput | GaAccountOrderByWithRelationInput[]
    cursor?: GaAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaAccountScalarFieldEnum | GaAccountScalarFieldEnum[]
  }

  /**
   * User.gaImportRuns
   */
  export type User$gaImportRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    where?: GaImportRunWhereInput
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    cursor?: GaImportRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaImportRunScalarFieldEnum | GaImportRunScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsAvgAggregateOutputType = {
    apiCredits: number | null
    apiCreditsLimit: number | null
  }

  export type UserSettingsSumAggregateOutputType = {
    apiCredits: number | null
    apiCreditsLimit: number | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    emailNotifications: boolean | null
    theme: string | null
    apiCredits: number | null
    apiCreditsLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    emailNotifications: boolean | null
    theme: string | null
    apiCredits: number | null
    apiCreditsLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    emailNotifications: number
    theme: number
    apiCredits: number
    apiCreditsLimit: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type UserSettingsAvgAggregateInputType = {
    apiCredits?: true
    apiCreditsLimit?: true
  }

  export type UserSettingsSumAggregateInputType = {
    apiCredits?: true
    apiCreditsLimit?: true
  }

  export type UserSettingsMinAggregateInputType = {
    id?: true
    emailNotifications?: true
    theme?: true
    apiCredits?: true
    apiCreditsLimit?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    emailNotifications?: true
    theme?: true
    apiCredits?: true
    apiCreditsLimit?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    emailNotifications?: true
    theme?: true
    apiCredits?: true
    apiCreditsLimit?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _avg?: UserSettingsAvgAggregateInputType
    _sum?: UserSettingsSumAggregateInputType
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    emailNotifications: boolean
    theme: string | null
    apiCredits: number
    apiCreditsLimit: number
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailNotifications?: boolean
    theme?: boolean
    apiCredits?: boolean
    apiCreditsLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailNotifications?: boolean
    theme?: boolean
    apiCredits?: boolean
    apiCreditsLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailNotifications?: boolean
    theme?: boolean
    apiCredits?: boolean
    apiCreditsLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    emailNotifications?: boolean
    theme?: boolean
    apiCredits?: boolean
    apiCreditsLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailNotifications" | "theme" | "apiCredits" | "apiCreditsLimit" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["userSettings"]>
  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailNotifications: boolean
      theme: string | null
      apiCredits: number
      apiCreditsLimit: number
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly emailNotifications: FieldRef<"UserSettings", 'Boolean'>
    readonly theme: FieldRef<"UserSettings", 'String'>
    readonly apiCredits: FieldRef<"UserSettings", 'Int'>
    readonly apiCreditsLimit: FieldRef<"UserSettings", 'Int'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
    readonly userId: FieldRef<"UserSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings updateManyAndReturn
   */
  export type UserSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedToId: string | null
    clientId: string | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedToId: string | null
    clientId: string | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    assignedToId: number
    clientId: number
    _all: number
  }


  export type TicketMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    clientId?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    clientId?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    clientId?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    title: string
    description: string
    status: $Enums.TicketStatus
    priority: $Enums.TicketPriority
    createdAt: Date
    updatedAt: Date
    assignedToId: string | null
    clientId: string
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    clientId?: boolean
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Ticket$attachmentsArgs<ExtArgs>
    comments?: boolean | Ticket$commentsArgs<ExtArgs>
    tags?: boolean | Ticket$tagsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    clientId?: boolean
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    clientId?: boolean
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    clientId?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "priority" | "createdAt" | "updatedAt" | "assignedToId" | "clientId", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Ticket$attachmentsArgs<ExtArgs>
    comments?: boolean | Ticket$commentsArgs<ExtArgs>
    tags?: boolean | Ticket$tagsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      client: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$TicketAttachmentPayload<ExtArgs>[]
      comments: Prisma.$TicketCommentPayload<ExtArgs>[]
      tags: Prisma.$TicketTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: $Enums.TicketStatus
      priority: $Enums.TicketPriority
      createdAt: Date
      updatedAt: Date
      assignedToId: string | null
      clientId: string
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends Ticket$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Ticket$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Ticket$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Ticket$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly title: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly priority: FieldRef<"Ticket", 'TicketPriority'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
    readonly assignedToId: FieldRef<"Ticket", 'String'>
    readonly clientId: FieldRef<"Ticket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket.assignedTo
   */
  export type Ticket$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.attachments
   */
  export type Ticket$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    cursor?: TicketAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * Ticket.comments
   */
  export type Ticket$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * Ticket.tags
   */
  export type Ticket$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    where?: TicketTagWhereInput
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    cursor?: TicketTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketAttachment
   */

  export type AggregateTicketAttachment = {
    _count: TicketAttachmentCountAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  export type TicketAttachmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    createdAt: Date | null
    ticketId: string | null
  }

  export type TicketAttachmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    createdAt: Date | null
    ticketId: string | null
  }

  export type TicketAttachmentCountAggregateOutputType = {
    id: number
    name: number
    url: number
    createdAt: number
    ticketId: number
    _all: number
  }


  export type TicketAttachmentMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    createdAt?: true
    ticketId?: true
  }

  export type TicketAttachmentMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    createdAt?: true
    ticketId?: true
  }

  export type TicketAttachmentCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    createdAt?: true
    ticketId?: true
    _all?: true
  }

  export type TicketAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachment to aggregate.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketAttachments
    **/
    _count?: true | TicketAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type GetTicketAttachmentAggregateType<T extends TicketAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketAttachment[P]>
      : GetScalarType<T[P], AggregateTicketAttachment[P]>
  }




  export type TicketAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithAggregationInput | TicketAttachmentOrderByWithAggregationInput[]
    by: TicketAttachmentScalarFieldEnum[] | TicketAttachmentScalarFieldEnum
    having?: TicketAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketAttachmentCountAggregateInputType | true
    _min?: TicketAttachmentMinAggregateInputType
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type TicketAttachmentGroupByOutputType = {
    id: string
    name: string
    url: string
    createdAt: Date
    ticketId: string
    _count: TicketAttachmentCountAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  type GetTicketAttachmentGroupByPayload<T extends TicketAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type TicketAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    createdAt?: boolean
    ticketId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    createdAt?: boolean
    ticketId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    createdAt?: boolean
    ticketId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    createdAt?: boolean
    ticketId?: boolean
  }

  export type TicketAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "createdAt" | "ticketId", ExtArgs["result"]["ticketAttachment"]>
  export type TicketAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketAttachment"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      createdAt: Date
      ticketId: string
    }, ExtArgs["result"]["ticketAttachment"]>
    composites: {}
  }

  type TicketAttachmentGetPayload<S extends boolean | null | undefined | TicketAttachmentDefaultArgs> = $Result.GetResult<Prisma.$TicketAttachmentPayload, S>

  type TicketAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketAttachmentCountAggregateInputType | true
    }

  export interface TicketAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketAttachment'], meta: { name: 'TicketAttachment' } }
    /**
     * Find zero or one TicketAttachment that matches the filter.
     * @param {TicketAttachmentFindUniqueArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketAttachmentFindUniqueArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketAttachmentFindUniqueOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketAttachmentFindFirstArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany()
     * 
     * // Get first 10 TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketAttachmentFindManyArgs>(args?: SelectSubset<T, TicketAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketAttachment.
     * @param {TicketAttachmentCreateArgs} args - Arguments to create a TicketAttachment.
     * @example
     * // Create one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.create({
     *   data: {
     *     // ... data to create a TicketAttachment
     *   }
     * })
     * 
     */
    create<T extends TicketAttachmentCreateArgs>(args: SelectSubset<T, TicketAttachmentCreateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketAttachments.
     * @param {TicketAttachmentCreateManyArgs} args - Arguments to create many TicketAttachments.
     * @example
     * // Create many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketAttachmentCreateManyArgs>(args?: SelectSubset<T, TicketAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketAttachments and returns the data saved in the database.
     * @param {TicketAttachmentCreateManyAndReturnArgs} args - Arguments to create many TicketAttachments.
     * @example
     * // Create many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketAttachments and only return the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketAttachment.
     * @param {TicketAttachmentDeleteArgs} args - Arguments to delete one TicketAttachment.
     * @example
     * // Delete one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.delete({
     *   where: {
     *     // ... filter to delete one TicketAttachment
     *   }
     * })
     * 
     */
    delete<T extends TicketAttachmentDeleteArgs>(args: SelectSubset<T, TicketAttachmentDeleteArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketAttachment.
     * @param {TicketAttachmentUpdateArgs} args - Arguments to update one TicketAttachment.
     * @example
     * // Update one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketAttachmentUpdateArgs>(args: SelectSubset<T, TicketAttachmentUpdateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketAttachments.
     * @param {TicketAttachmentDeleteManyArgs} args - Arguments to filter TicketAttachments to delete.
     * @example
     * // Delete a few TicketAttachments
     * const { count } = await prisma.ticketAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketAttachmentDeleteManyArgs>(args?: SelectSubset<T, TicketAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketAttachmentUpdateManyArgs>(args: SelectSubset<T, TicketAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAttachments and returns the data updated in the database.
     * @param {TicketAttachmentUpdateManyAndReturnArgs} args - Arguments to update many TicketAttachments.
     * @example
     * // Update many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketAttachments and only return the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketAttachment.
     * @param {TicketAttachmentUpsertArgs} args - Arguments to update or create a TicketAttachment.
     * @example
     * // Update or create a TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.upsert({
     *   create: {
     *     // ... data to create a TicketAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketAttachment we want to update
     *   }
     * })
     */
    upsert<T extends TicketAttachmentUpsertArgs>(args: SelectSubset<T, TicketAttachmentUpsertArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentCountArgs} args - Arguments to filter TicketAttachments to count.
     * @example
     * // Count the number of TicketAttachments
     * const count = await prisma.ticketAttachment.count({
     *   where: {
     *     // ... the filter for the TicketAttachments we want to count
     *   }
     * })
    **/
    count<T extends TicketAttachmentCountArgs>(
      args?: Subset<T, TicketAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAttachmentAggregateArgs>(args: Subset<T, TicketAttachmentAggregateArgs>): Prisma.PrismaPromise<GetTicketAttachmentAggregateType<T>>

    /**
     * Group by TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: TicketAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketAttachment model
   */
  readonly fields: TicketAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketAttachment model
   */
  interface TicketAttachmentFieldRefs {
    readonly id: FieldRef<"TicketAttachment", 'String'>
    readonly name: FieldRef<"TicketAttachment", 'String'>
    readonly url: FieldRef<"TicketAttachment", 'String'>
    readonly createdAt: FieldRef<"TicketAttachment", 'DateTime'>
    readonly ticketId: FieldRef<"TicketAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TicketAttachment findUnique
   */
  export type TicketAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findUniqueOrThrow
   */
  export type TicketAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findFirst
   */
  export type TicketAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findFirstOrThrow
   */
  export type TicketAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findMany
   */
  export type TicketAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachments to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment create
   */
  export type TicketAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketAttachment.
     */
    data: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
  }

  /**
   * TicketAttachment createMany
   */
  export type TicketAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketAttachments.
     */
    data: TicketAttachmentCreateManyInput | TicketAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketAttachment createManyAndReturn
   */
  export type TicketAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many TicketAttachments.
     */
    data: TicketAttachmentCreateManyInput | TicketAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketAttachment update
   */
  export type TicketAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketAttachment.
     */
    data: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
    /**
     * Choose, which TicketAttachment to update.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment updateMany
   */
  export type TicketAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketAttachments.
     */
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAttachments to update
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to update.
     */
    limit?: number
  }

  /**
   * TicketAttachment updateManyAndReturn
   */
  export type TicketAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update TicketAttachments.
     */
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAttachments to update
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketAttachment upsert
   */
  export type TicketAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketAttachment to update in case it exists.
     */
    where: TicketAttachmentWhereUniqueInput
    /**
     * In case the TicketAttachment found by the `where` argument doesn't exist, create a new TicketAttachment with this data.
     */
    create: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
    /**
     * In case the TicketAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
  }

  /**
   * TicketAttachment delete
   */
  export type TicketAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter which TicketAttachment to delete.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment deleteMany
   */
  export type TicketAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachments to delete
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to delete.
     */
    limit?: number
  }

  /**
   * TicketAttachment without action
   */
  export type TicketAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model TicketComment
   */

  export type AggregateTicketComment = {
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  export type TicketCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ticketId: string | null
    authorId: string | null
  }

  export type TicketCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ticketId: string | null
    authorId: string | null
  }

  export type TicketCommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    ticketId: number
    authorId: number
    _all: number
  }


  export type TicketCommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    ticketId?: true
    authorId?: true
  }

  export type TicketCommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    ticketId?: true
    authorId?: true
  }

  export type TicketCommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    ticketId?: true
    authorId?: true
    _all?: true
  }

  export type TicketCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComment to aggregate.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketComments
    **/
    _count?: true | TicketCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketCommentMaxAggregateInputType
  }

  export type GetTicketCommentAggregateType<T extends TicketCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketComment[P]>
      : GetScalarType<T[P], AggregateTicketComment[P]>
  }




  export type TicketCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithAggregationInput | TicketCommentOrderByWithAggregationInput[]
    by: TicketCommentScalarFieldEnum[] | TicketCommentScalarFieldEnum
    having?: TicketCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCommentCountAggregateInputType | true
    _min?: TicketCommentMinAggregateInputType
    _max?: TicketCommentMaxAggregateInputType
  }

  export type TicketCommentGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    ticketId: string
    authorId: string
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  type GetTicketCommentGroupByPayload<T extends TicketCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
        }
      >
    >


  export type TicketCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticketId?: boolean
    authorId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticketId?: boolean
    authorId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticketId?: boolean
    authorId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticketId?: boolean
    authorId?: boolean
  }

  export type TicketCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt" | "ticketId" | "authorId", ExtArgs["result"]["ticketComment"]>
  export type TicketCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketComment"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
      ticketId: string
      authorId: string
    }, ExtArgs["result"]["ticketComment"]>
    composites: {}
  }

  type TicketCommentGetPayload<S extends boolean | null | undefined | TicketCommentDefaultArgs> = $Result.GetResult<Prisma.$TicketCommentPayload, S>

  type TicketCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCommentCountAggregateInputType | true
    }

  export interface TicketCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketComment'], meta: { name: 'TicketComment' } }
    /**
     * Find zero or one TicketComment that matches the filter.
     * @param {TicketCommentFindUniqueArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketCommentFindUniqueArgs>(args: SelectSubset<T, TicketCommentFindUniqueArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketCommentFindUniqueOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketCommentFindFirstArgs>(args?: SelectSubset<T, TicketCommentFindFirstArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketComments
     * const ticketComments = await prisma.ticketComment.findMany()
     * 
     * // Get first 10 TicketComments
     * const ticketComments = await prisma.ticketComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketCommentFindManyArgs>(args?: SelectSubset<T, TicketCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketComment.
     * @param {TicketCommentCreateArgs} args - Arguments to create a TicketComment.
     * @example
     * // Create one TicketComment
     * const TicketComment = await prisma.ticketComment.create({
     *   data: {
     *     // ... data to create a TicketComment
     *   }
     * })
     * 
     */
    create<T extends TicketCommentCreateArgs>(args: SelectSubset<T, TicketCommentCreateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketComments.
     * @param {TicketCommentCreateManyArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCommentCreateManyArgs>(args?: SelectSubset<T, TicketCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketComments and returns the data saved in the database.
     * @param {TicketCommentCreateManyAndReturnArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketComments and only return the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketComment.
     * @param {TicketCommentDeleteArgs} args - Arguments to delete one TicketComment.
     * @example
     * // Delete one TicketComment
     * const TicketComment = await prisma.ticketComment.delete({
     *   where: {
     *     // ... filter to delete one TicketComment
     *   }
     * })
     * 
     */
    delete<T extends TicketCommentDeleteArgs>(args: SelectSubset<T, TicketCommentDeleteArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketComment.
     * @param {TicketCommentUpdateArgs} args - Arguments to update one TicketComment.
     * @example
     * // Update one TicketComment
     * const ticketComment = await prisma.ticketComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketCommentUpdateArgs>(args: SelectSubset<T, TicketCommentUpdateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketComments.
     * @param {TicketCommentDeleteManyArgs} args - Arguments to filter TicketComments to delete.
     * @example
     * // Delete a few TicketComments
     * const { count } = await prisma.ticketComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketCommentDeleteManyArgs>(args?: SelectSubset<T, TicketCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketCommentUpdateManyArgs>(args: SelectSubset<T, TicketCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments and returns the data updated in the database.
     * @param {TicketCommentUpdateManyAndReturnArgs} args - Arguments to update many TicketComments.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketComments and only return the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketComment.
     * @param {TicketCommentUpsertArgs} args - Arguments to update or create a TicketComment.
     * @example
     * // Update or create a TicketComment
     * const ticketComment = await prisma.ticketComment.upsert({
     *   create: {
     *     // ... data to create a TicketComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketComment we want to update
     *   }
     * })
     */
    upsert<T extends TicketCommentUpsertArgs>(args: SelectSubset<T, TicketCommentUpsertArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentCountArgs} args - Arguments to filter TicketComments to count.
     * @example
     * // Count the number of TicketComments
     * const count = await prisma.ticketComment.count({
     *   where: {
     *     // ... the filter for the TicketComments we want to count
     *   }
     * })
    **/
    count<T extends TicketCommentCountArgs>(
      args?: Subset<T, TicketCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketCommentAggregateArgs>(args: Subset<T, TicketCommentAggregateArgs>): Prisma.PrismaPromise<GetTicketCommentAggregateType<T>>

    /**
     * Group by TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketCommentGroupByArgs['orderBy'] }
        : { orderBy?: TicketCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketComment model
   */
  readonly fields: TicketCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketComment model
   */
  interface TicketCommentFieldRefs {
    readonly id: FieldRef<"TicketComment", 'String'>
    readonly content: FieldRef<"TicketComment", 'String'>
    readonly createdAt: FieldRef<"TicketComment", 'DateTime'>
    readonly updatedAt: FieldRef<"TicketComment", 'DateTime'>
    readonly ticketId: FieldRef<"TicketComment", 'String'>
    readonly authorId: FieldRef<"TicketComment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TicketComment findUnique
   */
  export type TicketCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findUniqueOrThrow
   */
  export type TicketCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findFirst
   */
  export type TicketCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findFirstOrThrow
   */
  export type TicketCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findMany
   */
  export type TicketCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComments to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment create
   */
  export type TicketCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketComment.
     */
    data: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
  }

  /**
   * TicketComment createMany
   */
  export type TicketCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketComment createManyAndReturn
   */
  export type TicketCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketComment update
   */
  export type TicketCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketComment.
     */
    data: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
    /**
     * Choose, which TicketComment to update.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment updateMany
   */
  export type TicketCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to update.
     */
    limit?: number
  }

  /**
   * TicketComment updateManyAndReturn
   */
  export type TicketCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketComment upsert
   */
  export type TicketCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketComment to update in case it exists.
     */
    where: TicketCommentWhereUniqueInput
    /**
     * In case the TicketComment found by the `where` argument doesn't exist, create a new TicketComment with this data.
     */
    create: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
    /**
     * In case the TicketComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
  }

  /**
   * TicketComment delete
   */
  export type TicketCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter which TicketComment to delete.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment deleteMany
   */
  export type TicketCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComments to delete
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to delete.
     */
    limit?: number
  }

  /**
   * TicketComment without action
   */
  export type TicketCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
  }


  /**
   * Model TicketTag
   */

  export type AggregateTicketTag = {
    _count: TicketTagCountAggregateOutputType | null
    _min: TicketTagMinAggregateOutputType | null
    _max: TicketTagMaxAggregateOutputType | null
  }

  export type TicketTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type TicketTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type TicketTagCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type TicketTagMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type TicketTagMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type TicketTagCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type TicketTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketTag to aggregate.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketTags
    **/
    _count?: true | TicketTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketTagMaxAggregateInputType
  }

  export type GetTicketTagAggregateType<T extends TicketTagAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketTag[P]>
      : GetScalarType<T[P], AggregateTicketTag[P]>
  }




  export type TicketTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTagWhereInput
    orderBy?: TicketTagOrderByWithAggregationInput | TicketTagOrderByWithAggregationInput[]
    by: TicketTagScalarFieldEnum[] | TicketTagScalarFieldEnum
    having?: TicketTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketTagCountAggregateInputType | true
    _min?: TicketTagMinAggregateInputType
    _max?: TicketTagMaxAggregateInputType
  }

  export type TicketTagGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    _count: TicketTagCountAggregateOutputType | null
    _min: TicketTagMinAggregateOutputType | null
    _max: TicketTagMaxAggregateOutputType | null
  }

  type GetTicketTagGroupByPayload<T extends TicketTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketTagGroupByOutputType[P]>
            : GetScalarType<T[P], TicketTagGroupByOutputType[P]>
        }
      >
    >


  export type TicketTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    tickets?: boolean | TicketTag$ticketsArgs<ExtArgs>
    _count?: boolean | TicketTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketTag"]>

  export type TicketTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ticketTag"]>

  export type TicketTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ticketTag"]>

  export type TicketTagSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type TicketTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt", ExtArgs["result"]["ticketTag"]>
  export type TicketTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | TicketTag$ticketsArgs<ExtArgs>
    _count?: boolean | TicketTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TicketTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TicketTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketTag"
    objects: {
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
    }, ExtArgs["result"]["ticketTag"]>
    composites: {}
  }

  type TicketTagGetPayload<S extends boolean | null | undefined | TicketTagDefaultArgs> = $Result.GetResult<Prisma.$TicketTagPayload, S>

  type TicketTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketTagCountAggregateInputType | true
    }

  export interface TicketTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketTag'], meta: { name: 'TicketTag' } }
    /**
     * Find zero or one TicketTag that matches the filter.
     * @param {TicketTagFindUniqueArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketTagFindUniqueArgs>(args: SelectSubset<T, TicketTagFindUniqueArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketTagFindUniqueOrThrowArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketTagFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagFindFirstArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketTagFindFirstArgs>(args?: SelectSubset<T, TicketTagFindFirstArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagFindFirstOrThrowArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketTagFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketTags
     * const ticketTags = await prisma.ticketTag.findMany()
     * 
     * // Get first 10 TicketTags
     * const ticketTags = await prisma.ticketTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketTagWithIdOnly = await prisma.ticketTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketTagFindManyArgs>(args?: SelectSubset<T, TicketTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketTag.
     * @param {TicketTagCreateArgs} args - Arguments to create a TicketTag.
     * @example
     * // Create one TicketTag
     * const TicketTag = await prisma.ticketTag.create({
     *   data: {
     *     // ... data to create a TicketTag
     *   }
     * })
     * 
     */
    create<T extends TicketTagCreateArgs>(args: SelectSubset<T, TicketTagCreateArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketTags.
     * @param {TicketTagCreateManyArgs} args - Arguments to create many TicketTags.
     * @example
     * // Create many TicketTags
     * const ticketTag = await prisma.ticketTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketTagCreateManyArgs>(args?: SelectSubset<T, TicketTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketTags and returns the data saved in the database.
     * @param {TicketTagCreateManyAndReturnArgs} args - Arguments to create many TicketTags.
     * @example
     * // Create many TicketTags
     * const ticketTag = await prisma.ticketTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketTags and only return the `id`
     * const ticketTagWithIdOnly = await prisma.ticketTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketTagCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketTag.
     * @param {TicketTagDeleteArgs} args - Arguments to delete one TicketTag.
     * @example
     * // Delete one TicketTag
     * const TicketTag = await prisma.ticketTag.delete({
     *   where: {
     *     // ... filter to delete one TicketTag
     *   }
     * })
     * 
     */
    delete<T extends TicketTagDeleteArgs>(args: SelectSubset<T, TicketTagDeleteArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketTag.
     * @param {TicketTagUpdateArgs} args - Arguments to update one TicketTag.
     * @example
     * // Update one TicketTag
     * const ticketTag = await prisma.ticketTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketTagUpdateArgs>(args: SelectSubset<T, TicketTagUpdateArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketTags.
     * @param {TicketTagDeleteManyArgs} args - Arguments to filter TicketTags to delete.
     * @example
     * // Delete a few TicketTags
     * const { count } = await prisma.ticketTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketTagDeleteManyArgs>(args?: SelectSubset<T, TicketTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketTags
     * const ticketTag = await prisma.ticketTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketTagUpdateManyArgs>(args: SelectSubset<T, TicketTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketTags and returns the data updated in the database.
     * @param {TicketTagUpdateManyAndReturnArgs} args - Arguments to update many TicketTags.
     * @example
     * // Update many TicketTags
     * const ticketTag = await prisma.ticketTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketTags and only return the `id`
     * const ticketTagWithIdOnly = await prisma.ticketTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketTagUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketTag.
     * @param {TicketTagUpsertArgs} args - Arguments to update or create a TicketTag.
     * @example
     * // Update or create a TicketTag
     * const ticketTag = await prisma.ticketTag.upsert({
     *   create: {
     *     // ... data to create a TicketTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketTag we want to update
     *   }
     * })
     */
    upsert<T extends TicketTagUpsertArgs>(args: SelectSubset<T, TicketTagUpsertArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagCountArgs} args - Arguments to filter TicketTags to count.
     * @example
     * // Count the number of TicketTags
     * const count = await prisma.ticketTag.count({
     *   where: {
     *     // ... the filter for the TicketTags we want to count
     *   }
     * })
    **/
    count<T extends TicketTagCountArgs>(
      args?: Subset<T, TicketTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketTagAggregateArgs>(args: Subset<T, TicketTagAggregateArgs>): Prisma.PrismaPromise<GetTicketTagAggregateType<T>>

    /**
     * Group by TicketTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketTagGroupByArgs['orderBy'] }
        : { orderBy?: TicketTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketTag model
   */
  readonly fields: TicketTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tickets<T extends TicketTag$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, TicketTag$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketTag model
   */
  interface TicketTagFieldRefs {
    readonly id: FieldRef<"TicketTag", 'String'>
    readonly name: FieldRef<"TicketTag", 'String'>
    readonly createdAt: FieldRef<"TicketTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketTag findUnique
   */
  export type TicketTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where: TicketTagWhereUniqueInput
  }

  /**
   * TicketTag findUniqueOrThrow
   */
  export type TicketTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where: TicketTagWhereUniqueInput
  }

  /**
   * TicketTag findFirst
   */
  export type TicketTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTags.
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTags.
     */
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
  }

  /**
   * TicketTag findFirstOrThrow
   */
  export type TicketTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTags.
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTags.
     */
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
  }

  /**
   * TicketTag findMany
   */
  export type TicketTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTags to fetch.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketTags.
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
  }

  /**
   * TicketTag create
   */
  export type TicketTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketTag.
     */
    data: XOR<TicketTagCreateInput, TicketTagUncheckedCreateInput>
  }

  /**
   * TicketTag createMany
   */
  export type TicketTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketTags.
     */
    data: TicketTagCreateManyInput | TicketTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketTag createManyAndReturn
   */
  export type TicketTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * The data used to create many TicketTags.
     */
    data: TicketTagCreateManyInput | TicketTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketTag update
   */
  export type TicketTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketTag.
     */
    data: XOR<TicketTagUpdateInput, TicketTagUncheckedUpdateInput>
    /**
     * Choose, which TicketTag to update.
     */
    where: TicketTagWhereUniqueInput
  }

  /**
   * TicketTag updateMany
   */
  export type TicketTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketTags.
     */
    data: XOR<TicketTagUpdateManyMutationInput, TicketTagUncheckedUpdateManyInput>
    /**
     * Filter which TicketTags to update
     */
    where?: TicketTagWhereInput
    /**
     * Limit how many TicketTags to update.
     */
    limit?: number
  }

  /**
   * TicketTag updateManyAndReturn
   */
  export type TicketTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * The data used to update TicketTags.
     */
    data: XOR<TicketTagUpdateManyMutationInput, TicketTagUncheckedUpdateManyInput>
    /**
     * Filter which TicketTags to update
     */
    where?: TicketTagWhereInput
    /**
     * Limit how many TicketTags to update.
     */
    limit?: number
  }

  /**
   * TicketTag upsert
   */
  export type TicketTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketTag to update in case it exists.
     */
    where: TicketTagWhereUniqueInput
    /**
     * In case the TicketTag found by the `where` argument doesn't exist, create a new TicketTag with this data.
     */
    create: XOR<TicketTagCreateInput, TicketTagUncheckedCreateInput>
    /**
     * In case the TicketTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketTagUpdateInput, TicketTagUncheckedUpdateInput>
  }

  /**
   * TicketTag delete
   */
  export type TicketTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter which TicketTag to delete.
     */
    where: TicketTagWhereUniqueInput
  }

  /**
   * TicketTag deleteMany
   */
  export type TicketTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketTags to delete
     */
    where?: TicketTagWhereInput
    /**
     * Limit how many TicketTags to delete.
     */
    limit?: number
  }

  /**
   * TicketTag.tickets
   */
  export type TicketTag$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * TicketTag without action
   */
  export type TicketTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
  }


  /**
   * Model MessageAttachment
   */

  export type AggregateMessageAttachment = {
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  export type MessageAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type MessageAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type MessageAttachmentMinAggregateOutputType = {
    id: string | null
    filename: string | null
    fileSize: number | null
    mimeType: string | null
    url: string | null
    createdAt: Date | null
    messageId: string | null
  }

  export type MessageAttachmentMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    fileSize: number | null
    mimeType: string | null
    url: string | null
    createdAt: Date | null
    messageId: string | null
  }

  export type MessageAttachmentCountAggregateOutputType = {
    id: number
    filename: number
    fileSize: number
    mimeType: number
    url: number
    createdAt: number
    messageId: number
    _all: number
  }


  export type MessageAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type MessageAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type MessageAttachmentMinAggregateInputType = {
    id?: true
    filename?: true
    fileSize?: true
    mimeType?: true
    url?: true
    createdAt?: true
    messageId?: true
  }

  export type MessageAttachmentMaxAggregateInputType = {
    id?: true
    filename?: true
    fileSize?: true
    mimeType?: true
    url?: true
    createdAt?: true
    messageId?: true
  }

  export type MessageAttachmentCountAggregateInputType = {
    id?: true
    filename?: true
    fileSize?: true
    mimeType?: true
    url?: true
    createdAt?: true
    messageId?: true
    _all?: true
  }

  export type MessageAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachment to aggregate.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageAttachments
    **/
    _count?: true | MessageAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type GetMessageAttachmentAggregateType<T extends MessageAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageAttachment[P]>
      : GetScalarType<T[P], AggregateMessageAttachment[P]>
  }




  export type MessageAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithAggregationInput | MessageAttachmentOrderByWithAggregationInput[]
    by: MessageAttachmentScalarFieldEnum[] | MessageAttachmentScalarFieldEnum
    having?: MessageAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageAttachmentCountAggregateInputType | true
    _avg?: MessageAttachmentAvgAggregateInputType
    _sum?: MessageAttachmentSumAggregateInputType
    _min?: MessageAttachmentMinAggregateInputType
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type MessageAttachmentGroupByOutputType = {
    id: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt: Date
    messageId: string
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  type GetMessageAttachmentGroupByPayload<T extends MessageAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type MessageAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
    messageId?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
    messageId?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
    messageId?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectScalar = {
    id?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
    messageId?: boolean
  }

  export type MessageAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "fileSize" | "mimeType" | "url" | "createdAt" | "messageId", ExtArgs["result"]["messageAttachment"]>
  export type MessageAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $MessageAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageAttachment"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      fileSize: number
      mimeType: string
      url: string
      createdAt: Date
      messageId: string
    }, ExtArgs["result"]["messageAttachment"]>
    composites: {}
  }

  type MessageAttachmentGetPayload<S extends boolean | null | undefined | MessageAttachmentDefaultArgs> = $Result.GetResult<Prisma.$MessageAttachmentPayload, S>

  type MessageAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageAttachmentCountAggregateInputType | true
    }

  export interface MessageAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageAttachment'], meta: { name: 'MessageAttachment' } }
    /**
     * Find zero or one MessageAttachment that matches the filter.
     * @param {MessageAttachmentFindUniqueArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageAttachmentFindUniqueArgs>(args: SelectSubset<T, MessageAttachmentFindUniqueArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageAttachmentFindUniqueOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageAttachmentFindFirstArgs>(args?: SelectSubset<T, MessageAttachmentFindFirstArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany()
     * 
     * // Get first 10 MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageAttachmentFindManyArgs>(args?: SelectSubset<T, MessageAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageAttachment.
     * @param {MessageAttachmentCreateArgs} args - Arguments to create a MessageAttachment.
     * @example
     * // Create one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.create({
     *   data: {
     *     // ... data to create a MessageAttachment
     *   }
     * })
     * 
     */
    create<T extends MessageAttachmentCreateArgs>(args: SelectSubset<T, MessageAttachmentCreateArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageAttachments.
     * @param {MessageAttachmentCreateManyArgs} args - Arguments to create many MessageAttachments.
     * @example
     * // Create many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageAttachmentCreateManyArgs>(args?: SelectSubset<T, MessageAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageAttachments and returns the data saved in the database.
     * @param {MessageAttachmentCreateManyAndReturnArgs} args - Arguments to create many MessageAttachments.
     * @example
     * // Create many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageAttachments and only return the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageAttachment.
     * @param {MessageAttachmentDeleteArgs} args - Arguments to delete one MessageAttachment.
     * @example
     * // Delete one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.delete({
     *   where: {
     *     // ... filter to delete one MessageAttachment
     *   }
     * })
     * 
     */
    delete<T extends MessageAttachmentDeleteArgs>(args: SelectSubset<T, MessageAttachmentDeleteArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageAttachment.
     * @param {MessageAttachmentUpdateArgs} args - Arguments to update one MessageAttachment.
     * @example
     * // Update one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageAttachmentUpdateArgs>(args: SelectSubset<T, MessageAttachmentUpdateArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageAttachments.
     * @param {MessageAttachmentDeleteManyArgs} args - Arguments to filter MessageAttachments to delete.
     * @example
     * // Delete a few MessageAttachments
     * const { count } = await prisma.messageAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageAttachmentDeleteManyArgs>(args?: SelectSubset<T, MessageAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageAttachmentUpdateManyArgs>(args: SelectSubset<T, MessageAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAttachments and returns the data updated in the database.
     * @param {MessageAttachmentUpdateManyAndReturnArgs} args - Arguments to update many MessageAttachments.
     * @example
     * // Update many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageAttachments and only return the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageAttachment.
     * @param {MessageAttachmentUpsertArgs} args - Arguments to update or create a MessageAttachment.
     * @example
     * // Update or create a MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.upsert({
     *   create: {
     *     // ... data to create a MessageAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageAttachment we want to update
     *   }
     * })
     */
    upsert<T extends MessageAttachmentUpsertArgs>(args: SelectSubset<T, MessageAttachmentUpsertArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentCountArgs} args - Arguments to filter MessageAttachments to count.
     * @example
     * // Count the number of MessageAttachments
     * const count = await prisma.messageAttachment.count({
     *   where: {
     *     // ... the filter for the MessageAttachments we want to count
     *   }
     * })
    **/
    count<T extends MessageAttachmentCountArgs>(
      args?: Subset<T, MessageAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAttachmentAggregateArgs>(args: Subset<T, MessageAttachmentAggregateArgs>): Prisma.PrismaPromise<GetMessageAttachmentAggregateType<T>>

    /**
     * Group by MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: MessageAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageAttachment model
   */
  readonly fields: MessageAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageAttachment model
   */
  interface MessageAttachmentFieldRefs {
    readonly id: FieldRef<"MessageAttachment", 'String'>
    readonly filename: FieldRef<"MessageAttachment", 'String'>
    readonly fileSize: FieldRef<"MessageAttachment", 'Int'>
    readonly mimeType: FieldRef<"MessageAttachment", 'String'>
    readonly url: FieldRef<"MessageAttachment", 'String'>
    readonly createdAt: FieldRef<"MessageAttachment", 'DateTime'>
    readonly messageId: FieldRef<"MessageAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MessageAttachment findUnique
   */
  export type MessageAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment findUniqueOrThrow
   */
  export type MessageAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment findFirst
   */
  export type MessageAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment findFirstOrThrow
   */
  export type MessageAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment findMany
   */
  export type MessageAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachments to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment create
   */
  export type MessageAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageAttachment.
     */
    data: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
  }

  /**
   * MessageAttachment createMany
   */
  export type MessageAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageAttachments.
     */
    data: MessageAttachmentCreateManyInput | MessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageAttachment createManyAndReturn
   */
  export type MessageAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many MessageAttachments.
     */
    data: MessageAttachmentCreateManyInput | MessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAttachment update
   */
  export type MessageAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageAttachment.
     */
    data: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
    /**
     * Choose, which MessageAttachment to update.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment updateMany
   */
  export type MessageAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageAttachments.
     */
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAttachments to update
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to update.
     */
    limit?: number
  }

  /**
   * MessageAttachment updateManyAndReturn
   */
  export type MessageAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update MessageAttachments.
     */
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAttachments to update
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAttachment upsert
   */
  export type MessageAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageAttachment to update in case it exists.
     */
    where: MessageAttachmentWhereUniqueInput
    /**
     * In case the MessageAttachment found by the `where` argument doesn't exist, create a new MessageAttachment with this data.
     */
    create: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
    /**
     * In case the MessageAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
  }

  /**
   * MessageAttachment delete
   */
  export type MessageAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter which MessageAttachment to delete.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment deleteMany
   */
  export type MessageAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachments to delete
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to delete.
     */
    limit?: number
  }

  /**
   * MessageAttachment without action
   */
  export type MessageAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model ClientActivity
   */

  export type AggregateClientActivity = {
    _count: ClientActivityCountAggregateOutputType | null
    _min: ClientActivityMinAggregateOutputType | null
    _max: ClientActivityMaxAggregateOutputType | null
  }

  export type ClientActivityMinAggregateOutputType = {
    id: string | null
    type: string | null
    description: string | null
    status: $Enums.ActivityStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ClientActivityMaxAggregateOutputType = {
    id: string | null
    type: string | null
    description: string | null
    status: $Enums.ActivityStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ClientActivityCountAggregateOutputType = {
    id: number
    type: number
    description: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type ClientActivityMinAggregateInputType = {
    id?: true
    type?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ClientActivityMaxAggregateInputType = {
    id?: true
    type?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ClientActivityCountAggregateInputType = {
    id?: true
    type?: true
    description?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type ClientActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientActivity to aggregate.
     */
    where?: ClientActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientActivities to fetch.
     */
    orderBy?: ClientActivityOrderByWithRelationInput | ClientActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientActivities
    **/
    _count?: true | ClientActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientActivityMaxAggregateInputType
  }

  export type GetClientActivityAggregateType<T extends ClientActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateClientActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientActivity[P]>
      : GetScalarType<T[P], AggregateClientActivity[P]>
  }




  export type ClientActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientActivityWhereInput
    orderBy?: ClientActivityOrderByWithAggregationInput | ClientActivityOrderByWithAggregationInput[]
    by: ClientActivityScalarFieldEnum[] | ClientActivityScalarFieldEnum
    having?: ClientActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientActivityCountAggregateInputType | true
    _min?: ClientActivityMinAggregateInputType
    _max?: ClientActivityMaxAggregateInputType
  }

  export type ClientActivityGroupByOutputType = {
    id: string
    type: string
    description: string
    status: $Enums.ActivityStatus
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: ClientActivityCountAggregateOutputType | null
    _min: ClientActivityMinAggregateOutputType | null
    _max: ClientActivityMaxAggregateOutputType | null
  }

  type GetClientActivityGroupByPayload<T extends ClientActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ClientActivityGroupByOutputType[P]>
        }
      >
    >


  export type ClientActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientActivity"]>

  export type ClientActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientActivity"]>

  export type ClientActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientActivity"]>

  export type ClientActivitySelectScalar = {
    id?: boolean
    type?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type ClientActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "description" | "status" | "metadata" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["clientActivity"]>
  export type ClientActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientActivity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      description: string
      status: $Enums.ActivityStatus
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["clientActivity"]>
    composites: {}
  }

  type ClientActivityGetPayload<S extends boolean | null | undefined | ClientActivityDefaultArgs> = $Result.GetResult<Prisma.$ClientActivityPayload, S>

  type ClientActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientActivityCountAggregateInputType | true
    }

  export interface ClientActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientActivity'], meta: { name: 'ClientActivity' } }
    /**
     * Find zero or one ClientActivity that matches the filter.
     * @param {ClientActivityFindUniqueArgs} args - Arguments to find a ClientActivity
     * @example
     * // Get one ClientActivity
     * const clientActivity = await prisma.clientActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientActivityFindUniqueArgs>(args: SelectSubset<T, ClientActivityFindUniqueArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientActivityFindUniqueOrThrowArgs} args - Arguments to find a ClientActivity
     * @example
     * // Get one ClientActivity
     * const clientActivity = await prisma.clientActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityFindFirstArgs} args - Arguments to find a ClientActivity
     * @example
     * // Get one ClientActivity
     * const clientActivity = await prisma.clientActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientActivityFindFirstArgs>(args?: SelectSubset<T, ClientActivityFindFirstArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityFindFirstOrThrowArgs} args - Arguments to find a ClientActivity
     * @example
     * // Get one ClientActivity
     * const clientActivity = await prisma.clientActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientActivities
     * const clientActivities = await prisma.clientActivity.findMany()
     * 
     * // Get first 10 ClientActivities
     * const clientActivities = await prisma.clientActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientActivityWithIdOnly = await prisma.clientActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientActivityFindManyArgs>(args?: SelectSubset<T, ClientActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientActivity.
     * @param {ClientActivityCreateArgs} args - Arguments to create a ClientActivity.
     * @example
     * // Create one ClientActivity
     * const ClientActivity = await prisma.clientActivity.create({
     *   data: {
     *     // ... data to create a ClientActivity
     *   }
     * })
     * 
     */
    create<T extends ClientActivityCreateArgs>(args: SelectSubset<T, ClientActivityCreateArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientActivities.
     * @param {ClientActivityCreateManyArgs} args - Arguments to create many ClientActivities.
     * @example
     * // Create many ClientActivities
     * const clientActivity = await prisma.clientActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientActivityCreateManyArgs>(args?: SelectSubset<T, ClientActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientActivities and returns the data saved in the database.
     * @param {ClientActivityCreateManyAndReturnArgs} args - Arguments to create many ClientActivities.
     * @example
     * // Create many ClientActivities
     * const clientActivity = await prisma.clientActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientActivities and only return the `id`
     * const clientActivityWithIdOnly = await prisma.clientActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientActivity.
     * @param {ClientActivityDeleteArgs} args - Arguments to delete one ClientActivity.
     * @example
     * // Delete one ClientActivity
     * const ClientActivity = await prisma.clientActivity.delete({
     *   where: {
     *     // ... filter to delete one ClientActivity
     *   }
     * })
     * 
     */
    delete<T extends ClientActivityDeleteArgs>(args: SelectSubset<T, ClientActivityDeleteArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientActivity.
     * @param {ClientActivityUpdateArgs} args - Arguments to update one ClientActivity.
     * @example
     * // Update one ClientActivity
     * const clientActivity = await prisma.clientActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientActivityUpdateArgs>(args: SelectSubset<T, ClientActivityUpdateArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientActivities.
     * @param {ClientActivityDeleteManyArgs} args - Arguments to filter ClientActivities to delete.
     * @example
     * // Delete a few ClientActivities
     * const { count } = await prisma.clientActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientActivityDeleteManyArgs>(args?: SelectSubset<T, ClientActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientActivities
     * const clientActivity = await prisma.clientActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientActivityUpdateManyArgs>(args: SelectSubset<T, ClientActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientActivities and returns the data updated in the database.
     * @param {ClientActivityUpdateManyAndReturnArgs} args - Arguments to update many ClientActivities.
     * @example
     * // Update many ClientActivities
     * const clientActivity = await prisma.clientActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientActivities and only return the `id`
     * const clientActivityWithIdOnly = await prisma.clientActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientActivity.
     * @param {ClientActivityUpsertArgs} args - Arguments to update or create a ClientActivity.
     * @example
     * // Update or create a ClientActivity
     * const clientActivity = await prisma.clientActivity.upsert({
     *   create: {
     *     // ... data to create a ClientActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientActivity we want to update
     *   }
     * })
     */
    upsert<T extends ClientActivityUpsertArgs>(args: SelectSubset<T, ClientActivityUpsertArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityCountArgs} args - Arguments to filter ClientActivities to count.
     * @example
     * // Count the number of ClientActivities
     * const count = await prisma.clientActivity.count({
     *   where: {
     *     // ... the filter for the ClientActivities we want to count
     *   }
     * })
    **/
    count<T extends ClientActivityCountArgs>(
      args?: Subset<T, ClientActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientActivityAggregateArgs>(args: Subset<T, ClientActivityAggregateArgs>): Prisma.PrismaPromise<GetClientActivityAggregateType<T>>

    /**
     * Group by ClientActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientActivityGroupByArgs['orderBy'] }
        : { orderBy?: ClientActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientActivity model
   */
  readonly fields: ClientActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientActivity model
   */
  interface ClientActivityFieldRefs {
    readonly id: FieldRef<"ClientActivity", 'String'>
    readonly type: FieldRef<"ClientActivity", 'String'>
    readonly description: FieldRef<"ClientActivity", 'String'>
    readonly status: FieldRef<"ClientActivity", 'ActivityStatus'>
    readonly metadata: FieldRef<"ClientActivity", 'Json'>
    readonly createdAt: FieldRef<"ClientActivity", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientActivity", 'DateTime'>
    readonly userId: FieldRef<"ClientActivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientActivity findUnique
   */
  export type ClientActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter, which ClientActivity to fetch.
     */
    where: ClientActivityWhereUniqueInput
  }

  /**
   * ClientActivity findUniqueOrThrow
   */
  export type ClientActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter, which ClientActivity to fetch.
     */
    where: ClientActivityWhereUniqueInput
  }

  /**
   * ClientActivity findFirst
   */
  export type ClientActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter, which ClientActivity to fetch.
     */
    where?: ClientActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientActivities to fetch.
     */
    orderBy?: ClientActivityOrderByWithRelationInput | ClientActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientActivities.
     */
    cursor?: ClientActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientActivities.
     */
    distinct?: ClientActivityScalarFieldEnum | ClientActivityScalarFieldEnum[]
  }

  /**
   * ClientActivity findFirstOrThrow
   */
  export type ClientActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter, which ClientActivity to fetch.
     */
    where?: ClientActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientActivities to fetch.
     */
    orderBy?: ClientActivityOrderByWithRelationInput | ClientActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientActivities.
     */
    cursor?: ClientActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientActivities.
     */
    distinct?: ClientActivityScalarFieldEnum | ClientActivityScalarFieldEnum[]
  }

  /**
   * ClientActivity findMany
   */
  export type ClientActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter, which ClientActivities to fetch.
     */
    where?: ClientActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientActivities to fetch.
     */
    orderBy?: ClientActivityOrderByWithRelationInput | ClientActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientActivities.
     */
    cursor?: ClientActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientActivities.
     */
    skip?: number
    distinct?: ClientActivityScalarFieldEnum | ClientActivityScalarFieldEnum[]
  }

  /**
   * ClientActivity create
   */
  export type ClientActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientActivity.
     */
    data: XOR<ClientActivityCreateInput, ClientActivityUncheckedCreateInput>
  }

  /**
   * ClientActivity createMany
   */
  export type ClientActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientActivities.
     */
    data: ClientActivityCreateManyInput | ClientActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientActivity createManyAndReturn
   */
  export type ClientActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * The data used to create many ClientActivities.
     */
    data: ClientActivityCreateManyInput | ClientActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientActivity update
   */
  export type ClientActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientActivity.
     */
    data: XOR<ClientActivityUpdateInput, ClientActivityUncheckedUpdateInput>
    /**
     * Choose, which ClientActivity to update.
     */
    where: ClientActivityWhereUniqueInput
  }

  /**
   * ClientActivity updateMany
   */
  export type ClientActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientActivities.
     */
    data: XOR<ClientActivityUpdateManyMutationInput, ClientActivityUncheckedUpdateManyInput>
    /**
     * Filter which ClientActivities to update
     */
    where?: ClientActivityWhereInput
    /**
     * Limit how many ClientActivities to update.
     */
    limit?: number
  }

  /**
   * ClientActivity updateManyAndReturn
   */
  export type ClientActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * The data used to update ClientActivities.
     */
    data: XOR<ClientActivityUpdateManyMutationInput, ClientActivityUncheckedUpdateManyInput>
    /**
     * Filter which ClientActivities to update
     */
    where?: ClientActivityWhereInput
    /**
     * Limit how many ClientActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientActivity upsert
   */
  export type ClientActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientActivity to update in case it exists.
     */
    where: ClientActivityWhereUniqueInput
    /**
     * In case the ClientActivity found by the `where` argument doesn't exist, create a new ClientActivity with this data.
     */
    create: XOR<ClientActivityCreateInput, ClientActivityUncheckedCreateInput>
    /**
     * In case the ClientActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientActivityUpdateInput, ClientActivityUncheckedUpdateInput>
  }

  /**
   * ClientActivity delete
   */
  export type ClientActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter which ClientActivity to delete.
     */
    where: ClientActivityWhereUniqueInput
  }

  /**
   * ClientActivity deleteMany
   */
  export type ClientActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientActivities to delete
     */
    where?: ClientActivityWhereInput
    /**
     * Limit how many ClientActivities to delete.
     */
    limit?: number
  }

  /**
   * ClientActivity without action
   */
  export type ClientActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const ClientSatisfactionScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    feedback: 'feedback',
    createdAt: 'createdAt',
    userId: 'userId',
    accountRepId: 'accountRepId'
  };

  export type ClientSatisfactionScalarFieldEnum = (typeof ClientSatisfactionScalarFieldEnum)[keyof typeof ClientSatisfactionScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    isStarred: 'isStarred',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    gaAccountId: 'gaAccountId',
    gaPropertyId: 'gaPropertyId',
    userId: 'userId'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const GaAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gaAccountId: 'gaAccountId',
    gaAccountName: 'gaAccountName'
  };

  export type GaAccountScalarFieldEnum = (typeof GaAccountScalarFieldEnum)[keyof typeof GaAccountScalarFieldEnum]


  export const GaPropertyScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    gaPropertyName: 'gaPropertyName',
    gaAccountId: 'gaAccountId'
  };

  export type GaPropertyScalarFieldEnum = (typeof GaPropertyScalarFieldEnum)[keyof typeof GaPropertyScalarFieldEnum]


  export const GaImportRunScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    dateStart: 'dateStart',
    dateEnd: 'dateEnd',
    status: 'status',
    errorMessage: 'errorMessage',
    requestedByUserId: 'requestedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GaImportRunScalarFieldEnum = (typeof GaImportRunScalarFieldEnum)[keyof typeof GaImportRunScalarFieldEnum]


  export const GaKpiDailyScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    date: 'date',
    sessions: 'sessions',
    screenPageViewsPerSession: 'screenPageViewsPerSession',
    engagementRate: 'engagementRate',
    avgSessionDurationSec: 'avgSessionDurationSec',
    goalCompletions: 'goalCompletions',
    goalCompletionRate: 'goalCompletionRate',
    createdAt: 'createdAt'
  };

  export type GaKpiDailyScalarFieldEnum = (typeof GaKpiDailyScalarFieldEnum)[keyof typeof GaKpiDailyScalarFieldEnum]


  export const GaKpiMonthlyScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    month: 'month',
    sessions: 'sessions',
    screenPageViewsPerSession: 'screenPageViewsPerSession',
    engagementRate: 'engagementRate',
    avgSessionDurationSec: 'avgSessionDurationSec',
    goalCompletions: 'goalCompletions',
    goalCompletionRate: 'goalCompletionRate',
    createdAt: 'createdAt'
  };

  export type GaKpiMonthlyScalarFieldEnum = (typeof GaKpiMonthlyScalarFieldEnum)[keyof typeof GaKpiMonthlyScalarFieldEnum]


  export const GaChannelDailyScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    date: 'date',
    channelGroup: 'channelGroup',
    sessions: 'sessions',
    screenPageViewsPerSession: 'screenPageViewsPerSession',
    engagementRate: 'engagementRate',
    avgSessionDurationSec: 'avgSessionDurationSec',
    goalCompletions: 'goalCompletions',
    goalCompletionRate: 'goalCompletionRate',
    createdAt: 'createdAt'
  };

  export type GaChannelDailyScalarFieldEnum = (typeof GaChannelDailyScalarFieldEnum)[keyof typeof GaChannelDailyScalarFieldEnum]


  export const GaSourceDailyScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    date: 'date',
    trafficSource: 'trafficSource',
    sessions: 'sessions',
    screenPageViewsPerSession: 'screenPageViewsPerSession',
    engagementRate: 'engagementRate',
    avgSessionDurationSec: 'avgSessionDurationSec',
    goalCompletions: 'goalCompletions',
    goalCompletionRate: 'goalCompletionRate',
    createdAt: 'createdAt'
  };

  export type GaSourceDailyScalarFieldEnum = (typeof GaSourceDailyScalarFieldEnum)[keyof typeof GaSourceDailyScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    isRead: 'isRead',
    archived: 'archived',
    isThreadStart: 'isThreadStart',
    threadId: 'threadId',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    senderId: 'senderId',
    recipientId: 'recipientId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ParsedPieGraphDataScalarFieldEnum: {
    id: 'id',
    queryId: 'queryId',
    channel: 'channel',
    source: 'source',
    sessions: 'sessions',
    conversionRate: 'conversionRate',
    conversions: 'conversions',
    bounces: 'bounces',
    prevSessionsDiff: 'prevSessionsDiff',
    prevConversionRateDiff: 'prevConversionRateDiff',
    prevConversionsDiff: 'prevConversionsDiff',
    prevBouncesDiff: 'prevBouncesDiff',
    yearSessionsDiff: 'yearSessionsDiff',
    yearConversionRateDiff: 'yearConversionRateDiff',
    yearConversionsDiff: 'yearConversionsDiff',
    yearBouncesDiff: 'yearBouncesDiff',
    createdAt: 'createdAt'
  };

  export type ParsedPieGraphDataScalarFieldEnum = (typeof ParsedPieGraphDataScalarFieldEnum)[keyof typeof ParsedPieGraphDataScalarFieldEnum]


  export const ParsedQueryDataScalarFieldEnum: {
    id: 'id',
    queryId: 'queryId',
    date: 'date',
    channel: 'channel',
    source: 'source',
    sessions: 'sessions',
    conversionRate: 'conversionRate',
    conversions: 'conversions',
    bounces: 'bounces',
    createdAt: 'createdAt',
    engagedSessions: 'engagedSessions',
    bounceRate: 'bounceRate',
    newUsers: 'newUsers'
  };

  export type ParsedQueryDataScalarFieldEnum = (typeof ParsedQueryDataScalarFieldEnum)[keyof typeof ParsedQueryDataScalarFieldEnum]


  export const ParsedQuerySummaryScalarFieldEnum: {
    id: 'id',
    queryId: 'queryId',
    date: 'date',
    totalEngagedSessions: 'totalEngagedSessions',
    averageBounceRate: 'averageBounceRate',
    totalNewUsers: 'totalNewUsers',
    totalConversions: 'totalConversions',
    createdAt: 'createdAt'
  };

  export type ParsedQuerySummaryScalarFieldEnum = (typeof ParsedQuerySummaryScalarFieldEnum)[keyof typeof ParsedQuerySummaryScalarFieldEnum]


  export const QueryScalarFieldEnum: {
    id: 'id',
    content: 'content',
    response: 'response',
    status: 'status',
    rating: 'rating',
    metadata: 'metadata',
    lineGraphData: 'lineGraphData',
    pieGraphData: 'pieGraphData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    conversationId: 'conversationId'
  };

  export type QueryScalarFieldEnum = (typeof QueryScalarFieldEnum)[keyof typeof QueryScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    emailVerified: 'emailVerified',
    image: 'image',
    roleId: 'roleId',
    isActive: 'isActive',
    accountRepId: 'accountRepId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    emailNotifications: 'emailNotifications',
    theme: 'theme',
    apiCredits: 'apiCredits',
    apiCreditsLimit: 'apiCreditsLimit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedToId: 'assignedToId',
    clientId: 'clientId'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketAttachmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    createdAt: 'createdAt',
    ticketId: 'ticketId'
  };

  export type TicketAttachmentScalarFieldEnum = (typeof TicketAttachmentScalarFieldEnum)[keyof typeof TicketAttachmentScalarFieldEnum]


  export const TicketCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ticketId: 'ticketId',
    authorId: 'authorId'
  };

  export type TicketCommentScalarFieldEnum = (typeof TicketCommentScalarFieldEnum)[keyof typeof TicketCommentScalarFieldEnum]


  export const TicketTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type TicketTagScalarFieldEnum = (typeof TicketTagScalarFieldEnum)[keyof typeof TicketTagScalarFieldEnum]


  export const MessageAttachmentScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    url: 'url',
    createdAt: 'createdAt',
    messageId: 'messageId'
  };

  export type MessageAttachmentScalarFieldEnum = (typeof MessageAttachmentScalarFieldEnum)[keyof typeof MessageAttachmentScalarFieldEnum]


  export const ClientActivityScalarFieldEnum: {
    id: 'id',
    type: 'type',
    description: 'description',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type ClientActivityScalarFieldEnum = (typeof ClientActivityScalarFieldEnum)[keyof typeof ClientActivityScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ImportStatus'
   */
  export type EnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus'>
    


  /**
   * Reference to a field of type 'ImportStatus[]'
   */
  export type ListEnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'QueryStatus'
   */
  export type EnumQueryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryStatus'>
    


  /**
   * Reference to a field of type 'QueryStatus[]'
   */
  export type ListEnumQueryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'TicketPriority[]'
   */
  export type ListEnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority[]'>
    


  /**
   * Reference to a field of type 'ActivityStatus'
   */
  export type EnumActivityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityStatus'>
    


  /**
   * Reference to a field of type 'ActivityStatus[]'
   */
  export type ListEnumActivityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type ClientSatisfactionWhereInput = {
    AND?: ClientSatisfactionWhereInput | ClientSatisfactionWhereInput[]
    OR?: ClientSatisfactionWhereInput[]
    NOT?: ClientSatisfactionWhereInput | ClientSatisfactionWhereInput[]
    id?: StringFilter<"ClientSatisfaction"> | string
    rating?: FloatFilter<"ClientSatisfaction"> | number
    feedback?: StringNullableFilter<"ClientSatisfaction"> | string | null
    createdAt?: DateTimeFilter<"ClientSatisfaction"> | Date | string
    userId?: StringFilter<"ClientSatisfaction"> | string
    accountRepId?: StringFilter<"ClientSatisfaction"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    accountRep?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClientSatisfactionOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    accountRepId?: SortOrder
    user?: UserOrderByWithRelationInput
    accountRep?: UserOrderByWithRelationInput
  }

  export type ClientSatisfactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientSatisfactionWhereInput | ClientSatisfactionWhereInput[]
    OR?: ClientSatisfactionWhereInput[]
    NOT?: ClientSatisfactionWhereInput | ClientSatisfactionWhereInput[]
    rating?: FloatFilter<"ClientSatisfaction"> | number
    feedback?: StringNullableFilter<"ClientSatisfaction"> | string | null
    createdAt?: DateTimeFilter<"ClientSatisfaction"> | Date | string
    userId?: StringFilter<"ClientSatisfaction"> | string
    accountRepId?: StringFilter<"ClientSatisfaction"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    accountRep?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ClientSatisfactionOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    accountRepId?: SortOrder
    _count?: ClientSatisfactionCountOrderByAggregateInput
    _avg?: ClientSatisfactionAvgOrderByAggregateInput
    _max?: ClientSatisfactionMaxOrderByAggregateInput
    _min?: ClientSatisfactionMinOrderByAggregateInput
    _sum?: ClientSatisfactionSumOrderByAggregateInput
  }

  export type ClientSatisfactionScalarWhereWithAggregatesInput = {
    AND?: ClientSatisfactionScalarWhereWithAggregatesInput | ClientSatisfactionScalarWhereWithAggregatesInput[]
    OR?: ClientSatisfactionScalarWhereWithAggregatesInput[]
    NOT?: ClientSatisfactionScalarWhereWithAggregatesInput | ClientSatisfactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientSatisfaction"> | string
    rating?: FloatWithAggregatesFilter<"ClientSatisfaction"> | number
    feedback?: StringNullableWithAggregatesFilter<"ClientSatisfaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientSatisfaction"> | Date | string
    userId?: StringWithAggregatesFilter<"ClientSatisfaction"> | string
    accountRepId?: StringWithAggregatesFilter<"ClientSatisfaction"> | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    description?: StringNullableFilter<"Conversation"> | string | null
    isStarred?: BoolFilter<"Conversation"> | boolean
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    gaAccountId?: StringNullableFilter<"Conversation"> | string | null
    gaPropertyId?: StringNullableFilter<"Conversation"> | string | null
    userId?: StringFilter<"Conversation"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    queries?: QueryListRelationFilter
    gaAccount?: XOR<GaAccountNullableScalarRelationFilter, GaAccountWhereInput> | null
    gaProperty?: XOR<GaPropertyNullableScalarRelationFilter, GaPropertyWhereInput> | null
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isStarred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaAccountId?: SortOrderInput | SortOrder
    gaPropertyId?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    queries?: QueryOrderByRelationAggregateInput
    gaAccount?: GaAccountOrderByWithRelationInput
    gaProperty?: GaPropertyOrderByWithRelationInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    title?: StringFilter<"Conversation"> | string
    description?: StringNullableFilter<"Conversation"> | string | null
    isStarred?: BoolFilter<"Conversation"> | boolean
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    gaAccountId?: StringNullableFilter<"Conversation"> | string | null
    gaPropertyId?: StringNullableFilter<"Conversation"> | string | null
    userId?: StringFilter<"Conversation"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    queries?: QueryListRelationFilter
    gaAccount?: XOR<GaAccountNullableScalarRelationFilter, GaAccountWhereInput> | null
    gaProperty?: XOR<GaPropertyNullableScalarRelationFilter, GaPropertyWhereInput> | null
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isStarred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaAccountId?: SortOrderInput | SortOrder
    gaPropertyId?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    title?: StringWithAggregatesFilter<"Conversation"> | string
    description?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    isStarred?: BoolWithAggregatesFilter<"Conversation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    gaAccountId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    gaPropertyId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    userId?: StringWithAggregatesFilter<"Conversation"> | string
  }

  export type GaAccountWhereInput = {
    AND?: GaAccountWhereInput | GaAccountWhereInput[]
    OR?: GaAccountWhereInput[]
    NOT?: GaAccountWhereInput | GaAccountWhereInput[]
    id?: StringFilter<"GaAccount"> | string
    userId?: StringFilter<"GaAccount"> | string
    gaAccountId?: StringFilter<"GaAccount"> | string
    gaAccountName?: StringFilter<"GaAccount"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    gaProperties?: GaPropertyListRelationFilter
    conversations?: ConversationListRelationFilter
  }

  export type GaAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gaAccountId?: SortOrder
    gaAccountName?: SortOrder
    user?: UserOrderByWithRelationInput
    gaProperties?: GaPropertyOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
  }

  export type GaAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GaAccountWhereInput | GaAccountWhereInput[]
    OR?: GaAccountWhereInput[]
    NOT?: GaAccountWhereInput | GaAccountWhereInput[]
    userId?: StringFilter<"GaAccount"> | string
    gaAccountId?: StringFilter<"GaAccount"> | string
    gaAccountName?: StringFilter<"GaAccount"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    gaProperties?: GaPropertyListRelationFilter
    conversations?: ConversationListRelationFilter
  }, "id">

  export type GaAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gaAccountId?: SortOrder
    gaAccountName?: SortOrder
    _count?: GaAccountCountOrderByAggregateInput
    _max?: GaAccountMaxOrderByAggregateInput
    _min?: GaAccountMinOrderByAggregateInput
  }

  export type GaAccountScalarWhereWithAggregatesInput = {
    AND?: GaAccountScalarWhereWithAggregatesInput | GaAccountScalarWhereWithAggregatesInput[]
    OR?: GaAccountScalarWhereWithAggregatesInput[]
    NOT?: GaAccountScalarWhereWithAggregatesInput | GaAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaAccount"> | string
    userId?: StringWithAggregatesFilter<"GaAccount"> | string
    gaAccountId?: StringWithAggregatesFilter<"GaAccount"> | string
    gaAccountName?: StringWithAggregatesFilter<"GaAccount"> | string
  }

  export type GaPropertyWhereInput = {
    AND?: GaPropertyWhereInput | GaPropertyWhereInput[]
    OR?: GaPropertyWhereInput[]
    NOT?: GaPropertyWhereInput | GaPropertyWhereInput[]
    id?: StringFilter<"GaProperty"> | string
    gaPropertyId?: StringFilter<"GaProperty"> | string
    gaPropertyName?: StringFilter<"GaProperty"> | string
    gaAccountId?: StringFilter<"GaProperty"> | string
    gaAccount?: XOR<GaAccountScalarRelationFilter, GaAccountWhereInput>
    conversations?: ConversationListRelationFilter
    imports?: GaImportRunListRelationFilter
    kpiDaily?: GaKpiDailyListRelationFilter
    kpiMonthly?: GaKpiMonthlyListRelationFilter
    channelDaily?: GaChannelDailyListRelationFilter
    sourceDaily?: GaSourceDailyListRelationFilter
  }

  export type GaPropertyOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    gaPropertyName?: SortOrder
    gaAccountId?: SortOrder
    gaAccount?: GaAccountOrderByWithRelationInput
    conversations?: ConversationOrderByRelationAggregateInput
    imports?: GaImportRunOrderByRelationAggregateInput
    kpiDaily?: GaKpiDailyOrderByRelationAggregateInput
    kpiMonthly?: GaKpiMonthlyOrderByRelationAggregateInput
    channelDaily?: GaChannelDailyOrderByRelationAggregateInput
    sourceDaily?: GaSourceDailyOrderByRelationAggregateInput
  }

  export type GaPropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GaPropertyWhereInput | GaPropertyWhereInput[]
    OR?: GaPropertyWhereInput[]
    NOT?: GaPropertyWhereInput | GaPropertyWhereInput[]
    gaPropertyId?: StringFilter<"GaProperty"> | string
    gaPropertyName?: StringFilter<"GaProperty"> | string
    gaAccountId?: StringFilter<"GaProperty"> | string
    gaAccount?: XOR<GaAccountScalarRelationFilter, GaAccountWhereInput>
    conversations?: ConversationListRelationFilter
    imports?: GaImportRunListRelationFilter
    kpiDaily?: GaKpiDailyListRelationFilter
    kpiMonthly?: GaKpiMonthlyListRelationFilter
    channelDaily?: GaChannelDailyListRelationFilter
    sourceDaily?: GaSourceDailyListRelationFilter
  }, "id">

  export type GaPropertyOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    gaPropertyName?: SortOrder
    gaAccountId?: SortOrder
    _count?: GaPropertyCountOrderByAggregateInput
    _max?: GaPropertyMaxOrderByAggregateInput
    _min?: GaPropertyMinOrderByAggregateInput
  }

  export type GaPropertyScalarWhereWithAggregatesInput = {
    AND?: GaPropertyScalarWhereWithAggregatesInput | GaPropertyScalarWhereWithAggregatesInput[]
    OR?: GaPropertyScalarWhereWithAggregatesInput[]
    NOT?: GaPropertyScalarWhereWithAggregatesInput | GaPropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaProperty"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaProperty"> | string
    gaPropertyName?: StringWithAggregatesFilter<"GaProperty"> | string
    gaAccountId?: StringWithAggregatesFilter<"GaProperty"> | string
  }

  export type GaImportRunWhereInput = {
    AND?: GaImportRunWhereInput | GaImportRunWhereInput[]
    OR?: GaImportRunWhereInput[]
    NOT?: GaImportRunWhereInput | GaImportRunWhereInput[]
    id?: StringFilter<"GaImportRun"> | string
    gaPropertyId?: StringFilter<"GaImportRun"> | string
    dateStart?: DateTimeFilter<"GaImportRun"> | Date | string
    dateEnd?: DateTimeFilter<"GaImportRun"> | Date | string
    status?: EnumImportStatusFilter<"GaImportRun"> | $Enums.ImportStatus
    errorMessage?: StringNullableFilter<"GaImportRun"> | string | null
    requestedByUserId?: StringFilter<"GaImportRun"> | string
    createdAt?: DateTimeFilter<"GaImportRun"> | Date | string
    updatedAt?: DateTimeFilter<"GaImportRun"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
    requestedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GaImportRunOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    requestedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaProperty?: GaPropertyOrderByWithRelationInput
    requestedBy?: UserOrderByWithRelationInput
  }

  export type GaImportRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GaImportRunWhereInput | GaImportRunWhereInput[]
    OR?: GaImportRunWhereInput[]
    NOT?: GaImportRunWhereInput | GaImportRunWhereInput[]
    gaPropertyId?: StringFilter<"GaImportRun"> | string
    dateStart?: DateTimeFilter<"GaImportRun"> | Date | string
    dateEnd?: DateTimeFilter<"GaImportRun"> | Date | string
    status?: EnumImportStatusFilter<"GaImportRun"> | $Enums.ImportStatus
    errorMessage?: StringNullableFilter<"GaImportRun"> | string | null
    requestedByUserId?: StringFilter<"GaImportRun"> | string
    createdAt?: DateTimeFilter<"GaImportRun"> | Date | string
    updatedAt?: DateTimeFilter<"GaImportRun"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
    requestedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GaImportRunOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    requestedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GaImportRunCountOrderByAggregateInput
    _max?: GaImportRunMaxOrderByAggregateInput
    _min?: GaImportRunMinOrderByAggregateInput
  }

  export type GaImportRunScalarWhereWithAggregatesInput = {
    AND?: GaImportRunScalarWhereWithAggregatesInput | GaImportRunScalarWhereWithAggregatesInput[]
    OR?: GaImportRunScalarWhereWithAggregatesInput[]
    NOT?: GaImportRunScalarWhereWithAggregatesInput | GaImportRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaImportRun"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaImportRun"> | string
    dateStart?: DateTimeWithAggregatesFilter<"GaImportRun"> | Date | string
    dateEnd?: DateTimeWithAggregatesFilter<"GaImportRun"> | Date | string
    status?: EnumImportStatusWithAggregatesFilter<"GaImportRun"> | $Enums.ImportStatus
    errorMessage?: StringNullableWithAggregatesFilter<"GaImportRun"> | string | null
    requestedByUserId?: StringWithAggregatesFilter<"GaImportRun"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GaImportRun"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GaImportRun"> | Date | string
  }

  export type GaKpiDailyWhereInput = {
    AND?: GaKpiDailyWhereInput | GaKpiDailyWhereInput[]
    OR?: GaKpiDailyWhereInput[]
    NOT?: GaKpiDailyWhereInput | GaKpiDailyWhereInput[]
    id?: StringFilter<"GaKpiDaily"> | string
    gaPropertyId?: StringFilter<"GaKpiDaily"> | string
    date?: DateTimeFilter<"GaKpiDaily"> | Date | string
    sessions?: IntFilter<"GaKpiDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiDaily"> | number
    engagementRate?: FloatFilter<"GaKpiDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiDaily"> | number
    goalCompletions?: IntFilter<"GaKpiDaily"> | number
    goalCompletionRate?: FloatFilter<"GaKpiDaily"> | number
    createdAt?: DateTimeFilter<"GaKpiDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }

  export type GaKpiDailyOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    gaProperty?: GaPropertyOrderByWithRelationInput
  }

  export type GaKpiDailyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gaPropertyId_date?: GaKpiDailyGaPropertyIdDateCompoundUniqueInput
    AND?: GaKpiDailyWhereInput | GaKpiDailyWhereInput[]
    OR?: GaKpiDailyWhereInput[]
    NOT?: GaKpiDailyWhereInput | GaKpiDailyWhereInput[]
    gaPropertyId?: StringFilter<"GaKpiDaily"> | string
    date?: DateTimeFilter<"GaKpiDaily"> | Date | string
    sessions?: IntFilter<"GaKpiDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiDaily"> | number
    engagementRate?: FloatFilter<"GaKpiDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiDaily"> | number
    goalCompletions?: IntFilter<"GaKpiDaily"> | number
    goalCompletionRate?: FloatFilter<"GaKpiDaily"> | number
    createdAt?: DateTimeFilter<"GaKpiDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }, "id" | "gaPropertyId_date">

  export type GaKpiDailyOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    _count?: GaKpiDailyCountOrderByAggregateInput
    _avg?: GaKpiDailyAvgOrderByAggregateInput
    _max?: GaKpiDailyMaxOrderByAggregateInput
    _min?: GaKpiDailyMinOrderByAggregateInput
    _sum?: GaKpiDailySumOrderByAggregateInput
  }

  export type GaKpiDailyScalarWhereWithAggregatesInput = {
    AND?: GaKpiDailyScalarWhereWithAggregatesInput | GaKpiDailyScalarWhereWithAggregatesInput[]
    OR?: GaKpiDailyScalarWhereWithAggregatesInput[]
    NOT?: GaKpiDailyScalarWhereWithAggregatesInput | GaKpiDailyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaKpiDaily"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaKpiDaily"> | string
    date?: DateTimeWithAggregatesFilter<"GaKpiDaily"> | Date | string
    sessions?: IntWithAggregatesFilter<"GaKpiDaily"> | number
    screenPageViewsPerSession?: FloatWithAggregatesFilter<"GaKpiDaily"> | number
    engagementRate?: FloatWithAggregatesFilter<"GaKpiDaily"> | number
    avgSessionDurationSec?: IntWithAggregatesFilter<"GaKpiDaily"> | number
    goalCompletions?: IntWithAggregatesFilter<"GaKpiDaily"> | number
    goalCompletionRate?: FloatWithAggregatesFilter<"GaKpiDaily"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GaKpiDaily"> | Date | string
  }

  export type GaKpiMonthlyWhereInput = {
    AND?: GaKpiMonthlyWhereInput | GaKpiMonthlyWhereInput[]
    OR?: GaKpiMonthlyWhereInput[]
    NOT?: GaKpiMonthlyWhereInput | GaKpiMonthlyWhereInput[]
    id?: StringFilter<"GaKpiMonthly"> | string
    gaPropertyId?: StringFilter<"GaKpiMonthly"> | string
    month?: IntFilter<"GaKpiMonthly"> | number
    sessions?: IntFilter<"GaKpiMonthly"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiMonthly"> | number
    engagementRate?: FloatFilter<"GaKpiMonthly"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiMonthly"> | number
    goalCompletions?: IntFilter<"GaKpiMonthly"> | number
    goalCompletionRate?: FloatFilter<"GaKpiMonthly"> | number
    createdAt?: DateTimeFilter<"GaKpiMonthly"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }

  export type GaKpiMonthlyOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    gaProperty?: GaPropertyOrderByWithRelationInput
  }

  export type GaKpiMonthlyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gaPropertyId_month?: GaKpiMonthlyGaPropertyIdMonthCompoundUniqueInput
    AND?: GaKpiMonthlyWhereInput | GaKpiMonthlyWhereInput[]
    OR?: GaKpiMonthlyWhereInput[]
    NOT?: GaKpiMonthlyWhereInput | GaKpiMonthlyWhereInput[]
    gaPropertyId?: StringFilter<"GaKpiMonthly"> | string
    month?: IntFilter<"GaKpiMonthly"> | number
    sessions?: IntFilter<"GaKpiMonthly"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiMonthly"> | number
    engagementRate?: FloatFilter<"GaKpiMonthly"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiMonthly"> | number
    goalCompletions?: IntFilter<"GaKpiMonthly"> | number
    goalCompletionRate?: FloatFilter<"GaKpiMonthly"> | number
    createdAt?: DateTimeFilter<"GaKpiMonthly"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }, "id" | "gaPropertyId_month">

  export type GaKpiMonthlyOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    _count?: GaKpiMonthlyCountOrderByAggregateInput
    _avg?: GaKpiMonthlyAvgOrderByAggregateInput
    _max?: GaKpiMonthlyMaxOrderByAggregateInput
    _min?: GaKpiMonthlyMinOrderByAggregateInput
    _sum?: GaKpiMonthlySumOrderByAggregateInput
  }

  export type GaKpiMonthlyScalarWhereWithAggregatesInput = {
    AND?: GaKpiMonthlyScalarWhereWithAggregatesInput | GaKpiMonthlyScalarWhereWithAggregatesInput[]
    OR?: GaKpiMonthlyScalarWhereWithAggregatesInput[]
    NOT?: GaKpiMonthlyScalarWhereWithAggregatesInput | GaKpiMonthlyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaKpiMonthly"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaKpiMonthly"> | string
    month?: IntWithAggregatesFilter<"GaKpiMonthly"> | number
    sessions?: IntWithAggregatesFilter<"GaKpiMonthly"> | number
    screenPageViewsPerSession?: FloatWithAggregatesFilter<"GaKpiMonthly"> | number
    engagementRate?: FloatWithAggregatesFilter<"GaKpiMonthly"> | number
    avgSessionDurationSec?: IntWithAggregatesFilter<"GaKpiMonthly"> | number
    goalCompletions?: IntWithAggregatesFilter<"GaKpiMonthly"> | number
    goalCompletionRate?: FloatWithAggregatesFilter<"GaKpiMonthly"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GaKpiMonthly"> | Date | string
  }

  export type GaChannelDailyWhereInput = {
    AND?: GaChannelDailyWhereInput | GaChannelDailyWhereInput[]
    OR?: GaChannelDailyWhereInput[]
    NOT?: GaChannelDailyWhereInput | GaChannelDailyWhereInput[]
    id?: StringFilter<"GaChannelDaily"> | string
    gaPropertyId?: StringFilter<"GaChannelDaily"> | string
    date?: DateTimeFilter<"GaChannelDaily"> | Date | string
    channelGroup?: StringFilter<"GaChannelDaily"> | string
    sessions?: IntFilter<"GaChannelDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaChannelDaily"> | number
    engagementRate?: FloatFilter<"GaChannelDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaChannelDaily"> | number
    goalCompletions?: IntFilter<"GaChannelDaily"> | number
    goalCompletionRate?: FloatFilter<"GaChannelDaily"> | number
    createdAt?: DateTimeFilter<"GaChannelDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }

  export type GaChannelDailyOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    channelGroup?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    gaProperty?: GaPropertyOrderByWithRelationInput
  }

  export type GaChannelDailyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gaPropertyId_date_channelGroup?: GaChannelDailyGaPropertyIdDateChannelGroupCompoundUniqueInput
    AND?: GaChannelDailyWhereInput | GaChannelDailyWhereInput[]
    OR?: GaChannelDailyWhereInput[]
    NOT?: GaChannelDailyWhereInput | GaChannelDailyWhereInput[]
    gaPropertyId?: StringFilter<"GaChannelDaily"> | string
    date?: DateTimeFilter<"GaChannelDaily"> | Date | string
    channelGroup?: StringFilter<"GaChannelDaily"> | string
    sessions?: IntFilter<"GaChannelDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaChannelDaily"> | number
    engagementRate?: FloatFilter<"GaChannelDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaChannelDaily"> | number
    goalCompletions?: IntFilter<"GaChannelDaily"> | number
    goalCompletionRate?: FloatFilter<"GaChannelDaily"> | number
    createdAt?: DateTimeFilter<"GaChannelDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }, "id" | "gaPropertyId_date_channelGroup">

  export type GaChannelDailyOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    channelGroup?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    _count?: GaChannelDailyCountOrderByAggregateInput
    _avg?: GaChannelDailyAvgOrderByAggregateInput
    _max?: GaChannelDailyMaxOrderByAggregateInput
    _min?: GaChannelDailyMinOrderByAggregateInput
    _sum?: GaChannelDailySumOrderByAggregateInput
  }

  export type GaChannelDailyScalarWhereWithAggregatesInput = {
    AND?: GaChannelDailyScalarWhereWithAggregatesInput | GaChannelDailyScalarWhereWithAggregatesInput[]
    OR?: GaChannelDailyScalarWhereWithAggregatesInput[]
    NOT?: GaChannelDailyScalarWhereWithAggregatesInput | GaChannelDailyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaChannelDaily"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaChannelDaily"> | string
    date?: DateTimeWithAggregatesFilter<"GaChannelDaily"> | Date | string
    channelGroup?: StringWithAggregatesFilter<"GaChannelDaily"> | string
    sessions?: IntWithAggregatesFilter<"GaChannelDaily"> | number
    screenPageViewsPerSession?: FloatWithAggregatesFilter<"GaChannelDaily"> | number
    engagementRate?: FloatWithAggregatesFilter<"GaChannelDaily"> | number
    avgSessionDurationSec?: IntWithAggregatesFilter<"GaChannelDaily"> | number
    goalCompletions?: IntWithAggregatesFilter<"GaChannelDaily"> | number
    goalCompletionRate?: FloatWithAggregatesFilter<"GaChannelDaily"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GaChannelDaily"> | Date | string
  }

  export type GaSourceDailyWhereInput = {
    AND?: GaSourceDailyWhereInput | GaSourceDailyWhereInput[]
    OR?: GaSourceDailyWhereInput[]
    NOT?: GaSourceDailyWhereInput | GaSourceDailyWhereInput[]
    id?: StringFilter<"GaSourceDaily"> | string
    gaPropertyId?: StringFilter<"GaSourceDaily"> | string
    date?: DateTimeFilter<"GaSourceDaily"> | Date | string
    trafficSource?: StringFilter<"GaSourceDaily"> | string
    sessions?: IntFilter<"GaSourceDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaSourceDaily"> | number
    engagementRate?: FloatFilter<"GaSourceDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaSourceDaily"> | number
    goalCompletions?: IntFilter<"GaSourceDaily"> | number
    goalCompletionRate?: FloatFilter<"GaSourceDaily"> | number
    createdAt?: DateTimeFilter<"GaSourceDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }

  export type GaSourceDailyOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    trafficSource?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    gaProperty?: GaPropertyOrderByWithRelationInput
  }

  export type GaSourceDailyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gaPropertyId_date_trafficSource?: GaSourceDailyGaPropertyIdDateTrafficSourceCompoundUniqueInput
    AND?: GaSourceDailyWhereInput | GaSourceDailyWhereInput[]
    OR?: GaSourceDailyWhereInput[]
    NOT?: GaSourceDailyWhereInput | GaSourceDailyWhereInput[]
    gaPropertyId?: StringFilter<"GaSourceDaily"> | string
    date?: DateTimeFilter<"GaSourceDaily"> | Date | string
    trafficSource?: StringFilter<"GaSourceDaily"> | string
    sessions?: IntFilter<"GaSourceDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaSourceDaily"> | number
    engagementRate?: FloatFilter<"GaSourceDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaSourceDaily"> | number
    goalCompletions?: IntFilter<"GaSourceDaily"> | number
    goalCompletionRate?: FloatFilter<"GaSourceDaily"> | number
    createdAt?: DateTimeFilter<"GaSourceDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }, "id" | "gaPropertyId_date_trafficSource">

  export type GaSourceDailyOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    trafficSource?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    _count?: GaSourceDailyCountOrderByAggregateInput
    _avg?: GaSourceDailyAvgOrderByAggregateInput
    _max?: GaSourceDailyMaxOrderByAggregateInput
    _min?: GaSourceDailyMinOrderByAggregateInput
    _sum?: GaSourceDailySumOrderByAggregateInput
  }

  export type GaSourceDailyScalarWhereWithAggregatesInput = {
    AND?: GaSourceDailyScalarWhereWithAggregatesInput | GaSourceDailyScalarWhereWithAggregatesInput[]
    OR?: GaSourceDailyScalarWhereWithAggregatesInput[]
    NOT?: GaSourceDailyScalarWhereWithAggregatesInput | GaSourceDailyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaSourceDaily"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaSourceDaily"> | string
    date?: DateTimeWithAggregatesFilter<"GaSourceDaily"> | Date | string
    trafficSource?: StringWithAggregatesFilter<"GaSourceDaily"> | string
    sessions?: IntWithAggregatesFilter<"GaSourceDaily"> | number
    screenPageViewsPerSession?: FloatWithAggregatesFilter<"GaSourceDaily"> | number
    engagementRate?: FloatWithAggregatesFilter<"GaSourceDaily"> | number
    avgSessionDurationSec?: IntWithAggregatesFilter<"GaSourceDaily"> | number
    goalCompletions?: IntWithAggregatesFilter<"GaSourceDaily"> | number
    goalCompletionRate?: FloatWithAggregatesFilter<"GaSourceDaily"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GaSourceDaily"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    archived?: BoolFilter<"Message"> | boolean
    isThreadStart?: BoolFilter<"Message"> | boolean
    threadId?: StringNullableFilter<"Message"> | string | null
    parentId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    replies?: MessageListRelationFilter
    attachments?: MessageAttachmentListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    archived?: SortOrder
    isThreadStart?: SortOrder
    threadId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    sender?: UserOrderByWithRelationInput
    recipient?: UserOrderByWithRelationInput
    parent?: MessageOrderByWithRelationInput
    replies?: MessageOrderByRelationAggregateInput
    attachments?: MessageAttachmentOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    archived?: BoolFilter<"Message"> | boolean
    isThreadStart?: BoolFilter<"Message"> | boolean
    threadId?: StringNullableFilter<"Message"> | string | null
    parentId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    replies?: MessageListRelationFilter
    attachments?: MessageAttachmentListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    archived?: SortOrder
    isThreadStart?: SortOrder
    threadId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    archived?: BoolWithAggregatesFilter<"Message"> | boolean
    isThreadStart?: BoolWithAggregatesFilter<"Message"> | boolean
    threadId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    recipientId?: StringWithAggregatesFilter<"Message"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type ParsedPieGraphDataWhereInput = {
    AND?: ParsedPieGraphDataWhereInput | ParsedPieGraphDataWhereInput[]
    OR?: ParsedPieGraphDataWhereInput[]
    NOT?: ParsedPieGraphDataWhereInput | ParsedPieGraphDataWhereInput[]
    id?: StringFilter<"ParsedPieGraphData"> | string
    queryId?: StringFilter<"ParsedPieGraphData"> | string
    channel?: StringFilter<"ParsedPieGraphData"> | string
    source?: StringFilter<"ParsedPieGraphData"> | string
    sessions?: IntFilter<"ParsedPieGraphData"> | number
    conversionRate?: FloatFilter<"ParsedPieGraphData"> | number
    conversions?: IntFilter<"ParsedPieGraphData"> | number
    bounces?: IntFilter<"ParsedPieGraphData"> | number
    prevSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    createdAt?: DateTimeFilter<"ParsedPieGraphData"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }

  export type ParsedPieGraphDataOrderByWithRelationInput = {
    id?: SortOrder
    queryId?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
    createdAt?: SortOrder
    query?: QueryOrderByWithRelationInput
  }

  export type ParsedPieGraphDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParsedPieGraphDataWhereInput | ParsedPieGraphDataWhereInput[]
    OR?: ParsedPieGraphDataWhereInput[]
    NOT?: ParsedPieGraphDataWhereInput | ParsedPieGraphDataWhereInput[]
    queryId?: StringFilter<"ParsedPieGraphData"> | string
    channel?: StringFilter<"ParsedPieGraphData"> | string
    source?: StringFilter<"ParsedPieGraphData"> | string
    sessions?: IntFilter<"ParsedPieGraphData"> | number
    conversionRate?: FloatFilter<"ParsedPieGraphData"> | number
    conversions?: IntFilter<"ParsedPieGraphData"> | number
    bounces?: IntFilter<"ParsedPieGraphData"> | number
    prevSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    createdAt?: DateTimeFilter<"ParsedPieGraphData"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }, "id">

  export type ParsedPieGraphDataOrderByWithAggregationInput = {
    id?: SortOrder
    queryId?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
    createdAt?: SortOrder
    _count?: ParsedPieGraphDataCountOrderByAggregateInput
    _avg?: ParsedPieGraphDataAvgOrderByAggregateInput
    _max?: ParsedPieGraphDataMaxOrderByAggregateInput
    _min?: ParsedPieGraphDataMinOrderByAggregateInput
    _sum?: ParsedPieGraphDataSumOrderByAggregateInput
  }

  export type ParsedPieGraphDataScalarWhereWithAggregatesInput = {
    AND?: ParsedPieGraphDataScalarWhereWithAggregatesInput | ParsedPieGraphDataScalarWhereWithAggregatesInput[]
    OR?: ParsedPieGraphDataScalarWhereWithAggregatesInput[]
    NOT?: ParsedPieGraphDataScalarWhereWithAggregatesInput | ParsedPieGraphDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParsedPieGraphData"> | string
    queryId?: StringWithAggregatesFilter<"ParsedPieGraphData"> | string
    channel?: StringWithAggregatesFilter<"ParsedPieGraphData"> | string
    source?: StringWithAggregatesFilter<"ParsedPieGraphData"> | string
    sessions?: IntWithAggregatesFilter<"ParsedPieGraphData"> | number
    conversionRate?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    conversions?: IntWithAggregatesFilter<"ParsedPieGraphData"> | number
    bounces?: IntWithAggregatesFilter<"ParsedPieGraphData"> | number
    prevSessionsDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    prevConversionRateDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    prevConversionsDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    prevBouncesDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    yearSessionsDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    yearConversionRateDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    yearConversionsDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    yearBouncesDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ParsedPieGraphData"> | Date | string
  }

  export type ParsedQueryDataWhereInput = {
    AND?: ParsedQueryDataWhereInput | ParsedQueryDataWhereInput[]
    OR?: ParsedQueryDataWhereInput[]
    NOT?: ParsedQueryDataWhereInput | ParsedQueryDataWhereInput[]
    id?: StringFilter<"ParsedQueryData"> | string
    queryId?: StringFilter<"ParsedQueryData"> | string
    date?: DateTimeFilter<"ParsedQueryData"> | Date | string
    channel?: StringFilter<"ParsedQueryData"> | string
    source?: StringFilter<"ParsedQueryData"> | string
    sessions?: IntFilter<"ParsedQueryData"> | number
    conversionRate?: FloatFilter<"ParsedQueryData"> | number
    conversions?: IntFilter<"ParsedQueryData"> | number
    bounces?: IntFilter<"ParsedQueryData"> | number
    createdAt?: DateTimeFilter<"ParsedQueryData"> | Date | string
    engagedSessions?: IntNullableFilter<"ParsedQueryData"> | number | null
    bounceRate?: FloatNullableFilter<"ParsedQueryData"> | number | null
    newUsers?: IntNullableFilter<"ParsedQueryData"> | number | null
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }

  export type ParsedQueryDataOrderByWithRelationInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    createdAt?: SortOrder
    engagedSessions?: SortOrderInput | SortOrder
    bounceRate?: SortOrderInput | SortOrder
    newUsers?: SortOrderInput | SortOrder
    query?: QueryOrderByWithRelationInput
  }

  export type ParsedQueryDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParsedQueryDataWhereInput | ParsedQueryDataWhereInput[]
    OR?: ParsedQueryDataWhereInput[]
    NOT?: ParsedQueryDataWhereInput | ParsedQueryDataWhereInput[]
    queryId?: StringFilter<"ParsedQueryData"> | string
    date?: DateTimeFilter<"ParsedQueryData"> | Date | string
    channel?: StringFilter<"ParsedQueryData"> | string
    source?: StringFilter<"ParsedQueryData"> | string
    sessions?: IntFilter<"ParsedQueryData"> | number
    conversionRate?: FloatFilter<"ParsedQueryData"> | number
    conversions?: IntFilter<"ParsedQueryData"> | number
    bounces?: IntFilter<"ParsedQueryData"> | number
    createdAt?: DateTimeFilter<"ParsedQueryData"> | Date | string
    engagedSessions?: IntNullableFilter<"ParsedQueryData"> | number | null
    bounceRate?: FloatNullableFilter<"ParsedQueryData"> | number | null
    newUsers?: IntNullableFilter<"ParsedQueryData"> | number | null
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }, "id">

  export type ParsedQueryDataOrderByWithAggregationInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    createdAt?: SortOrder
    engagedSessions?: SortOrderInput | SortOrder
    bounceRate?: SortOrderInput | SortOrder
    newUsers?: SortOrderInput | SortOrder
    _count?: ParsedQueryDataCountOrderByAggregateInput
    _avg?: ParsedQueryDataAvgOrderByAggregateInput
    _max?: ParsedQueryDataMaxOrderByAggregateInput
    _min?: ParsedQueryDataMinOrderByAggregateInput
    _sum?: ParsedQueryDataSumOrderByAggregateInput
  }

  export type ParsedQueryDataScalarWhereWithAggregatesInput = {
    AND?: ParsedQueryDataScalarWhereWithAggregatesInput | ParsedQueryDataScalarWhereWithAggregatesInput[]
    OR?: ParsedQueryDataScalarWhereWithAggregatesInput[]
    NOT?: ParsedQueryDataScalarWhereWithAggregatesInput | ParsedQueryDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParsedQueryData"> | string
    queryId?: StringWithAggregatesFilter<"ParsedQueryData"> | string
    date?: DateTimeWithAggregatesFilter<"ParsedQueryData"> | Date | string
    channel?: StringWithAggregatesFilter<"ParsedQueryData"> | string
    source?: StringWithAggregatesFilter<"ParsedQueryData"> | string
    sessions?: IntWithAggregatesFilter<"ParsedQueryData"> | number
    conversionRate?: FloatWithAggregatesFilter<"ParsedQueryData"> | number
    conversions?: IntWithAggregatesFilter<"ParsedQueryData"> | number
    bounces?: IntWithAggregatesFilter<"ParsedQueryData"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ParsedQueryData"> | Date | string
    engagedSessions?: IntNullableWithAggregatesFilter<"ParsedQueryData"> | number | null
    bounceRate?: FloatNullableWithAggregatesFilter<"ParsedQueryData"> | number | null
    newUsers?: IntNullableWithAggregatesFilter<"ParsedQueryData"> | number | null
  }

  export type ParsedQuerySummaryWhereInput = {
    AND?: ParsedQuerySummaryWhereInput | ParsedQuerySummaryWhereInput[]
    OR?: ParsedQuerySummaryWhereInput[]
    NOT?: ParsedQuerySummaryWhereInput | ParsedQuerySummaryWhereInput[]
    id?: StringFilter<"ParsedQuerySummary"> | string
    queryId?: StringFilter<"ParsedQuerySummary"> | string
    date?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
    totalEngagedSessions?: IntFilter<"ParsedQuerySummary"> | number
    averageBounceRate?: FloatFilter<"ParsedQuerySummary"> | number
    totalNewUsers?: IntFilter<"ParsedQuerySummary"> | number
    totalConversions?: IntFilter<"ParsedQuerySummary"> | number
    createdAt?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }

  export type ParsedQuerySummaryOrderByWithRelationInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
    createdAt?: SortOrder
    query?: QueryOrderByWithRelationInput
  }

  export type ParsedQuerySummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParsedQuerySummaryWhereInput | ParsedQuerySummaryWhereInput[]
    OR?: ParsedQuerySummaryWhereInput[]
    NOT?: ParsedQuerySummaryWhereInput | ParsedQuerySummaryWhereInput[]
    queryId?: StringFilter<"ParsedQuerySummary"> | string
    date?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
    totalEngagedSessions?: IntFilter<"ParsedQuerySummary"> | number
    averageBounceRate?: FloatFilter<"ParsedQuerySummary"> | number
    totalNewUsers?: IntFilter<"ParsedQuerySummary"> | number
    totalConversions?: IntFilter<"ParsedQuerySummary"> | number
    createdAt?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }, "id">

  export type ParsedQuerySummaryOrderByWithAggregationInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
    createdAt?: SortOrder
    _count?: ParsedQuerySummaryCountOrderByAggregateInput
    _avg?: ParsedQuerySummaryAvgOrderByAggregateInput
    _max?: ParsedQuerySummaryMaxOrderByAggregateInput
    _min?: ParsedQuerySummaryMinOrderByAggregateInput
    _sum?: ParsedQuerySummarySumOrderByAggregateInput
  }

  export type ParsedQuerySummaryScalarWhereWithAggregatesInput = {
    AND?: ParsedQuerySummaryScalarWhereWithAggregatesInput | ParsedQuerySummaryScalarWhereWithAggregatesInput[]
    OR?: ParsedQuerySummaryScalarWhereWithAggregatesInput[]
    NOT?: ParsedQuerySummaryScalarWhereWithAggregatesInput | ParsedQuerySummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParsedQuerySummary"> | string
    queryId?: StringWithAggregatesFilter<"ParsedQuerySummary"> | string
    date?: DateTimeWithAggregatesFilter<"ParsedQuerySummary"> | Date | string
    totalEngagedSessions?: IntWithAggregatesFilter<"ParsedQuerySummary"> | number
    averageBounceRate?: FloatWithAggregatesFilter<"ParsedQuerySummary"> | number
    totalNewUsers?: IntWithAggregatesFilter<"ParsedQuerySummary"> | number
    totalConversions?: IntWithAggregatesFilter<"ParsedQuerySummary"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ParsedQuerySummary"> | Date | string
  }

  export type QueryWhereInput = {
    AND?: QueryWhereInput | QueryWhereInput[]
    OR?: QueryWhereInput[]
    NOT?: QueryWhereInput | QueryWhereInput[]
    id?: StringFilter<"Query"> | string
    content?: StringFilter<"Query"> | string
    response?: StringNullableFilter<"Query"> | string | null
    status?: EnumQueryStatusFilter<"Query"> | $Enums.QueryStatus
    rating?: IntFilter<"Query"> | number
    metadata?: JsonNullableFilter<"Query">
    lineGraphData?: JsonNullableFilter<"Query">
    pieGraphData?: JsonNullableFilter<"Query">
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
    userId?: StringFilter<"Query"> | string
    conversationId?: StringNullableFilter<"Query"> | string | null
    parsedData?: ParsedQueryDataListRelationFilter
    parsedPieData?: ParsedPieGraphDataListRelationFilter
    parsedSummary?: ParsedQuerySummaryListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    conversation?: XOR<ConversationNullableScalarRelationFilter, ConversationWhereInput> | null
  }

  export type QueryOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    response?: SortOrderInput | SortOrder
    status?: SortOrder
    rating?: SortOrder
    metadata?: SortOrderInput | SortOrder
    lineGraphData?: SortOrderInput | SortOrder
    pieGraphData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    parsedData?: ParsedQueryDataOrderByRelationAggregateInput
    parsedPieData?: ParsedPieGraphDataOrderByRelationAggregateInput
    parsedSummary?: ParsedQuerySummaryOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    conversation?: ConversationOrderByWithRelationInput
  }

  export type QueryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QueryWhereInput | QueryWhereInput[]
    OR?: QueryWhereInput[]
    NOT?: QueryWhereInput | QueryWhereInput[]
    content?: StringFilter<"Query"> | string
    response?: StringNullableFilter<"Query"> | string | null
    status?: EnumQueryStatusFilter<"Query"> | $Enums.QueryStatus
    rating?: IntFilter<"Query"> | number
    metadata?: JsonNullableFilter<"Query">
    lineGraphData?: JsonNullableFilter<"Query">
    pieGraphData?: JsonNullableFilter<"Query">
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
    userId?: StringFilter<"Query"> | string
    conversationId?: StringNullableFilter<"Query"> | string | null
    parsedData?: ParsedQueryDataListRelationFilter
    parsedPieData?: ParsedPieGraphDataListRelationFilter
    parsedSummary?: ParsedQuerySummaryListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    conversation?: XOR<ConversationNullableScalarRelationFilter, ConversationWhereInput> | null
  }, "id">

  export type QueryOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    response?: SortOrderInput | SortOrder
    status?: SortOrder
    rating?: SortOrder
    metadata?: SortOrderInput | SortOrder
    lineGraphData?: SortOrderInput | SortOrder
    pieGraphData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    _count?: QueryCountOrderByAggregateInput
    _avg?: QueryAvgOrderByAggregateInput
    _max?: QueryMaxOrderByAggregateInput
    _min?: QueryMinOrderByAggregateInput
    _sum?: QuerySumOrderByAggregateInput
  }

  export type QueryScalarWhereWithAggregatesInput = {
    AND?: QueryScalarWhereWithAggregatesInput | QueryScalarWhereWithAggregatesInput[]
    OR?: QueryScalarWhereWithAggregatesInput[]
    NOT?: QueryScalarWhereWithAggregatesInput | QueryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Query"> | string
    content?: StringWithAggregatesFilter<"Query"> | string
    response?: StringNullableWithAggregatesFilter<"Query"> | string | null
    status?: EnumQueryStatusWithAggregatesFilter<"Query"> | $Enums.QueryStatus
    rating?: IntWithAggregatesFilter<"Query"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Query">
    lineGraphData?: JsonNullableWithAggregatesFilter<"Query">
    pieGraphData?: JsonNullableWithAggregatesFilter<"Query">
    createdAt?: DateTimeWithAggregatesFilter<"Query"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Query"> | Date | string
    userId?: StringWithAggregatesFilter<"Query"> | string
    conversationId?: StringNullableWithAggregatesFilter<"Query"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    roleId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    accountRepId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    accountRep?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clients?: UserListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    queries?: QueryListRelationFilter
    conversations?: ConversationListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    givenRatings?: ClientSatisfactionListRelationFilter
    receivedRatings?: ClientSatisfactionListRelationFilter
    assignedTickets?: TicketListRelationFilter
    clientTickets?: TicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    activities?: ClientActivityListRelationFilter
    gaAccounts?: GaAccountListRelationFilter
    gaImportRuns?: GaImportRunListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    accountRepId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    accountRep?: UserOrderByWithRelationInput
    clients?: UserOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    queries?: QueryOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    settings?: UserSettingsOrderByWithRelationInput
    givenRatings?: ClientSatisfactionOrderByRelationAggregateInput
    receivedRatings?: ClientSatisfactionOrderByRelationAggregateInput
    assignedTickets?: TicketOrderByRelationAggregateInput
    clientTickets?: TicketOrderByRelationAggregateInput
    ticketComments?: TicketCommentOrderByRelationAggregateInput
    activities?: ClientActivityOrderByRelationAggregateInput
    gaAccounts?: GaAccountOrderByRelationAggregateInput
    gaImportRuns?: GaImportRunOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    roleId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    accountRepId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    accountRep?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clients?: UserListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    queries?: QueryListRelationFilter
    conversations?: ConversationListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    givenRatings?: ClientSatisfactionListRelationFilter
    receivedRatings?: ClientSatisfactionListRelationFilter
    assignedTickets?: TicketListRelationFilter
    clientTickets?: TicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    activities?: ClientActivityListRelationFilter
    gaAccounts?: GaAccountListRelationFilter
    gaImportRuns?: GaImportRunListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    accountRepId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    roleId?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    accountRepId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    emailNotifications?: BoolFilter<"UserSettings"> | boolean
    theme?: StringNullableFilter<"UserSettings"> | string | null
    apiCredits?: IntFilter<"UserSettings"> | number
    apiCreditsLimit?: IntFilter<"UserSettings"> | number
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    userId?: StringFilter<"UserSettings"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    emailNotifications?: SortOrder
    theme?: SortOrderInput | SortOrder
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    emailNotifications?: BoolFilter<"UserSettings"> | boolean
    theme?: StringNullableFilter<"UserSettings"> | string | null
    apiCredits?: IntFilter<"UserSettings"> | number
    apiCreditsLimit?: IntFilter<"UserSettings"> | number
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    emailNotifications?: SortOrder
    theme?: SortOrderInput | SortOrder
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _avg?: UserSettingsAvgOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
    _sum?: UserSettingsSumOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    emailNotifications?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    theme?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    apiCredits?: IntWithAggregatesFilter<"UserSettings"> | number
    apiCreditsLimit?: IntWithAggregatesFilter<"UserSettings"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    assignedToId?: StringNullableFilter<"Ticket"> | string | null
    clientId?: StringFilter<"Ticket"> | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: TicketAttachmentListRelationFilter
    comments?: TicketCommentListRelationFilter
    tags?: TicketTagListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    assignedTo?: UserOrderByWithRelationInput
    client?: UserOrderByWithRelationInput
    attachments?: TicketAttachmentOrderByRelationAggregateInput
    comments?: TicketCommentOrderByRelationAggregateInput
    tags?: TicketTagOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    assignedToId?: StringNullableFilter<"Ticket"> | string | null
    clientId?: StringFilter<"Ticket"> | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: TicketAttachmentListRelationFilter
    comments?: TicketCommentListRelationFilter
    tags?: TicketTagListRelationFilter
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    title?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringWithAggregatesFilter<"Ticket"> | string
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityWithAggregatesFilter<"Ticket"> | $Enums.TicketPriority
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    assignedToId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    clientId?: StringWithAggregatesFilter<"Ticket"> | string
  }

  export type TicketAttachmentWhereInput = {
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    id?: StringFilter<"TicketAttachment"> | string
    name?: StringFilter<"TicketAttachment"> | string
    url?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: StringFilter<"TicketAttachment"> | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }

  export type TicketAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    ticket?: TicketOrderByWithRelationInput
  }

  export type TicketAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    name?: StringFilter<"TicketAttachment"> | string
    url?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: StringFilter<"TicketAttachment"> | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    _count?: TicketAttachmentCountOrderByAggregateInput
    _max?: TicketAttachmentMaxOrderByAggregateInput
    _min?: TicketAttachmentMinOrderByAggregateInput
  }

  export type TicketAttachmentScalarWhereWithAggregatesInput = {
    AND?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    OR?: TicketAttachmentScalarWhereWithAggregatesInput[]
    NOT?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketAttachment"> | string
    name?: StringWithAggregatesFilter<"TicketAttachment"> | string
    url?: StringWithAggregatesFilter<"TicketAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketAttachment"> | Date | string
    ticketId?: StringWithAggregatesFilter<"TicketAttachment"> | string
  }

  export type TicketCommentWhereInput = {
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TicketCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type TicketCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TicketCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    _count?: TicketCommentCountOrderByAggregateInput
    _max?: TicketCommentMaxOrderByAggregateInput
    _min?: TicketCommentMinOrderByAggregateInput
  }

  export type TicketCommentScalarWhereWithAggregatesInput = {
    AND?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    OR?: TicketCommentScalarWhereWithAggregatesInput[]
    NOT?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketComment"> | string
    content?: StringWithAggregatesFilter<"TicketComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
    ticketId?: StringWithAggregatesFilter<"TicketComment"> | string
    authorId?: StringWithAggregatesFilter<"TicketComment"> | string
  }

  export type TicketTagWhereInput = {
    AND?: TicketTagWhereInput | TicketTagWhereInput[]
    OR?: TicketTagWhereInput[]
    NOT?: TicketTagWhereInput | TicketTagWhereInput[]
    id?: StringFilter<"TicketTag"> | string
    name?: StringFilter<"TicketTag"> | string
    createdAt?: DateTimeFilter<"TicketTag"> | Date | string
    tickets?: TicketListRelationFilter
  }

  export type TicketTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type TicketTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TicketTagWhereInput | TicketTagWhereInput[]
    OR?: TicketTagWhereInput[]
    NOT?: TicketTagWhereInput | TicketTagWhereInput[]
    createdAt?: DateTimeFilter<"TicketTag"> | Date | string
    tickets?: TicketListRelationFilter
  }, "id" | "name">

  export type TicketTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: TicketTagCountOrderByAggregateInput
    _max?: TicketTagMaxOrderByAggregateInput
    _min?: TicketTagMinOrderByAggregateInput
  }

  export type TicketTagScalarWhereWithAggregatesInput = {
    AND?: TicketTagScalarWhereWithAggregatesInput | TicketTagScalarWhereWithAggregatesInput[]
    OR?: TicketTagScalarWhereWithAggregatesInput[]
    NOT?: TicketTagScalarWhereWithAggregatesInput | TicketTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketTag"> | string
    name?: StringWithAggregatesFilter<"TicketTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketTag"> | Date | string
  }

  export type MessageAttachmentWhereInput = {
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    filename?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    mimeType?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    messageId?: StringFilter<"MessageAttachment"> | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }

  export type MessageAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type MessageAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    filename?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    mimeType?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    messageId?: StringFilter<"MessageAttachment"> | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }, "id">

  export type MessageAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    _count?: MessageAttachmentCountOrderByAggregateInput
    _avg?: MessageAttachmentAvgOrderByAggregateInput
    _max?: MessageAttachmentMaxOrderByAggregateInput
    _min?: MessageAttachmentMinOrderByAggregateInput
    _sum?: MessageAttachmentSumOrderByAggregateInput
  }

  export type MessageAttachmentScalarWhereWithAggregatesInput = {
    AND?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    OR?: MessageAttachmentScalarWhereWithAggregatesInput[]
    NOT?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageAttachment"> | string
    filename?: StringWithAggregatesFilter<"MessageAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"MessageAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"MessageAttachment"> | string
    url?: StringWithAggregatesFilter<"MessageAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageAttachment"> | Date | string
    messageId?: StringWithAggregatesFilter<"MessageAttachment"> | string
  }

  export type ClientActivityWhereInput = {
    AND?: ClientActivityWhereInput | ClientActivityWhereInput[]
    OR?: ClientActivityWhereInput[]
    NOT?: ClientActivityWhereInput | ClientActivityWhereInput[]
    id?: StringFilter<"ClientActivity"> | string
    type?: StringFilter<"ClientActivity"> | string
    description?: StringFilter<"ClientActivity"> | string
    status?: EnumActivityStatusFilter<"ClientActivity"> | $Enums.ActivityStatus
    metadata?: JsonNullableFilter<"ClientActivity">
    createdAt?: DateTimeFilter<"ClientActivity"> | Date | string
    updatedAt?: DateTimeFilter<"ClientActivity"> | Date | string
    userId?: StringFilter<"ClientActivity"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClientActivityOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ClientActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientActivityWhereInput | ClientActivityWhereInput[]
    OR?: ClientActivityWhereInput[]
    NOT?: ClientActivityWhereInput | ClientActivityWhereInput[]
    type?: StringFilter<"ClientActivity"> | string
    description?: StringFilter<"ClientActivity"> | string
    status?: EnumActivityStatusFilter<"ClientActivity"> | $Enums.ActivityStatus
    metadata?: JsonNullableFilter<"ClientActivity">
    createdAt?: DateTimeFilter<"ClientActivity"> | Date | string
    updatedAt?: DateTimeFilter<"ClientActivity"> | Date | string
    userId?: StringFilter<"ClientActivity"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ClientActivityOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: ClientActivityCountOrderByAggregateInput
    _max?: ClientActivityMaxOrderByAggregateInput
    _min?: ClientActivityMinOrderByAggregateInput
  }

  export type ClientActivityScalarWhereWithAggregatesInput = {
    AND?: ClientActivityScalarWhereWithAggregatesInput | ClientActivityScalarWhereWithAggregatesInput[]
    OR?: ClientActivityScalarWhereWithAggregatesInput[]
    NOT?: ClientActivityScalarWhereWithAggregatesInput | ClientActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientActivity"> | string
    type?: StringWithAggregatesFilter<"ClientActivity"> | string
    description?: StringWithAggregatesFilter<"ClientActivity"> | string
    status?: EnumActivityStatusWithAggregatesFilter<"ClientActivity"> | $Enums.ActivityStatus
    metadata?: JsonNullableWithAggregatesFilter<"ClientActivity">
    createdAt?: DateTimeWithAggregatesFilter<"ClientActivity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientActivity"> | Date | string
    userId?: StringWithAggregatesFilter<"ClientActivity"> | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientSatisfactionCreateInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutGivenRatingsInput
    accountRep: UserCreateNestedOneWithoutReceivedRatingsInput
  }

  export type ClientSatisfactionUncheckedCreateInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    userId: string
    accountRepId: string
  }

  export type ClientSatisfactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGivenRatingsNestedInput
    accountRep?: UserUpdateOneRequiredWithoutReceivedRatingsNestedInput
  }

  export type ClientSatisfactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    accountRepId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientSatisfactionCreateManyInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    userId: string
    accountRepId: string
  }

  export type ClientSatisfactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSatisfactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    accountRepId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCreateInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    queries?: QueryCreateNestedManyWithoutConversationInput
    gaAccount?: GaAccountCreateNestedOneWithoutConversationsInput
    gaProperty?: GaPropertyCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gaAccountId?: string | null
    gaPropertyId?: string | null
    userId: string
    queries?: QueryUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    queries?: QueryUpdateManyWithoutConversationNestedInput
    gaAccount?: GaAccountUpdateOneWithoutConversationsNestedInput
    gaProperty?: GaPropertyUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    queries?: QueryUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gaAccountId?: string | null
    gaPropertyId?: string | null
    userId: string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GaAccountCreateInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    user: UserCreateNestedOneWithoutGaAccountsInput
    gaProperties?: GaPropertyCreateNestedManyWithoutGaAccountInput
    conversations?: ConversationCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountUncheckedCreateInput = {
    id?: string
    userId: string
    gaAccountId: string
    gaAccountName: string
    gaProperties?: GaPropertyUncheckedCreateNestedManyWithoutGaAccountInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutGaAccountsNestedInput
    gaProperties?: GaPropertyUpdateManyWithoutGaAccountNestedInput
    conversations?: ConversationUpdateManyWithoutGaAccountNestedInput
  }

  export type GaAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    gaProperties?: GaPropertyUncheckedUpdateManyWithoutGaAccountNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutGaAccountNestedInput
  }

  export type GaAccountCreateManyInput = {
    id?: string
    userId: string
    gaAccountId: string
    gaAccountName: string
  }

  export type GaAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
  }

  export type GaAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
  }

  export type GaPropertyCreateInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyCreateManyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
  }

  export type GaPropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
  }

  export type GaPropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type GaImportRunCreateInput = {
    id?: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutImportsInput
    requestedBy: UserCreateNestedOneWithoutGaImportRunsInput
  }

  export type GaImportRunUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    requestedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaImportRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutImportsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutGaImportRunsNestedInput
  }

  export type GaImportRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaImportRunCreateManyInput = {
    id?: string
    gaPropertyId: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    requestedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaImportRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaImportRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyCreateInput = {
    id?: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutKpiDailyInput
  }

  export type GaKpiDailyUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaKpiDailyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutKpiDailyNestedInput
  }

  export type GaKpiDailyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyCreateManyInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaKpiDailyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyCreateInput = {
    id?: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutKpiMonthlyInput
  }

  export type GaKpiMonthlyUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaKpiMonthlyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutKpiMonthlyNestedInput
  }

  export type GaKpiMonthlyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyCreateManyInput = {
    id?: string
    gaPropertyId: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaKpiMonthlyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaChannelDailyCreateInput = {
    id?: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutChannelDailyInput
  }

  export type GaChannelDailyUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaChannelDailyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutChannelDailyNestedInput
  }

  export type GaChannelDailyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaChannelDailyCreateManyInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaChannelDailyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaChannelDailyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyCreateInput = {
    id?: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutSourceDailyInput
  }

  export type GaSourceDailyUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaSourceDailyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutSourceDailyNestedInput
  }

  export type GaSourceDailyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyCreateManyInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaSourceDailyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    parent?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    recipientId: string
    replies?: MessageUncheckedCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    parent?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    replies?: MessageUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    recipientId: string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ParsedPieGraphDataCreateInput = {
    id?: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
    query: QueryCreateNestedOneWithoutParsedPieDataInput
  }

  export type ParsedPieGraphDataUncheckedCreateInput = {
    id?: string
    queryId: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
  }

  export type ParsedPieGraphDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: QueryUpdateOneRequiredWithoutParsedPieDataNestedInput
  }

  export type ParsedPieGraphDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedPieGraphDataCreateManyInput = {
    id?: string
    queryId: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
  }

  export type ParsedPieGraphDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedPieGraphDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQueryDataCreateInput = {
    id?: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    engagedSessions?: number | null
    bounceRate?: number | null
    newUsers?: number | null
    query: QueryCreateNestedOneWithoutParsedDataInput
  }

  export type ParsedQueryDataUncheckedCreateInput = {
    id?: string
    queryId: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    engagedSessions?: number | null
    bounceRate?: number | null
    newUsers?: number | null
  }

  export type ParsedQueryDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
    query?: QueryUpdateOneRequiredWithoutParsedDataNestedInput
  }

  export type ParsedQueryDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedQueryDataCreateManyInput = {
    id?: string
    queryId: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    engagedSessions?: number | null
    bounceRate?: number | null
    newUsers?: number | null
  }

  export type ParsedQueryDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedQueryDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedQuerySummaryCreateInput = {
    id?: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
    query: QueryCreateNestedOneWithoutParsedSummaryInput
  }

  export type ParsedQuerySummaryUncheckedCreateInput = {
    id?: string
    queryId: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
  }

  export type ParsedQuerySummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: QueryUpdateOneRequiredWithoutParsedSummaryNestedInput
  }

  export type ParsedQuerySummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQuerySummaryCreateManyInput = {
    id?: string
    queryId: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
  }

  export type ParsedQuerySummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQuerySummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryCreateInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    parsedData?: ParsedQueryDataCreateNestedManyWithoutQueryInput
    parsedPieData?: ParsedPieGraphDataCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryCreateNestedManyWithoutQueryInput
    user: UserCreateNestedOneWithoutQueriesInput
    conversation?: ConversationCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    conversationId?: string | null
    parsedData?: ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput
    parsedPieData?: ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parsedData?: ParsedQueryDataUpdateManyWithoutQueryNestedInput
    parsedPieData?: ParsedPieGraphDataUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUpdateManyWithoutQueryNestedInput
    user?: UserUpdateOneRequiredWithoutQueriesNestedInput
    conversation?: ConversationUpdateOneWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedData?: ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedPieData?: ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryCreateManyInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    conversationId?: string | null
  }

  export type QueryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    id?: string
    emailNotifications?: boolean
    theme?: string | null
    apiCredits?: number
    apiCreditsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    emailNotifications?: boolean
    theme?: string | null
    apiCredits?: number
    apiCreditsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    emailNotifications?: boolean
    theme?: string | null
    apiCredits?: number
    apiCreditsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    client: UserCreateNestedOneWithoutClientTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
    tags?: TicketTagCreateNestedManyWithoutTicketsInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    clientId: string
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    tags?: TicketTagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    client?: UserUpdateOneRequiredWithoutClientTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketCreateManyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    clientId: string
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketAttachmentCreateInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutAttachmentsInput
  }

  export type TicketAttachmentUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
    ticketId: string
  }

  export type TicketAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type TicketAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketAttachmentCreateManyInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
    ticketId: string
  }

  export type TicketAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketId: string
    authorId: string
  }

  export type TicketCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCommentCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketId: string
    authorId: string
  }

  export type TicketCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketTagCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutTagsInput
  }

  export type TicketTagUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TicketTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutTagsNestedInput
  }

  export type TicketTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TicketTagCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type TicketTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutAttachmentsInput
  }

  export type MessageAttachmentUncheckedCreateInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
    messageId: string
  }

  export type MessageAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type MessageAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageAttachmentCreateManyInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
    messageId: string
  }

  export type MessageAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientActivityCreateInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ClientActivityUncheckedCreateInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ClientActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ClientActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientActivityCreateManyInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ClientActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClientSatisfactionCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    accountRepId?: SortOrder
  }

  export type ClientSatisfactionAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ClientSatisfactionMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    accountRepId?: SortOrder
  }

  export type ClientSatisfactionMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    accountRepId?: SortOrder
  }

  export type ClientSatisfactionSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type QueryListRelationFilter = {
    every?: QueryWhereInput
    some?: QueryWhereInput
    none?: QueryWhereInput
  }

  export type GaAccountNullableScalarRelationFilter = {
    is?: GaAccountWhereInput | null
    isNot?: GaAccountWhereInput | null
  }

  export type GaPropertyNullableScalarRelationFilter = {
    is?: GaPropertyWhereInput | null
    isNot?: GaPropertyWhereInput | null
  }

  export type QueryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isStarred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaAccountId?: SortOrder
    gaPropertyId?: SortOrder
    userId?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isStarred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaAccountId?: SortOrder
    gaPropertyId?: SortOrder
    userId?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isStarred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaAccountId?: SortOrder
    gaPropertyId?: SortOrder
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type GaPropertyListRelationFilter = {
    every?: GaPropertyWhereInput
    some?: GaPropertyWhereInput
    none?: GaPropertyWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type GaPropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gaAccountId?: SortOrder
    gaAccountName?: SortOrder
  }

  export type GaAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gaAccountId?: SortOrder
    gaAccountName?: SortOrder
  }

  export type GaAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gaAccountId?: SortOrder
    gaAccountName?: SortOrder
  }

  export type GaAccountScalarRelationFilter = {
    is?: GaAccountWhereInput
    isNot?: GaAccountWhereInput
  }

  export type GaImportRunListRelationFilter = {
    every?: GaImportRunWhereInput
    some?: GaImportRunWhereInput
    none?: GaImportRunWhereInput
  }

  export type GaKpiDailyListRelationFilter = {
    every?: GaKpiDailyWhereInput
    some?: GaKpiDailyWhereInput
    none?: GaKpiDailyWhereInput
  }

  export type GaKpiMonthlyListRelationFilter = {
    every?: GaKpiMonthlyWhereInput
    some?: GaKpiMonthlyWhereInput
    none?: GaKpiMonthlyWhereInput
  }

  export type GaChannelDailyListRelationFilter = {
    every?: GaChannelDailyWhereInput
    some?: GaChannelDailyWhereInput
    none?: GaChannelDailyWhereInput
  }

  export type GaSourceDailyListRelationFilter = {
    every?: GaSourceDailyWhereInput
    some?: GaSourceDailyWhereInput
    none?: GaSourceDailyWhereInput
  }

  export type GaImportRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaKpiDailyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaKpiMonthlyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaChannelDailyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaSourceDailyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaPropertyCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    gaPropertyName?: SortOrder
    gaAccountId?: SortOrder
  }

  export type GaPropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    gaPropertyName?: SortOrder
    gaAccountId?: SortOrder
  }

  export type GaPropertyMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    gaPropertyName?: SortOrder
    gaAccountId?: SortOrder
  }

  export type EnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }

  export type GaPropertyScalarRelationFilter = {
    is?: GaPropertyWhereInput
    isNot?: GaPropertyWhereInput
  }

  export type GaImportRunCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    requestedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaImportRunMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    requestedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaImportRunMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    requestedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type GaKpiDailyGaPropertyIdDateCompoundUniqueInput = {
    gaPropertyId: string
    date: Date | string
  }

  export type GaKpiDailyCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaKpiDailyAvgOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaKpiDailyMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaKpiDailyMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaKpiDailySumOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type GaKpiMonthlyGaPropertyIdMonthCompoundUniqueInput = {
    gaPropertyId: string
    month: number
  }

  export type GaKpiMonthlyCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaKpiMonthlyAvgOrderByAggregateInput = {
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaKpiMonthlyMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaKpiMonthlyMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaKpiMonthlySumOrderByAggregateInput = {
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaChannelDailyGaPropertyIdDateChannelGroupCompoundUniqueInput = {
    gaPropertyId: string
    date: Date | string
    channelGroup: string
  }

  export type GaChannelDailyCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    channelGroup?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaChannelDailyAvgOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaChannelDailyMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    channelGroup?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaChannelDailyMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    channelGroup?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaChannelDailySumOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaSourceDailyGaPropertyIdDateTrafficSourceCompoundUniqueInput = {
    gaPropertyId: string
    date: Date | string
    trafficSource: string
  }

  export type GaSourceDailyCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    trafficSource?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaSourceDailyAvgOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaSourceDailyMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    trafficSource?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaSourceDailyMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    trafficSource?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type GaSourceDailySumOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageNullableScalarRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageAttachmentListRelationFilter = {
    every?: MessageAttachmentWhereInput
    some?: MessageAttachmentWhereInput
    none?: MessageAttachmentWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    archived?: SortOrder
    isThreadStart?: SortOrder
    threadId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    archived?: SortOrder
    isThreadStart?: SortOrder
    threadId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    archived?: SortOrder
    isThreadStart?: SortOrder
    threadId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type QueryScalarRelationFilter = {
    is?: QueryWhereInput
    isNot?: QueryWhereInput
  }

  export type ParsedPieGraphDataCountOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
    createdAt?: SortOrder
  }

  export type ParsedPieGraphDataAvgOrderByAggregateInput = {
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
  }

  export type ParsedPieGraphDataMaxOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
    createdAt?: SortOrder
  }

  export type ParsedPieGraphDataMinOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
    createdAt?: SortOrder
  }

  export type ParsedPieGraphDataSumOrderByAggregateInput = {
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ParsedQueryDataCountOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    createdAt?: SortOrder
    engagedSessions?: SortOrder
    bounceRate?: SortOrder
    newUsers?: SortOrder
  }

  export type ParsedQueryDataAvgOrderByAggregateInput = {
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    engagedSessions?: SortOrder
    bounceRate?: SortOrder
    newUsers?: SortOrder
  }

  export type ParsedQueryDataMaxOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    createdAt?: SortOrder
    engagedSessions?: SortOrder
    bounceRate?: SortOrder
    newUsers?: SortOrder
  }

  export type ParsedQueryDataMinOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    createdAt?: SortOrder
    engagedSessions?: SortOrder
    bounceRate?: SortOrder
    newUsers?: SortOrder
  }

  export type ParsedQueryDataSumOrderByAggregateInput = {
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    engagedSessions?: SortOrder
    bounceRate?: SortOrder
    newUsers?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ParsedQuerySummaryCountOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
    createdAt?: SortOrder
  }

  export type ParsedQuerySummaryAvgOrderByAggregateInput = {
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
  }

  export type ParsedQuerySummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
    createdAt?: SortOrder
  }

  export type ParsedQuerySummaryMinOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
    createdAt?: SortOrder
  }

  export type ParsedQuerySummarySumOrderByAggregateInput = {
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
  }

  export type EnumQueryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusFilter<$PrismaModel> | $Enums.QueryStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ParsedQueryDataListRelationFilter = {
    every?: ParsedQueryDataWhereInput
    some?: ParsedQueryDataWhereInput
    none?: ParsedQueryDataWhereInput
  }

  export type ParsedPieGraphDataListRelationFilter = {
    every?: ParsedPieGraphDataWhereInput
    some?: ParsedPieGraphDataWhereInput
    none?: ParsedPieGraphDataWhereInput
  }

  export type ParsedQuerySummaryListRelationFilter = {
    every?: ParsedQuerySummaryWhereInput
    some?: ParsedQuerySummaryWhereInput
    none?: ParsedQuerySummaryWhereInput
  }

  export type ConversationNullableScalarRelationFilter = {
    is?: ConversationWhereInput | null
    isNot?: ConversationWhereInput | null
  }

  export type ParsedQueryDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParsedPieGraphDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParsedQuerySummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueryCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    response?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    metadata?: SortOrder
    lineGraphData?: SortOrder
    pieGraphData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrder
  }

  export type QueryAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type QueryMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    response?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrder
  }

  export type QueryMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    response?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrder
  }

  export type QuerySumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumQueryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueryStatusFilter<$PrismaModel>
    _max?: NestedEnumQueryStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type ClientSatisfactionListRelationFilter = {
    every?: ClientSatisfactionWhereInput
    some?: ClientSatisfactionWhereInput
    none?: ClientSatisfactionWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type TicketCommentListRelationFilter = {
    every?: TicketCommentWhereInput
    some?: TicketCommentWhereInput
    none?: TicketCommentWhereInput
  }

  export type ClientActivityListRelationFilter = {
    every?: ClientActivityWhereInput
    some?: ClientActivityWhereInput
    none?: ClientActivityWhereInput
  }

  export type GaAccountListRelationFilter = {
    every?: GaAccountWhereInput
    some?: GaAccountWhereInput
    none?: GaAccountWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientSatisfactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    accountRepId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    accountRepId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    accountRepId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    emailNotifications?: SortOrder
    theme?: SortOrder
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserSettingsAvgOrderByAggregateInput = {
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    emailNotifications?: SortOrder
    theme?: SortOrder
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    emailNotifications?: SortOrder
    theme?: SortOrder
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserSettingsSumOrderByAggregateInput = {
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type TicketAttachmentListRelationFilter = {
    every?: TicketAttachmentWhereInput
    some?: TicketAttachmentWhereInput
    none?: TicketAttachmentWhereInput
  }

  export type TicketTagListRelationFilter = {
    every?: TicketTagWhereInput
    some?: TicketTagWhereInput
    none?: TicketTagWhereInput
  }

  export type TicketAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    clientId?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    clientId?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    clientId?: SortOrder
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type TicketScalarRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type TicketAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
  }

  export type TicketAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
  }

  export type TicketAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
  }

  export type TicketCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
  }

  export type TicketCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
  }

  export type TicketCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
  }

  export type TicketTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
  }

  export type MessageAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type MessageAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
  }

  export type MessageAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
  }

  export type MessageAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumActivityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusFilter<$PrismaModel> | $Enums.ActivityStatus
  }

  export type ClientActivityCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ClientActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ClientActivityMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumActivityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActivityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityStatusFilter<$PrismaModel>
    _max?: NestedEnumActivityStatusFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutGivenRatingsInput = {
    create?: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGivenRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedRatingsInput = {
    create?: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutGivenRatingsNestedInput = {
    create?: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGivenRatingsInput
    upsert?: UserUpsertWithoutGivenRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGivenRatingsInput, UserUpdateWithoutGivenRatingsInput>, UserUncheckedUpdateWithoutGivenRatingsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedRatingsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedRatingsInput
    upsert?: UserUpsertWithoutReceivedRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedRatingsInput, UserUpdateWithoutReceivedRatingsInput>, UserUncheckedUpdateWithoutReceivedRatingsInput>
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type QueryCreateNestedManyWithoutConversationInput = {
    create?: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput> | QueryCreateWithoutConversationInput[] | QueryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutConversationInput | QueryCreateOrConnectWithoutConversationInput[]
    createMany?: QueryCreateManyConversationInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type GaAccountCreateNestedOneWithoutConversationsInput = {
    create?: XOR<GaAccountCreateWithoutConversationsInput, GaAccountUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: GaAccountCreateOrConnectWithoutConversationsInput
    connect?: GaAccountWhereUniqueInput
  }

  export type GaPropertyCreateNestedOneWithoutConversationsInput = {
    create?: XOR<GaPropertyCreateWithoutConversationsInput, GaPropertyUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutConversationsInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type QueryUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput> | QueryCreateWithoutConversationInput[] | QueryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutConversationInput | QueryCreateOrConnectWithoutConversationInput[]
    createMany?: QueryCreateManyConversationInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type QueryUpdateManyWithoutConversationNestedInput = {
    create?: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput> | QueryCreateWithoutConversationInput[] | QueryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutConversationInput | QueryCreateOrConnectWithoutConversationInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutConversationInput | QueryUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: QueryCreateManyConversationInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutConversationInput | QueryUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutConversationInput | QueryUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type GaAccountUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<GaAccountCreateWithoutConversationsInput, GaAccountUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: GaAccountCreateOrConnectWithoutConversationsInput
    upsert?: GaAccountUpsertWithoutConversationsInput
    disconnect?: GaAccountWhereInput | boolean
    delete?: GaAccountWhereInput | boolean
    connect?: GaAccountWhereUniqueInput
    update?: XOR<XOR<GaAccountUpdateToOneWithWhereWithoutConversationsInput, GaAccountUpdateWithoutConversationsInput>, GaAccountUncheckedUpdateWithoutConversationsInput>
  }

  export type GaPropertyUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<GaPropertyCreateWithoutConversationsInput, GaPropertyUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutConversationsInput
    upsert?: GaPropertyUpsertWithoutConversationsInput
    disconnect?: GaPropertyWhereInput | boolean
    delete?: GaPropertyWhereInput | boolean
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutConversationsInput, GaPropertyUpdateWithoutConversationsInput>, GaPropertyUncheckedUpdateWithoutConversationsInput>
  }

  export type QueryUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput> | QueryCreateWithoutConversationInput[] | QueryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutConversationInput | QueryCreateOrConnectWithoutConversationInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutConversationInput | QueryUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: QueryCreateManyConversationInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutConversationInput | QueryUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutConversationInput | QueryUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutGaAccountsInput = {
    create?: XOR<UserCreateWithoutGaAccountsInput, UserUncheckedCreateWithoutGaAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGaAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type GaPropertyCreateNestedManyWithoutGaAccountInput = {
    create?: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput> | GaPropertyCreateWithoutGaAccountInput[] | GaPropertyUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: GaPropertyCreateOrConnectWithoutGaAccountInput | GaPropertyCreateOrConnectWithoutGaAccountInput[]
    createMany?: GaPropertyCreateManyGaAccountInputEnvelope
    connect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutGaAccountInput = {
    create?: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput> | ConversationCreateWithoutGaAccountInput[] | ConversationUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaAccountInput | ConversationCreateOrConnectWithoutGaAccountInput[]
    createMany?: ConversationCreateManyGaAccountInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type GaPropertyUncheckedCreateNestedManyWithoutGaAccountInput = {
    create?: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput> | GaPropertyCreateWithoutGaAccountInput[] | GaPropertyUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: GaPropertyCreateOrConnectWithoutGaAccountInput | GaPropertyCreateOrConnectWithoutGaAccountInput[]
    createMany?: GaPropertyCreateManyGaAccountInputEnvelope
    connect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutGaAccountInput = {
    create?: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput> | ConversationCreateWithoutGaAccountInput[] | ConversationUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaAccountInput | ConversationCreateOrConnectWithoutGaAccountInput[]
    createMany?: ConversationCreateManyGaAccountInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutGaAccountsNestedInput = {
    create?: XOR<UserCreateWithoutGaAccountsInput, UserUncheckedCreateWithoutGaAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGaAccountsInput
    upsert?: UserUpsertWithoutGaAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGaAccountsInput, UserUpdateWithoutGaAccountsInput>, UserUncheckedUpdateWithoutGaAccountsInput>
  }

  export type GaPropertyUpdateManyWithoutGaAccountNestedInput = {
    create?: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput> | GaPropertyCreateWithoutGaAccountInput[] | GaPropertyUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: GaPropertyCreateOrConnectWithoutGaAccountInput | GaPropertyCreateOrConnectWithoutGaAccountInput[]
    upsert?: GaPropertyUpsertWithWhereUniqueWithoutGaAccountInput | GaPropertyUpsertWithWhereUniqueWithoutGaAccountInput[]
    createMany?: GaPropertyCreateManyGaAccountInputEnvelope
    set?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    disconnect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    delete?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    connect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    update?: GaPropertyUpdateWithWhereUniqueWithoutGaAccountInput | GaPropertyUpdateWithWhereUniqueWithoutGaAccountInput[]
    updateMany?: GaPropertyUpdateManyWithWhereWithoutGaAccountInput | GaPropertyUpdateManyWithWhereWithoutGaAccountInput[]
    deleteMany?: GaPropertyScalarWhereInput | GaPropertyScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutGaAccountNestedInput = {
    create?: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput> | ConversationCreateWithoutGaAccountInput[] | ConversationUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaAccountInput | ConversationCreateOrConnectWithoutGaAccountInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutGaAccountInput | ConversationUpsertWithWhereUniqueWithoutGaAccountInput[]
    createMany?: ConversationCreateManyGaAccountInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutGaAccountInput | ConversationUpdateWithWhereUniqueWithoutGaAccountInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutGaAccountInput | ConversationUpdateManyWithWhereWithoutGaAccountInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GaPropertyUncheckedUpdateManyWithoutGaAccountNestedInput = {
    create?: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput> | GaPropertyCreateWithoutGaAccountInput[] | GaPropertyUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: GaPropertyCreateOrConnectWithoutGaAccountInput | GaPropertyCreateOrConnectWithoutGaAccountInput[]
    upsert?: GaPropertyUpsertWithWhereUniqueWithoutGaAccountInput | GaPropertyUpsertWithWhereUniqueWithoutGaAccountInput[]
    createMany?: GaPropertyCreateManyGaAccountInputEnvelope
    set?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    disconnect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    delete?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    connect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    update?: GaPropertyUpdateWithWhereUniqueWithoutGaAccountInput | GaPropertyUpdateWithWhereUniqueWithoutGaAccountInput[]
    updateMany?: GaPropertyUpdateManyWithWhereWithoutGaAccountInput | GaPropertyUpdateManyWithWhereWithoutGaAccountInput[]
    deleteMany?: GaPropertyScalarWhereInput | GaPropertyScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutGaAccountNestedInput = {
    create?: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput> | ConversationCreateWithoutGaAccountInput[] | ConversationUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaAccountInput | ConversationCreateOrConnectWithoutGaAccountInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutGaAccountInput | ConversationUpsertWithWhereUniqueWithoutGaAccountInput[]
    createMany?: ConversationCreateManyGaAccountInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutGaAccountInput | ConversationUpdateWithWhereUniqueWithoutGaAccountInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutGaAccountInput | ConversationUpdateManyWithWhereWithoutGaAccountInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GaAccountCreateNestedOneWithoutGaPropertiesInput = {
    create?: XOR<GaAccountCreateWithoutGaPropertiesInput, GaAccountUncheckedCreateWithoutGaPropertiesInput>
    connectOrCreate?: GaAccountCreateOrConnectWithoutGaPropertiesInput
    connect?: GaAccountWhereUniqueInput
  }

  export type ConversationCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput> | ConversationCreateWithoutGaPropertyInput[] | ConversationUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaPropertyInput | ConversationCreateOrConnectWithoutGaPropertyInput[]
    createMany?: ConversationCreateManyGaPropertyInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type GaImportRunCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput> | GaImportRunCreateWithoutGaPropertyInput[] | GaImportRunUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutGaPropertyInput | GaImportRunCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaImportRunCreateManyGaPropertyInputEnvelope
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
  }

  export type GaKpiDailyCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput> | GaKpiDailyCreateWithoutGaPropertyInput[] | GaKpiDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiDailyCreateOrConnectWithoutGaPropertyInput | GaKpiDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaKpiDailyCreateManyGaPropertyInputEnvelope
    connect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
  }

  export type GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput> | GaKpiMonthlyCreateWithoutGaPropertyInput[] | GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput | GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaKpiMonthlyCreateManyGaPropertyInputEnvelope
    connect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
  }

  export type GaChannelDailyCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput> | GaChannelDailyCreateWithoutGaPropertyInput[] | GaChannelDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaChannelDailyCreateOrConnectWithoutGaPropertyInput | GaChannelDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaChannelDailyCreateManyGaPropertyInputEnvelope
    connect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
  }

  export type GaSourceDailyCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput> | GaSourceDailyCreateWithoutGaPropertyInput[] | GaSourceDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaSourceDailyCreateOrConnectWithoutGaPropertyInput | GaSourceDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaSourceDailyCreateManyGaPropertyInputEnvelope
    connect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput> | ConversationCreateWithoutGaPropertyInput[] | ConversationUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaPropertyInput | ConversationCreateOrConnectWithoutGaPropertyInput[]
    createMany?: ConversationCreateManyGaPropertyInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput> | GaImportRunCreateWithoutGaPropertyInput[] | GaImportRunUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutGaPropertyInput | GaImportRunCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaImportRunCreateManyGaPropertyInputEnvelope
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
  }

  export type GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput> | GaKpiDailyCreateWithoutGaPropertyInput[] | GaKpiDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiDailyCreateOrConnectWithoutGaPropertyInput | GaKpiDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaKpiDailyCreateManyGaPropertyInputEnvelope
    connect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
  }

  export type GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput> | GaKpiMonthlyCreateWithoutGaPropertyInput[] | GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput | GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaKpiMonthlyCreateManyGaPropertyInputEnvelope
    connect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
  }

  export type GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput> | GaChannelDailyCreateWithoutGaPropertyInput[] | GaChannelDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaChannelDailyCreateOrConnectWithoutGaPropertyInput | GaChannelDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaChannelDailyCreateManyGaPropertyInputEnvelope
    connect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
  }

  export type GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput> | GaSourceDailyCreateWithoutGaPropertyInput[] | GaSourceDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaSourceDailyCreateOrConnectWithoutGaPropertyInput | GaSourceDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaSourceDailyCreateManyGaPropertyInputEnvelope
    connect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
  }

  export type GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput = {
    create?: XOR<GaAccountCreateWithoutGaPropertiesInput, GaAccountUncheckedCreateWithoutGaPropertiesInput>
    connectOrCreate?: GaAccountCreateOrConnectWithoutGaPropertiesInput
    upsert?: GaAccountUpsertWithoutGaPropertiesInput
    connect?: GaAccountWhereUniqueInput
    update?: XOR<XOR<GaAccountUpdateToOneWithWhereWithoutGaPropertiesInput, GaAccountUpdateWithoutGaPropertiesInput>, GaAccountUncheckedUpdateWithoutGaPropertiesInput>
  }

  export type ConversationUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput> | ConversationCreateWithoutGaPropertyInput[] | ConversationUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaPropertyInput | ConversationCreateOrConnectWithoutGaPropertyInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutGaPropertyInput | ConversationUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: ConversationCreateManyGaPropertyInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutGaPropertyInput | ConversationUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutGaPropertyInput | ConversationUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GaImportRunUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput> | GaImportRunCreateWithoutGaPropertyInput[] | GaImportRunUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutGaPropertyInput | GaImportRunCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaImportRunUpsertWithWhereUniqueWithoutGaPropertyInput | GaImportRunUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaImportRunCreateManyGaPropertyInputEnvelope
    set?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    disconnect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    delete?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    update?: GaImportRunUpdateWithWhereUniqueWithoutGaPropertyInput | GaImportRunUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaImportRunUpdateManyWithWhereWithoutGaPropertyInput | GaImportRunUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
  }

  export type GaKpiDailyUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput> | GaKpiDailyCreateWithoutGaPropertyInput[] | GaKpiDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiDailyCreateOrConnectWithoutGaPropertyInput | GaKpiDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaKpiDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaKpiDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaKpiDailyCreateManyGaPropertyInputEnvelope
    set?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    disconnect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    delete?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    connect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    update?: GaKpiDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaKpiDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaKpiDailyUpdateManyWithWhereWithoutGaPropertyInput | GaKpiDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaKpiDailyScalarWhereInput | GaKpiDailyScalarWhereInput[]
  }

  export type GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput> | GaKpiMonthlyCreateWithoutGaPropertyInput[] | GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput | GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaKpiMonthlyUpsertWithWhereUniqueWithoutGaPropertyInput | GaKpiMonthlyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaKpiMonthlyCreateManyGaPropertyInputEnvelope
    set?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    disconnect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    delete?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    connect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    update?: GaKpiMonthlyUpdateWithWhereUniqueWithoutGaPropertyInput | GaKpiMonthlyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaKpiMonthlyUpdateManyWithWhereWithoutGaPropertyInput | GaKpiMonthlyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaKpiMonthlyScalarWhereInput | GaKpiMonthlyScalarWhereInput[]
  }

  export type GaChannelDailyUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput> | GaChannelDailyCreateWithoutGaPropertyInput[] | GaChannelDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaChannelDailyCreateOrConnectWithoutGaPropertyInput | GaChannelDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaChannelDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaChannelDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaChannelDailyCreateManyGaPropertyInputEnvelope
    set?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    disconnect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    delete?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    connect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    update?: GaChannelDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaChannelDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaChannelDailyUpdateManyWithWhereWithoutGaPropertyInput | GaChannelDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaChannelDailyScalarWhereInput | GaChannelDailyScalarWhereInput[]
  }

  export type GaSourceDailyUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput> | GaSourceDailyCreateWithoutGaPropertyInput[] | GaSourceDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaSourceDailyCreateOrConnectWithoutGaPropertyInput | GaSourceDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaSourceDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaSourceDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaSourceDailyCreateManyGaPropertyInputEnvelope
    set?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    disconnect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    delete?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    connect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    update?: GaSourceDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaSourceDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaSourceDailyUpdateManyWithWhereWithoutGaPropertyInput | GaSourceDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaSourceDailyScalarWhereInput | GaSourceDailyScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput> | ConversationCreateWithoutGaPropertyInput[] | ConversationUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaPropertyInput | ConversationCreateOrConnectWithoutGaPropertyInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutGaPropertyInput | ConversationUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: ConversationCreateManyGaPropertyInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutGaPropertyInput | ConversationUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutGaPropertyInput | ConversationUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput> | GaImportRunCreateWithoutGaPropertyInput[] | GaImportRunUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutGaPropertyInput | GaImportRunCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaImportRunUpsertWithWhereUniqueWithoutGaPropertyInput | GaImportRunUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaImportRunCreateManyGaPropertyInputEnvelope
    set?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    disconnect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    delete?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    update?: GaImportRunUpdateWithWhereUniqueWithoutGaPropertyInput | GaImportRunUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaImportRunUpdateManyWithWhereWithoutGaPropertyInput | GaImportRunUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
  }

  export type GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput> | GaKpiDailyCreateWithoutGaPropertyInput[] | GaKpiDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiDailyCreateOrConnectWithoutGaPropertyInput | GaKpiDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaKpiDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaKpiDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaKpiDailyCreateManyGaPropertyInputEnvelope
    set?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    disconnect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    delete?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    connect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    update?: GaKpiDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaKpiDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaKpiDailyUpdateManyWithWhereWithoutGaPropertyInput | GaKpiDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaKpiDailyScalarWhereInput | GaKpiDailyScalarWhereInput[]
  }

  export type GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput> | GaKpiMonthlyCreateWithoutGaPropertyInput[] | GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput | GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaKpiMonthlyUpsertWithWhereUniqueWithoutGaPropertyInput | GaKpiMonthlyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaKpiMonthlyCreateManyGaPropertyInputEnvelope
    set?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    disconnect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    delete?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    connect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    update?: GaKpiMonthlyUpdateWithWhereUniqueWithoutGaPropertyInput | GaKpiMonthlyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaKpiMonthlyUpdateManyWithWhereWithoutGaPropertyInput | GaKpiMonthlyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaKpiMonthlyScalarWhereInput | GaKpiMonthlyScalarWhereInput[]
  }

  export type GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput> | GaChannelDailyCreateWithoutGaPropertyInput[] | GaChannelDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaChannelDailyCreateOrConnectWithoutGaPropertyInput | GaChannelDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaChannelDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaChannelDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaChannelDailyCreateManyGaPropertyInputEnvelope
    set?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    disconnect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    delete?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    connect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    update?: GaChannelDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaChannelDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaChannelDailyUpdateManyWithWhereWithoutGaPropertyInput | GaChannelDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaChannelDailyScalarWhereInput | GaChannelDailyScalarWhereInput[]
  }

  export type GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput> | GaSourceDailyCreateWithoutGaPropertyInput[] | GaSourceDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaSourceDailyCreateOrConnectWithoutGaPropertyInput | GaSourceDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaSourceDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaSourceDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaSourceDailyCreateManyGaPropertyInputEnvelope
    set?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    disconnect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    delete?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    connect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    update?: GaSourceDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaSourceDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaSourceDailyUpdateManyWithWhereWithoutGaPropertyInput | GaSourceDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaSourceDailyScalarWhereInput | GaSourceDailyScalarWhereInput[]
  }

  export type GaPropertyCreateNestedOneWithoutImportsInput = {
    create?: XOR<GaPropertyCreateWithoutImportsInput, GaPropertyUncheckedCreateWithoutImportsInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutImportsInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGaImportRunsInput = {
    create?: XOR<UserCreateWithoutGaImportRunsInput, UserUncheckedCreateWithoutGaImportRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGaImportRunsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumImportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImportStatus
  }

  export type GaPropertyUpdateOneRequiredWithoutImportsNestedInput = {
    create?: XOR<GaPropertyCreateWithoutImportsInput, GaPropertyUncheckedCreateWithoutImportsInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutImportsInput
    upsert?: GaPropertyUpsertWithoutImportsInput
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutImportsInput, GaPropertyUpdateWithoutImportsInput>, GaPropertyUncheckedUpdateWithoutImportsInput>
  }

  export type UserUpdateOneRequiredWithoutGaImportRunsNestedInput = {
    create?: XOR<UserCreateWithoutGaImportRunsInput, UserUncheckedCreateWithoutGaImportRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGaImportRunsInput
    upsert?: UserUpsertWithoutGaImportRunsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGaImportRunsInput, UserUpdateWithoutGaImportRunsInput>, UserUncheckedUpdateWithoutGaImportRunsInput>
  }

  export type GaPropertyCreateNestedOneWithoutKpiDailyInput = {
    create?: XOR<GaPropertyCreateWithoutKpiDailyInput, GaPropertyUncheckedCreateWithoutKpiDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutKpiDailyInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GaPropertyUpdateOneRequiredWithoutKpiDailyNestedInput = {
    create?: XOR<GaPropertyCreateWithoutKpiDailyInput, GaPropertyUncheckedCreateWithoutKpiDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutKpiDailyInput
    upsert?: GaPropertyUpsertWithoutKpiDailyInput
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutKpiDailyInput, GaPropertyUpdateWithoutKpiDailyInput>, GaPropertyUncheckedUpdateWithoutKpiDailyInput>
  }

  export type GaPropertyCreateNestedOneWithoutKpiMonthlyInput = {
    create?: XOR<GaPropertyCreateWithoutKpiMonthlyInput, GaPropertyUncheckedCreateWithoutKpiMonthlyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutKpiMonthlyInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type GaPropertyUpdateOneRequiredWithoutKpiMonthlyNestedInput = {
    create?: XOR<GaPropertyCreateWithoutKpiMonthlyInput, GaPropertyUncheckedCreateWithoutKpiMonthlyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutKpiMonthlyInput
    upsert?: GaPropertyUpsertWithoutKpiMonthlyInput
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutKpiMonthlyInput, GaPropertyUpdateWithoutKpiMonthlyInput>, GaPropertyUncheckedUpdateWithoutKpiMonthlyInput>
  }

  export type GaPropertyCreateNestedOneWithoutChannelDailyInput = {
    create?: XOR<GaPropertyCreateWithoutChannelDailyInput, GaPropertyUncheckedCreateWithoutChannelDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutChannelDailyInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type GaPropertyUpdateOneRequiredWithoutChannelDailyNestedInput = {
    create?: XOR<GaPropertyCreateWithoutChannelDailyInput, GaPropertyUncheckedCreateWithoutChannelDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutChannelDailyInput
    upsert?: GaPropertyUpsertWithoutChannelDailyInput
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutChannelDailyInput, GaPropertyUpdateWithoutChannelDailyInput>, GaPropertyUncheckedUpdateWithoutChannelDailyInput>
  }

  export type GaPropertyCreateNestedOneWithoutSourceDailyInput = {
    create?: XOR<GaPropertyCreateWithoutSourceDailyInput, GaPropertyUncheckedCreateWithoutSourceDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutSourceDailyInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type GaPropertyUpdateOneRequiredWithoutSourceDailyNestedInput = {
    create?: XOR<GaPropertyCreateWithoutSourceDailyInput, GaPropertyUncheckedCreateWithoutSourceDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutSourceDailyInput
    upsert?: GaPropertyUpsertWithoutSourceDailyInput
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutSourceDailyInput, GaPropertyUpdateWithoutSourceDailyInput>, GaPropertyUncheckedUpdateWithoutSourceDailyInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutRepliesInput = {
    create?: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRepliesInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutParentInput = {
    create?: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput> | MessageCreateWithoutParentInput[] | MessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentInput | MessageCreateOrConnectWithoutParentInput[]
    createMany?: MessageCreateManyParentInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageAttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput> | MessageCreateWithoutParentInput[] | MessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentInput | MessageCreateOrConnectWithoutParentInput[]
    createMany?: MessageCreateManyParentInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type MessageUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRepliesInput
    upsert?: MessageUpsertWithoutRepliesInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutRepliesInput, MessageUpdateWithoutRepliesInput>, MessageUncheckedUpdateWithoutRepliesInput>
  }

  export type MessageUpdateManyWithoutParentNestedInput = {
    create?: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput> | MessageCreateWithoutParentInput[] | MessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentInput | MessageCreateOrConnectWithoutParentInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutParentInput | MessageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MessageCreateManyParentInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutParentInput | MessageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutParentInput | MessageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageAttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput> | MessageCreateWithoutParentInput[] | MessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentInput | MessageCreateOrConnectWithoutParentInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutParentInput | MessageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MessageCreateManyParentInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutParentInput | MessageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutParentInput | MessageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type QueryCreateNestedOneWithoutParsedPieDataInput = {
    create?: XOR<QueryCreateWithoutParsedPieDataInput, QueryUncheckedCreateWithoutParsedPieDataInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedPieDataInput
    connect?: QueryWhereUniqueInput
  }

  export type QueryUpdateOneRequiredWithoutParsedPieDataNestedInput = {
    create?: XOR<QueryCreateWithoutParsedPieDataInput, QueryUncheckedCreateWithoutParsedPieDataInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedPieDataInput
    upsert?: QueryUpsertWithoutParsedPieDataInput
    connect?: QueryWhereUniqueInput
    update?: XOR<XOR<QueryUpdateToOneWithWhereWithoutParsedPieDataInput, QueryUpdateWithoutParsedPieDataInput>, QueryUncheckedUpdateWithoutParsedPieDataInput>
  }

  export type QueryCreateNestedOneWithoutParsedDataInput = {
    create?: XOR<QueryCreateWithoutParsedDataInput, QueryUncheckedCreateWithoutParsedDataInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedDataInput
    connect?: QueryWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QueryUpdateOneRequiredWithoutParsedDataNestedInput = {
    create?: XOR<QueryCreateWithoutParsedDataInput, QueryUncheckedCreateWithoutParsedDataInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedDataInput
    upsert?: QueryUpsertWithoutParsedDataInput
    connect?: QueryWhereUniqueInput
    update?: XOR<XOR<QueryUpdateToOneWithWhereWithoutParsedDataInput, QueryUpdateWithoutParsedDataInput>, QueryUncheckedUpdateWithoutParsedDataInput>
  }

  export type QueryCreateNestedOneWithoutParsedSummaryInput = {
    create?: XOR<QueryCreateWithoutParsedSummaryInput, QueryUncheckedCreateWithoutParsedSummaryInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedSummaryInput
    connect?: QueryWhereUniqueInput
  }

  export type QueryUpdateOneRequiredWithoutParsedSummaryNestedInput = {
    create?: XOR<QueryCreateWithoutParsedSummaryInput, QueryUncheckedCreateWithoutParsedSummaryInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedSummaryInput
    upsert?: QueryUpsertWithoutParsedSummaryInput
    connect?: QueryWhereUniqueInput
    update?: XOR<XOR<QueryUpdateToOneWithWhereWithoutParsedSummaryInput, QueryUpdateWithoutParsedSummaryInput>, QueryUncheckedUpdateWithoutParsedSummaryInput>
  }

  export type ParsedQueryDataCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput> | ParsedQueryDataCreateWithoutQueryInput[] | ParsedQueryDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQueryDataCreateOrConnectWithoutQueryInput | ParsedQueryDataCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedQueryDataCreateManyQueryInputEnvelope
    connect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
  }

  export type ParsedPieGraphDataCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput> | ParsedPieGraphDataCreateWithoutQueryInput[] | ParsedPieGraphDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedPieGraphDataCreateOrConnectWithoutQueryInput | ParsedPieGraphDataCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedPieGraphDataCreateManyQueryInputEnvelope
    connect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
  }

  export type ParsedQuerySummaryCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput> | ParsedQuerySummaryCreateWithoutQueryInput[] | ParsedQuerySummaryUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQuerySummaryCreateOrConnectWithoutQueryInput | ParsedQuerySummaryCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedQuerySummaryCreateManyQueryInputEnvelope
    connect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutQueriesInput = {
    create?: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQueriesInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationCreateNestedOneWithoutQueriesInput = {
    create?: XOR<ConversationCreateWithoutQueriesInput, ConversationUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutQueriesInput
    connect?: ConversationWhereUniqueInput
  }

  export type ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput> | ParsedQueryDataCreateWithoutQueryInput[] | ParsedQueryDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQueryDataCreateOrConnectWithoutQueryInput | ParsedQueryDataCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedQueryDataCreateManyQueryInputEnvelope
    connect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
  }

  export type ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput> | ParsedPieGraphDataCreateWithoutQueryInput[] | ParsedPieGraphDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedPieGraphDataCreateOrConnectWithoutQueryInput | ParsedPieGraphDataCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedPieGraphDataCreateManyQueryInputEnvelope
    connect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
  }

  export type ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput> | ParsedQuerySummaryCreateWithoutQueryInput[] | ParsedQuerySummaryUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQuerySummaryCreateOrConnectWithoutQueryInput | ParsedQuerySummaryCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedQuerySummaryCreateManyQueryInputEnvelope
    connect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
  }

  export type EnumQueryStatusFieldUpdateOperationsInput = {
    set?: $Enums.QueryStatus
  }

  export type ParsedQueryDataUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput> | ParsedQueryDataCreateWithoutQueryInput[] | ParsedQueryDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQueryDataCreateOrConnectWithoutQueryInput | ParsedQueryDataCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedQueryDataUpsertWithWhereUniqueWithoutQueryInput | ParsedQueryDataUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedQueryDataCreateManyQueryInputEnvelope
    set?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    disconnect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    delete?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    connect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    update?: ParsedQueryDataUpdateWithWhereUniqueWithoutQueryInput | ParsedQueryDataUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedQueryDataUpdateManyWithWhereWithoutQueryInput | ParsedQueryDataUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedQueryDataScalarWhereInput | ParsedQueryDataScalarWhereInput[]
  }

  export type ParsedPieGraphDataUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput> | ParsedPieGraphDataCreateWithoutQueryInput[] | ParsedPieGraphDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedPieGraphDataCreateOrConnectWithoutQueryInput | ParsedPieGraphDataCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedPieGraphDataUpsertWithWhereUniqueWithoutQueryInput | ParsedPieGraphDataUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedPieGraphDataCreateManyQueryInputEnvelope
    set?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    disconnect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    delete?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    connect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    update?: ParsedPieGraphDataUpdateWithWhereUniqueWithoutQueryInput | ParsedPieGraphDataUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedPieGraphDataUpdateManyWithWhereWithoutQueryInput | ParsedPieGraphDataUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedPieGraphDataScalarWhereInput | ParsedPieGraphDataScalarWhereInput[]
  }

  export type ParsedQuerySummaryUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput> | ParsedQuerySummaryCreateWithoutQueryInput[] | ParsedQuerySummaryUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQuerySummaryCreateOrConnectWithoutQueryInput | ParsedQuerySummaryCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedQuerySummaryUpsertWithWhereUniqueWithoutQueryInput | ParsedQuerySummaryUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedQuerySummaryCreateManyQueryInputEnvelope
    set?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    disconnect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    delete?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    connect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    update?: ParsedQuerySummaryUpdateWithWhereUniqueWithoutQueryInput | ParsedQuerySummaryUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedQuerySummaryUpdateManyWithWhereWithoutQueryInput | ParsedQuerySummaryUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedQuerySummaryScalarWhereInput | ParsedQuerySummaryScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutQueriesNestedInput = {
    create?: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQueriesInput
    upsert?: UserUpsertWithoutQueriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQueriesInput, UserUpdateWithoutQueriesInput>, UserUncheckedUpdateWithoutQueriesInput>
  }

  export type ConversationUpdateOneWithoutQueriesNestedInput = {
    create?: XOR<ConversationCreateWithoutQueriesInput, ConversationUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutQueriesInput
    upsert?: ConversationUpsertWithoutQueriesInput
    disconnect?: ConversationWhereInput | boolean
    delete?: ConversationWhereInput | boolean
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutQueriesInput, ConversationUpdateWithoutQueriesInput>, ConversationUncheckedUpdateWithoutQueriesInput>
  }

  export type ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput> | ParsedQueryDataCreateWithoutQueryInput[] | ParsedQueryDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQueryDataCreateOrConnectWithoutQueryInput | ParsedQueryDataCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedQueryDataUpsertWithWhereUniqueWithoutQueryInput | ParsedQueryDataUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedQueryDataCreateManyQueryInputEnvelope
    set?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    disconnect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    delete?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    connect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    update?: ParsedQueryDataUpdateWithWhereUniqueWithoutQueryInput | ParsedQueryDataUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedQueryDataUpdateManyWithWhereWithoutQueryInput | ParsedQueryDataUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedQueryDataScalarWhereInput | ParsedQueryDataScalarWhereInput[]
  }

  export type ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput> | ParsedPieGraphDataCreateWithoutQueryInput[] | ParsedPieGraphDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedPieGraphDataCreateOrConnectWithoutQueryInput | ParsedPieGraphDataCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedPieGraphDataUpsertWithWhereUniqueWithoutQueryInput | ParsedPieGraphDataUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedPieGraphDataCreateManyQueryInputEnvelope
    set?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    disconnect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    delete?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    connect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    update?: ParsedPieGraphDataUpdateWithWhereUniqueWithoutQueryInput | ParsedPieGraphDataUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedPieGraphDataUpdateManyWithWhereWithoutQueryInput | ParsedPieGraphDataUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedPieGraphDataScalarWhereInput | ParsedPieGraphDataScalarWhereInput[]
  }

  export type ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput> | ParsedQuerySummaryCreateWithoutQueryInput[] | ParsedQuerySummaryUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQuerySummaryCreateOrConnectWithoutQueryInput | ParsedQuerySummaryCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedQuerySummaryUpsertWithWhereUniqueWithoutQueryInput | ParsedQuerySummaryUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedQuerySummaryCreateManyQueryInputEnvelope
    set?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    disconnect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    delete?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    connect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    update?: ParsedQuerySummaryUpdateWithWhereUniqueWithoutQueryInput | ParsedQuerySummaryUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedQuerySummaryUpdateManyWithWhereWithoutQueryInput | ParsedQuerySummaryUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedQuerySummaryScalarWhereInput | ParsedQuerySummaryScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClientsInput = {
    create?: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutAccountRepInput = {
    create?: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput> | UserCreateWithoutAccountRepInput[] | UserUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountRepInput | UserCreateOrConnectWithoutAccountRepInput[]
    createMany?: UserCreateManyAccountRepInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type QueryCreateNestedManyWithoutUserInput = {
    create?: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput> | QueryCreateWithoutUserInput[] | QueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutUserInput | QueryCreateOrConnectWithoutUserInput[]
    createMany?: QueryCreateManyUserInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type ClientSatisfactionCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput> | ClientSatisfactionCreateWithoutUserInput[] | ClientSatisfactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutUserInput | ClientSatisfactionCreateOrConnectWithoutUserInput[]
    createMany?: ClientSatisfactionCreateManyUserInputEnvelope
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
  }

  export type ClientSatisfactionCreateNestedManyWithoutAccountRepInput = {
    create?: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput> | ClientSatisfactionCreateWithoutAccountRepInput[] | ClientSatisfactionUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutAccountRepInput | ClientSatisfactionCreateOrConnectWithoutAccountRepInput[]
    createMany?: ClientSatisfactionCreateManyAccountRepInputEnvelope
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutClientInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type ClientActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput> | ClientActivityCreateWithoutUserInput[] | ClientActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientActivityCreateOrConnectWithoutUserInput | ClientActivityCreateOrConnectWithoutUserInput[]
    createMany?: ClientActivityCreateManyUserInputEnvelope
    connect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
  }

  export type GaAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<GaAccountCreateWithoutUserInput, GaAccountUncheckedCreateWithoutUserInput> | GaAccountCreateWithoutUserInput[] | GaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GaAccountCreateOrConnectWithoutUserInput | GaAccountCreateOrConnectWithoutUserInput[]
    createMany?: GaAccountCreateManyUserInputEnvelope
    connect?: GaAccountWhereUniqueInput | GaAccountWhereUniqueInput[]
  }

  export type GaImportRunCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput> | GaImportRunCreateWithoutRequestedByInput[] | GaImportRunUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutRequestedByInput | GaImportRunCreateOrConnectWithoutRequestedByInput[]
    createMany?: GaImportRunCreateManyRequestedByInputEnvelope
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAccountRepInput = {
    create?: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput> | UserCreateWithoutAccountRepInput[] | UserUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountRepInput | UserCreateOrConnectWithoutAccountRepInput[]
    createMany?: UserCreateManyAccountRepInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type QueryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput> | QueryCreateWithoutUserInput[] | QueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutUserInput | QueryCreateOrConnectWithoutUserInput[]
    createMany?: QueryCreateManyUserInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput> | ClientSatisfactionCreateWithoutUserInput[] | ClientSatisfactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutUserInput | ClientSatisfactionCreateOrConnectWithoutUserInput[]
    createMany?: ClientSatisfactionCreateManyUserInputEnvelope
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
  }

  export type ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput = {
    create?: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput> | ClientSatisfactionCreateWithoutAccountRepInput[] | ClientSatisfactionUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutAccountRepInput | ClientSatisfactionCreateOrConnectWithoutAccountRepInput[]
    createMany?: ClientSatisfactionCreateManyAccountRepInputEnvelope
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type ClientActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput> | ClientActivityCreateWithoutUserInput[] | ClientActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientActivityCreateOrConnectWithoutUserInput | ClientActivityCreateOrConnectWithoutUserInput[]
    createMany?: ClientActivityCreateManyUserInputEnvelope
    connect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
  }

  export type GaAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GaAccountCreateWithoutUserInput, GaAccountUncheckedCreateWithoutUserInput> | GaAccountCreateWithoutUserInput[] | GaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GaAccountCreateOrConnectWithoutUserInput | GaAccountCreateOrConnectWithoutUserInput[]
    createMany?: GaAccountCreateManyUserInputEnvelope
    connect?: GaAccountWhereUniqueInput | GaAccountWhereUniqueInput[]
  }

  export type GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput> | GaImportRunCreateWithoutRequestedByInput[] | GaImportRunUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutRequestedByInput | GaImportRunCreateOrConnectWithoutRequestedByInput[]
    createMany?: GaImportRunCreateManyRequestedByInputEnvelope
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneWithoutClientsNestedInput = {
    create?: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsInput
    upsert?: UserUpsertWithoutClientsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientsInput, UserUpdateWithoutClientsInput>, UserUncheckedUpdateWithoutClientsInput>
  }

  export type UserUpdateManyWithoutAccountRepNestedInput = {
    create?: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput> | UserCreateWithoutAccountRepInput[] | UserUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountRepInput | UserCreateOrConnectWithoutAccountRepInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAccountRepInput | UserUpsertWithWhereUniqueWithoutAccountRepInput[]
    createMany?: UserCreateManyAccountRepInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAccountRepInput | UserUpdateWithWhereUniqueWithoutAccountRepInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAccountRepInput | UserUpdateManyWithWhereWithoutAccountRepInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type QueryUpdateManyWithoutUserNestedInput = {
    create?: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput> | QueryCreateWithoutUserInput[] | QueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutUserInput | QueryCreateOrConnectWithoutUserInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutUserInput | QueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QueryCreateManyUserInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutUserInput | QueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutUserInput | QueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ClientSatisfactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput> | ClientSatisfactionCreateWithoutUserInput[] | ClientSatisfactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutUserInput | ClientSatisfactionCreateOrConnectWithoutUserInput[]
    upsert?: ClientSatisfactionUpsertWithWhereUniqueWithoutUserInput | ClientSatisfactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientSatisfactionCreateManyUserInputEnvelope
    set?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    disconnect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    delete?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    update?: ClientSatisfactionUpdateWithWhereUniqueWithoutUserInput | ClientSatisfactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientSatisfactionUpdateManyWithWhereWithoutUserInput | ClientSatisfactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
  }

  export type ClientSatisfactionUpdateManyWithoutAccountRepNestedInput = {
    create?: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput> | ClientSatisfactionCreateWithoutAccountRepInput[] | ClientSatisfactionUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutAccountRepInput | ClientSatisfactionCreateOrConnectWithoutAccountRepInput[]
    upsert?: ClientSatisfactionUpsertWithWhereUniqueWithoutAccountRepInput | ClientSatisfactionUpsertWithWhereUniqueWithoutAccountRepInput[]
    createMany?: ClientSatisfactionCreateManyAccountRepInputEnvelope
    set?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    disconnect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    delete?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    update?: ClientSatisfactionUpdateWithWhereUniqueWithoutAccountRepInput | ClientSatisfactionUpdateWithWhereUniqueWithoutAccountRepInput[]
    updateMany?: ClientSatisfactionUpdateManyWithWhereWithoutAccountRepInput | ClientSatisfactionUpdateManyWithWhereWithoutAccountRepInput[]
    deleteMany?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedToInput | TicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedToInput | TicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedToInput | TicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutClientNestedInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClientInput | TicketUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClientInput | TicketUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClientInput | TicketUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutAuthorInput | TicketCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutAuthorInput | TicketCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutAuthorInput | TicketCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type ClientActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput> | ClientActivityCreateWithoutUserInput[] | ClientActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientActivityCreateOrConnectWithoutUserInput | ClientActivityCreateOrConnectWithoutUserInput[]
    upsert?: ClientActivityUpsertWithWhereUniqueWithoutUserInput | ClientActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientActivityCreateManyUserInputEnvelope
    set?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    disconnect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    delete?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    connect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    update?: ClientActivityUpdateWithWhereUniqueWithoutUserInput | ClientActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientActivityUpdateManyWithWhereWithoutUserInput | ClientActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientActivityScalarWhereInput | ClientActivityScalarWhereInput[]
  }

  export type GaAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<GaAccountCreateWithoutUserInput, GaAccountUncheckedCreateWithoutUserInput> | GaAccountCreateWithoutUserInput[] | GaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GaAccountCreateOrConnectWithoutUserInput | GaAccountCreateOrConnectWithoutUserInput[]
    upsert?: GaAccountUpsertWithWhereUniqueWithoutUserInput | GaAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GaAccountCreateManyUserInputEnvelope
    set?: GaAccountWhereUniqueInput | GaAccountWhereUniqueInput[]
    disconnect?: GaAccountWhereUniqueInput | GaAccountWhereUniqueInput[]
    delete?: GaAccountWhereUniqueInput | GaAccountWhereUniqueInput[]
    connect?: GaAccountWhereUniqueInput | GaAccountWhereUniqueInput[]
    update?: GaAccountUpdateWithWhereUniqueWithoutUserInput | GaAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GaAccountUpdateManyWithWhereWithoutUserInput | GaAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GaAccountScalarWhereInput | GaAccountScalarWhereInput[]
  }

  export type GaImportRunUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput> | GaImportRunCreateWithoutRequestedByInput[] | GaImportRunUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutRequestedByInput | GaImportRunCreateOrConnectWithoutRequestedByInput[]
    upsert?: GaImportRunUpsertWithWhereUniqueWithoutRequestedByInput | GaImportRunUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: GaImportRunCreateManyRequestedByInputEnvelope
    set?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    disconnect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    delete?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    update?: GaImportRunUpdateWithWhereUniqueWithoutRequestedByInput | GaImportRunUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: GaImportRunUpdateManyWithWhereWithoutRequestedByInput | GaImportRunUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAccountRepNestedInput = {
    create?: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput> | UserCreateWithoutAccountRepInput[] | UserUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountRepInput | UserCreateOrConnectWithoutAccountRepInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAccountRepInput | UserUpsertWithWhereUniqueWithoutAccountRepInput[]
    createMany?: UserCreateManyAccountRepInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAccountRepInput | UserUpdateWithWhereUniqueWithoutAccountRepInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAccountRepInput | UserUpdateManyWithWhereWithoutAccountRepInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type QueryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput> | QueryCreateWithoutUserInput[] | QueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutUserInput | QueryCreateOrConnectWithoutUserInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutUserInput | QueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QueryCreateManyUserInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutUserInput | QueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutUserInput | QueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput> | ClientSatisfactionCreateWithoutUserInput[] | ClientSatisfactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutUserInput | ClientSatisfactionCreateOrConnectWithoutUserInput[]
    upsert?: ClientSatisfactionUpsertWithWhereUniqueWithoutUserInput | ClientSatisfactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientSatisfactionCreateManyUserInputEnvelope
    set?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    disconnect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    delete?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    update?: ClientSatisfactionUpdateWithWhereUniqueWithoutUserInput | ClientSatisfactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientSatisfactionUpdateManyWithWhereWithoutUserInput | ClientSatisfactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
  }

  export type ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput = {
    create?: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput> | ClientSatisfactionCreateWithoutAccountRepInput[] | ClientSatisfactionUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutAccountRepInput | ClientSatisfactionCreateOrConnectWithoutAccountRepInput[]
    upsert?: ClientSatisfactionUpsertWithWhereUniqueWithoutAccountRepInput | ClientSatisfactionUpsertWithWhereUniqueWithoutAccountRepInput[]
    createMany?: ClientSatisfactionCreateManyAccountRepInputEnvelope
    set?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    disconnect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    delete?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    update?: ClientSatisfactionUpdateWithWhereUniqueWithoutAccountRepInput | ClientSatisfactionUpdateWithWhereUniqueWithoutAccountRepInput[]
    updateMany?: ClientSatisfactionUpdateManyWithWhereWithoutAccountRepInput | ClientSatisfactionUpdateManyWithWhereWithoutAccountRepInput[]
    deleteMany?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedToInput | TicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedToInput | TicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedToInput | TicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClientInput | TicketUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClientInput | TicketUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClientInput | TicketUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutAuthorInput | TicketCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutAuthorInput | TicketCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutAuthorInput | TicketCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type ClientActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput> | ClientActivityCreateWithoutUserInput[] | ClientActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientActivityCreateOrConnectWithoutUserInput | ClientActivityCreateOrConnectWithoutUserInput[]
    upsert?: ClientActivityUpsertWithWhereUniqueWithoutUserInput | ClientActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientActivityCreateManyUserInputEnvelope
    set?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    disconnect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    delete?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    connect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    update?: ClientActivityUpdateWithWhereUniqueWithoutUserInput | ClientActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientActivityUpdateManyWithWhereWithoutUserInput | ClientActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientActivityScalarWhereInput | ClientActivityScalarWhereInput[]
  }

  export type GaAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GaAccountCreateWithoutUserInput, GaAccountUncheckedCreateWithoutUserInput> | GaAccountCreateWithoutUserInput[] | GaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GaAccountCreateOrConnectWithoutUserInput | GaAccountCreateOrConnectWithoutUserInput[]
    upsert?: GaAccountUpsertWithWhereUniqueWithoutUserInput | GaAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GaAccountCreateManyUserInputEnvelope
    set?: GaAccountWhereUniqueInput | GaAccountWhereUniqueInput[]
    disconnect?: GaAccountWhereUniqueInput | GaAccountWhereUniqueInput[]
    delete?: GaAccountWhereUniqueInput | GaAccountWhereUniqueInput[]
    connect?: GaAccountWhereUniqueInput | GaAccountWhereUniqueInput[]
    update?: GaAccountUpdateWithWhereUniqueWithoutUserInput | GaAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GaAccountUpdateManyWithWhereWithoutUserInput | GaAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GaAccountScalarWhereInput | GaAccountScalarWhereInput[]
  }

  export type GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput> | GaImportRunCreateWithoutRequestedByInput[] | GaImportRunUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutRequestedByInput | GaImportRunCreateOrConnectWithoutRequestedByInput[]
    upsert?: GaImportRunUpsertWithWhereUniqueWithoutRequestedByInput | GaImportRunUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: GaImportRunCreateManyRequestedByInputEnvelope
    set?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    disconnect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    delete?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    update?: GaImportRunUpdateWithWhereUniqueWithoutRequestedByInput | GaImportRunUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: GaImportRunUpdateManyWithWhereWithoutRequestedByInput | GaImportRunUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutAssignedTicketsInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClientTicketsInput = {
    create?: XOR<UserCreateWithoutClientTicketsInput, UserUncheckedCreateWithoutClientTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketAttachmentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketTagCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput> | TicketTagCreateWithoutTicketsInput[] | TicketTagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketsInput | TicketTagCreateOrConnectWithoutTicketsInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
  }

  export type TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketTagUncheckedCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput> | TicketTagCreateWithoutTicketsInput[] | TicketTagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketsInput | TicketTagCreateOrConnectWithoutTicketsInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type UserUpdateOneWithoutAssignedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    upsert?: UserUpsertWithoutAssignedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTicketsInput, UserUpdateWithoutAssignedTicketsInput>, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateOneRequiredWithoutClientTicketsNestedInput = {
    create?: XOR<UserCreateWithoutClientTicketsInput, UserUncheckedCreateWithoutClientTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientTicketsInput
    upsert?: UserUpsertWithoutClientTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientTicketsInput, UserUpdateWithoutClientTicketsInput>, UserUncheckedUpdateWithoutClientTicketsInput>
  }

  export type TicketAttachmentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketTagUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput> | TicketTagCreateWithoutTicketsInput[] | TicketTagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketsInput | TicketTagCreateOrConnectWithoutTicketsInput[]
    upsert?: TicketTagUpsertWithWhereUniqueWithoutTicketsInput | TicketTagUpsertWithWhereUniqueWithoutTicketsInput[]
    set?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    disconnect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    delete?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    update?: TicketTagUpdateWithWhereUniqueWithoutTicketsInput | TicketTagUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TicketTagUpdateManyWithWhereWithoutTicketsInput | TicketTagUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketTagUncheckedUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput> | TicketTagCreateWithoutTicketsInput[] | TicketTagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketsInput | TicketTagCreateOrConnectWithoutTicketsInput[]
    upsert?: TicketTagUpsertWithWhereUniqueWithoutTicketsInput | TicketTagUpsertWithWhereUniqueWithoutTicketsInput[]
    set?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    disconnect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    delete?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    update?: TicketTagUpdateWithWhereUniqueWithoutTicketsInput | TicketTagUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TicketTagUpdateManyWithWhereWithoutTicketsInput | TicketTagUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
  }

  export type TicketCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAttachmentsInput
    connect?: TicketWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAttachmentsInput
    upsert?: TicketUpsertWithoutAttachmentsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutAttachmentsInput, TicketUpdateWithoutAttachmentsInput>, TicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TicketCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCommentsInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketCommentsInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCommentsInput
    upsert?: TicketUpsertWithoutCommentsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutCommentsInput, TicketUpdateWithoutCommentsInput>, TicketUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutTicketCommentsNestedInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    upsert?: UserUpsertWithoutTicketCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketCommentsInput, UserUpdateWithoutTicketCommentsInput>, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type TicketCreateNestedManyWithoutTagsInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUpdateManyWithoutTagsNestedInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTagsInput | TicketUpsertWithWhereUniqueWithoutTagsInput[]
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTagsInput | TicketUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTagsInput | TicketUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTagsInput | TicketUpsertWithWhereUniqueWithoutTagsInput[]
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTagsInput | TicketUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTagsInput | TicketUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    upsert?: MessageUpsertWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAttachmentsInput, MessageUpdateWithoutAttachmentsInput>, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActivityStatusFieldUpdateOperationsInput = {
    set?: $Enums.ActivityStatus
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }

  export type NestedEnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumQueryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusFilter<$PrismaModel> | $Enums.QueryStatus
  }

  export type NestedEnumQueryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueryStatusFilter<$PrismaModel>
    _max?: NestedEnumQueryStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedEnumActivityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusFilter<$PrismaModel> | $Enums.ActivityStatus
  }

  export type NestedEnumActivityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActivityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityStatusFilter<$PrismaModel>
    _max?: NestedEnumActivityStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserCreateWithoutGivenRatingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutGivenRatingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutGivenRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
  }

  export type UserCreateWithoutReceivedRatingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutReceivedRatingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutReceivedRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
  }

  export type UserUpsertWithoutGivenRatingsInput = {
    update: XOR<UserUpdateWithoutGivenRatingsInput, UserUncheckedUpdateWithoutGivenRatingsInput>
    create: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGivenRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGivenRatingsInput, UserUncheckedUpdateWithoutGivenRatingsInput>
  }

  export type UserUpdateWithoutGivenRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutGivenRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUpsertWithoutReceivedRatingsInput = {
    update: XOR<UserUpdateWithoutReceivedRatingsInput, UserUncheckedUpdateWithoutReceivedRatingsInput>
    create: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedRatingsInput, UserUncheckedUpdateWithoutReceivedRatingsInput>
  }

  export type UserUpdateWithoutReceivedRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type QueryCreateWithoutConversationInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    parsedData?: ParsedQueryDataCreateNestedManyWithoutQueryInput
    parsedPieData?: ParsedPieGraphDataCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryCreateNestedManyWithoutQueryInput
    user: UserCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateWithoutConversationInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    parsedData?: ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput
    parsedPieData?: ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutConversationInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput>
  }

  export type QueryCreateManyConversationInputEnvelope = {
    data: QueryCreateManyConversationInput | QueryCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type GaAccountCreateWithoutConversationsInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    user: UserCreateNestedOneWithoutGaAccountsInput
    gaProperties?: GaPropertyCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountUncheckedCreateWithoutConversationsInput = {
    id?: string
    userId: string
    gaAccountId: string
    gaAccountName: string
    gaProperties?: GaPropertyUncheckedCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountCreateOrConnectWithoutConversationsInput = {
    where: GaAccountWhereUniqueInput
    create: XOR<GaAccountCreateWithoutConversationsInput, GaAccountUncheckedCreateWithoutConversationsInput>
  }

  export type GaPropertyCreateWithoutConversationsInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutConversationsInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutConversationsInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutConversationsInput, GaPropertyUncheckedCreateWithoutConversationsInput>
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type QueryUpsertWithWhereUniqueWithoutConversationInput = {
    where: QueryWhereUniqueInput
    update: XOR<QueryUpdateWithoutConversationInput, QueryUncheckedUpdateWithoutConversationInput>
    create: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput>
  }

  export type QueryUpdateWithWhereUniqueWithoutConversationInput = {
    where: QueryWhereUniqueInput
    data: XOR<QueryUpdateWithoutConversationInput, QueryUncheckedUpdateWithoutConversationInput>
  }

  export type QueryUpdateManyWithWhereWithoutConversationInput = {
    where: QueryScalarWhereInput
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyWithoutConversationInput>
  }

  export type QueryScalarWhereInput = {
    AND?: QueryScalarWhereInput | QueryScalarWhereInput[]
    OR?: QueryScalarWhereInput[]
    NOT?: QueryScalarWhereInput | QueryScalarWhereInput[]
    id?: StringFilter<"Query"> | string
    content?: StringFilter<"Query"> | string
    response?: StringNullableFilter<"Query"> | string | null
    status?: EnumQueryStatusFilter<"Query"> | $Enums.QueryStatus
    rating?: IntFilter<"Query"> | number
    metadata?: JsonNullableFilter<"Query">
    lineGraphData?: JsonNullableFilter<"Query">
    pieGraphData?: JsonNullableFilter<"Query">
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
    userId?: StringFilter<"Query"> | string
    conversationId?: StringNullableFilter<"Query"> | string | null
  }

  export type GaAccountUpsertWithoutConversationsInput = {
    update: XOR<GaAccountUpdateWithoutConversationsInput, GaAccountUncheckedUpdateWithoutConversationsInput>
    create: XOR<GaAccountCreateWithoutConversationsInput, GaAccountUncheckedCreateWithoutConversationsInput>
    where?: GaAccountWhereInput
  }

  export type GaAccountUpdateToOneWithWhereWithoutConversationsInput = {
    where?: GaAccountWhereInput
    data: XOR<GaAccountUpdateWithoutConversationsInput, GaAccountUncheckedUpdateWithoutConversationsInput>
  }

  export type GaAccountUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutGaAccountsNestedInput
    gaProperties?: GaPropertyUpdateManyWithoutGaAccountNestedInput
  }

  export type GaAccountUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    gaProperties?: GaPropertyUncheckedUpdateManyWithoutGaAccountNestedInput
  }

  export type GaPropertyUpsertWithoutConversationsInput = {
    update: XOR<GaPropertyUpdateWithoutConversationsInput, GaPropertyUncheckedUpdateWithoutConversationsInput>
    create: XOR<GaPropertyCreateWithoutConversationsInput, GaPropertyUncheckedCreateWithoutConversationsInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutConversationsInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutConversationsInput, GaPropertyUncheckedUpdateWithoutConversationsInput>
  }

  export type GaPropertyUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type UserCreateWithoutGaAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutGaAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutGaAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGaAccountsInput, UserUncheckedCreateWithoutGaAccountsInput>
  }

  export type GaPropertyCreateWithoutGaAccountInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutGaAccountInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutGaAccountInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput>
  }

  export type GaPropertyCreateManyGaAccountInputEnvelope = {
    data: GaPropertyCreateManyGaAccountInput | GaPropertyCreateManyGaAccountInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutGaAccountInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    queries?: QueryCreateNestedManyWithoutConversationInput
    gaProperty?: GaPropertyCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutGaAccountInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gaPropertyId?: string | null
    userId: string
    queries?: QueryUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutGaAccountInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput>
  }

  export type ConversationCreateManyGaAccountInputEnvelope = {
    data: ConversationCreateManyGaAccountInput | ConversationCreateManyGaAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutGaAccountsInput = {
    update: XOR<UserUpdateWithoutGaAccountsInput, UserUncheckedUpdateWithoutGaAccountsInput>
    create: XOR<UserCreateWithoutGaAccountsInput, UserUncheckedCreateWithoutGaAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGaAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGaAccountsInput, UserUncheckedUpdateWithoutGaAccountsInput>
  }

  export type UserUpdateWithoutGaAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutGaAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type GaPropertyUpsertWithWhereUniqueWithoutGaAccountInput = {
    where: GaPropertyWhereUniqueInput
    update: XOR<GaPropertyUpdateWithoutGaAccountInput, GaPropertyUncheckedUpdateWithoutGaAccountInput>
    create: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput>
  }

  export type GaPropertyUpdateWithWhereUniqueWithoutGaAccountInput = {
    where: GaPropertyWhereUniqueInput
    data: XOR<GaPropertyUpdateWithoutGaAccountInput, GaPropertyUncheckedUpdateWithoutGaAccountInput>
  }

  export type GaPropertyUpdateManyWithWhereWithoutGaAccountInput = {
    where: GaPropertyScalarWhereInput
    data: XOR<GaPropertyUpdateManyMutationInput, GaPropertyUncheckedUpdateManyWithoutGaAccountInput>
  }

  export type GaPropertyScalarWhereInput = {
    AND?: GaPropertyScalarWhereInput | GaPropertyScalarWhereInput[]
    OR?: GaPropertyScalarWhereInput[]
    NOT?: GaPropertyScalarWhereInput | GaPropertyScalarWhereInput[]
    id?: StringFilter<"GaProperty"> | string
    gaPropertyId?: StringFilter<"GaProperty"> | string
    gaPropertyName?: StringFilter<"GaProperty"> | string
    gaAccountId?: StringFilter<"GaProperty"> | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutGaAccountInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutGaAccountInput, ConversationUncheckedUpdateWithoutGaAccountInput>
    create: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutGaAccountInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutGaAccountInput, ConversationUncheckedUpdateWithoutGaAccountInput>
  }

  export type ConversationUpdateManyWithWhereWithoutGaAccountInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutGaAccountInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    description?: StringNullableFilter<"Conversation"> | string | null
    isStarred?: BoolFilter<"Conversation"> | boolean
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    gaAccountId?: StringNullableFilter<"Conversation"> | string | null
    gaPropertyId?: StringNullableFilter<"Conversation"> | string | null
    userId?: StringFilter<"Conversation"> | string
  }

  export type GaAccountCreateWithoutGaPropertiesInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    user: UserCreateNestedOneWithoutGaAccountsInput
    conversations?: ConversationCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountUncheckedCreateWithoutGaPropertiesInput = {
    id?: string
    userId: string
    gaAccountId: string
    gaAccountName: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountCreateOrConnectWithoutGaPropertiesInput = {
    where: GaAccountWhereUniqueInput
    create: XOR<GaAccountCreateWithoutGaPropertiesInput, GaAccountUncheckedCreateWithoutGaPropertiesInput>
  }

  export type ConversationCreateWithoutGaPropertyInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    queries?: QueryCreateNestedManyWithoutConversationInput
    gaAccount?: GaAccountCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gaAccountId?: string | null
    userId: string
    queries?: QueryUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutGaPropertyInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput>
  }

  export type ConversationCreateManyGaPropertyInputEnvelope = {
    data: ConversationCreateManyGaPropertyInput | ConversationCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type GaImportRunCreateWithoutGaPropertyInput = {
    id?: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedBy: UserCreateNestedOneWithoutGaImportRunsInput
  }

  export type GaImportRunUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    requestedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaImportRunCreateOrConnectWithoutGaPropertyInput = {
    where: GaImportRunWhereUniqueInput
    create: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaImportRunCreateManyGaPropertyInputEnvelope = {
    data: GaImportRunCreateManyGaPropertyInput | GaImportRunCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type GaKpiDailyCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaKpiDailyUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaKpiDailyCreateOrConnectWithoutGaPropertyInput = {
    where: GaKpiDailyWhereUniqueInput
    create: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaKpiDailyCreateManyGaPropertyInputEnvelope = {
    data: GaKpiDailyCreateManyGaPropertyInput | GaKpiDailyCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type GaKpiMonthlyCreateWithoutGaPropertyInput = {
    id?: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput = {
    where: GaKpiMonthlyWhereUniqueInput
    create: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaKpiMonthlyCreateManyGaPropertyInputEnvelope = {
    data: GaKpiMonthlyCreateManyGaPropertyInput | GaKpiMonthlyCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type GaChannelDailyCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaChannelDailyUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaChannelDailyCreateOrConnectWithoutGaPropertyInput = {
    where: GaChannelDailyWhereUniqueInput
    create: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaChannelDailyCreateManyGaPropertyInputEnvelope = {
    data: GaChannelDailyCreateManyGaPropertyInput | GaChannelDailyCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type GaSourceDailyCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaSourceDailyUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaSourceDailyCreateOrConnectWithoutGaPropertyInput = {
    where: GaSourceDailyWhereUniqueInput
    create: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaSourceDailyCreateManyGaPropertyInputEnvelope = {
    data: GaSourceDailyCreateManyGaPropertyInput | GaSourceDailyCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type GaAccountUpsertWithoutGaPropertiesInput = {
    update: XOR<GaAccountUpdateWithoutGaPropertiesInput, GaAccountUncheckedUpdateWithoutGaPropertiesInput>
    create: XOR<GaAccountCreateWithoutGaPropertiesInput, GaAccountUncheckedCreateWithoutGaPropertiesInput>
    where?: GaAccountWhereInput
  }

  export type GaAccountUpdateToOneWithWhereWithoutGaPropertiesInput = {
    where?: GaAccountWhereInput
    data: XOR<GaAccountUpdateWithoutGaPropertiesInput, GaAccountUncheckedUpdateWithoutGaPropertiesInput>
  }

  export type GaAccountUpdateWithoutGaPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutGaAccountsNestedInput
    conversations?: ConversationUpdateManyWithoutGaAccountNestedInput
  }

  export type GaAccountUncheckedUpdateWithoutGaPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaAccountNestedInput
  }

  export type ConversationUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutGaPropertyInput, ConversationUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutGaPropertyInput, ConversationUncheckedUpdateWithoutGaPropertyInput>
  }

  export type ConversationUpdateManyWithWhereWithoutGaPropertyInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaImportRunUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: GaImportRunWhereUniqueInput
    update: XOR<GaImportRunUpdateWithoutGaPropertyInput, GaImportRunUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaImportRunUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: GaImportRunWhereUniqueInput
    data: XOR<GaImportRunUpdateWithoutGaPropertyInput, GaImportRunUncheckedUpdateWithoutGaPropertyInput>
  }

  export type GaImportRunUpdateManyWithWhereWithoutGaPropertyInput = {
    where: GaImportRunScalarWhereInput
    data: XOR<GaImportRunUpdateManyMutationInput, GaImportRunUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaImportRunScalarWhereInput = {
    AND?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
    OR?: GaImportRunScalarWhereInput[]
    NOT?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
    id?: StringFilter<"GaImportRun"> | string
    gaPropertyId?: StringFilter<"GaImportRun"> | string
    dateStart?: DateTimeFilter<"GaImportRun"> | Date | string
    dateEnd?: DateTimeFilter<"GaImportRun"> | Date | string
    status?: EnumImportStatusFilter<"GaImportRun"> | $Enums.ImportStatus
    errorMessage?: StringNullableFilter<"GaImportRun"> | string | null
    requestedByUserId?: StringFilter<"GaImportRun"> | string
    createdAt?: DateTimeFilter<"GaImportRun"> | Date | string
    updatedAt?: DateTimeFilter<"GaImportRun"> | Date | string
  }

  export type GaKpiDailyUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: GaKpiDailyWhereUniqueInput
    update: XOR<GaKpiDailyUpdateWithoutGaPropertyInput, GaKpiDailyUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaKpiDailyUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: GaKpiDailyWhereUniqueInput
    data: XOR<GaKpiDailyUpdateWithoutGaPropertyInput, GaKpiDailyUncheckedUpdateWithoutGaPropertyInput>
  }

  export type GaKpiDailyUpdateManyWithWhereWithoutGaPropertyInput = {
    where: GaKpiDailyScalarWhereInput
    data: XOR<GaKpiDailyUpdateManyMutationInput, GaKpiDailyUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaKpiDailyScalarWhereInput = {
    AND?: GaKpiDailyScalarWhereInput | GaKpiDailyScalarWhereInput[]
    OR?: GaKpiDailyScalarWhereInput[]
    NOT?: GaKpiDailyScalarWhereInput | GaKpiDailyScalarWhereInput[]
    id?: StringFilter<"GaKpiDaily"> | string
    gaPropertyId?: StringFilter<"GaKpiDaily"> | string
    date?: DateTimeFilter<"GaKpiDaily"> | Date | string
    sessions?: IntFilter<"GaKpiDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiDaily"> | number
    engagementRate?: FloatFilter<"GaKpiDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiDaily"> | number
    goalCompletions?: IntFilter<"GaKpiDaily"> | number
    goalCompletionRate?: FloatFilter<"GaKpiDaily"> | number
    createdAt?: DateTimeFilter<"GaKpiDaily"> | Date | string
  }

  export type GaKpiMonthlyUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: GaKpiMonthlyWhereUniqueInput
    update: XOR<GaKpiMonthlyUpdateWithoutGaPropertyInput, GaKpiMonthlyUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaKpiMonthlyUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: GaKpiMonthlyWhereUniqueInput
    data: XOR<GaKpiMonthlyUpdateWithoutGaPropertyInput, GaKpiMonthlyUncheckedUpdateWithoutGaPropertyInput>
  }

  export type GaKpiMonthlyUpdateManyWithWhereWithoutGaPropertyInput = {
    where: GaKpiMonthlyScalarWhereInput
    data: XOR<GaKpiMonthlyUpdateManyMutationInput, GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaKpiMonthlyScalarWhereInput = {
    AND?: GaKpiMonthlyScalarWhereInput | GaKpiMonthlyScalarWhereInput[]
    OR?: GaKpiMonthlyScalarWhereInput[]
    NOT?: GaKpiMonthlyScalarWhereInput | GaKpiMonthlyScalarWhereInput[]
    id?: StringFilter<"GaKpiMonthly"> | string
    gaPropertyId?: StringFilter<"GaKpiMonthly"> | string
    month?: IntFilter<"GaKpiMonthly"> | number
    sessions?: IntFilter<"GaKpiMonthly"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiMonthly"> | number
    engagementRate?: FloatFilter<"GaKpiMonthly"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiMonthly"> | number
    goalCompletions?: IntFilter<"GaKpiMonthly"> | number
    goalCompletionRate?: FloatFilter<"GaKpiMonthly"> | number
    createdAt?: DateTimeFilter<"GaKpiMonthly"> | Date | string
  }

  export type GaChannelDailyUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: GaChannelDailyWhereUniqueInput
    update: XOR<GaChannelDailyUpdateWithoutGaPropertyInput, GaChannelDailyUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaChannelDailyUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: GaChannelDailyWhereUniqueInput
    data: XOR<GaChannelDailyUpdateWithoutGaPropertyInput, GaChannelDailyUncheckedUpdateWithoutGaPropertyInput>
  }

  export type GaChannelDailyUpdateManyWithWhereWithoutGaPropertyInput = {
    where: GaChannelDailyScalarWhereInput
    data: XOR<GaChannelDailyUpdateManyMutationInput, GaChannelDailyUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaChannelDailyScalarWhereInput = {
    AND?: GaChannelDailyScalarWhereInput | GaChannelDailyScalarWhereInput[]
    OR?: GaChannelDailyScalarWhereInput[]
    NOT?: GaChannelDailyScalarWhereInput | GaChannelDailyScalarWhereInput[]
    id?: StringFilter<"GaChannelDaily"> | string
    gaPropertyId?: StringFilter<"GaChannelDaily"> | string
    date?: DateTimeFilter<"GaChannelDaily"> | Date | string
    channelGroup?: StringFilter<"GaChannelDaily"> | string
    sessions?: IntFilter<"GaChannelDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaChannelDaily"> | number
    engagementRate?: FloatFilter<"GaChannelDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaChannelDaily"> | number
    goalCompletions?: IntFilter<"GaChannelDaily"> | number
    goalCompletionRate?: FloatFilter<"GaChannelDaily"> | number
    createdAt?: DateTimeFilter<"GaChannelDaily"> | Date | string
  }

  export type GaSourceDailyUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: GaSourceDailyWhereUniqueInput
    update: XOR<GaSourceDailyUpdateWithoutGaPropertyInput, GaSourceDailyUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaSourceDailyUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: GaSourceDailyWhereUniqueInput
    data: XOR<GaSourceDailyUpdateWithoutGaPropertyInput, GaSourceDailyUncheckedUpdateWithoutGaPropertyInput>
  }

  export type GaSourceDailyUpdateManyWithWhereWithoutGaPropertyInput = {
    where: GaSourceDailyScalarWhereInput
    data: XOR<GaSourceDailyUpdateManyMutationInput, GaSourceDailyUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaSourceDailyScalarWhereInput = {
    AND?: GaSourceDailyScalarWhereInput | GaSourceDailyScalarWhereInput[]
    OR?: GaSourceDailyScalarWhereInput[]
    NOT?: GaSourceDailyScalarWhereInput | GaSourceDailyScalarWhereInput[]
    id?: StringFilter<"GaSourceDaily"> | string
    gaPropertyId?: StringFilter<"GaSourceDaily"> | string
    date?: DateTimeFilter<"GaSourceDaily"> | Date | string
    trafficSource?: StringFilter<"GaSourceDaily"> | string
    sessions?: IntFilter<"GaSourceDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaSourceDaily"> | number
    engagementRate?: FloatFilter<"GaSourceDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaSourceDaily"> | number
    goalCompletions?: IntFilter<"GaSourceDaily"> | number
    goalCompletionRate?: FloatFilter<"GaSourceDaily"> | number
    createdAt?: DateTimeFilter<"GaSourceDaily"> | Date | string
  }

  export type GaPropertyCreateWithoutImportsInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutImportsInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutImportsInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutImportsInput, GaPropertyUncheckedCreateWithoutImportsInput>
  }

  export type UserCreateWithoutGaImportRunsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGaImportRunsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGaImportRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGaImportRunsInput, UserUncheckedCreateWithoutGaImportRunsInput>
  }

  export type GaPropertyUpsertWithoutImportsInput = {
    update: XOR<GaPropertyUpdateWithoutImportsInput, GaPropertyUncheckedUpdateWithoutImportsInput>
    create: XOR<GaPropertyCreateWithoutImportsInput, GaPropertyUncheckedCreateWithoutImportsInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutImportsInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutImportsInput, GaPropertyUncheckedUpdateWithoutImportsInput>
  }

  export type GaPropertyUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type UserUpsertWithoutGaImportRunsInput = {
    update: XOR<UserUpdateWithoutGaImportRunsInput, UserUncheckedUpdateWithoutGaImportRunsInput>
    create: XOR<UserCreateWithoutGaImportRunsInput, UserUncheckedCreateWithoutGaImportRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGaImportRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGaImportRunsInput, UserUncheckedUpdateWithoutGaImportRunsInput>
  }

  export type UserUpdateWithoutGaImportRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGaImportRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GaPropertyCreateWithoutKpiDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutKpiDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutKpiDailyInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutKpiDailyInput, GaPropertyUncheckedCreateWithoutKpiDailyInput>
  }

  export type GaPropertyUpsertWithoutKpiDailyInput = {
    update: XOR<GaPropertyUpdateWithoutKpiDailyInput, GaPropertyUncheckedUpdateWithoutKpiDailyInput>
    create: XOR<GaPropertyCreateWithoutKpiDailyInput, GaPropertyUncheckedCreateWithoutKpiDailyInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutKpiDailyInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutKpiDailyInput, GaPropertyUncheckedUpdateWithoutKpiDailyInput>
  }

  export type GaPropertyUpdateWithoutKpiDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutKpiDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyCreateWithoutKpiMonthlyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutKpiMonthlyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutKpiMonthlyInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutKpiMonthlyInput, GaPropertyUncheckedCreateWithoutKpiMonthlyInput>
  }

  export type GaPropertyUpsertWithoutKpiMonthlyInput = {
    update: XOR<GaPropertyUpdateWithoutKpiMonthlyInput, GaPropertyUncheckedUpdateWithoutKpiMonthlyInput>
    create: XOR<GaPropertyCreateWithoutKpiMonthlyInput, GaPropertyUncheckedCreateWithoutKpiMonthlyInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutKpiMonthlyInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutKpiMonthlyInput, GaPropertyUncheckedUpdateWithoutKpiMonthlyInput>
  }

  export type GaPropertyUpdateWithoutKpiMonthlyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutKpiMonthlyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyCreateWithoutChannelDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutChannelDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutChannelDailyInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutChannelDailyInput, GaPropertyUncheckedCreateWithoutChannelDailyInput>
  }

  export type GaPropertyUpsertWithoutChannelDailyInput = {
    update: XOR<GaPropertyUpdateWithoutChannelDailyInput, GaPropertyUncheckedUpdateWithoutChannelDailyInput>
    create: XOR<GaPropertyCreateWithoutChannelDailyInput, GaPropertyUncheckedCreateWithoutChannelDailyInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutChannelDailyInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutChannelDailyInput, GaPropertyUncheckedUpdateWithoutChannelDailyInput>
  }

  export type GaPropertyUpdateWithoutChannelDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutChannelDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyCreateWithoutSourceDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutSourceDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutSourceDailyInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutSourceDailyInput, GaPropertyUncheckedCreateWithoutSourceDailyInput>
  }

  export type GaPropertyUpsertWithoutSourceDailyInput = {
    update: XOR<GaPropertyUpdateWithoutSourceDailyInput, GaPropertyUncheckedUpdateWithoutSourceDailyInput>
    create: XOR<GaPropertyCreateWithoutSourceDailyInput, GaPropertyUncheckedCreateWithoutSourceDailyInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutSourceDailyInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutSourceDailyInput, GaPropertyUncheckedUpdateWithoutSourceDailyInput>
  }

  export type GaPropertyUpdateWithoutSourceDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutSourceDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    roleId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    accountRepId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type MessageCreateWithoutRepliesInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    parent?: MessageCreateNestedOneWithoutRepliesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutRepliesInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    recipientId: string
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutRepliesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
  }

  export type MessageCreateWithoutParentInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    replies?: MessageCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutParentInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    recipientId: string
    replies?: MessageUncheckedCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutParentInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput>
  }

  export type MessageCreateManyParentInputEnvelope = {
    data: MessageCreateManyParentInput | MessageCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type MessageAttachmentCreateWithoutMessageInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
  }

  export type MessageAttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
  }

  export type MessageAttachmentCreateOrConnectWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentCreateManyMessageInputEnvelope = {
    data: MessageAttachmentCreateManyMessageInput | MessageAttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type MessageUpsertWithoutRepliesInput = {
    update: XOR<MessageUpdateWithoutRepliesInput, MessageUncheckedUpdateWithoutRepliesInput>
    create: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutRepliesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutRepliesInput, MessageUncheckedUpdateWithoutRepliesInput>
  }

  export type MessageUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    parent?: MessageUpdateOneWithoutRepliesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutParentInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutParentInput, MessageUncheckedUpdateWithoutParentInput>
    create: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutParentInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutParentInput, MessageUncheckedUpdateWithoutParentInput>
  }

  export type MessageUpdateManyWithWhereWithoutParentInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutParentInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    archived?: BoolFilter<"Message"> | boolean
    isThreadStart?: BoolFilter<"Message"> | boolean
    threadId?: StringNullableFilter<"Message"> | string | null
    parentId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
  }

  export type MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    update: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    data: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: MessageAttachmentScalarWhereInput
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageAttachmentScalarWhereInput = {
    AND?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    OR?: MessageAttachmentScalarWhereInput[]
    NOT?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    filename?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    mimeType?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    messageId?: StringFilter<"MessageAttachment"> | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type QueryCreateWithoutParsedPieDataInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    parsedData?: ParsedQueryDataCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryCreateNestedManyWithoutQueryInput
    user: UserCreateNestedOneWithoutQueriesInput
    conversation?: ConversationCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateWithoutParsedPieDataInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    conversationId?: string | null
    parsedData?: ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutParsedPieDataInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutParsedPieDataInput, QueryUncheckedCreateWithoutParsedPieDataInput>
  }

  export type QueryUpsertWithoutParsedPieDataInput = {
    update: XOR<QueryUpdateWithoutParsedPieDataInput, QueryUncheckedUpdateWithoutParsedPieDataInput>
    create: XOR<QueryCreateWithoutParsedPieDataInput, QueryUncheckedCreateWithoutParsedPieDataInput>
    where?: QueryWhereInput
  }

  export type QueryUpdateToOneWithWhereWithoutParsedPieDataInput = {
    where?: QueryWhereInput
    data: XOR<QueryUpdateWithoutParsedPieDataInput, QueryUncheckedUpdateWithoutParsedPieDataInput>
  }

  export type QueryUpdateWithoutParsedPieDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parsedData?: ParsedQueryDataUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUpdateManyWithoutQueryNestedInput
    user?: UserUpdateOneRequiredWithoutQueriesNestedInput
    conversation?: ConversationUpdateOneWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateWithoutParsedPieDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedData?: ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryCreateWithoutParsedDataInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    parsedPieData?: ParsedPieGraphDataCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryCreateNestedManyWithoutQueryInput
    user: UserCreateNestedOneWithoutQueriesInput
    conversation?: ConversationCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateWithoutParsedDataInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    conversationId?: string | null
    parsedPieData?: ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutParsedDataInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutParsedDataInput, QueryUncheckedCreateWithoutParsedDataInput>
  }

  export type QueryUpsertWithoutParsedDataInput = {
    update: XOR<QueryUpdateWithoutParsedDataInput, QueryUncheckedUpdateWithoutParsedDataInput>
    create: XOR<QueryCreateWithoutParsedDataInput, QueryUncheckedCreateWithoutParsedDataInput>
    where?: QueryWhereInput
  }

  export type QueryUpdateToOneWithWhereWithoutParsedDataInput = {
    where?: QueryWhereInput
    data: XOR<QueryUpdateWithoutParsedDataInput, QueryUncheckedUpdateWithoutParsedDataInput>
  }

  export type QueryUpdateWithoutParsedDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parsedPieData?: ParsedPieGraphDataUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUpdateManyWithoutQueryNestedInput
    user?: UserUpdateOneRequiredWithoutQueriesNestedInput
    conversation?: ConversationUpdateOneWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateWithoutParsedDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedPieData?: ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryCreateWithoutParsedSummaryInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    parsedData?: ParsedQueryDataCreateNestedManyWithoutQueryInput
    parsedPieData?: ParsedPieGraphDataCreateNestedManyWithoutQueryInput
    user: UserCreateNestedOneWithoutQueriesInput
    conversation?: ConversationCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateWithoutParsedSummaryInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    conversationId?: string | null
    parsedData?: ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput
    parsedPieData?: ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutParsedSummaryInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutParsedSummaryInput, QueryUncheckedCreateWithoutParsedSummaryInput>
  }

  export type QueryUpsertWithoutParsedSummaryInput = {
    update: XOR<QueryUpdateWithoutParsedSummaryInput, QueryUncheckedUpdateWithoutParsedSummaryInput>
    create: XOR<QueryCreateWithoutParsedSummaryInput, QueryUncheckedCreateWithoutParsedSummaryInput>
    where?: QueryWhereInput
  }

  export type QueryUpdateToOneWithWhereWithoutParsedSummaryInput = {
    where?: QueryWhereInput
    data: XOR<QueryUpdateWithoutParsedSummaryInput, QueryUncheckedUpdateWithoutParsedSummaryInput>
  }

  export type QueryUpdateWithoutParsedSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parsedData?: ParsedQueryDataUpdateManyWithoutQueryNestedInput
    parsedPieData?: ParsedPieGraphDataUpdateManyWithoutQueryNestedInput
    user?: UserUpdateOneRequiredWithoutQueriesNestedInput
    conversation?: ConversationUpdateOneWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateWithoutParsedSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedData?: ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedPieData?: ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type ParsedQueryDataCreateWithoutQueryInput = {
    id?: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    engagedSessions?: number | null
    bounceRate?: number | null
    newUsers?: number | null
  }

  export type ParsedQueryDataUncheckedCreateWithoutQueryInput = {
    id?: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    engagedSessions?: number | null
    bounceRate?: number | null
    newUsers?: number | null
  }

  export type ParsedQueryDataCreateOrConnectWithoutQueryInput = {
    where: ParsedQueryDataWhereUniqueInput
    create: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput>
  }

  export type ParsedQueryDataCreateManyQueryInputEnvelope = {
    data: ParsedQueryDataCreateManyQueryInput | ParsedQueryDataCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type ParsedPieGraphDataCreateWithoutQueryInput = {
    id?: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
  }

  export type ParsedPieGraphDataUncheckedCreateWithoutQueryInput = {
    id?: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
  }

  export type ParsedPieGraphDataCreateOrConnectWithoutQueryInput = {
    where: ParsedPieGraphDataWhereUniqueInput
    create: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput>
  }

  export type ParsedPieGraphDataCreateManyQueryInputEnvelope = {
    data: ParsedPieGraphDataCreateManyQueryInput | ParsedPieGraphDataCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type ParsedQuerySummaryCreateWithoutQueryInput = {
    id?: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
  }

  export type ParsedQuerySummaryUncheckedCreateWithoutQueryInput = {
    id?: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
  }

  export type ParsedQuerySummaryCreateOrConnectWithoutQueryInput = {
    where: ParsedQuerySummaryWhereUniqueInput
    create: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput>
  }

  export type ParsedQuerySummaryCreateManyQueryInputEnvelope = {
    data: ParsedQuerySummaryCreateManyQueryInput | ParsedQuerySummaryCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutQueriesInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutQueriesInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutQueriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
  }

  export type ConversationCreateWithoutQueriesInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    gaAccount?: GaAccountCreateNestedOneWithoutConversationsInput
    gaProperty?: GaPropertyCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutQueriesInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gaAccountId?: string | null
    gaPropertyId?: string | null
    userId: string
  }

  export type ConversationCreateOrConnectWithoutQueriesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutQueriesInput, ConversationUncheckedCreateWithoutQueriesInput>
  }

  export type ParsedQueryDataUpsertWithWhereUniqueWithoutQueryInput = {
    where: ParsedQueryDataWhereUniqueInput
    update: XOR<ParsedQueryDataUpdateWithoutQueryInput, ParsedQueryDataUncheckedUpdateWithoutQueryInput>
    create: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput>
  }

  export type ParsedQueryDataUpdateWithWhereUniqueWithoutQueryInput = {
    where: ParsedQueryDataWhereUniqueInput
    data: XOR<ParsedQueryDataUpdateWithoutQueryInput, ParsedQueryDataUncheckedUpdateWithoutQueryInput>
  }

  export type ParsedQueryDataUpdateManyWithWhereWithoutQueryInput = {
    where: ParsedQueryDataScalarWhereInput
    data: XOR<ParsedQueryDataUpdateManyMutationInput, ParsedQueryDataUncheckedUpdateManyWithoutQueryInput>
  }

  export type ParsedQueryDataScalarWhereInput = {
    AND?: ParsedQueryDataScalarWhereInput | ParsedQueryDataScalarWhereInput[]
    OR?: ParsedQueryDataScalarWhereInput[]
    NOT?: ParsedQueryDataScalarWhereInput | ParsedQueryDataScalarWhereInput[]
    id?: StringFilter<"ParsedQueryData"> | string
    queryId?: StringFilter<"ParsedQueryData"> | string
    date?: DateTimeFilter<"ParsedQueryData"> | Date | string
    channel?: StringFilter<"ParsedQueryData"> | string
    source?: StringFilter<"ParsedQueryData"> | string
    sessions?: IntFilter<"ParsedQueryData"> | number
    conversionRate?: FloatFilter<"ParsedQueryData"> | number
    conversions?: IntFilter<"ParsedQueryData"> | number
    bounces?: IntFilter<"ParsedQueryData"> | number
    createdAt?: DateTimeFilter<"ParsedQueryData"> | Date | string
    engagedSessions?: IntNullableFilter<"ParsedQueryData"> | number | null
    bounceRate?: FloatNullableFilter<"ParsedQueryData"> | number | null
    newUsers?: IntNullableFilter<"ParsedQueryData"> | number | null
  }

  export type ParsedPieGraphDataUpsertWithWhereUniqueWithoutQueryInput = {
    where: ParsedPieGraphDataWhereUniqueInput
    update: XOR<ParsedPieGraphDataUpdateWithoutQueryInput, ParsedPieGraphDataUncheckedUpdateWithoutQueryInput>
    create: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput>
  }

  export type ParsedPieGraphDataUpdateWithWhereUniqueWithoutQueryInput = {
    where: ParsedPieGraphDataWhereUniqueInput
    data: XOR<ParsedPieGraphDataUpdateWithoutQueryInput, ParsedPieGraphDataUncheckedUpdateWithoutQueryInput>
  }

  export type ParsedPieGraphDataUpdateManyWithWhereWithoutQueryInput = {
    where: ParsedPieGraphDataScalarWhereInput
    data: XOR<ParsedPieGraphDataUpdateManyMutationInput, ParsedPieGraphDataUncheckedUpdateManyWithoutQueryInput>
  }

  export type ParsedPieGraphDataScalarWhereInput = {
    AND?: ParsedPieGraphDataScalarWhereInput | ParsedPieGraphDataScalarWhereInput[]
    OR?: ParsedPieGraphDataScalarWhereInput[]
    NOT?: ParsedPieGraphDataScalarWhereInput | ParsedPieGraphDataScalarWhereInput[]
    id?: StringFilter<"ParsedPieGraphData"> | string
    queryId?: StringFilter<"ParsedPieGraphData"> | string
    channel?: StringFilter<"ParsedPieGraphData"> | string
    source?: StringFilter<"ParsedPieGraphData"> | string
    sessions?: IntFilter<"ParsedPieGraphData"> | number
    conversionRate?: FloatFilter<"ParsedPieGraphData"> | number
    conversions?: IntFilter<"ParsedPieGraphData"> | number
    bounces?: IntFilter<"ParsedPieGraphData"> | number
    prevSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    createdAt?: DateTimeFilter<"ParsedPieGraphData"> | Date | string
  }

  export type ParsedQuerySummaryUpsertWithWhereUniqueWithoutQueryInput = {
    where: ParsedQuerySummaryWhereUniqueInput
    update: XOR<ParsedQuerySummaryUpdateWithoutQueryInput, ParsedQuerySummaryUncheckedUpdateWithoutQueryInput>
    create: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput>
  }

  export type ParsedQuerySummaryUpdateWithWhereUniqueWithoutQueryInput = {
    where: ParsedQuerySummaryWhereUniqueInput
    data: XOR<ParsedQuerySummaryUpdateWithoutQueryInput, ParsedQuerySummaryUncheckedUpdateWithoutQueryInput>
  }

  export type ParsedQuerySummaryUpdateManyWithWhereWithoutQueryInput = {
    where: ParsedQuerySummaryScalarWhereInput
    data: XOR<ParsedQuerySummaryUpdateManyMutationInput, ParsedQuerySummaryUncheckedUpdateManyWithoutQueryInput>
  }

  export type ParsedQuerySummaryScalarWhereInput = {
    AND?: ParsedQuerySummaryScalarWhereInput | ParsedQuerySummaryScalarWhereInput[]
    OR?: ParsedQuerySummaryScalarWhereInput[]
    NOT?: ParsedQuerySummaryScalarWhereInput | ParsedQuerySummaryScalarWhereInput[]
    id?: StringFilter<"ParsedQuerySummary"> | string
    queryId?: StringFilter<"ParsedQuerySummary"> | string
    date?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
    totalEngagedSessions?: IntFilter<"ParsedQuerySummary"> | number
    averageBounceRate?: FloatFilter<"ParsedQuerySummary"> | number
    totalNewUsers?: IntFilter<"ParsedQuerySummary"> | number
    totalConversions?: IntFilter<"ParsedQuerySummary"> | number
    createdAt?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
  }

  export type UserUpsertWithoutQueriesInput = {
    update: XOR<UserUpdateWithoutQueriesInput, UserUncheckedUpdateWithoutQueriesInput>
    create: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQueriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQueriesInput, UserUncheckedUpdateWithoutQueriesInput>
  }

  export type UserUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type ConversationUpsertWithoutQueriesInput = {
    update: XOR<ConversationUpdateWithoutQueriesInput, ConversationUncheckedUpdateWithoutQueriesInput>
    create: XOR<ConversationCreateWithoutQueriesInput, ConversationUncheckedCreateWithoutQueriesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutQueriesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutQueriesInput, ConversationUncheckedUpdateWithoutQueriesInput>
  }

  export type ConversationUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    gaAccount?: GaAccountUpdateOneWithoutConversationsNestedInput
    gaProperty?: GaPropertyUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutClientsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutClientsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutClientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
  }

  export type UserCreateWithoutAccountRepInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutAccountRepInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutAccountRepInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput>
  }

  export type UserCreateManyAccountRepInputEnvelope = {
    data: UserCreateManyAccountRepInput | UserCreateManyAccountRepInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QueryCreateWithoutUserInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    parsedData?: ParsedQueryDataCreateNestedManyWithoutQueryInput
    parsedPieData?: ParsedPieGraphDataCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryCreateNestedManyWithoutQueryInput
    conversation?: ConversationCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateWithoutUserInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId?: string | null
    parsedData?: ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput
    parsedPieData?: ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutUserInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput>
  }

  export type QueryCreateManyUserInputEnvelope = {
    data: QueryCreateManyUserInput | QueryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    queries?: QueryCreateNestedManyWithoutConversationInput
    gaAccount?: GaAccountCreateNestedOneWithoutConversationsInput
    gaProperty?: GaPropertyCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gaAccountId?: string | null
    gaPropertyId?: string | null
    queries?: QueryUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: ConversationCreateManyUserInput | ConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    parent?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipientId: string
    replies?: MessageUncheckedCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutRecipientInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    parent?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutRecipientInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    replies?: MessageUncheckedCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageCreateManyRecipientInputEnvelope = {
    data: MessageCreateManyRecipientInput | MessageCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    emailNotifications?: boolean
    theme?: string | null
    apiCredits?: number
    apiCreditsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    emailNotifications?: boolean
    theme?: string | null
    apiCredits?: number
    apiCreditsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type ClientSatisfactionCreateWithoutUserInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    accountRep: UserCreateNestedOneWithoutReceivedRatingsInput
  }

  export type ClientSatisfactionUncheckedCreateWithoutUserInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    accountRepId: string
  }

  export type ClientSatisfactionCreateOrConnectWithoutUserInput = {
    where: ClientSatisfactionWhereUniqueInput
    create: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput>
  }

  export type ClientSatisfactionCreateManyUserInputEnvelope = {
    data: ClientSatisfactionCreateManyUserInput | ClientSatisfactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClientSatisfactionCreateWithoutAccountRepInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutGivenRatingsInput
  }

  export type ClientSatisfactionUncheckedCreateWithoutAccountRepInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    userId: string
  }

  export type ClientSatisfactionCreateOrConnectWithoutAccountRepInput = {
    where: ClientSatisfactionWhereUniqueInput
    create: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput>
  }

  export type ClientSatisfactionCreateManyAccountRepInputEnvelope = {
    data: ClientSatisfactionCreateManyAccountRepInput | ClientSatisfactionCreateManyAccountRepInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    client: UserCreateNestedOneWithoutClientTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
    tags?: TicketTagCreateNestedManyWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    tags?: TicketTagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketCreateOrConnectWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput>
  }

  export type TicketCreateManyAssignedToInputEnvelope = {
    data: TicketCreateManyAssignedToInput | TicketCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
    tags?: TicketTagCreateNestedManyWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    tags?: TicketTagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketCreateOrConnectWithoutClientInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput>
  }

  export type TicketCreateManyClientInputEnvelope = {
    data: TicketCreateManyClientInput | TicketCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type TicketCommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketId: string
  }

  export type TicketCommentCreateOrConnectWithoutAuthorInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput>
  }

  export type TicketCommentCreateManyAuthorInputEnvelope = {
    data: TicketCommentCreateManyAuthorInput | TicketCommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ClientActivityCreateWithoutUserInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientActivityUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientActivityCreateOrConnectWithoutUserInput = {
    where: ClientActivityWhereUniqueInput
    create: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput>
  }

  export type ClientActivityCreateManyUserInputEnvelope = {
    data: ClientActivityCreateManyUserInput | ClientActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GaAccountCreateWithoutUserInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    gaProperties?: GaPropertyCreateNestedManyWithoutGaAccountInput
    conversations?: ConversationCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountUncheckedCreateWithoutUserInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    gaProperties?: GaPropertyUncheckedCreateNestedManyWithoutGaAccountInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountCreateOrConnectWithoutUserInput = {
    where: GaAccountWhereUniqueInput
    create: XOR<GaAccountCreateWithoutUserInput, GaAccountUncheckedCreateWithoutUserInput>
  }

  export type GaAccountCreateManyUserInputEnvelope = {
    data: GaAccountCreateManyUserInput | GaAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GaImportRunCreateWithoutRequestedByInput = {
    id?: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutImportsInput
  }

  export type GaImportRunUncheckedCreateWithoutRequestedByInput = {
    id?: string
    gaPropertyId: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaImportRunCreateOrConnectWithoutRequestedByInput = {
    where: GaImportRunWhereUniqueInput
    create: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput>
  }

  export type GaImportRunCreateManyRequestedByInputEnvelope = {
    data: GaImportRunCreateManyRequestedByInput | GaImportRunCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutClientsInput = {
    update: XOR<UserUpdateWithoutClientsInput, UserUncheckedUpdateWithoutClientsInput>
    create: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientsInput, UserUncheckedUpdateWithoutClientsInput>
  }

  export type UserUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutAccountRepInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAccountRepInput, UserUncheckedUpdateWithoutAccountRepInput>
    create: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAccountRepInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAccountRepInput, UserUncheckedUpdateWithoutAccountRepInput>
  }

  export type UserUpdateManyWithWhereWithoutAccountRepInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAccountRepInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type QueryUpsertWithWhereUniqueWithoutUserInput = {
    where: QueryWhereUniqueInput
    update: XOR<QueryUpdateWithoutUserInput, QueryUncheckedUpdateWithoutUserInput>
    create: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput>
  }

  export type QueryUpdateWithWhereUniqueWithoutUserInput = {
    where: QueryWhereUniqueInput
    data: XOR<QueryUpdateWithoutUserInput, QueryUncheckedUpdateWithoutUserInput>
  }

  export type QueryUpdateManyWithWhereWithoutUserInput = {
    where: QueryScalarWhereInput
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
  }

  export type MessageUpdateManyWithWhereWithoutRecipientInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSatisfactionUpsertWithWhereUniqueWithoutUserInput = {
    where: ClientSatisfactionWhereUniqueInput
    update: XOR<ClientSatisfactionUpdateWithoutUserInput, ClientSatisfactionUncheckedUpdateWithoutUserInput>
    create: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput>
  }

  export type ClientSatisfactionUpdateWithWhereUniqueWithoutUserInput = {
    where: ClientSatisfactionWhereUniqueInput
    data: XOR<ClientSatisfactionUpdateWithoutUserInput, ClientSatisfactionUncheckedUpdateWithoutUserInput>
  }

  export type ClientSatisfactionUpdateManyWithWhereWithoutUserInput = {
    where: ClientSatisfactionScalarWhereInput
    data: XOR<ClientSatisfactionUpdateManyMutationInput, ClientSatisfactionUncheckedUpdateManyWithoutUserInput>
  }

  export type ClientSatisfactionScalarWhereInput = {
    AND?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
    OR?: ClientSatisfactionScalarWhereInput[]
    NOT?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
    id?: StringFilter<"ClientSatisfaction"> | string
    rating?: FloatFilter<"ClientSatisfaction"> | number
    feedback?: StringNullableFilter<"ClientSatisfaction"> | string | null
    createdAt?: DateTimeFilter<"ClientSatisfaction"> | Date | string
    userId?: StringFilter<"ClientSatisfaction"> | string
    accountRepId?: StringFilter<"ClientSatisfaction"> | string
  }

  export type ClientSatisfactionUpsertWithWhereUniqueWithoutAccountRepInput = {
    where: ClientSatisfactionWhereUniqueInput
    update: XOR<ClientSatisfactionUpdateWithoutAccountRepInput, ClientSatisfactionUncheckedUpdateWithoutAccountRepInput>
    create: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput>
  }

  export type ClientSatisfactionUpdateWithWhereUniqueWithoutAccountRepInput = {
    where: ClientSatisfactionWhereUniqueInput
    data: XOR<ClientSatisfactionUpdateWithoutAccountRepInput, ClientSatisfactionUncheckedUpdateWithoutAccountRepInput>
  }

  export type ClientSatisfactionUpdateManyWithWhereWithoutAccountRepInput = {
    where: ClientSatisfactionScalarWhereInput
    data: XOR<ClientSatisfactionUpdateManyMutationInput, ClientSatisfactionUncheckedUpdateManyWithoutAccountRepInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAssignedToInput, TicketUncheckedUpdateWithoutAssignedToInput>
    create: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAssignedToInput, TicketUncheckedUpdateWithoutAssignedToInput>
  }

  export type TicketUpdateManyWithWhereWithoutAssignedToInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    assignedToId?: StringNullableFilter<"Ticket"> | string | null
    clientId?: StringFilter<"Ticket"> | string
  }

  export type TicketUpsertWithWhereUniqueWithoutClientInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutClientInput, TicketUncheckedUpdateWithoutClientInput>
    create: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutClientInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutClientInput, TicketUncheckedUpdateWithoutClientInput>
  }

  export type TicketUpdateManyWithWhereWithoutClientInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutClientInput>
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutAuthorInput, TicketCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutAuthorInput, TicketCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type TicketCommentScalarWhereInput = {
    AND?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    OR?: TicketCommentScalarWhereInput[]
    NOT?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
  }

  export type ClientActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ClientActivityWhereUniqueInput
    update: XOR<ClientActivityUpdateWithoutUserInput, ClientActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput>
  }

  export type ClientActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ClientActivityWhereUniqueInput
    data: XOR<ClientActivityUpdateWithoutUserInput, ClientActivityUncheckedUpdateWithoutUserInput>
  }

  export type ClientActivityUpdateManyWithWhereWithoutUserInput = {
    where: ClientActivityScalarWhereInput
    data: XOR<ClientActivityUpdateManyMutationInput, ClientActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ClientActivityScalarWhereInput = {
    AND?: ClientActivityScalarWhereInput | ClientActivityScalarWhereInput[]
    OR?: ClientActivityScalarWhereInput[]
    NOT?: ClientActivityScalarWhereInput | ClientActivityScalarWhereInput[]
    id?: StringFilter<"ClientActivity"> | string
    type?: StringFilter<"ClientActivity"> | string
    description?: StringFilter<"ClientActivity"> | string
    status?: EnumActivityStatusFilter<"ClientActivity"> | $Enums.ActivityStatus
    metadata?: JsonNullableFilter<"ClientActivity">
    createdAt?: DateTimeFilter<"ClientActivity"> | Date | string
    updatedAt?: DateTimeFilter<"ClientActivity"> | Date | string
    userId?: StringFilter<"ClientActivity"> | string
  }

  export type GaAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: GaAccountWhereUniqueInput
    update: XOR<GaAccountUpdateWithoutUserInput, GaAccountUncheckedUpdateWithoutUserInput>
    create: XOR<GaAccountCreateWithoutUserInput, GaAccountUncheckedCreateWithoutUserInput>
  }

  export type GaAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: GaAccountWhereUniqueInput
    data: XOR<GaAccountUpdateWithoutUserInput, GaAccountUncheckedUpdateWithoutUserInput>
  }

  export type GaAccountUpdateManyWithWhereWithoutUserInput = {
    where: GaAccountScalarWhereInput
    data: XOR<GaAccountUpdateManyMutationInput, GaAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type GaAccountScalarWhereInput = {
    AND?: GaAccountScalarWhereInput | GaAccountScalarWhereInput[]
    OR?: GaAccountScalarWhereInput[]
    NOT?: GaAccountScalarWhereInput | GaAccountScalarWhereInput[]
    id?: StringFilter<"GaAccount"> | string
    userId?: StringFilter<"GaAccount"> | string
    gaAccountId?: StringFilter<"GaAccount"> | string
    gaAccountName?: StringFilter<"GaAccount"> | string
  }

  export type GaImportRunUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: GaImportRunWhereUniqueInput
    update: XOR<GaImportRunUpdateWithoutRequestedByInput, GaImportRunUncheckedUpdateWithoutRequestedByInput>
    create: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput>
  }

  export type GaImportRunUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: GaImportRunWhereUniqueInput
    data: XOR<GaImportRunUpdateWithoutRequestedByInput, GaImportRunUncheckedUpdateWithoutRequestedByInput>
  }

  export type GaImportRunUpdateManyWithWhereWithoutRequestedByInput = {
    where: GaImportRunScalarWhereInput
    data: XOR<GaImportRunUpdateManyMutationInput, GaImportRunUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserCreateWithoutAssignedTicketsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutAssignedTicketsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutAssignedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
  }

  export type UserCreateWithoutClientTicketsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutClientTicketsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutClientTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientTicketsInput, UserUncheckedCreateWithoutClientTicketsInput>
  }

  export type TicketAttachmentCreateWithoutTicketInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
  }

  export type TicketAttachmentUncheckedCreateWithoutTicketInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
  }

  export type TicketAttachmentCreateOrConnectWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentCreateManyTicketInputEnvelope = {
    data: TicketAttachmentCreateManyTicketInput | TicketAttachmentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketCommentCreateWithoutTicketInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutTicketInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
  }

  export type TicketCommentCreateOrConnectWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentCreateManyTicketInputEnvelope = {
    data: TicketCommentCreateManyTicketInput | TicketCommentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketTagCreateWithoutTicketsInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type TicketTagUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type TicketTagCreateOrConnectWithoutTicketsInput = {
    where: TicketTagWhereUniqueInput
    create: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput>
  }

  export type UserUpsertWithoutAssignedTicketsInput = {
    update: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUpsertWithoutClientTicketsInput = {
    update: XOR<UserUpdateWithoutClientTicketsInput, UserUncheckedUpdateWithoutClientTicketsInput>
    create: XOR<UserCreateWithoutClientTicketsInput, UserUncheckedCreateWithoutClientTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientTicketsInput, UserUncheckedUpdateWithoutClientTicketsInput>
  }

  export type UserUpdateWithoutClientTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutClientTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    update: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    data: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketAttachmentScalarWhereInput
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketAttachmentScalarWhereInput = {
    AND?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    OR?: TicketAttachmentScalarWhereInput[]
    NOT?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    id?: StringFilter<"TicketAttachment"> | string
    name?: StringFilter<"TicketAttachment"> | string
    url?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: StringFilter<"TicketAttachment"> | string
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketTagUpsertWithWhereUniqueWithoutTicketsInput = {
    where: TicketTagWhereUniqueInput
    update: XOR<TicketTagUpdateWithoutTicketsInput, TicketTagUncheckedUpdateWithoutTicketsInput>
    create: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput>
  }

  export type TicketTagUpdateWithWhereUniqueWithoutTicketsInput = {
    where: TicketTagWhereUniqueInput
    data: XOR<TicketTagUpdateWithoutTicketsInput, TicketTagUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketTagUpdateManyWithWhereWithoutTicketsInput = {
    where: TicketTagScalarWhereInput
    data: XOR<TicketTagUpdateManyMutationInput, TicketTagUncheckedUpdateManyWithoutTicketsInput>
  }

  export type TicketTagScalarWhereInput = {
    AND?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
    OR?: TicketTagScalarWhereInput[]
    NOT?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
    id?: StringFilter<"TicketTag"> | string
    name?: StringFilter<"TicketTag"> | string
    createdAt?: DateTimeFilter<"TicketTag"> | Date | string
  }

  export type TicketCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    client: UserCreateNestedOneWithoutClientTicketsInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
    tags?: TicketTagCreateNestedManyWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    clientId: string
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    tags?: TicketTagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketCreateOrConnectWithoutAttachmentsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
  }

  export type TicketUpsertWithoutAttachmentsInput = {
    update: XOR<TicketUpdateWithoutAttachmentsInput, TicketUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutAttachmentsInput, TicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TicketUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    client?: UserUpdateOneRequiredWithoutClientTicketsNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketCreateWithoutCommentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    client: UserCreateNestedOneWithoutClientTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    tags?: TicketTagCreateNestedManyWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    clientId: string
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    tags?: TicketTagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketCreateOrConnectWithoutCommentsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutTicketCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutTicketCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutTicketCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
  }

  export type TicketUpsertWithoutCommentsInput = {
    update: XOR<TicketUpdateWithoutCommentsInput, TicketUncheckedUpdateWithoutCommentsInput>
    create: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutCommentsInput, TicketUncheckedUpdateWithoutCommentsInput>
  }

  export type TicketUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    client?: UserUpdateOneRequiredWithoutClientTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type UserUpsertWithoutTicketCommentsInput = {
    update: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type UserUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type TicketCreateWithoutTagsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    client: UserCreateNestedOneWithoutClientTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    clientId: string
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTagsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutTagsInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutTagsInput, TicketUncheckedUpdateWithoutTagsInput>
    create: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutTagsInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutTagsInput, TicketUncheckedUpdateWithoutTagsInput>
  }

  export type TicketUpdateManyWithWhereWithoutTagsInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutTagsInput>
  }

  export type MessageCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    parent?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentInput
  }

  export type MessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    recipientId: string
    replies?: MessageUncheckedCreateNestedManyWithoutParentInput
  }

  export type MessageCreateOrConnectWithoutAttachmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type MessageUpsertWithoutAttachmentsInput = {
    update: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    parent?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentNestedInput
  }

  export type MessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    replies?: MessageUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    gaAccounts?: GaAccountCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    gaAccounts?: GaAccountUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type QueryCreateManyConversationInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type QueryUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parsedData?: ParsedQueryDataUpdateManyWithoutQueryNestedInput
    parsedPieData?: ParsedPieGraphDataUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUpdateManyWithoutQueryNestedInput
    user?: UserUpdateOneRequiredWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    parsedData?: ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedPieData?: ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GaPropertyCreateManyGaAccountInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
  }

  export type ConversationCreateManyGaAccountInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gaPropertyId?: string | null
    userId: string
  }

  export type GaPropertyUpdateWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateManyWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationUpdateWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    queries?: QueryUpdateManyWithoutConversationNestedInput
    gaProperty?: GaPropertyUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    queries?: QueryUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCreateManyGaPropertyInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gaAccountId?: string | null
    userId: string
  }

  export type GaImportRunCreateManyGaPropertyInput = {
    id?: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    requestedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaKpiDailyCreateManyGaPropertyInput = {
    id?: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaKpiMonthlyCreateManyGaPropertyInput = {
    id?: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaChannelDailyCreateManyGaPropertyInput = {
    id?: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type GaSourceDailyCreateManyGaPropertyInput = {
    id?: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
  }

  export type ConversationUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    queries?: QueryUpdateManyWithoutConversationNestedInput
    gaAccount?: GaAccountUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    queries?: QueryUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GaImportRunUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: UserUpdateOneRequiredWithoutGaImportRunsNestedInput
  }

  export type GaImportRunUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaImportRunUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaChannelDailyUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaChannelDailyUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaChannelDailyUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    isActive?: boolean
    accountRepId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyParentInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
    recipientId: string
  }

  export type MessageAttachmentCreateManyMessageInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    replies?: MessageUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    replies?: MessageUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageAttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQueryDataCreateManyQueryInput = {
    id?: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    engagedSessions?: number | null
    bounceRate?: number | null
    newUsers?: number | null
  }

  export type ParsedPieGraphDataCreateManyQueryInput = {
    id?: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
  }

  export type ParsedQuerySummaryCreateManyQueryInput = {
    id?: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
  }

  export type ParsedQueryDataUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedQueryDataUncheckedUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedQueryDataUncheckedUpdateManyWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedPieGraphDataUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedPieGraphDataUncheckedUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedPieGraphDataUncheckedUpdateManyWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQuerySummaryUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQuerySummaryUncheckedUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQuerySummaryUncheckedUpdateManyWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyAccountRepInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    roleId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type QueryCreateManyUserInput = {
    id?: string
    content?: string
    response?: string | null
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId?: string | null
  }

  export type ConversationCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gaAccountId?: string | null
    gaPropertyId?: string | null
  }

  export type MessageCreateManySenderInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipientId: string
  }

  export type MessageCreateManyRecipientInput = {
    id?: string
    content: string
    isRead?: boolean
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId: string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ClientSatisfactionCreateManyUserInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    accountRepId: string
  }

  export type ClientSatisfactionCreateManyAccountRepInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    userId: string
  }

  export type TicketCreateManyAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
  }

  export type TicketCreateManyClientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
  }

  export type TicketCommentCreateManyAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketId: string
  }

  export type ClientActivityCreateManyUserInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaAccountCreateManyUserInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
  }

  export type GaImportRunCreateManyRequestedByInput = {
    id?: string
    gaPropertyId: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    gaAccounts?: GaAccountUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parsedData?: ParsedQueryDataUpdateManyWithoutQueryNestedInput
    parsedPieData?: ParsedPieGraphDataUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUpdateManyWithoutQueryNestedInput
    conversation?: ConversationUpdateOneWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    parsedData?: ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedPieData?: ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: QueryUpdateManyWithoutConversationNestedInput
    gaAccount?: GaAccountUpdateOneWithoutConversationsNestedInput
    gaProperty?: GaPropertyUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    queries?: QueryUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    parent?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipientId?: StringFieldUpdateOperationsInput | string
    replies?: MessageUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipientId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    parent?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    replies?: MessageUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSatisfactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountRep?: UserUpdateOneRequiredWithoutReceivedRatingsNestedInput
  }

  export type ClientSatisfactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountRepId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientSatisfactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountRepId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientSatisfactionUpdateWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGivenRatingsNestedInput
  }

  export type ClientSatisfactionUncheckedUpdateWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientSatisfactionUncheckedUpdateManyWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutClientTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketCommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    gaProperties?: GaPropertyUpdateManyWithoutGaAccountNestedInput
    conversations?: ConversationUpdateManyWithoutGaAccountNestedInput
  }

  export type GaAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    gaProperties?: GaPropertyUncheckedUpdateManyWithoutGaAccountNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutGaAccountNestedInput
  }

  export type GaAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
  }

  export type GaImportRunUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutImportsNestedInput
  }

  export type GaImportRunUncheckedUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaImportRunUncheckedUpdateManyWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentCreateManyTicketInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
  }

  export type TicketCommentCreateManyTicketInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
  }

  export type TicketAttachmentUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketTagUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTagUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTagUncheckedUpdateManyWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    client?: UserUpdateOneRequiredWithoutClientTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}