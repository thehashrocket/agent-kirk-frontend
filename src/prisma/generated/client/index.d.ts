
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model ClientSatisfaction
 * 
 */
export type ClientSatisfaction = $Result.DefaultSelection<Prisma.$ClientSatisfactionPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model EmailCampaign
 * 
 */
export type EmailCampaign = $Result.DefaultSelection<Prisma.$EmailCampaignPayload>
/**
 * Model EmailCampaignContent
 * 
 */
export type EmailCampaignContent = $Result.DefaultSelection<Prisma.$EmailCampaignContentPayload>
/**
 * Model EmailCampaignDailyStats
 * 
 */
export type EmailCampaignDailyStats = $Result.DefaultSelection<Prisma.$EmailCampaignDailyStatsPayload>
/**
 * Model EmailClient
 * 
 */
export type EmailClient = $Result.DefaultSelection<Prisma.$EmailClientPayload>
/**
 * Model EmailClientCredentials
 * 
 */
export type EmailClientCredentials = $Result.DefaultSelection<Prisma.$EmailClientCredentialsPayload>
/**
 * Model EmailGlobalDailyStats
 * 
 */
export type EmailGlobalDailyStats = $Result.DefaultSelection<Prisma.$EmailGlobalDailyStatsPayload>
/**
 * Model GaAccount
 * 
 */
export type GaAccount = $Result.DefaultSelection<Prisma.$GaAccountPayload>
/**
 * Model GaProperty
 * 
 */
export type GaProperty = $Result.DefaultSelection<Prisma.$GaPropertyPayload>
/**
 * Model GaImportRun
 * 
 */
export type GaImportRun = $Result.DefaultSelection<Prisma.$GaImportRunPayload>
/**
 * Model GaKpiDaily
 * 
 */
export type GaKpiDaily = $Result.DefaultSelection<Prisma.$GaKpiDailyPayload>
/**
 * Model GaKpiMonthly
 * 
 */
export type GaKpiMonthly = $Result.DefaultSelection<Prisma.$GaKpiMonthlyPayload>
/**
 * Model GaChannelDaily
 * 
 */
export type GaChannelDaily = $Result.DefaultSelection<Prisma.$GaChannelDailyPayload>
/**
 * Model GaSourceDaily
 * 
 */
export type GaSourceDaily = $Result.DefaultSelection<Prisma.$GaSourceDailyPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ParsedPieGraphData
 * 
 */
export type ParsedPieGraphData = $Result.DefaultSelection<Prisma.$ParsedPieGraphDataPayload>
/**
 * Model ParsedQueryData
 * 
 */
export type ParsedQueryData = $Result.DefaultSelection<Prisma.$ParsedQueryDataPayload>
/**
 * Model ParsedQuerySummary
 * 
 */
export type ParsedQuerySummary = $Result.DefaultSelection<Prisma.$ParsedQuerySummaryPayload>
/**
 * Model Query
 * 
 */
export type Query = $Result.DefaultSelection<Prisma.$QueryPayload>
/**
 * Model SproutFacebookAnalytics
 * 
 */
export type SproutFacebookAnalytics = $Result.DefaultSelection<Prisma.$SproutFacebookAnalyticsPayload>
/**
 * Model SproutFacebookPost
 * 
 */
export type SproutFacebookPost = $Result.DefaultSelection<Prisma.$SproutFacebookPostPayload>
/**
 * Model SproutFacebookPostAnalytics
 * 
 */
export type SproutFacebookPostAnalytics = $Result.DefaultSelection<Prisma.$SproutFacebookPostAnalyticsPayload>
/**
 * Model SproutInstagramAnalytics
 * 
 */
export type SproutInstagramAnalytics = $Result.DefaultSelection<Prisma.$SproutInstagramAnalyticsPayload>
/**
 * Model SproutInstagramFollowersByCity
 * 
 */
export type SproutInstagramFollowersByCity = $Result.DefaultSelection<Prisma.$SproutInstagramFollowersByCityPayload>
/**
 * Model SproutInstagramFollowersByCountry
 * 
 */
export type SproutInstagramFollowersByCountry = $Result.DefaultSelection<Prisma.$SproutInstagramFollowersByCountryPayload>
/**
 * Model SproutLinkedInAnalytics
 * 
 */
export type SproutLinkedInAnalytics = $Result.DefaultSelection<Prisma.$SproutLinkedInAnalyticsPayload>
/**
 * Model SproutPinterestAnalytics
 * 
 */
export type SproutPinterestAnalytics = $Result.DefaultSelection<Prisma.$SproutPinterestAnalyticsPayload>
/**
 * Model SproutSocialAccount
 * 
 */
export type SproutSocialAccount = $Result.DefaultSelection<Prisma.$SproutSocialAccountPayload>
/**
 * Model UserToSproutSocialAccount
 * 
 */
export type UserToSproutSocialAccount = $Result.DefaultSelection<Prisma.$UserToSproutSocialAccountPayload>
/**
 * Model UserToGaAccount
 * 
 */
export type UserToGaAccount = $Result.DefaultSelection<Prisma.$UserToGaAccountPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketAttachment
 * 
 */
export type TicketAttachment = $Result.DefaultSelection<Prisma.$TicketAttachmentPayload>
/**
 * Model TicketComment
 * 
 */
export type TicketComment = $Result.DefaultSelection<Prisma.$TicketCommentPayload>
/**
 * Model TicketTag
 * 
 */
export type TicketTag = $Result.DefaultSelection<Prisma.$TicketTagPayload>
/**
 * Model MessageAttachment
 * 
 */
export type MessageAttachment = $Result.DefaultSelection<Prisma.$MessageAttachmentPayload>
/**
 * Model ClientActivity
 * 
 */
export type ClientActivity = $Result.DefaultSelection<Prisma.$ClientActivityPayload>
/**
 * Model UserToEmailClient
 * 
 */
export type UserToEmailClient = $Result.DefaultSelection<Prisma.$UserToEmailClientPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ImportStatus: {
  queued: 'queued',
  ok: 'ok',
  error: 'error'
};

export type ImportStatus = (typeof ImportStatus)[keyof typeof ImportStatus]


export const TicketStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const TicketPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const ActivityStatus: {
  SUCCESS: 'SUCCESS',
  ERROR: 'ERROR',
  PENDING: 'PENDING'
};

export type ActivityStatus = (typeof ActivityStatus)[keyof typeof ActivityStatus]


export const QueryStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type QueryStatus = (typeof QueryStatus)[keyof typeof QueryStatus]


export const NotificationType: {
  SYSTEM: 'SYSTEM',
  MESSAGE: 'MESSAGE',
  QUERY_COMPLETE: 'QUERY_COMPLETE',
  REPORT_GENERATED: 'REPORT_GENERATED'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type ImportStatus = $Enums.ImportStatus

export const ImportStatus: typeof $Enums.ImportStatus

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type ActivityStatus = $Enums.ActivityStatus

export const ActivityStatus: typeof $Enums.ActivityStatus

export type QueryStatus = $Enums.QueryStatus

export const QueryStatus: typeof $Enums.QueryStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientSatisfaction`: Exposes CRUD operations for the **ClientSatisfaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientSatisfactions
    * const clientSatisfactions = await prisma.clientSatisfaction.findMany()
    * ```
    */
  get clientSatisfaction(): Prisma.ClientSatisfactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailCampaign`: Exposes CRUD operations for the **EmailCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailCampaigns
    * const emailCampaigns = await prisma.emailCampaign.findMany()
    * ```
    */
  get emailCampaign(): Prisma.EmailCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailCampaignContent`: Exposes CRUD operations for the **EmailCampaignContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailCampaignContents
    * const emailCampaignContents = await prisma.emailCampaignContent.findMany()
    * ```
    */
  get emailCampaignContent(): Prisma.EmailCampaignContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailCampaignDailyStats`: Exposes CRUD operations for the **EmailCampaignDailyStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailCampaignDailyStats
    * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.findMany()
    * ```
    */
  get emailCampaignDailyStats(): Prisma.EmailCampaignDailyStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailClient`: Exposes CRUD operations for the **EmailClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailClients
    * const emailClients = await prisma.emailClient.findMany()
    * ```
    */
  get emailClient(): Prisma.EmailClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailClientCredentials`: Exposes CRUD operations for the **EmailClientCredentials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailClientCredentials
    * const emailClientCredentials = await prisma.emailClientCredentials.findMany()
    * ```
    */
  get emailClientCredentials(): Prisma.EmailClientCredentialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailGlobalDailyStats`: Exposes CRUD operations for the **EmailGlobalDailyStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailGlobalDailyStats
    * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.findMany()
    * ```
    */
  get emailGlobalDailyStats(): Prisma.EmailGlobalDailyStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaAccount`: Exposes CRUD operations for the **GaAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaAccounts
    * const gaAccounts = await prisma.gaAccount.findMany()
    * ```
    */
  get gaAccount(): Prisma.GaAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaProperty`: Exposes CRUD operations for the **GaProperty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaProperties
    * const gaProperties = await prisma.gaProperty.findMany()
    * ```
    */
  get gaProperty(): Prisma.GaPropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaImportRun`: Exposes CRUD operations for the **GaImportRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaImportRuns
    * const gaImportRuns = await prisma.gaImportRun.findMany()
    * ```
    */
  get gaImportRun(): Prisma.GaImportRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaKpiDaily`: Exposes CRUD operations for the **GaKpiDaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaKpiDailies
    * const gaKpiDailies = await prisma.gaKpiDaily.findMany()
    * ```
    */
  get gaKpiDaily(): Prisma.GaKpiDailyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaKpiMonthly`: Exposes CRUD operations for the **GaKpiMonthly** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaKpiMonthlies
    * const gaKpiMonthlies = await prisma.gaKpiMonthly.findMany()
    * ```
    */
  get gaKpiMonthly(): Prisma.GaKpiMonthlyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaChannelDaily`: Exposes CRUD operations for the **GaChannelDaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaChannelDailies
    * const gaChannelDailies = await prisma.gaChannelDaily.findMany()
    * ```
    */
  get gaChannelDaily(): Prisma.GaChannelDailyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaSourceDaily`: Exposes CRUD operations for the **GaSourceDaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GaSourceDailies
    * const gaSourceDailies = await prisma.gaSourceDaily.findMany()
    * ```
    */
  get gaSourceDaily(): Prisma.GaSourceDailyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parsedPieGraphData`: Exposes CRUD operations for the **ParsedPieGraphData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParsedPieGraphData
    * const parsedPieGraphData = await prisma.parsedPieGraphData.findMany()
    * ```
    */
  get parsedPieGraphData(): Prisma.ParsedPieGraphDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parsedQueryData`: Exposes CRUD operations for the **ParsedQueryData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParsedQueryData
    * const parsedQueryData = await prisma.parsedQueryData.findMany()
    * ```
    */
  get parsedQueryData(): Prisma.ParsedQueryDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parsedQuerySummary`: Exposes CRUD operations for the **ParsedQuerySummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParsedQuerySummaries
    * const parsedQuerySummaries = await prisma.parsedQuerySummary.findMany()
    * ```
    */
  get parsedQuerySummary(): Prisma.ParsedQuerySummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.query`: Exposes CRUD operations for the **Query** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Queries
    * const queries = await prisma.query.findMany()
    * ```
    */
  get query(): Prisma.QueryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sproutFacebookAnalytics`: Exposes CRUD operations for the **SproutFacebookAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SproutFacebookAnalytics
    * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.findMany()
    * ```
    */
  get sproutFacebookAnalytics(): Prisma.SproutFacebookAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sproutFacebookPost`: Exposes CRUD operations for the **SproutFacebookPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SproutFacebookPosts
    * const sproutFacebookPosts = await prisma.sproutFacebookPost.findMany()
    * ```
    */
  get sproutFacebookPost(): Prisma.SproutFacebookPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sproutFacebookPostAnalytics`: Exposes CRUD operations for the **SproutFacebookPostAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SproutFacebookPostAnalytics
    * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.findMany()
    * ```
    */
  get sproutFacebookPostAnalytics(): Prisma.SproutFacebookPostAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sproutInstagramAnalytics`: Exposes CRUD operations for the **SproutInstagramAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SproutInstagramAnalytics
    * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.findMany()
    * ```
    */
  get sproutInstagramAnalytics(): Prisma.SproutInstagramAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sproutInstagramFollowersByCity`: Exposes CRUD operations for the **SproutInstagramFollowersByCity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SproutInstagramFollowersByCities
    * const sproutInstagramFollowersByCities = await prisma.sproutInstagramFollowersByCity.findMany()
    * ```
    */
  get sproutInstagramFollowersByCity(): Prisma.SproutInstagramFollowersByCityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sproutInstagramFollowersByCountry`: Exposes CRUD operations for the **SproutInstagramFollowersByCountry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SproutInstagramFollowersByCountries
    * const sproutInstagramFollowersByCountries = await prisma.sproutInstagramFollowersByCountry.findMany()
    * ```
    */
  get sproutInstagramFollowersByCountry(): Prisma.SproutInstagramFollowersByCountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sproutLinkedInAnalytics`: Exposes CRUD operations for the **SproutLinkedInAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SproutLinkedInAnalytics
    * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.findMany()
    * ```
    */
  get sproutLinkedInAnalytics(): Prisma.SproutLinkedInAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sproutPinterestAnalytics`: Exposes CRUD operations for the **SproutPinterestAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SproutPinterestAnalytics
    * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.findMany()
    * ```
    */
  get sproutPinterestAnalytics(): Prisma.SproutPinterestAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sproutSocialAccount`: Exposes CRUD operations for the **SproutSocialAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SproutSocialAccounts
    * const sproutSocialAccounts = await prisma.sproutSocialAccount.findMany()
    * ```
    */
  get sproutSocialAccount(): Prisma.SproutSocialAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userToSproutSocialAccount`: Exposes CRUD operations for the **UserToSproutSocialAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToSproutSocialAccounts
    * const userToSproutSocialAccounts = await prisma.userToSproutSocialAccount.findMany()
    * ```
    */
  get userToSproutSocialAccount(): Prisma.UserToSproutSocialAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userToGaAccount`: Exposes CRUD operations for the **UserToGaAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToGaAccounts
    * const userToGaAccounts = await prisma.userToGaAccount.findMany()
    * ```
    */
  get userToGaAccount(): Prisma.UserToGaAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketAttachment`: Exposes CRUD operations for the **TicketAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketAttachments
    * const ticketAttachments = await prisma.ticketAttachment.findMany()
    * ```
    */
  get ticketAttachment(): Prisma.TicketAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketComment`: Exposes CRUD operations for the **TicketComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketComments
    * const ticketComments = await prisma.ticketComment.findMany()
    * ```
    */
  get ticketComment(): Prisma.TicketCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketTag`: Exposes CRUD operations for the **TicketTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketTags
    * const ticketTags = await prisma.ticketTag.findMany()
    * ```
    */
  get ticketTag(): Prisma.TicketTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageAttachment`: Exposes CRUD operations for the **MessageAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageAttachments
    * const messageAttachments = await prisma.messageAttachment.findMany()
    * ```
    */
  get messageAttachment(): Prisma.MessageAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientActivity`: Exposes CRUD operations for the **ClientActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientActivities
    * const clientActivities = await prisma.clientActivity.findMany()
    * ```
    */
  get clientActivity(): Prisma.ClientActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userToEmailClient`: Exposes CRUD operations for the **UserToEmailClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToEmailClients
    * const userToEmailClients = await prisma.userToEmailClient.findMany()
    * ```
    */
  get userToEmailClient(): Prisma.UserToEmailClientDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    ClientSatisfaction: 'ClientSatisfaction',
    Company: 'Company',
    Conversation: 'Conversation',
    EmailCampaign: 'EmailCampaign',
    EmailCampaignContent: 'EmailCampaignContent',
    EmailCampaignDailyStats: 'EmailCampaignDailyStats',
    EmailClient: 'EmailClient',
    EmailClientCredentials: 'EmailClientCredentials',
    EmailGlobalDailyStats: 'EmailGlobalDailyStats',
    GaAccount: 'GaAccount',
    GaProperty: 'GaProperty',
    GaImportRun: 'GaImportRun',
    GaKpiDaily: 'GaKpiDaily',
    GaKpiMonthly: 'GaKpiMonthly',
    GaChannelDaily: 'GaChannelDaily',
    GaSourceDaily: 'GaSourceDaily',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Role: 'Role',
    Message: 'Message',
    Notification: 'Notification',
    ParsedPieGraphData: 'ParsedPieGraphData',
    ParsedQueryData: 'ParsedQueryData',
    ParsedQuerySummary: 'ParsedQuerySummary',
    Query: 'Query',
    SproutFacebookAnalytics: 'SproutFacebookAnalytics',
    SproutFacebookPost: 'SproutFacebookPost',
    SproutFacebookPostAnalytics: 'SproutFacebookPostAnalytics',
    SproutInstagramAnalytics: 'SproutInstagramAnalytics',
    SproutInstagramFollowersByCity: 'SproutInstagramFollowersByCity',
    SproutInstagramFollowersByCountry: 'SproutInstagramFollowersByCountry',
    SproutLinkedInAnalytics: 'SproutLinkedInAnalytics',
    SproutPinterestAnalytics: 'SproutPinterestAnalytics',
    SproutSocialAccount: 'SproutSocialAccount',
    UserToSproutSocialAccount: 'UserToSproutSocialAccount',
    UserToGaAccount: 'UserToGaAccount',
    User: 'User',
    UserSettings: 'UserSettings',
    Ticket: 'Ticket',
    TicketAttachment: 'TicketAttachment',
    TicketComment: 'TicketComment',
    TicketTag: 'TicketTag',
    MessageAttachment: 'MessageAttachment',
    ClientActivity: 'ClientActivity',
    UserToEmailClient: 'UserToEmailClient'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "clientSatisfaction" | "company" | "conversation" | "emailCampaign" | "emailCampaignContent" | "emailCampaignDailyStats" | "emailClient" | "emailClientCredentials" | "emailGlobalDailyStats" | "gaAccount" | "gaProperty" | "gaImportRun" | "gaKpiDaily" | "gaKpiMonthly" | "gaChannelDaily" | "gaSourceDaily" | "session" | "verificationToken" | "role" | "message" | "notification" | "parsedPieGraphData" | "parsedQueryData" | "parsedQuerySummary" | "query" | "sproutFacebookAnalytics" | "sproutFacebookPost" | "sproutFacebookPostAnalytics" | "sproutInstagramAnalytics" | "sproutInstagramFollowersByCity" | "sproutInstagramFollowersByCountry" | "sproutLinkedInAnalytics" | "sproutPinterestAnalytics" | "sproutSocialAccount" | "userToSproutSocialAccount" | "userToGaAccount" | "user" | "userSettings" | "ticket" | "ticketAttachment" | "ticketComment" | "ticketTag" | "messageAttachment" | "clientActivity" | "userToEmailClient"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      ClientSatisfaction: {
        payload: Prisma.$ClientSatisfactionPayload<ExtArgs>
        fields: Prisma.ClientSatisfactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientSatisfactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientSatisfactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          findFirst: {
            args: Prisma.ClientSatisfactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientSatisfactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          findMany: {
            args: Prisma.ClientSatisfactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>[]
          }
          create: {
            args: Prisma.ClientSatisfactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          createMany: {
            args: Prisma.ClientSatisfactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientSatisfactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>[]
          }
          delete: {
            args: Prisma.ClientSatisfactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          update: {
            args: Prisma.ClientSatisfactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          deleteMany: {
            args: Prisma.ClientSatisfactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientSatisfactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientSatisfactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>[]
          }
          upsert: {
            args: Prisma.ClientSatisfactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSatisfactionPayload>
          }
          aggregate: {
            args: Prisma.ClientSatisfactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientSatisfaction>
          }
          groupBy: {
            args: Prisma.ClientSatisfactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientSatisfactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientSatisfactionCountArgs<ExtArgs>
            result: $Utils.Optional<ClientSatisfactionCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      EmailCampaign: {
        payload: Prisma.$EmailCampaignPayload<ExtArgs>
        fields: Prisma.EmailCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          findFirst: {
            args: Prisma.EmailCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          findMany: {
            args: Prisma.EmailCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>[]
          }
          create: {
            args: Prisma.EmailCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          createMany: {
            args: Prisma.EmailCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>[]
          }
          delete: {
            args: Prisma.EmailCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          update: {
            args: Prisma.EmailCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          deleteMany: {
            args: Prisma.EmailCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailCampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>[]
          }
          upsert: {
            args: Prisma.EmailCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignPayload>
          }
          aggregate: {
            args: Prisma.EmailCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailCampaign>
          }
          groupBy: {
            args: Prisma.EmailCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<EmailCampaignCountAggregateOutputType> | number
          }
        }
      }
      EmailCampaignContent: {
        payload: Prisma.$EmailCampaignContentPayload<ExtArgs>
        fields: Prisma.EmailCampaignContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailCampaignContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailCampaignContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignContentPayload>
          }
          findFirst: {
            args: Prisma.EmailCampaignContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailCampaignContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignContentPayload>
          }
          findMany: {
            args: Prisma.EmailCampaignContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignContentPayload>[]
          }
          create: {
            args: Prisma.EmailCampaignContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignContentPayload>
          }
          createMany: {
            args: Prisma.EmailCampaignContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailCampaignContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignContentPayload>[]
          }
          delete: {
            args: Prisma.EmailCampaignContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignContentPayload>
          }
          update: {
            args: Prisma.EmailCampaignContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignContentPayload>
          }
          deleteMany: {
            args: Prisma.EmailCampaignContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailCampaignContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailCampaignContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignContentPayload>[]
          }
          upsert: {
            args: Prisma.EmailCampaignContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignContentPayload>
          }
          aggregate: {
            args: Prisma.EmailCampaignContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailCampaignContent>
          }
          groupBy: {
            args: Prisma.EmailCampaignContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailCampaignContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCampaignContentCountArgs<ExtArgs>
            result: $Utils.Optional<EmailCampaignContentCountAggregateOutputType> | number
          }
        }
      }
      EmailCampaignDailyStats: {
        payload: Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>
        fields: Prisma.EmailCampaignDailyStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailCampaignDailyStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignDailyStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailCampaignDailyStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignDailyStatsPayload>
          }
          findFirst: {
            args: Prisma.EmailCampaignDailyStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignDailyStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailCampaignDailyStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignDailyStatsPayload>
          }
          findMany: {
            args: Prisma.EmailCampaignDailyStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignDailyStatsPayload>[]
          }
          create: {
            args: Prisma.EmailCampaignDailyStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignDailyStatsPayload>
          }
          createMany: {
            args: Prisma.EmailCampaignDailyStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailCampaignDailyStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignDailyStatsPayload>[]
          }
          delete: {
            args: Prisma.EmailCampaignDailyStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignDailyStatsPayload>
          }
          update: {
            args: Prisma.EmailCampaignDailyStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignDailyStatsPayload>
          }
          deleteMany: {
            args: Prisma.EmailCampaignDailyStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailCampaignDailyStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailCampaignDailyStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignDailyStatsPayload>[]
          }
          upsert: {
            args: Prisma.EmailCampaignDailyStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailCampaignDailyStatsPayload>
          }
          aggregate: {
            args: Prisma.EmailCampaignDailyStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailCampaignDailyStats>
          }
          groupBy: {
            args: Prisma.EmailCampaignDailyStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailCampaignDailyStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCampaignDailyStatsCountArgs<ExtArgs>
            result: $Utils.Optional<EmailCampaignDailyStatsCountAggregateOutputType> | number
          }
        }
      }
      EmailClient: {
        payload: Prisma.$EmailClientPayload<ExtArgs>
        fields: Prisma.EmailClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientPayload>
          }
          findFirst: {
            args: Prisma.EmailClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientPayload>
          }
          findMany: {
            args: Prisma.EmailClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientPayload>[]
          }
          create: {
            args: Prisma.EmailClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientPayload>
          }
          createMany: {
            args: Prisma.EmailClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientPayload>[]
          }
          delete: {
            args: Prisma.EmailClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientPayload>
          }
          update: {
            args: Prisma.EmailClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientPayload>
          }
          deleteMany: {
            args: Prisma.EmailClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientPayload>[]
          }
          upsert: {
            args: Prisma.EmailClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientPayload>
          }
          aggregate: {
            args: Prisma.EmailClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailClient>
          }
          groupBy: {
            args: Prisma.EmailClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailClientCountArgs<ExtArgs>
            result: $Utils.Optional<EmailClientCountAggregateOutputType> | number
          }
        }
      }
      EmailClientCredentials: {
        payload: Prisma.$EmailClientCredentialsPayload<ExtArgs>
        fields: Prisma.EmailClientCredentialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailClientCredentialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientCredentialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailClientCredentialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientCredentialsPayload>
          }
          findFirst: {
            args: Prisma.EmailClientCredentialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientCredentialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailClientCredentialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientCredentialsPayload>
          }
          findMany: {
            args: Prisma.EmailClientCredentialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientCredentialsPayload>[]
          }
          create: {
            args: Prisma.EmailClientCredentialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientCredentialsPayload>
          }
          createMany: {
            args: Prisma.EmailClientCredentialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailClientCredentialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientCredentialsPayload>[]
          }
          delete: {
            args: Prisma.EmailClientCredentialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientCredentialsPayload>
          }
          update: {
            args: Prisma.EmailClientCredentialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientCredentialsPayload>
          }
          deleteMany: {
            args: Prisma.EmailClientCredentialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailClientCredentialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailClientCredentialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientCredentialsPayload>[]
          }
          upsert: {
            args: Prisma.EmailClientCredentialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailClientCredentialsPayload>
          }
          aggregate: {
            args: Prisma.EmailClientCredentialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailClientCredentials>
          }
          groupBy: {
            args: Prisma.EmailClientCredentialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailClientCredentialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailClientCredentialsCountArgs<ExtArgs>
            result: $Utils.Optional<EmailClientCredentialsCountAggregateOutputType> | number
          }
        }
      }
      EmailGlobalDailyStats: {
        payload: Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>
        fields: Prisma.EmailGlobalDailyStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailGlobalDailyStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailGlobalDailyStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailGlobalDailyStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailGlobalDailyStatsPayload>
          }
          findFirst: {
            args: Prisma.EmailGlobalDailyStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailGlobalDailyStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailGlobalDailyStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailGlobalDailyStatsPayload>
          }
          findMany: {
            args: Prisma.EmailGlobalDailyStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailGlobalDailyStatsPayload>[]
          }
          create: {
            args: Prisma.EmailGlobalDailyStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailGlobalDailyStatsPayload>
          }
          createMany: {
            args: Prisma.EmailGlobalDailyStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailGlobalDailyStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailGlobalDailyStatsPayload>[]
          }
          delete: {
            args: Prisma.EmailGlobalDailyStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailGlobalDailyStatsPayload>
          }
          update: {
            args: Prisma.EmailGlobalDailyStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailGlobalDailyStatsPayload>
          }
          deleteMany: {
            args: Prisma.EmailGlobalDailyStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailGlobalDailyStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailGlobalDailyStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailGlobalDailyStatsPayload>[]
          }
          upsert: {
            args: Prisma.EmailGlobalDailyStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailGlobalDailyStatsPayload>
          }
          aggregate: {
            args: Prisma.EmailGlobalDailyStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailGlobalDailyStats>
          }
          groupBy: {
            args: Prisma.EmailGlobalDailyStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailGlobalDailyStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailGlobalDailyStatsCountArgs<ExtArgs>
            result: $Utils.Optional<EmailGlobalDailyStatsCountAggregateOutputType> | number
          }
        }
      }
      GaAccount: {
        payload: Prisma.$GaAccountPayload<ExtArgs>
        fields: Prisma.GaAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          findFirst: {
            args: Prisma.GaAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          findMany: {
            args: Prisma.GaAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>[]
          }
          create: {
            args: Prisma.GaAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          createMany: {
            args: Prisma.GaAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>[]
          }
          delete: {
            args: Prisma.GaAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          update: {
            args: Prisma.GaAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          deleteMany: {
            args: Prisma.GaAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>[]
          }
          upsert: {
            args: Prisma.GaAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaAccountPayload>
          }
          aggregate: {
            args: Prisma.GaAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaAccount>
          }
          groupBy: {
            args: Prisma.GaAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaAccountCountArgs<ExtArgs>
            result: $Utils.Optional<GaAccountCountAggregateOutputType> | number
          }
        }
      }
      GaProperty: {
        payload: Prisma.$GaPropertyPayload<ExtArgs>
        fields: Prisma.GaPropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaPropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaPropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          findFirst: {
            args: Prisma.GaPropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaPropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          findMany: {
            args: Prisma.GaPropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>[]
          }
          create: {
            args: Prisma.GaPropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          createMany: {
            args: Prisma.GaPropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaPropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>[]
          }
          delete: {
            args: Prisma.GaPropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          update: {
            args: Prisma.GaPropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          deleteMany: {
            args: Prisma.GaPropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaPropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaPropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>[]
          }
          upsert: {
            args: Prisma.GaPropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaPropertyPayload>
          }
          aggregate: {
            args: Prisma.GaPropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaProperty>
          }
          groupBy: {
            args: Prisma.GaPropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaPropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaPropertyCountArgs<ExtArgs>
            result: $Utils.Optional<GaPropertyCountAggregateOutputType> | number
          }
        }
      }
      GaImportRun: {
        payload: Prisma.$GaImportRunPayload<ExtArgs>
        fields: Prisma.GaImportRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaImportRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaImportRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          findFirst: {
            args: Prisma.GaImportRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaImportRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          findMany: {
            args: Prisma.GaImportRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>[]
          }
          create: {
            args: Prisma.GaImportRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          createMany: {
            args: Prisma.GaImportRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaImportRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>[]
          }
          delete: {
            args: Prisma.GaImportRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          update: {
            args: Prisma.GaImportRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          deleteMany: {
            args: Prisma.GaImportRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaImportRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaImportRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>[]
          }
          upsert: {
            args: Prisma.GaImportRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaImportRunPayload>
          }
          aggregate: {
            args: Prisma.GaImportRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaImportRun>
          }
          groupBy: {
            args: Prisma.GaImportRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaImportRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaImportRunCountArgs<ExtArgs>
            result: $Utils.Optional<GaImportRunCountAggregateOutputType> | number
          }
        }
      }
      GaKpiDaily: {
        payload: Prisma.$GaKpiDailyPayload<ExtArgs>
        fields: Prisma.GaKpiDailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaKpiDailyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaKpiDailyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          findFirst: {
            args: Prisma.GaKpiDailyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaKpiDailyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          findMany: {
            args: Prisma.GaKpiDailyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>[]
          }
          create: {
            args: Prisma.GaKpiDailyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          createMany: {
            args: Prisma.GaKpiDailyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaKpiDailyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>[]
          }
          delete: {
            args: Prisma.GaKpiDailyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          update: {
            args: Prisma.GaKpiDailyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          deleteMany: {
            args: Prisma.GaKpiDailyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaKpiDailyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaKpiDailyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>[]
          }
          upsert: {
            args: Prisma.GaKpiDailyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiDailyPayload>
          }
          aggregate: {
            args: Prisma.GaKpiDailyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaKpiDaily>
          }
          groupBy: {
            args: Prisma.GaKpiDailyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaKpiDailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaKpiDailyCountArgs<ExtArgs>
            result: $Utils.Optional<GaKpiDailyCountAggregateOutputType> | number
          }
        }
      }
      GaKpiMonthly: {
        payload: Prisma.$GaKpiMonthlyPayload<ExtArgs>
        fields: Prisma.GaKpiMonthlyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaKpiMonthlyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaKpiMonthlyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          findFirst: {
            args: Prisma.GaKpiMonthlyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaKpiMonthlyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          findMany: {
            args: Prisma.GaKpiMonthlyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>[]
          }
          create: {
            args: Prisma.GaKpiMonthlyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          createMany: {
            args: Prisma.GaKpiMonthlyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaKpiMonthlyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>[]
          }
          delete: {
            args: Prisma.GaKpiMonthlyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          update: {
            args: Prisma.GaKpiMonthlyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          deleteMany: {
            args: Prisma.GaKpiMonthlyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaKpiMonthlyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaKpiMonthlyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>[]
          }
          upsert: {
            args: Prisma.GaKpiMonthlyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaKpiMonthlyPayload>
          }
          aggregate: {
            args: Prisma.GaKpiMonthlyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaKpiMonthly>
          }
          groupBy: {
            args: Prisma.GaKpiMonthlyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaKpiMonthlyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaKpiMonthlyCountArgs<ExtArgs>
            result: $Utils.Optional<GaKpiMonthlyCountAggregateOutputType> | number
          }
        }
      }
      GaChannelDaily: {
        payload: Prisma.$GaChannelDailyPayload<ExtArgs>
        fields: Prisma.GaChannelDailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaChannelDailyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaChannelDailyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          findFirst: {
            args: Prisma.GaChannelDailyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaChannelDailyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          findMany: {
            args: Prisma.GaChannelDailyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>[]
          }
          create: {
            args: Prisma.GaChannelDailyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          createMany: {
            args: Prisma.GaChannelDailyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaChannelDailyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>[]
          }
          delete: {
            args: Prisma.GaChannelDailyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          update: {
            args: Prisma.GaChannelDailyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          deleteMany: {
            args: Prisma.GaChannelDailyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaChannelDailyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaChannelDailyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>[]
          }
          upsert: {
            args: Prisma.GaChannelDailyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaChannelDailyPayload>
          }
          aggregate: {
            args: Prisma.GaChannelDailyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaChannelDaily>
          }
          groupBy: {
            args: Prisma.GaChannelDailyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaChannelDailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaChannelDailyCountArgs<ExtArgs>
            result: $Utils.Optional<GaChannelDailyCountAggregateOutputType> | number
          }
        }
      }
      GaSourceDaily: {
        payload: Prisma.$GaSourceDailyPayload<ExtArgs>
        fields: Prisma.GaSourceDailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaSourceDailyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaSourceDailyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          findFirst: {
            args: Prisma.GaSourceDailyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaSourceDailyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          findMany: {
            args: Prisma.GaSourceDailyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>[]
          }
          create: {
            args: Prisma.GaSourceDailyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          createMany: {
            args: Prisma.GaSourceDailyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GaSourceDailyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>[]
          }
          delete: {
            args: Prisma.GaSourceDailyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          update: {
            args: Prisma.GaSourceDailyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          deleteMany: {
            args: Prisma.GaSourceDailyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaSourceDailyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GaSourceDailyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>[]
          }
          upsert: {
            args: Prisma.GaSourceDailyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaSourceDailyPayload>
          }
          aggregate: {
            args: Prisma.GaSourceDailyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaSourceDaily>
          }
          groupBy: {
            args: Prisma.GaSourceDailyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaSourceDailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaSourceDailyCountArgs<ExtArgs>
            result: $Utils.Optional<GaSourceDailyCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ParsedPieGraphData: {
        payload: Prisma.$ParsedPieGraphDataPayload<ExtArgs>
        fields: Prisma.ParsedPieGraphDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParsedPieGraphDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParsedPieGraphDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          findFirst: {
            args: Prisma.ParsedPieGraphDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParsedPieGraphDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          findMany: {
            args: Prisma.ParsedPieGraphDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>[]
          }
          create: {
            args: Prisma.ParsedPieGraphDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          createMany: {
            args: Prisma.ParsedPieGraphDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParsedPieGraphDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>[]
          }
          delete: {
            args: Prisma.ParsedPieGraphDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          update: {
            args: Prisma.ParsedPieGraphDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          deleteMany: {
            args: Prisma.ParsedPieGraphDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParsedPieGraphDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParsedPieGraphDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>[]
          }
          upsert: {
            args: Prisma.ParsedPieGraphDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedPieGraphDataPayload>
          }
          aggregate: {
            args: Prisma.ParsedPieGraphDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParsedPieGraphData>
          }
          groupBy: {
            args: Prisma.ParsedPieGraphDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParsedPieGraphDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParsedPieGraphDataCountArgs<ExtArgs>
            result: $Utils.Optional<ParsedPieGraphDataCountAggregateOutputType> | number
          }
        }
      }
      ParsedQueryData: {
        payload: Prisma.$ParsedQueryDataPayload<ExtArgs>
        fields: Prisma.ParsedQueryDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParsedQueryDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParsedQueryDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          findFirst: {
            args: Prisma.ParsedQueryDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParsedQueryDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          findMany: {
            args: Prisma.ParsedQueryDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>[]
          }
          create: {
            args: Prisma.ParsedQueryDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          createMany: {
            args: Prisma.ParsedQueryDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParsedQueryDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>[]
          }
          delete: {
            args: Prisma.ParsedQueryDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          update: {
            args: Prisma.ParsedQueryDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          deleteMany: {
            args: Prisma.ParsedQueryDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParsedQueryDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParsedQueryDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>[]
          }
          upsert: {
            args: Prisma.ParsedQueryDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQueryDataPayload>
          }
          aggregate: {
            args: Prisma.ParsedQueryDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParsedQueryData>
          }
          groupBy: {
            args: Prisma.ParsedQueryDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParsedQueryDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParsedQueryDataCountArgs<ExtArgs>
            result: $Utils.Optional<ParsedQueryDataCountAggregateOutputType> | number
          }
        }
      }
      ParsedQuerySummary: {
        payload: Prisma.$ParsedQuerySummaryPayload<ExtArgs>
        fields: Prisma.ParsedQuerySummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParsedQuerySummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParsedQuerySummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          findFirst: {
            args: Prisma.ParsedQuerySummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParsedQuerySummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          findMany: {
            args: Prisma.ParsedQuerySummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>[]
          }
          create: {
            args: Prisma.ParsedQuerySummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          createMany: {
            args: Prisma.ParsedQuerySummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParsedQuerySummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>[]
          }
          delete: {
            args: Prisma.ParsedQuerySummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          update: {
            args: Prisma.ParsedQuerySummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          deleteMany: {
            args: Prisma.ParsedQuerySummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParsedQuerySummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParsedQuerySummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>[]
          }
          upsert: {
            args: Prisma.ParsedQuerySummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedQuerySummaryPayload>
          }
          aggregate: {
            args: Prisma.ParsedQuerySummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParsedQuerySummary>
          }
          groupBy: {
            args: Prisma.ParsedQuerySummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParsedQuerySummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParsedQuerySummaryCountArgs<ExtArgs>
            result: $Utils.Optional<ParsedQuerySummaryCountAggregateOutputType> | number
          }
        }
      }
      Query: {
        payload: Prisma.$QueryPayload<ExtArgs>
        fields: Prisma.QueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          findFirst: {
            args: Prisma.QueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          findMany: {
            args: Prisma.QueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          create: {
            args: Prisma.QueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          createMany: {
            args: Prisma.QueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          delete: {
            args: Prisma.QueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          update: {
            args: Prisma.QueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          deleteMany: {
            args: Prisma.QueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          upsert: {
            args: Prisma.QueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          aggregate: {
            args: Prisma.QueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuery>
          }
          groupBy: {
            args: Prisma.QueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueryCountArgs<ExtArgs>
            result: $Utils.Optional<QueryCountAggregateOutputType> | number
          }
        }
      }
      SproutFacebookAnalytics: {
        payload: Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>
        fields: Prisma.SproutFacebookAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SproutFacebookAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SproutFacebookAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.SproutFacebookAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SproutFacebookAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookAnalyticsPayload>
          }
          findMany: {
            args: Prisma.SproutFacebookAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookAnalyticsPayload>[]
          }
          create: {
            args: Prisma.SproutFacebookAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookAnalyticsPayload>
          }
          createMany: {
            args: Prisma.SproutFacebookAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SproutFacebookAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.SproutFacebookAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookAnalyticsPayload>
          }
          update: {
            args: Prisma.SproutFacebookAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.SproutFacebookAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SproutFacebookAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SproutFacebookAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.SproutFacebookAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.SproutFacebookAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSproutFacebookAnalytics>
          }
          groupBy: {
            args: Prisma.SproutFacebookAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SproutFacebookAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SproutFacebookAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<SproutFacebookAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      SproutFacebookPost: {
        payload: Prisma.$SproutFacebookPostPayload<ExtArgs>
        fields: Prisma.SproutFacebookPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SproutFacebookPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SproutFacebookPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostPayload>
          }
          findFirst: {
            args: Prisma.SproutFacebookPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SproutFacebookPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostPayload>
          }
          findMany: {
            args: Prisma.SproutFacebookPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostPayload>[]
          }
          create: {
            args: Prisma.SproutFacebookPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostPayload>
          }
          createMany: {
            args: Prisma.SproutFacebookPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SproutFacebookPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostPayload>[]
          }
          delete: {
            args: Prisma.SproutFacebookPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostPayload>
          }
          update: {
            args: Prisma.SproutFacebookPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostPayload>
          }
          deleteMany: {
            args: Prisma.SproutFacebookPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SproutFacebookPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SproutFacebookPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostPayload>[]
          }
          upsert: {
            args: Prisma.SproutFacebookPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostPayload>
          }
          aggregate: {
            args: Prisma.SproutFacebookPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSproutFacebookPost>
          }
          groupBy: {
            args: Prisma.SproutFacebookPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<SproutFacebookPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.SproutFacebookPostCountArgs<ExtArgs>
            result: $Utils.Optional<SproutFacebookPostCountAggregateOutputType> | number
          }
        }
      }
      SproutFacebookPostAnalytics: {
        payload: Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>
        fields: Prisma.SproutFacebookPostAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SproutFacebookPostAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SproutFacebookPostAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.SproutFacebookPostAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SproutFacebookPostAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostAnalyticsPayload>
          }
          findMany: {
            args: Prisma.SproutFacebookPostAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostAnalyticsPayload>[]
          }
          create: {
            args: Prisma.SproutFacebookPostAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostAnalyticsPayload>
          }
          createMany: {
            args: Prisma.SproutFacebookPostAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SproutFacebookPostAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.SproutFacebookPostAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostAnalyticsPayload>
          }
          update: {
            args: Prisma.SproutFacebookPostAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.SproutFacebookPostAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SproutFacebookPostAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SproutFacebookPostAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.SproutFacebookPostAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutFacebookPostAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.SproutFacebookPostAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSproutFacebookPostAnalytics>
          }
          groupBy: {
            args: Prisma.SproutFacebookPostAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SproutFacebookPostAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SproutFacebookPostAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<SproutFacebookPostAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      SproutInstagramAnalytics: {
        payload: Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>
        fields: Prisma.SproutInstagramAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SproutInstagramAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SproutInstagramAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.SproutInstagramAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SproutInstagramAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramAnalyticsPayload>
          }
          findMany: {
            args: Prisma.SproutInstagramAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramAnalyticsPayload>[]
          }
          create: {
            args: Prisma.SproutInstagramAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramAnalyticsPayload>
          }
          createMany: {
            args: Prisma.SproutInstagramAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SproutInstagramAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.SproutInstagramAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramAnalyticsPayload>
          }
          update: {
            args: Prisma.SproutInstagramAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.SproutInstagramAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SproutInstagramAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SproutInstagramAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.SproutInstagramAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.SproutInstagramAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSproutInstagramAnalytics>
          }
          groupBy: {
            args: Prisma.SproutInstagramAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SproutInstagramAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SproutInstagramAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<SproutInstagramAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      SproutInstagramFollowersByCity: {
        payload: Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>
        fields: Prisma.SproutInstagramFollowersByCityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SproutInstagramFollowersByCityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SproutInstagramFollowersByCityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCityPayload>
          }
          findFirst: {
            args: Prisma.SproutInstagramFollowersByCityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SproutInstagramFollowersByCityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCityPayload>
          }
          findMany: {
            args: Prisma.SproutInstagramFollowersByCityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCityPayload>[]
          }
          create: {
            args: Prisma.SproutInstagramFollowersByCityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCityPayload>
          }
          createMany: {
            args: Prisma.SproutInstagramFollowersByCityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SproutInstagramFollowersByCityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCityPayload>[]
          }
          delete: {
            args: Prisma.SproutInstagramFollowersByCityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCityPayload>
          }
          update: {
            args: Prisma.SproutInstagramFollowersByCityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCityPayload>
          }
          deleteMany: {
            args: Prisma.SproutInstagramFollowersByCityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SproutInstagramFollowersByCityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SproutInstagramFollowersByCityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCityPayload>[]
          }
          upsert: {
            args: Prisma.SproutInstagramFollowersByCityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCityPayload>
          }
          aggregate: {
            args: Prisma.SproutInstagramFollowersByCityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSproutInstagramFollowersByCity>
          }
          groupBy: {
            args: Prisma.SproutInstagramFollowersByCityGroupByArgs<ExtArgs>
            result: $Utils.Optional<SproutInstagramFollowersByCityGroupByOutputType>[]
          }
          count: {
            args: Prisma.SproutInstagramFollowersByCityCountArgs<ExtArgs>
            result: $Utils.Optional<SproutInstagramFollowersByCityCountAggregateOutputType> | number
          }
        }
      }
      SproutInstagramFollowersByCountry: {
        payload: Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>
        fields: Prisma.SproutInstagramFollowersByCountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SproutInstagramFollowersByCountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SproutInstagramFollowersByCountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCountryPayload>
          }
          findFirst: {
            args: Prisma.SproutInstagramFollowersByCountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SproutInstagramFollowersByCountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCountryPayload>
          }
          findMany: {
            args: Prisma.SproutInstagramFollowersByCountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCountryPayload>[]
          }
          create: {
            args: Prisma.SproutInstagramFollowersByCountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCountryPayload>
          }
          createMany: {
            args: Prisma.SproutInstagramFollowersByCountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SproutInstagramFollowersByCountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCountryPayload>[]
          }
          delete: {
            args: Prisma.SproutInstagramFollowersByCountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCountryPayload>
          }
          update: {
            args: Prisma.SproutInstagramFollowersByCountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCountryPayload>
          }
          deleteMany: {
            args: Prisma.SproutInstagramFollowersByCountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SproutInstagramFollowersByCountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SproutInstagramFollowersByCountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCountryPayload>[]
          }
          upsert: {
            args: Prisma.SproutInstagramFollowersByCountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutInstagramFollowersByCountryPayload>
          }
          aggregate: {
            args: Prisma.SproutInstagramFollowersByCountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSproutInstagramFollowersByCountry>
          }
          groupBy: {
            args: Prisma.SproutInstagramFollowersByCountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SproutInstagramFollowersByCountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SproutInstagramFollowersByCountryCountArgs<ExtArgs>
            result: $Utils.Optional<SproutInstagramFollowersByCountryCountAggregateOutputType> | number
          }
        }
      }
      SproutLinkedInAnalytics: {
        payload: Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>
        fields: Prisma.SproutLinkedInAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SproutLinkedInAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutLinkedInAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SproutLinkedInAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutLinkedInAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.SproutLinkedInAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutLinkedInAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SproutLinkedInAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutLinkedInAnalyticsPayload>
          }
          findMany: {
            args: Prisma.SproutLinkedInAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutLinkedInAnalyticsPayload>[]
          }
          create: {
            args: Prisma.SproutLinkedInAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutLinkedInAnalyticsPayload>
          }
          createMany: {
            args: Prisma.SproutLinkedInAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SproutLinkedInAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutLinkedInAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.SproutLinkedInAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutLinkedInAnalyticsPayload>
          }
          update: {
            args: Prisma.SproutLinkedInAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutLinkedInAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.SproutLinkedInAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SproutLinkedInAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SproutLinkedInAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutLinkedInAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.SproutLinkedInAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutLinkedInAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.SproutLinkedInAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSproutLinkedInAnalytics>
          }
          groupBy: {
            args: Prisma.SproutLinkedInAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SproutLinkedInAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SproutLinkedInAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<SproutLinkedInAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      SproutPinterestAnalytics: {
        payload: Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>
        fields: Prisma.SproutPinterestAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SproutPinterestAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutPinterestAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SproutPinterestAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutPinterestAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.SproutPinterestAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutPinterestAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SproutPinterestAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutPinterestAnalyticsPayload>
          }
          findMany: {
            args: Prisma.SproutPinterestAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutPinterestAnalyticsPayload>[]
          }
          create: {
            args: Prisma.SproutPinterestAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutPinterestAnalyticsPayload>
          }
          createMany: {
            args: Prisma.SproutPinterestAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SproutPinterestAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutPinterestAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.SproutPinterestAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutPinterestAnalyticsPayload>
          }
          update: {
            args: Prisma.SproutPinterestAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutPinterestAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.SproutPinterestAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SproutPinterestAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SproutPinterestAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutPinterestAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.SproutPinterestAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutPinterestAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.SproutPinterestAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSproutPinterestAnalytics>
          }
          groupBy: {
            args: Prisma.SproutPinterestAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SproutPinterestAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SproutPinterestAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<SproutPinterestAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      SproutSocialAccount: {
        payload: Prisma.$SproutSocialAccountPayload<ExtArgs>
        fields: Prisma.SproutSocialAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SproutSocialAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutSocialAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SproutSocialAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutSocialAccountPayload>
          }
          findFirst: {
            args: Prisma.SproutSocialAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutSocialAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SproutSocialAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutSocialAccountPayload>
          }
          findMany: {
            args: Prisma.SproutSocialAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutSocialAccountPayload>[]
          }
          create: {
            args: Prisma.SproutSocialAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutSocialAccountPayload>
          }
          createMany: {
            args: Prisma.SproutSocialAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SproutSocialAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutSocialAccountPayload>[]
          }
          delete: {
            args: Prisma.SproutSocialAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutSocialAccountPayload>
          }
          update: {
            args: Prisma.SproutSocialAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutSocialAccountPayload>
          }
          deleteMany: {
            args: Prisma.SproutSocialAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SproutSocialAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SproutSocialAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutSocialAccountPayload>[]
          }
          upsert: {
            args: Prisma.SproutSocialAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SproutSocialAccountPayload>
          }
          aggregate: {
            args: Prisma.SproutSocialAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSproutSocialAccount>
          }
          groupBy: {
            args: Prisma.SproutSocialAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SproutSocialAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SproutSocialAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SproutSocialAccountCountAggregateOutputType> | number
          }
        }
      }
      UserToSproutSocialAccount: {
        payload: Prisma.$UserToSproutSocialAccountPayload<ExtArgs>
        fields: Prisma.UserToSproutSocialAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserToSproutSocialAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToSproutSocialAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserToSproutSocialAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToSproutSocialAccountPayload>
          }
          findFirst: {
            args: Prisma.UserToSproutSocialAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToSproutSocialAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserToSproutSocialAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToSproutSocialAccountPayload>
          }
          findMany: {
            args: Prisma.UserToSproutSocialAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToSproutSocialAccountPayload>[]
          }
          create: {
            args: Prisma.UserToSproutSocialAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToSproutSocialAccountPayload>
          }
          createMany: {
            args: Prisma.UserToSproutSocialAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserToSproutSocialAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToSproutSocialAccountPayload>[]
          }
          delete: {
            args: Prisma.UserToSproutSocialAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToSproutSocialAccountPayload>
          }
          update: {
            args: Prisma.UserToSproutSocialAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToSproutSocialAccountPayload>
          }
          deleteMany: {
            args: Prisma.UserToSproutSocialAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserToSproutSocialAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserToSproutSocialAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToSproutSocialAccountPayload>[]
          }
          upsert: {
            args: Prisma.UserToSproutSocialAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToSproutSocialAccountPayload>
          }
          aggregate: {
            args: Prisma.UserToSproutSocialAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserToSproutSocialAccount>
          }
          groupBy: {
            args: Prisma.UserToSproutSocialAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserToSproutSocialAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserToSproutSocialAccountCountArgs<ExtArgs>
            result: $Utils.Optional<UserToSproutSocialAccountCountAggregateOutputType> | number
          }
        }
      }
      UserToGaAccount: {
        payload: Prisma.$UserToGaAccountPayload<ExtArgs>
        fields: Prisma.UserToGaAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserToGaAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToGaAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserToGaAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToGaAccountPayload>
          }
          findFirst: {
            args: Prisma.UserToGaAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToGaAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserToGaAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToGaAccountPayload>
          }
          findMany: {
            args: Prisma.UserToGaAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToGaAccountPayload>[]
          }
          create: {
            args: Prisma.UserToGaAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToGaAccountPayload>
          }
          createMany: {
            args: Prisma.UserToGaAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserToGaAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToGaAccountPayload>[]
          }
          delete: {
            args: Prisma.UserToGaAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToGaAccountPayload>
          }
          update: {
            args: Prisma.UserToGaAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToGaAccountPayload>
          }
          deleteMany: {
            args: Prisma.UserToGaAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserToGaAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserToGaAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToGaAccountPayload>[]
          }
          upsert: {
            args: Prisma.UserToGaAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToGaAccountPayload>
          }
          aggregate: {
            args: Prisma.UserToGaAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserToGaAccount>
          }
          groupBy: {
            args: Prisma.UserToGaAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserToGaAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserToGaAccountCountArgs<ExtArgs>
            result: $Utils.Optional<UserToGaAccountCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketAttachment: {
        payload: Prisma.$TicketAttachmentPayload<ExtArgs>
        fields: Prisma.TicketAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findFirst: {
            args: Prisma.TicketAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findMany: {
            args: Prisma.TicketAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          create: {
            args: Prisma.TicketAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          createMany: {
            args: Prisma.TicketAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          delete: {
            args: Prisma.TicketAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          update: {
            args: Prisma.TicketAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.TicketAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.TicketAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          aggregate: {
            args: Prisma.TicketAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketAttachment>
          }
          groupBy: {
            args: Prisma.TicketAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentCountAggregateOutputType> | number
          }
        }
      }
      TicketComment: {
        payload: Prisma.$TicketCommentPayload<ExtArgs>
        fields: Prisma.TicketCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findFirst: {
            args: Prisma.TicketCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findMany: {
            args: Prisma.TicketCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          create: {
            args: Prisma.TicketCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          createMany: {
            args: Prisma.TicketCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          delete: {
            args: Prisma.TicketCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          update: {
            args: Prisma.TicketCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          deleteMany: {
            args: Prisma.TicketCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          upsert: {
            args: Prisma.TicketCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          aggregate: {
            args: Prisma.TicketCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketComment>
          }
          groupBy: {
            args: Prisma.TicketCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCommentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentCountAggregateOutputType> | number
          }
        }
      }
      TicketTag: {
        payload: Prisma.$TicketTagPayload<ExtArgs>
        fields: Prisma.TicketTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          findFirst: {
            args: Prisma.TicketTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          findMany: {
            args: Prisma.TicketTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>[]
          }
          create: {
            args: Prisma.TicketTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          createMany: {
            args: Prisma.TicketTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>[]
          }
          delete: {
            args: Prisma.TicketTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          update: {
            args: Prisma.TicketTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          deleteMany: {
            args: Prisma.TicketTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>[]
          }
          upsert: {
            args: Prisma.TicketTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          aggregate: {
            args: Prisma.TicketTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketTag>
          }
          groupBy: {
            args: Prisma.TicketTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketTagCountArgs<ExtArgs>
            result: $Utils.Optional<TicketTagCountAggregateOutputType> | number
          }
        }
      }
      MessageAttachment: {
        payload: Prisma.$MessageAttachmentPayload<ExtArgs>
        fields: Prisma.MessageAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findFirst: {
            args: Prisma.MessageAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findMany: {
            args: Prisma.MessageAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          create: {
            args: Prisma.MessageAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          createMany: {
            args: Prisma.MessageAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          delete: {
            args: Prisma.MessageAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          update: {
            args: Prisma.MessageAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.MessageAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.MessageAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          aggregate: {
            args: Prisma.MessageAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageAttachment>
          }
          groupBy: {
            args: Prisma.MessageAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<MessageAttachmentCountAggregateOutputType> | number
          }
        }
      }
      ClientActivity: {
        payload: Prisma.$ClientActivityPayload<ExtArgs>
        fields: Prisma.ClientActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          findFirst: {
            args: Prisma.ClientActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          findMany: {
            args: Prisma.ClientActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>[]
          }
          create: {
            args: Prisma.ClientActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          createMany: {
            args: Prisma.ClientActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>[]
          }
          delete: {
            args: Prisma.ClientActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          update: {
            args: Prisma.ClientActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          deleteMany: {
            args: Prisma.ClientActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>[]
          }
          upsert: {
            args: Prisma.ClientActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientActivityPayload>
          }
          aggregate: {
            args: Prisma.ClientActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientActivity>
          }
          groupBy: {
            args: Prisma.ClientActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ClientActivityCountAggregateOutputType> | number
          }
        }
      }
      UserToEmailClient: {
        payload: Prisma.$UserToEmailClientPayload<ExtArgs>
        fields: Prisma.UserToEmailClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserToEmailClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToEmailClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserToEmailClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToEmailClientPayload>
          }
          findFirst: {
            args: Prisma.UserToEmailClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToEmailClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserToEmailClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToEmailClientPayload>
          }
          findMany: {
            args: Prisma.UserToEmailClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToEmailClientPayload>[]
          }
          create: {
            args: Prisma.UserToEmailClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToEmailClientPayload>
          }
          createMany: {
            args: Prisma.UserToEmailClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserToEmailClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToEmailClientPayload>[]
          }
          delete: {
            args: Prisma.UserToEmailClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToEmailClientPayload>
          }
          update: {
            args: Prisma.UserToEmailClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToEmailClientPayload>
          }
          deleteMany: {
            args: Prisma.UserToEmailClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserToEmailClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserToEmailClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToEmailClientPayload>[]
          }
          upsert: {
            args: Prisma.UserToEmailClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToEmailClientPayload>
          }
          aggregate: {
            args: Prisma.UserToEmailClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserToEmailClient>
          }
          groupBy: {
            args: Prisma.UserToEmailClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserToEmailClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserToEmailClientCountArgs<ExtArgs>
            result: $Utils.Optional<UserToEmailClientCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    clientSatisfaction?: ClientSatisfactionOmit
    company?: CompanyOmit
    conversation?: ConversationOmit
    emailCampaign?: EmailCampaignOmit
    emailCampaignContent?: EmailCampaignContentOmit
    emailCampaignDailyStats?: EmailCampaignDailyStatsOmit
    emailClient?: EmailClientOmit
    emailClientCredentials?: EmailClientCredentialsOmit
    emailGlobalDailyStats?: EmailGlobalDailyStatsOmit
    gaAccount?: GaAccountOmit
    gaProperty?: GaPropertyOmit
    gaImportRun?: GaImportRunOmit
    gaKpiDaily?: GaKpiDailyOmit
    gaKpiMonthly?: GaKpiMonthlyOmit
    gaChannelDaily?: GaChannelDailyOmit
    gaSourceDaily?: GaSourceDailyOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    role?: RoleOmit
    message?: MessageOmit
    notification?: NotificationOmit
    parsedPieGraphData?: ParsedPieGraphDataOmit
    parsedQueryData?: ParsedQueryDataOmit
    parsedQuerySummary?: ParsedQuerySummaryOmit
    query?: QueryOmit
    sproutFacebookAnalytics?: SproutFacebookAnalyticsOmit
    sproutFacebookPost?: SproutFacebookPostOmit
    sproutFacebookPostAnalytics?: SproutFacebookPostAnalyticsOmit
    sproutInstagramAnalytics?: SproutInstagramAnalyticsOmit
    sproutInstagramFollowersByCity?: SproutInstagramFollowersByCityOmit
    sproutInstagramFollowersByCountry?: SproutInstagramFollowersByCountryOmit
    sproutLinkedInAnalytics?: SproutLinkedInAnalyticsOmit
    sproutPinterestAnalytics?: SproutPinterestAnalyticsOmit
    sproutSocialAccount?: SproutSocialAccountOmit
    userToSproutSocialAccount?: UserToSproutSocialAccountOmit
    userToGaAccount?: UserToGaAccountOmit
    user?: UserOmit
    userSettings?: UserSettingsOmit
    ticket?: TicketOmit
    ticketAttachment?: TicketAttachmentOmit
    ticketComment?: TicketCommentOmit
    ticketTag?: TicketTagOmit
    messageAttachment?: MessageAttachmentOmit
    clientActivity?: ClientActivityOmit
    userToEmailClient?: UserToEmailClientOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    users: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    queries: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    queries?: boolean | ConversationCountOutputTypeCountQueriesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
  }


  /**
   * Count Type EmailCampaignCountOutputType
   */

  export type EmailCampaignCountOutputType = {
    emailCampaignDailyStats: number
  }

  export type EmailCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailCampaignDailyStats?: boolean | EmailCampaignCountOutputTypeCountEmailCampaignDailyStatsArgs
  }

  // Custom InputTypes
  /**
   * EmailCampaignCountOutputType without action
   */
  export type EmailCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignCountOutputType
     */
    select?: EmailCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailCampaignCountOutputType without action
   */
  export type EmailCampaignCountOutputTypeCountEmailCampaignDailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCampaignDailyStatsWhereInput
  }


  /**
   * Count Type EmailClientCountOutputType
   */

  export type EmailClientCountOutputType = {
    emailCampaigns: number
    emailCampaignDailyStats: number
    emailClientCredentials: number
    emailGlobalDailyStats: number
    users: number
  }

  export type EmailClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailCampaigns?: boolean | EmailClientCountOutputTypeCountEmailCampaignsArgs
    emailCampaignDailyStats?: boolean | EmailClientCountOutputTypeCountEmailCampaignDailyStatsArgs
    emailClientCredentials?: boolean | EmailClientCountOutputTypeCountEmailClientCredentialsArgs
    emailGlobalDailyStats?: boolean | EmailClientCountOutputTypeCountEmailGlobalDailyStatsArgs
    users?: boolean | EmailClientCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * EmailClientCountOutputType without action
   */
  export type EmailClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCountOutputType
     */
    select?: EmailClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailClientCountOutputType without action
   */
  export type EmailClientCountOutputTypeCountEmailCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCampaignWhereInput
  }

  /**
   * EmailClientCountOutputType without action
   */
  export type EmailClientCountOutputTypeCountEmailCampaignDailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCampaignDailyStatsWhereInput
  }

  /**
   * EmailClientCountOutputType without action
   */
  export type EmailClientCountOutputTypeCountEmailClientCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailClientCredentialsWhereInput
  }

  /**
   * EmailClientCountOutputType without action
   */
  export type EmailClientCountOutputTypeCountEmailGlobalDailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailGlobalDailyStatsWhereInput
  }

  /**
   * EmailClientCountOutputType without action
   */
  export type EmailClientCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToEmailClientWhereInput
  }


  /**
   * Count Type GaAccountCountOutputType
   */

  export type GaAccountCountOutputType = {
    conversations: number
    gaProperties: number
    userToGaAccounts: number
  }

  export type GaAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | GaAccountCountOutputTypeCountConversationsArgs
    gaProperties?: boolean | GaAccountCountOutputTypeCountGaPropertiesArgs
    userToGaAccounts?: boolean | GaAccountCountOutputTypeCountUserToGaAccountsArgs
  }

  // Custom InputTypes
  /**
   * GaAccountCountOutputType without action
   */
  export type GaAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccountCountOutputType
     */
    select?: GaAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GaAccountCountOutputType without action
   */
  export type GaAccountCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * GaAccountCountOutputType without action
   */
  export type GaAccountCountOutputTypeCountGaPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaPropertyWhereInput
  }

  /**
   * GaAccountCountOutputType without action
   */
  export type GaAccountCountOutputTypeCountUserToGaAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToGaAccountWhereInput
  }


  /**
   * Count Type GaPropertyCountOutputType
   */

  export type GaPropertyCountOutputType = {
    conversations: number
    channelDaily: number
    imports: number
    kpiDaily: number
    kpiMonthly: number
    sourceDaily: number
  }

  export type GaPropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | GaPropertyCountOutputTypeCountConversationsArgs
    channelDaily?: boolean | GaPropertyCountOutputTypeCountChannelDailyArgs
    imports?: boolean | GaPropertyCountOutputTypeCountImportsArgs
    kpiDaily?: boolean | GaPropertyCountOutputTypeCountKpiDailyArgs
    kpiMonthly?: boolean | GaPropertyCountOutputTypeCountKpiMonthlyArgs
    sourceDaily?: boolean | GaPropertyCountOutputTypeCountSourceDailyArgs
  }

  // Custom InputTypes
  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaPropertyCountOutputType
     */
    select?: GaPropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountChannelDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaChannelDailyWhereInput
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaImportRunWhereInput
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountKpiDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaKpiDailyWhereInput
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountKpiMonthlyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaKpiMonthlyWhereInput
  }

  /**
   * GaPropertyCountOutputType without action
   */
  export type GaPropertyCountOutputTypeCountSourceDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaSourceDailyWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    replies: number
    attachments: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | MessageCountOutputTypeCountRepliesArgs
    attachments?: boolean | MessageCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
  }


  /**
   * Count Type QueryCountOutputType
   */

  export type QueryCountOutputType = {
    parsedPieData: number
    parsedData: number
    parsedSummary: number
  }

  export type QueryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parsedPieData?: boolean | QueryCountOutputTypeCountParsedPieDataArgs
    parsedData?: boolean | QueryCountOutputTypeCountParsedDataArgs
    parsedSummary?: boolean | QueryCountOutputTypeCountParsedSummaryArgs
  }

  // Custom InputTypes
  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryCountOutputType
     */
    select?: QueryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeCountParsedPieDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedPieGraphDataWhereInput
  }

  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeCountParsedDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedQueryDataWhereInput
  }

  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeCountParsedSummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedQuerySummaryWhereInput
  }


  /**
   * Count Type SproutInstagramAnalyticsCountOutputType
   */

  export type SproutInstagramAnalyticsCountOutputType = {
    followersByCity: number
    followersByCountry: number
  }

  export type SproutInstagramAnalyticsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followersByCity?: boolean | SproutInstagramAnalyticsCountOutputTypeCountFollowersByCityArgs
    followersByCountry?: boolean | SproutInstagramAnalyticsCountOutputTypeCountFollowersByCountryArgs
  }

  // Custom InputTypes
  /**
   * SproutInstagramAnalyticsCountOutputType without action
   */
  export type SproutInstagramAnalyticsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalyticsCountOutputType
     */
    select?: SproutInstagramAnalyticsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SproutInstagramAnalyticsCountOutputType without action
   */
  export type SproutInstagramAnalyticsCountOutputTypeCountFollowersByCityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutInstagramFollowersByCityWhereInput
  }

  /**
   * SproutInstagramAnalyticsCountOutputType without action
   */
  export type SproutInstagramAnalyticsCountOutputTypeCountFollowersByCountryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutInstagramFollowersByCountryWhereInput
  }


  /**
   * Count Type SproutSocialAccountCountOutputType
   */

  export type SproutSocialAccountCountOutputType = {
    facebookAnalytics: number
    facebookPosts: number
    facebookPostAnalytics: number
    instagramAnalytics: number
    linkedInAnalytics: number
    pinterestAnalytics: number
    users: number
  }

  export type SproutSocialAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facebookAnalytics?: boolean | SproutSocialAccountCountOutputTypeCountFacebookAnalyticsArgs
    facebookPosts?: boolean | SproutSocialAccountCountOutputTypeCountFacebookPostsArgs
    facebookPostAnalytics?: boolean | SproutSocialAccountCountOutputTypeCountFacebookPostAnalyticsArgs
    instagramAnalytics?: boolean | SproutSocialAccountCountOutputTypeCountInstagramAnalyticsArgs
    linkedInAnalytics?: boolean | SproutSocialAccountCountOutputTypeCountLinkedInAnalyticsArgs
    pinterestAnalytics?: boolean | SproutSocialAccountCountOutputTypeCountPinterestAnalyticsArgs
    users?: boolean | SproutSocialAccountCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * SproutSocialAccountCountOutputType without action
   */
  export type SproutSocialAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccountCountOutputType
     */
    select?: SproutSocialAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SproutSocialAccountCountOutputType without action
   */
  export type SproutSocialAccountCountOutputTypeCountFacebookAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutFacebookAnalyticsWhereInput
  }

  /**
   * SproutSocialAccountCountOutputType without action
   */
  export type SproutSocialAccountCountOutputTypeCountFacebookPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutFacebookPostWhereInput
  }

  /**
   * SproutSocialAccountCountOutputType without action
   */
  export type SproutSocialAccountCountOutputTypeCountFacebookPostAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutFacebookPostAnalyticsWhereInput
  }

  /**
   * SproutSocialAccountCountOutputType without action
   */
  export type SproutSocialAccountCountOutputTypeCountInstagramAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutInstagramAnalyticsWhereInput
  }

  /**
   * SproutSocialAccountCountOutputType without action
   */
  export type SproutSocialAccountCountOutputTypeCountLinkedInAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutLinkedInAnalyticsWhereInput
  }

  /**
   * SproutSocialAccountCountOutputType without action
   */
  export type SproutSocialAccountCountOutputTypeCountPinterestAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutPinterestAnalyticsWhereInput
  }

  /**
   * SproutSocialAccountCountOutputType without action
   */
  export type SproutSocialAccountCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToSproutSocialAccountWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    activities: number
    receivedRatings: number
    givenRatings: number
    clientConversations: number
    conversations: number
    gaImportRuns: number
    receivedMessages: number
    sentMessages: number
    notifications: number
    queries: number
    sessions: number
    assignedTickets: number
    clientTickets: number
    ticketComments: number
    clients: number
    emailClients: number
    userToGaAccounts: number
    sproutSocialAccounts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    receivedRatings?: boolean | UserCountOutputTypeCountReceivedRatingsArgs
    givenRatings?: boolean | UserCountOutputTypeCountGivenRatingsArgs
    clientConversations?: boolean | UserCountOutputTypeCountClientConversationsArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    gaImportRuns?: boolean | UserCountOutputTypeCountGaImportRunsArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    queries?: boolean | UserCountOutputTypeCountQueriesArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    assignedTickets?: boolean | UserCountOutputTypeCountAssignedTicketsArgs
    clientTickets?: boolean | UserCountOutputTypeCountClientTicketsArgs
    ticketComments?: boolean | UserCountOutputTypeCountTicketCommentsArgs
    clients?: boolean | UserCountOutputTypeCountClientsArgs
    emailClients?: boolean | UserCountOutputTypeCountEmailClientsArgs
    userToGaAccounts?: boolean | UserCountOutputTypeCountUserToGaAccountsArgs
    sproutSocialAccounts?: boolean | UserCountOutputTypeCountSproutSocialAccountsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSatisfactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGivenRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSatisfactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGaImportRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaImportRunWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToEmailClientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserToGaAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToGaAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSproutSocialAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToSproutSocialAccountWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    attachments: number
    comments: number
    tags: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | TicketCountOutputTypeCountAttachmentsArgs
    comments?: boolean | TicketCountOutputTypeCountCommentsArgs
    tags?: boolean | TicketCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTagWhereInput
  }


  /**
   * Count Type TicketTagCountOutputType
   */

  export type TicketTagCountOutputType = {
    tickets: number
  }

  export type TicketTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | TicketTagCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * TicketTagCountOutputType without action
   */
  export type TicketTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTagCountOutputType
     */
    select?: TicketTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketTagCountOutputType without action
   */
  export type TicketTagCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model ClientSatisfaction
   */

  export type AggregateClientSatisfaction = {
    _count: ClientSatisfactionCountAggregateOutputType | null
    _avg: ClientSatisfactionAvgAggregateOutputType | null
    _sum: ClientSatisfactionSumAggregateOutputType | null
    _min: ClientSatisfactionMinAggregateOutputType | null
    _max: ClientSatisfactionMaxAggregateOutputType | null
  }

  export type ClientSatisfactionAvgAggregateOutputType = {
    rating: number | null
  }

  export type ClientSatisfactionSumAggregateOutputType = {
    rating: number | null
  }

  export type ClientSatisfactionMinAggregateOutputType = {
    id: string | null
    rating: number | null
    feedback: string | null
    userId: string | null
    accountRepId: string | null
    createdAt: Date | null
  }

  export type ClientSatisfactionMaxAggregateOutputType = {
    id: string | null
    rating: number | null
    feedback: string | null
    userId: string | null
    accountRepId: string | null
    createdAt: Date | null
  }

  export type ClientSatisfactionCountAggregateOutputType = {
    id: number
    rating: number
    feedback: number
    userId: number
    accountRepId: number
    createdAt: number
    _all: number
  }


  export type ClientSatisfactionAvgAggregateInputType = {
    rating?: true
  }

  export type ClientSatisfactionSumAggregateInputType = {
    rating?: true
  }

  export type ClientSatisfactionMinAggregateInputType = {
    id?: true
    rating?: true
    feedback?: true
    userId?: true
    accountRepId?: true
    createdAt?: true
  }

  export type ClientSatisfactionMaxAggregateInputType = {
    id?: true
    rating?: true
    feedback?: true
    userId?: true
    accountRepId?: true
    createdAt?: true
  }

  export type ClientSatisfactionCountAggregateInputType = {
    id?: true
    rating?: true
    feedback?: true
    userId?: true
    accountRepId?: true
    createdAt?: true
    _all?: true
  }

  export type ClientSatisfactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientSatisfaction to aggregate.
     */
    where?: ClientSatisfactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSatisfactions to fetch.
     */
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientSatisfactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSatisfactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSatisfactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientSatisfactions
    **/
    _count?: true | ClientSatisfactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientSatisfactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSatisfactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientSatisfactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientSatisfactionMaxAggregateInputType
  }

  export type GetClientSatisfactionAggregateType<T extends ClientSatisfactionAggregateArgs> = {
        [P in keyof T & keyof AggregateClientSatisfaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientSatisfaction[P]>
      : GetScalarType<T[P], AggregateClientSatisfaction[P]>
  }




  export type ClientSatisfactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSatisfactionWhereInput
    orderBy?: ClientSatisfactionOrderByWithAggregationInput | ClientSatisfactionOrderByWithAggregationInput[]
    by: ClientSatisfactionScalarFieldEnum[] | ClientSatisfactionScalarFieldEnum
    having?: ClientSatisfactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientSatisfactionCountAggregateInputType | true
    _avg?: ClientSatisfactionAvgAggregateInputType
    _sum?: ClientSatisfactionSumAggregateInputType
    _min?: ClientSatisfactionMinAggregateInputType
    _max?: ClientSatisfactionMaxAggregateInputType
  }

  export type ClientSatisfactionGroupByOutputType = {
    id: string
    rating: number
    feedback: string | null
    userId: string
    accountRepId: string
    createdAt: Date
    _count: ClientSatisfactionCountAggregateOutputType | null
    _avg: ClientSatisfactionAvgAggregateOutputType | null
    _sum: ClientSatisfactionSumAggregateOutputType | null
    _min: ClientSatisfactionMinAggregateOutputType | null
    _max: ClientSatisfactionMaxAggregateOutputType | null
  }

  type GetClientSatisfactionGroupByPayload<T extends ClientSatisfactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientSatisfactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientSatisfactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientSatisfactionGroupByOutputType[P]>
            : GetScalarType<T[P], ClientSatisfactionGroupByOutputType[P]>
        }
      >
    >


  export type ClientSatisfactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    feedback?: boolean
    userId?: boolean
    accountRepId?: boolean
    createdAt?: boolean
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSatisfaction"]>

  export type ClientSatisfactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    feedback?: boolean
    userId?: boolean
    accountRepId?: boolean
    createdAt?: boolean
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSatisfaction"]>

  export type ClientSatisfactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    feedback?: boolean
    userId?: boolean
    accountRepId?: boolean
    createdAt?: boolean
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSatisfaction"]>

  export type ClientSatisfactionSelectScalar = {
    id?: boolean
    rating?: boolean
    feedback?: boolean
    userId?: boolean
    accountRepId?: boolean
    createdAt?: boolean
  }

  export type ClientSatisfactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rating" | "feedback" | "userId" | "accountRepId" | "createdAt", ExtArgs["result"]["clientSatisfaction"]>
  export type ClientSatisfactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientSatisfactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientSatisfactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountRep?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientSatisfactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientSatisfaction"
    objects: {
      accountRep: Prisma.$UserPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rating: number
      feedback: string | null
      userId: string
      accountRepId: string
      createdAt: Date
    }, ExtArgs["result"]["clientSatisfaction"]>
    composites: {}
  }

  type ClientSatisfactionGetPayload<S extends boolean | null | undefined | ClientSatisfactionDefaultArgs> = $Result.GetResult<Prisma.$ClientSatisfactionPayload, S>

  type ClientSatisfactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientSatisfactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientSatisfactionCountAggregateInputType | true
    }

  export interface ClientSatisfactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientSatisfaction'], meta: { name: 'ClientSatisfaction' } }
    /**
     * Find zero or one ClientSatisfaction that matches the filter.
     * @param {ClientSatisfactionFindUniqueArgs} args - Arguments to find a ClientSatisfaction
     * @example
     * // Get one ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientSatisfactionFindUniqueArgs>(args: SelectSubset<T, ClientSatisfactionFindUniqueArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientSatisfaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientSatisfactionFindUniqueOrThrowArgs} args - Arguments to find a ClientSatisfaction
     * @example
     * // Get one ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientSatisfactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientSatisfactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientSatisfaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionFindFirstArgs} args - Arguments to find a ClientSatisfaction
     * @example
     * // Get one ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientSatisfactionFindFirstArgs>(args?: SelectSubset<T, ClientSatisfactionFindFirstArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientSatisfaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionFindFirstOrThrowArgs} args - Arguments to find a ClientSatisfaction
     * @example
     * // Get one ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientSatisfactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientSatisfactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientSatisfactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientSatisfactions
     * const clientSatisfactions = await prisma.clientSatisfaction.findMany()
     * 
     * // Get first 10 ClientSatisfactions
     * const clientSatisfactions = await prisma.clientSatisfaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientSatisfactionWithIdOnly = await prisma.clientSatisfaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientSatisfactionFindManyArgs>(args?: SelectSubset<T, ClientSatisfactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientSatisfaction.
     * @param {ClientSatisfactionCreateArgs} args - Arguments to create a ClientSatisfaction.
     * @example
     * // Create one ClientSatisfaction
     * const ClientSatisfaction = await prisma.clientSatisfaction.create({
     *   data: {
     *     // ... data to create a ClientSatisfaction
     *   }
     * })
     * 
     */
    create<T extends ClientSatisfactionCreateArgs>(args: SelectSubset<T, ClientSatisfactionCreateArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientSatisfactions.
     * @param {ClientSatisfactionCreateManyArgs} args - Arguments to create many ClientSatisfactions.
     * @example
     * // Create many ClientSatisfactions
     * const clientSatisfaction = await prisma.clientSatisfaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientSatisfactionCreateManyArgs>(args?: SelectSubset<T, ClientSatisfactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientSatisfactions and returns the data saved in the database.
     * @param {ClientSatisfactionCreateManyAndReturnArgs} args - Arguments to create many ClientSatisfactions.
     * @example
     * // Create many ClientSatisfactions
     * const clientSatisfaction = await prisma.clientSatisfaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientSatisfactions and only return the `id`
     * const clientSatisfactionWithIdOnly = await prisma.clientSatisfaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientSatisfactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientSatisfactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientSatisfaction.
     * @param {ClientSatisfactionDeleteArgs} args - Arguments to delete one ClientSatisfaction.
     * @example
     * // Delete one ClientSatisfaction
     * const ClientSatisfaction = await prisma.clientSatisfaction.delete({
     *   where: {
     *     // ... filter to delete one ClientSatisfaction
     *   }
     * })
     * 
     */
    delete<T extends ClientSatisfactionDeleteArgs>(args: SelectSubset<T, ClientSatisfactionDeleteArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientSatisfaction.
     * @param {ClientSatisfactionUpdateArgs} args - Arguments to update one ClientSatisfaction.
     * @example
     * // Update one ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientSatisfactionUpdateArgs>(args: SelectSubset<T, ClientSatisfactionUpdateArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientSatisfactions.
     * @param {ClientSatisfactionDeleteManyArgs} args - Arguments to filter ClientSatisfactions to delete.
     * @example
     * // Delete a few ClientSatisfactions
     * const { count } = await prisma.clientSatisfaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientSatisfactionDeleteManyArgs>(args?: SelectSubset<T, ClientSatisfactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientSatisfactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientSatisfactions
     * const clientSatisfaction = await prisma.clientSatisfaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientSatisfactionUpdateManyArgs>(args: SelectSubset<T, ClientSatisfactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientSatisfactions and returns the data updated in the database.
     * @param {ClientSatisfactionUpdateManyAndReturnArgs} args - Arguments to update many ClientSatisfactions.
     * @example
     * // Update many ClientSatisfactions
     * const clientSatisfaction = await prisma.clientSatisfaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientSatisfactions and only return the `id`
     * const clientSatisfactionWithIdOnly = await prisma.clientSatisfaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientSatisfactionUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientSatisfactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientSatisfaction.
     * @param {ClientSatisfactionUpsertArgs} args - Arguments to update or create a ClientSatisfaction.
     * @example
     * // Update or create a ClientSatisfaction
     * const clientSatisfaction = await prisma.clientSatisfaction.upsert({
     *   create: {
     *     // ... data to create a ClientSatisfaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientSatisfaction we want to update
     *   }
     * })
     */
    upsert<T extends ClientSatisfactionUpsertArgs>(args: SelectSubset<T, ClientSatisfactionUpsertArgs<ExtArgs>>): Prisma__ClientSatisfactionClient<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientSatisfactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionCountArgs} args - Arguments to filter ClientSatisfactions to count.
     * @example
     * // Count the number of ClientSatisfactions
     * const count = await prisma.clientSatisfaction.count({
     *   where: {
     *     // ... the filter for the ClientSatisfactions we want to count
     *   }
     * })
    **/
    count<T extends ClientSatisfactionCountArgs>(
      args?: Subset<T, ClientSatisfactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientSatisfactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientSatisfaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientSatisfactionAggregateArgs>(args: Subset<T, ClientSatisfactionAggregateArgs>): Prisma.PrismaPromise<GetClientSatisfactionAggregateType<T>>

    /**
     * Group by ClientSatisfaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSatisfactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientSatisfactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientSatisfactionGroupByArgs['orderBy'] }
        : { orderBy?: ClientSatisfactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientSatisfactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientSatisfactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientSatisfaction model
   */
  readonly fields: ClientSatisfactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientSatisfaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientSatisfactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accountRep<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientSatisfaction model
   */
  interface ClientSatisfactionFieldRefs {
    readonly id: FieldRef<"ClientSatisfaction", 'String'>
    readonly rating: FieldRef<"ClientSatisfaction", 'Float'>
    readonly feedback: FieldRef<"ClientSatisfaction", 'String'>
    readonly userId: FieldRef<"ClientSatisfaction", 'String'>
    readonly accountRepId: FieldRef<"ClientSatisfaction", 'String'>
    readonly createdAt: FieldRef<"ClientSatisfaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientSatisfaction findUnique
   */
  export type ClientSatisfactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSatisfaction to fetch.
     */
    where: ClientSatisfactionWhereUniqueInput
  }

  /**
   * ClientSatisfaction findUniqueOrThrow
   */
  export type ClientSatisfactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSatisfaction to fetch.
     */
    where: ClientSatisfactionWhereUniqueInput
  }

  /**
   * ClientSatisfaction findFirst
   */
  export type ClientSatisfactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSatisfaction to fetch.
     */
    where?: ClientSatisfactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSatisfactions to fetch.
     */
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientSatisfactions.
     */
    cursor?: ClientSatisfactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSatisfactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSatisfactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientSatisfactions.
     */
    distinct?: ClientSatisfactionScalarFieldEnum | ClientSatisfactionScalarFieldEnum[]
  }

  /**
   * ClientSatisfaction findFirstOrThrow
   */
  export type ClientSatisfactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSatisfaction to fetch.
     */
    where?: ClientSatisfactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSatisfactions to fetch.
     */
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientSatisfactions.
     */
    cursor?: ClientSatisfactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSatisfactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSatisfactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientSatisfactions.
     */
    distinct?: ClientSatisfactionScalarFieldEnum | ClientSatisfactionScalarFieldEnum[]
  }

  /**
   * ClientSatisfaction findMany
   */
  export type ClientSatisfactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter, which ClientSatisfactions to fetch.
     */
    where?: ClientSatisfactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSatisfactions to fetch.
     */
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientSatisfactions.
     */
    cursor?: ClientSatisfactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSatisfactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSatisfactions.
     */
    skip?: number
    distinct?: ClientSatisfactionScalarFieldEnum | ClientSatisfactionScalarFieldEnum[]
  }

  /**
   * ClientSatisfaction create
   */
  export type ClientSatisfactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientSatisfaction.
     */
    data: XOR<ClientSatisfactionCreateInput, ClientSatisfactionUncheckedCreateInput>
  }

  /**
   * ClientSatisfaction createMany
   */
  export type ClientSatisfactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientSatisfactions.
     */
    data: ClientSatisfactionCreateManyInput | ClientSatisfactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientSatisfaction createManyAndReturn
   */
  export type ClientSatisfactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * The data used to create many ClientSatisfactions.
     */
    data: ClientSatisfactionCreateManyInput | ClientSatisfactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientSatisfaction update
   */
  export type ClientSatisfactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientSatisfaction.
     */
    data: XOR<ClientSatisfactionUpdateInput, ClientSatisfactionUncheckedUpdateInput>
    /**
     * Choose, which ClientSatisfaction to update.
     */
    where: ClientSatisfactionWhereUniqueInput
  }

  /**
   * ClientSatisfaction updateMany
   */
  export type ClientSatisfactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientSatisfactions.
     */
    data: XOR<ClientSatisfactionUpdateManyMutationInput, ClientSatisfactionUncheckedUpdateManyInput>
    /**
     * Filter which ClientSatisfactions to update
     */
    where?: ClientSatisfactionWhereInput
    /**
     * Limit how many ClientSatisfactions to update.
     */
    limit?: number
  }

  /**
   * ClientSatisfaction updateManyAndReturn
   */
  export type ClientSatisfactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * The data used to update ClientSatisfactions.
     */
    data: XOR<ClientSatisfactionUpdateManyMutationInput, ClientSatisfactionUncheckedUpdateManyInput>
    /**
     * Filter which ClientSatisfactions to update
     */
    where?: ClientSatisfactionWhereInput
    /**
     * Limit how many ClientSatisfactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientSatisfaction upsert
   */
  export type ClientSatisfactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientSatisfaction to update in case it exists.
     */
    where: ClientSatisfactionWhereUniqueInput
    /**
     * In case the ClientSatisfaction found by the `where` argument doesn't exist, create a new ClientSatisfaction with this data.
     */
    create: XOR<ClientSatisfactionCreateInput, ClientSatisfactionUncheckedCreateInput>
    /**
     * In case the ClientSatisfaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientSatisfactionUpdateInput, ClientSatisfactionUncheckedUpdateInput>
  }

  /**
   * ClientSatisfaction delete
   */
  export type ClientSatisfactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    /**
     * Filter which ClientSatisfaction to delete.
     */
    where: ClientSatisfactionWhereUniqueInput
  }

  /**
   * ClientSatisfaction deleteMany
   */
  export type ClientSatisfactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientSatisfactions to delete
     */
    where?: ClientSatisfactionWhereInput
    /**
     * Limit how many ClientSatisfactions to delete.
     */
    limit?: number
  }

  /**
   * ClientSatisfaction without action
   */
  export type ClientSatisfactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Company$usersArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Company$usersArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    title: string | null
    isStarred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    description: string | null
    gaAccountId: string | null
    gaPropertyId: string | null
    clientId: string | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    isStarred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    description: string | null
    gaAccountId: string | null
    gaPropertyId: string | null
    clientId: string | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    title: number
    isStarred: number
    createdAt: number
    updatedAt: number
    userId: number
    description: number
    gaAccountId: number
    gaPropertyId: number
    clientId: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    title?: true
    isStarred?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    description?: true
    gaAccountId?: true
    gaPropertyId?: true
    clientId?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    title?: true
    isStarred?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    description?: true
    gaAccountId?: true
    gaPropertyId?: true
    clientId?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    title?: true
    isStarred?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    description?: true
    gaAccountId?: true
    gaPropertyId?: true
    clientId?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    title: string
    isStarred: boolean
    createdAt: Date
    updatedAt: Date
    userId: string
    description: string | null
    gaAccountId: string | null
    gaPropertyId: string | null
    clientId: string | null
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isStarred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    description?: boolean
    gaAccountId?: boolean
    gaPropertyId?: boolean
    clientId?: boolean
    client?: boolean | Conversation$clientArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    queries?: boolean | Conversation$queriesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isStarred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    description?: boolean
    gaAccountId?: boolean
    gaPropertyId?: boolean
    clientId?: boolean
    client?: boolean | Conversation$clientArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isStarred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    description?: boolean
    gaAccountId?: boolean
    gaPropertyId?: boolean
    clientId?: boolean
    client?: boolean | Conversation$clientArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    title?: boolean
    isStarred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    description?: boolean
    gaAccountId?: boolean
    gaPropertyId?: boolean
    clientId?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "isStarred" | "createdAt" | "updatedAt" | "userId" | "description" | "gaAccountId" | "gaPropertyId" | "clientId", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Conversation$clientArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    queries?: boolean | Conversation$queriesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Conversation$clientArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Conversation$clientArgs<ExtArgs>
    gaAccount?: boolean | Conversation$gaAccountArgs<ExtArgs>
    gaProperty?: boolean | Conversation$gaPropertyArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      client: Prisma.$UserPayload<ExtArgs> | null
      gaAccount: Prisma.$GaAccountPayload<ExtArgs> | null
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      queries: Prisma.$QueryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      isStarred: boolean
      createdAt: Date
      updatedAt: Date
      userId: string
      description: string | null
      gaAccountId: string | null
      gaPropertyId: string | null
      clientId: string | null
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Conversation$clientArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$clientArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gaAccount<T extends Conversation$gaAccountArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$gaAccountArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gaProperty<T extends Conversation$gaPropertyArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$gaPropertyArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    queries<T extends Conversation$queriesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$queriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly isStarred: FieldRef<"Conversation", 'Boolean'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
    readonly userId: FieldRef<"Conversation", 'String'>
    readonly description: FieldRef<"Conversation", 'String'>
    readonly gaAccountId: FieldRef<"Conversation", 'String'>
    readonly gaPropertyId: FieldRef<"Conversation", 'String'>
    readonly clientId: FieldRef<"Conversation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.client
   */
  export type Conversation$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Conversation.gaAccount
   */
  export type Conversation$gaAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    where?: GaAccountWhereInput
  }

  /**
   * Conversation.gaProperty
   */
  export type Conversation$gaPropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    where?: GaPropertyWhereInput
  }

  /**
   * Conversation.queries
   */
  export type Conversation$queriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    cursor?: QueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model EmailCampaign
   */

  export type AggregateEmailCampaign = {
    _count: EmailCampaignCountAggregateOutputType | null
    _min: EmailCampaignMinAggregateOutputType | null
    _max: EmailCampaignMaxAggregateOutputType | null
  }

  export type EmailCampaignMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    campaignId: string | null
    campaignName: string | null
    emailClientId: string | null
  }

  export type EmailCampaignMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    campaignId: string | null
    campaignName: string | null
    emailClientId: string | null
  }

  export type EmailCampaignCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    campaignId: number
    campaignName: number
    emailClientId: number
    _all: number
  }


  export type EmailCampaignMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    campaignId?: true
    campaignName?: true
    emailClientId?: true
  }

  export type EmailCampaignMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    campaignId?: true
    campaignName?: true
    emailClientId?: true
  }

  export type EmailCampaignCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    campaignId?: true
    campaignName?: true
    emailClientId?: true
    _all?: true
  }

  export type EmailCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCampaign to aggregate.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailCampaigns
    **/
    _count?: true | EmailCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailCampaignMaxAggregateInputType
  }

  export type GetEmailCampaignAggregateType<T extends EmailCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailCampaign[P]>
      : GetScalarType<T[P], AggregateEmailCampaign[P]>
  }




  export type EmailCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCampaignWhereInput
    orderBy?: EmailCampaignOrderByWithAggregationInput | EmailCampaignOrderByWithAggregationInput[]
    by: EmailCampaignScalarFieldEnum[] | EmailCampaignScalarFieldEnum
    having?: EmailCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCampaignCountAggregateInputType | true
    _min?: EmailCampaignMinAggregateInputType
    _max?: EmailCampaignMaxAggregateInputType
  }

  export type EmailCampaignGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    campaignId: string
    campaignName: string
    emailClientId: string
    _count: EmailCampaignCountAggregateOutputType | null
    _min: EmailCampaignMinAggregateOutputType | null
    _max: EmailCampaignMaxAggregateOutputType | null
  }

  type GetEmailCampaignGroupByPayload<T extends EmailCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], EmailCampaignGroupByOutputType[P]>
        }
      >
    >


  export type EmailCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaignId?: boolean
    campaignName?: boolean
    emailClientId?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
    emailCampaignContents?: boolean | EmailCampaign$emailCampaignContentsArgs<ExtArgs>
    emailCampaignDailyStats?: boolean | EmailCampaign$emailCampaignDailyStatsArgs<ExtArgs>
    _count?: boolean | EmailCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaign"]>

  export type EmailCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaignId?: boolean
    campaignName?: boolean
    emailClientId?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaign"]>

  export type EmailCampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaignId?: boolean
    campaignName?: boolean
    emailClientId?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaign"]>

  export type EmailCampaignSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaignId?: boolean
    campaignName?: boolean
    emailClientId?: boolean
  }

  export type EmailCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "campaignId" | "campaignName" | "emailClientId", ExtArgs["result"]["emailCampaign"]>
  export type EmailCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
    emailCampaignContents?: boolean | EmailCampaign$emailCampaignContentsArgs<ExtArgs>
    emailCampaignDailyStats?: boolean | EmailCampaign$emailCampaignDailyStatsArgs<ExtArgs>
    _count?: boolean | EmailCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailCampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }
  export type EmailCampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }

  export type $EmailCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailCampaign"
    objects: {
      emailClient: Prisma.$EmailClientPayload<ExtArgs>
      emailCampaignContents: Prisma.$EmailCampaignContentPayload<ExtArgs> | null
      emailCampaignDailyStats: Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      campaignId: string
      campaignName: string
      emailClientId: string
    }, ExtArgs["result"]["emailCampaign"]>
    composites: {}
  }

  type EmailCampaignGetPayload<S extends boolean | null | undefined | EmailCampaignDefaultArgs> = $Result.GetResult<Prisma.$EmailCampaignPayload, S>

  type EmailCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailCampaignCountAggregateInputType | true
    }

  export interface EmailCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailCampaign'], meta: { name: 'EmailCampaign' } }
    /**
     * Find zero or one EmailCampaign that matches the filter.
     * @param {EmailCampaignFindUniqueArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailCampaignFindUniqueArgs>(args: SelectSubset<T, EmailCampaignFindUniqueArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailCampaignFindUniqueOrThrowArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignFindFirstArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailCampaignFindFirstArgs>(args?: SelectSubset<T, EmailCampaignFindFirstArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignFindFirstOrThrowArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailCampaigns
     * const emailCampaigns = await prisma.emailCampaign.findMany()
     * 
     * // Get first 10 EmailCampaigns
     * const emailCampaigns = await prisma.emailCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailCampaignWithIdOnly = await prisma.emailCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailCampaignFindManyArgs>(args?: SelectSubset<T, EmailCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailCampaign.
     * @param {EmailCampaignCreateArgs} args - Arguments to create a EmailCampaign.
     * @example
     * // Create one EmailCampaign
     * const EmailCampaign = await prisma.emailCampaign.create({
     *   data: {
     *     // ... data to create a EmailCampaign
     *   }
     * })
     * 
     */
    create<T extends EmailCampaignCreateArgs>(args: SelectSubset<T, EmailCampaignCreateArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailCampaigns.
     * @param {EmailCampaignCreateManyArgs} args - Arguments to create many EmailCampaigns.
     * @example
     * // Create many EmailCampaigns
     * const emailCampaign = await prisma.emailCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailCampaignCreateManyArgs>(args?: SelectSubset<T, EmailCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailCampaigns and returns the data saved in the database.
     * @param {EmailCampaignCreateManyAndReturnArgs} args - Arguments to create many EmailCampaigns.
     * @example
     * // Create many EmailCampaigns
     * const emailCampaign = await prisma.emailCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailCampaigns and only return the `id`
     * const emailCampaignWithIdOnly = await prisma.emailCampaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailCampaign.
     * @param {EmailCampaignDeleteArgs} args - Arguments to delete one EmailCampaign.
     * @example
     * // Delete one EmailCampaign
     * const EmailCampaign = await prisma.emailCampaign.delete({
     *   where: {
     *     // ... filter to delete one EmailCampaign
     *   }
     * })
     * 
     */
    delete<T extends EmailCampaignDeleteArgs>(args: SelectSubset<T, EmailCampaignDeleteArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailCampaign.
     * @param {EmailCampaignUpdateArgs} args - Arguments to update one EmailCampaign.
     * @example
     * // Update one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailCampaignUpdateArgs>(args: SelectSubset<T, EmailCampaignUpdateArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailCampaigns.
     * @param {EmailCampaignDeleteManyArgs} args - Arguments to filter EmailCampaigns to delete.
     * @example
     * // Delete a few EmailCampaigns
     * const { count } = await prisma.emailCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailCampaignDeleteManyArgs>(args?: SelectSubset<T, EmailCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailCampaigns
     * const emailCampaign = await prisma.emailCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailCampaignUpdateManyArgs>(args: SelectSubset<T, EmailCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailCampaigns and returns the data updated in the database.
     * @param {EmailCampaignUpdateManyAndReturnArgs} args - Arguments to update many EmailCampaigns.
     * @example
     * // Update many EmailCampaigns
     * const emailCampaign = await prisma.emailCampaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailCampaigns and only return the `id`
     * const emailCampaignWithIdOnly = await prisma.emailCampaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailCampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailCampaign.
     * @param {EmailCampaignUpsertArgs} args - Arguments to update or create a EmailCampaign.
     * @example
     * // Update or create a EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.upsert({
     *   create: {
     *     // ... data to create a EmailCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailCampaign we want to update
     *   }
     * })
     */
    upsert<T extends EmailCampaignUpsertArgs>(args: SelectSubset<T, EmailCampaignUpsertArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignCountArgs} args - Arguments to filter EmailCampaigns to count.
     * @example
     * // Count the number of EmailCampaigns
     * const count = await prisma.emailCampaign.count({
     *   where: {
     *     // ... the filter for the EmailCampaigns we want to count
     *   }
     * })
    **/
    count<T extends EmailCampaignCountArgs>(
      args?: Subset<T, EmailCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailCampaignAggregateArgs>(args: Subset<T, EmailCampaignAggregateArgs>): Prisma.PrismaPromise<GetEmailCampaignAggregateType<T>>

    /**
     * Group by EmailCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailCampaignGroupByArgs['orderBy'] }
        : { orderBy?: EmailCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailCampaign model
   */
  readonly fields: EmailCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailClient<T extends EmailClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailClientDefaultArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emailCampaignContents<T extends EmailCampaign$emailCampaignContentsArgs<ExtArgs> = {}>(args?: Subset<T, EmailCampaign$emailCampaignContentsArgs<ExtArgs>>): Prisma__EmailCampaignContentClient<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emailCampaignDailyStats<T extends EmailCampaign$emailCampaignDailyStatsArgs<ExtArgs> = {}>(args?: Subset<T, EmailCampaign$emailCampaignDailyStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailCampaign model
   */
  interface EmailCampaignFieldRefs {
    readonly id: FieldRef<"EmailCampaign", 'String'>
    readonly createdAt: FieldRef<"EmailCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailCampaign", 'DateTime'>
    readonly campaignId: FieldRef<"EmailCampaign", 'String'>
    readonly campaignName: FieldRef<"EmailCampaign", 'String'>
    readonly emailClientId: FieldRef<"EmailCampaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailCampaign findUnique
   */
  export type EmailCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where: EmailCampaignWhereUniqueInput
  }

  /**
   * EmailCampaign findUniqueOrThrow
   */
  export type EmailCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where: EmailCampaignWhereUniqueInput
  }

  /**
   * EmailCampaign findFirst
   */
  export type EmailCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCampaigns.
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCampaigns.
     */
    distinct?: EmailCampaignScalarFieldEnum | EmailCampaignScalarFieldEnum[]
  }

  /**
   * EmailCampaign findFirstOrThrow
   */
  export type EmailCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCampaigns.
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCampaigns.
     */
    distinct?: EmailCampaignScalarFieldEnum | EmailCampaignScalarFieldEnum[]
  }

  /**
   * EmailCampaign findMany
   */
  export type EmailCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaigns to fetch.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailCampaigns.
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    distinct?: EmailCampaignScalarFieldEnum | EmailCampaignScalarFieldEnum[]
  }

  /**
   * EmailCampaign create
   */
  export type EmailCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailCampaign.
     */
    data: XOR<EmailCampaignCreateInput, EmailCampaignUncheckedCreateInput>
  }

  /**
   * EmailCampaign createMany
   */
  export type EmailCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailCampaigns.
     */
    data: EmailCampaignCreateManyInput | EmailCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailCampaign createManyAndReturn
   */
  export type EmailCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * The data used to create many EmailCampaigns.
     */
    data: EmailCampaignCreateManyInput | EmailCampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailCampaign update
   */
  export type EmailCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailCampaign.
     */
    data: XOR<EmailCampaignUpdateInput, EmailCampaignUncheckedUpdateInput>
    /**
     * Choose, which EmailCampaign to update.
     */
    where: EmailCampaignWhereUniqueInput
  }

  /**
   * EmailCampaign updateMany
   */
  export type EmailCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailCampaigns.
     */
    data: XOR<EmailCampaignUpdateManyMutationInput, EmailCampaignUncheckedUpdateManyInput>
    /**
     * Filter which EmailCampaigns to update
     */
    where?: EmailCampaignWhereInput
    /**
     * Limit how many EmailCampaigns to update.
     */
    limit?: number
  }

  /**
   * EmailCampaign updateManyAndReturn
   */
  export type EmailCampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * The data used to update EmailCampaigns.
     */
    data: XOR<EmailCampaignUpdateManyMutationInput, EmailCampaignUncheckedUpdateManyInput>
    /**
     * Filter which EmailCampaigns to update
     */
    where?: EmailCampaignWhereInput
    /**
     * Limit how many EmailCampaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailCampaign upsert
   */
  export type EmailCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailCampaign to update in case it exists.
     */
    where: EmailCampaignWhereUniqueInput
    /**
     * In case the EmailCampaign found by the `where` argument doesn't exist, create a new EmailCampaign with this data.
     */
    create: XOR<EmailCampaignCreateInput, EmailCampaignUncheckedCreateInput>
    /**
     * In case the EmailCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailCampaignUpdateInput, EmailCampaignUncheckedUpdateInput>
  }

  /**
   * EmailCampaign delete
   */
  export type EmailCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    /**
     * Filter which EmailCampaign to delete.
     */
    where: EmailCampaignWhereUniqueInput
  }

  /**
   * EmailCampaign deleteMany
   */
  export type EmailCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCampaigns to delete
     */
    where?: EmailCampaignWhereInput
    /**
     * Limit how many EmailCampaigns to delete.
     */
    limit?: number
  }

  /**
   * EmailCampaign.emailCampaignContents
   */
  export type EmailCampaign$emailCampaignContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentInclude<ExtArgs> | null
    where?: EmailCampaignContentWhereInput
  }

  /**
   * EmailCampaign.emailCampaignDailyStats
   */
  export type EmailCampaign$emailCampaignDailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
    where?: EmailCampaignDailyStatsWhereInput
    orderBy?: EmailCampaignDailyStatsOrderByWithRelationInput | EmailCampaignDailyStatsOrderByWithRelationInput[]
    cursor?: EmailCampaignDailyStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailCampaignDailyStatsScalarFieldEnum | EmailCampaignDailyStatsScalarFieldEnum[]
  }

  /**
   * EmailCampaign without action
   */
  export type EmailCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
  }


  /**
   * Model EmailCampaignContent
   */

  export type AggregateEmailCampaignContent = {
    _count: EmailCampaignContentCountAggregateOutputType | null
    _avg: EmailCampaignContentAvgAggregateOutputType | null
    _sum: EmailCampaignContentSumAggregateOutputType | null
    _min: EmailCampaignContentMinAggregateOutputType | null
    _max: EmailCampaignContentMaxAggregateOutputType | null
  }

  export type EmailCampaignContentAvgAggregateOutputType = {
    recipients: number | null
  }

  export type EmailCampaignContentSumAggregateOutputType = {
    recipients: number | null
  }

  export type EmailCampaignContentMinAggregateOutputType = {
    id: string | null
    subject: string | null
    type: string | null
    recipients: number | null
    createdAt: Date | null
    updatedAt: Date | null
    contentType: string | null
    createTime: Date | null
    emailCampaignId: string | null
    htmlContent: string | null
    plainContent: string | null
    sendTime: Date | null
    webId: string | null
  }

  export type EmailCampaignContentMaxAggregateOutputType = {
    id: string | null
    subject: string | null
    type: string | null
    recipients: number | null
    createdAt: Date | null
    updatedAt: Date | null
    contentType: string | null
    createTime: Date | null
    emailCampaignId: string | null
    htmlContent: string | null
    plainContent: string | null
    sendTime: Date | null
    webId: string | null
  }

  export type EmailCampaignContentCountAggregateOutputType = {
    id: number
    subject: number
    type: number
    recipients: number
    createdAt: number
    updatedAt: number
    contentType: number
    createTime: number
    emailCampaignId: number
    htmlContent: number
    plainContent: number
    sendTime: number
    webId: number
    _all: number
  }


  export type EmailCampaignContentAvgAggregateInputType = {
    recipients?: true
  }

  export type EmailCampaignContentSumAggregateInputType = {
    recipients?: true
  }

  export type EmailCampaignContentMinAggregateInputType = {
    id?: true
    subject?: true
    type?: true
    recipients?: true
    createdAt?: true
    updatedAt?: true
    contentType?: true
    createTime?: true
    emailCampaignId?: true
    htmlContent?: true
    plainContent?: true
    sendTime?: true
    webId?: true
  }

  export type EmailCampaignContentMaxAggregateInputType = {
    id?: true
    subject?: true
    type?: true
    recipients?: true
    createdAt?: true
    updatedAt?: true
    contentType?: true
    createTime?: true
    emailCampaignId?: true
    htmlContent?: true
    plainContent?: true
    sendTime?: true
    webId?: true
  }

  export type EmailCampaignContentCountAggregateInputType = {
    id?: true
    subject?: true
    type?: true
    recipients?: true
    createdAt?: true
    updatedAt?: true
    contentType?: true
    createTime?: true
    emailCampaignId?: true
    htmlContent?: true
    plainContent?: true
    sendTime?: true
    webId?: true
    _all?: true
  }

  export type EmailCampaignContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCampaignContent to aggregate.
     */
    where?: EmailCampaignContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaignContents to fetch.
     */
    orderBy?: EmailCampaignContentOrderByWithRelationInput | EmailCampaignContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailCampaignContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaignContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaignContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailCampaignContents
    **/
    _count?: true | EmailCampaignContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailCampaignContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailCampaignContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailCampaignContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailCampaignContentMaxAggregateInputType
  }

  export type GetEmailCampaignContentAggregateType<T extends EmailCampaignContentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailCampaignContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailCampaignContent[P]>
      : GetScalarType<T[P], AggregateEmailCampaignContent[P]>
  }




  export type EmailCampaignContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCampaignContentWhereInput
    orderBy?: EmailCampaignContentOrderByWithAggregationInput | EmailCampaignContentOrderByWithAggregationInput[]
    by: EmailCampaignContentScalarFieldEnum[] | EmailCampaignContentScalarFieldEnum
    having?: EmailCampaignContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCampaignContentCountAggregateInputType | true
    _avg?: EmailCampaignContentAvgAggregateInputType
    _sum?: EmailCampaignContentSumAggregateInputType
    _min?: EmailCampaignContentMinAggregateInputType
    _max?: EmailCampaignContentMaxAggregateInputType
  }

  export type EmailCampaignContentGroupByOutputType = {
    id: string
    subject: string
    type: string
    recipients: number
    createdAt: Date
    updatedAt: Date
    contentType: string
    createTime: Date
    emailCampaignId: string
    htmlContent: string
    plainContent: string
    sendTime: Date
    webId: string
    _count: EmailCampaignContentCountAggregateOutputType | null
    _avg: EmailCampaignContentAvgAggregateOutputType | null
    _sum: EmailCampaignContentSumAggregateOutputType | null
    _min: EmailCampaignContentMinAggregateOutputType | null
    _max: EmailCampaignContentMaxAggregateOutputType | null
  }

  type GetEmailCampaignContentGroupByPayload<T extends EmailCampaignContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailCampaignContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailCampaignContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailCampaignContentGroupByOutputType[P]>
            : GetScalarType<T[P], EmailCampaignContentGroupByOutputType[P]>
        }
      >
    >


  export type EmailCampaignContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    type?: boolean
    recipients?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contentType?: boolean
    createTime?: boolean
    emailCampaignId?: boolean
    htmlContent?: boolean
    plainContent?: boolean
    sendTime?: boolean
    webId?: boolean
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaignContent"]>

  export type EmailCampaignContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    type?: boolean
    recipients?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contentType?: boolean
    createTime?: boolean
    emailCampaignId?: boolean
    htmlContent?: boolean
    plainContent?: boolean
    sendTime?: boolean
    webId?: boolean
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaignContent"]>

  export type EmailCampaignContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    type?: boolean
    recipients?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contentType?: boolean
    createTime?: boolean
    emailCampaignId?: boolean
    htmlContent?: boolean
    plainContent?: boolean
    sendTime?: boolean
    webId?: boolean
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaignContent"]>

  export type EmailCampaignContentSelectScalar = {
    id?: boolean
    subject?: boolean
    type?: boolean
    recipients?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contentType?: boolean
    createTime?: boolean
    emailCampaignId?: boolean
    htmlContent?: boolean
    plainContent?: boolean
    sendTime?: boolean
    webId?: boolean
  }

  export type EmailCampaignContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subject" | "type" | "recipients" | "createdAt" | "updatedAt" | "contentType" | "createTime" | "emailCampaignId" | "htmlContent" | "plainContent" | "sendTime" | "webId", ExtArgs["result"]["emailCampaignContent"]>
  export type EmailCampaignContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
  }
  export type EmailCampaignContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
  }
  export type EmailCampaignContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
  }

  export type $EmailCampaignContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailCampaignContent"
    objects: {
      emailCampaign: Prisma.$EmailCampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subject: string
      type: string
      recipients: number
      createdAt: Date
      updatedAt: Date
      contentType: string
      createTime: Date
      emailCampaignId: string
      htmlContent: string
      plainContent: string
      sendTime: Date
      webId: string
    }, ExtArgs["result"]["emailCampaignContent"]>
    composites: {}
  }

  type EmailCampaignContentGetPayload<S extends boolean | null | undefined | EmailCampaignContentDefaultArgs> = $Result.GetResult<Prisma.$EmailCampaignContentPayload, S>

  type EmailCampaignContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailCampaignContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailCampaignContentCountAggregateInputType | true
    }

  export interface EmailCampaignContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailCampaignContent'], meta: { name: 'EmailCampaignContent' } }
    /**
     * Find zero or one EmailCampaignContent that matches the filter.
     * @param {EmailCampaignContentFindUniqueArgs} args - Arguments to find a EmailCampaignContent
     * @example
     * // Get one EmailCampaignContent
     * const emailCampaignContent = await prisma.emailCampaignContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailCampaignContentFindUniqueArgs>(args: SelectSubset<T, EmailCampaignContentFindUniqueArgs<ExtArgs>>): Prisma__EmailCampaignContentClient<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailCampaignContent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailCampaignContentFindUniqueOrThrowArgs} args - Arguments to find a EmailCampaignContent
     * @example
     * // Get one EmailCampaignContent
     * const emailCampaignContent = await prisma.emailCampaignContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailCampaignContentFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailCampaignContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailCampaignContentClient<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailCampaignContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignContentFindFirstArgs} args - Arguments to find a EmailCampaignContent
     * @example
     * // Get one EmailCampaignContent
     * const emailCampaignContent = await prisma.emailCampaignContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailCampaignContentFindFirstArgs>(args?: SelectSubset<T, EmailCampaignContentFindFirstArgs<ExtArgs>>): Prisma__EmailCampaignContentClient<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailCampaignContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignContentFindFirstOrThrowArgs} args - Arguments to find a EmailCampaignContent
     * @example
     * // Get one EmailCampaignContent
     * const emailCampaignContent = await prisma.emailCampaignContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailCampaignContentFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailCampaignContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailCampaignContentClient<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailCampaignContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailCampaignContents
     * const emailCampaignContents = await prisma.emailCampaignContent.findMany()
     * 
     * // Get first 10 EmailCampaignContents
     * const emailCampaignContents = await prisma.emailCampaignContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailCampaignContentWithIdOnly = await prisma.emailCampaignContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailCampaignContentFindManyArgs>(args?: SelectSubset<T, EmailCampaignContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailCampaignContent.
     * @param {EmailCampaignContentCreateArgs} args - Arguments to create a EmailCampaignContent.
     * @example
     * // Create one EmailCampaignContent
     * const EmailCampaignContent = await prisma.emailCampaignContent.create({
     *   data: {
     *     // ... data to create a EmailCampaignContent
     *   }
     * })
     * 
     */
    create<T extends EmailCampaignContentCreateArgs>(args: SelectSubset<T, EmailCampaignContentCreateArgs<ExtArgs>>): Prisma__EmailCampaignContentClient<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailCampaignContents.
     * @param {EmailCampaignContentCreateManyArgs} args - Arguments to create many EmailCampaignContents.
     * @example
     * // Create many EmailCampaignContents
     * const emailCampaignContent = await prisma.emailCampaignContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailCampaignContentCreateManyArgs>(args?: SelectSubset<T, EmailCampaignContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailCampaignContents and returns the data saved in the database.
     * @param {EmailCampaignContentCreateManyAndReturnArgs} args - Arguments to create many EmailCampaignContents.
     * @example
     * // Create many EmailCampaignContents
     * const emailCampaignContent = await prisma.emailCampaignContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailCampaignContents and only return the `id`
     * const emailCampaignContentWithIdOnly = await prisma.emailCampaignContent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailCampaignContentCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailCampaignContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailCampaignContent.
     * @param {EmailCampaignContentDeleteArgs} args - Arguments to delete one EmailCampaignContent.
     * @example
     * // Delete one EmailCampaignContent
     * const EmailCampaignContent = await prisma.emailCampaignContent.delete({
     *   where: {
     *     // ... filter to delete one EmailCampaignContent
     *   }
     * })
     * 
     */
    delete<T extends EmailCampaignContentDeleteArgs>(args: SelectSubset<T, EmailCampaignContentDeleteArgs<ExtArgs>>): Prisma__EmailCampaignContentClient<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailCampaignContent.
     * @param {EmailCampaignContentUpdateArgs} args - Arguments to update one EmailCampaignContent.
     * @example
     * // Update one EmailCampaignContent
     * const emailCampaignContent = await prisma.emailCampaignContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailCampaignContentUpdateArgs>(args: SelectSubset<T, EmailCampaignContentUpdateArgs<ExtArgs>>): Prisma__EmailCampaignContentClient<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailCampaignContents.
     * @param {EmailCampaignContentDeleteManyArgs} args - Arguments to filter EmailCampaignContents to delete.
     * @example
     * // Delete a few EmailCampaignContents
     * const { count } = await prisma.emailCampaignContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailCampaignContentDeleteManyArgs>(args?: SelectSubset<T, EmailCampaignContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailCampaignContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailCampaignContents
     * const emailCampaignContent = await prisma.emailCampaignContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailCampaignContentUpdateManyArgs>(args: SelectSubset<T, EmailCampaignContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailCampaignContents and returns the data updated in the database.
     * @param {EmailCampaignContentUpdateManyAndReturnArgs} args - Arguments to update many EmailCampaignContents.
     * @example
     * // Update many EmailCampaignContents
     * const emailCampaignContent = await prisma.emailCampaignContent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailCampaignContents and only return the `id`
     * const emailCampaignContentWithIdOnly = await prisma.emailCampaignContent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailCampaignContentUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailCampaignContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailCampaignContent.
     * @param {EmailCampaignContentUpsertArgs} args - Arguments to update or create a EmailCampaignContent.
     * @example
     * // Update or create a EmailCampaignContent
     * const emailCampaignContent = await prisma.emailCampaignContent.upsert({
     *   create: {
     *     // ... data to create a EmailCampaignContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailCampaignContent we want to update
     *   }
     * })
     */
    upsert<T extends EmailCampaignContentUpsertArgs>(args: SelectSubset<T, EmailCampaignContentUpsertArgs<ExtArgs>>): Prisma__EmailCampaignContentClient<$Result.GetResult<Prisma.$EmailCampaignContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailCampaignContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignContentCountArgs} args - Arguments to filter EmailCampaignContents to count.
     * @example
     * // Count the number of EmailCampaignContents
     * const count = await prisma.emailCampaignContent.count({
     *   where: {
     *     // ... the filter for the EmailCampaignContents we want to count
     *   }
     * })
    **/
    count<T extends EmailCampaignContentCountArgs>(
      args?: Subset<T, EmailCampaignContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCampaignContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailCampaignContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailCampaignContentAggregateArgs>(args: Subset<T, EmailCampaignContentAggregateArgs>): Prisma.PrismaPromise<GetEmailCampaignContentAggregateType<T>>

    /**
     * Group by EmailCampaignContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailCampaignContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailCampaignContentGroupByArgs['orderBy'] }
        : { orderBy?: EmailCampaignContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailCampaignContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailCampaignContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailCampaignContent model
   */
  readonly fields: EmailCampaignContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailCampaignContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailCampaignContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailCampaign<T extends EmailCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailCampaignDefaultArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailCampaignContent model
   */
  interface EmailCampaignContentFieldRefs {
    readonly id: FieldRef<"EmailCampaignContent", 'String'>
    readonly subject: FieldRef<"EmailCampaignContent", 'String'>
    readonly type: FieldRef<"EmailCampaignContent", 'String'>
    readonly recipients: FieldRef<"EmailCampaignContent", 'Int'>
    readonly createdAt: FieldRef<"EmailCampaignContent", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailCampaignContent", 'DateTime'>
    readonly contentType: FieldRef<"EmailCampaignContent", 'String'>
    readonly createTime: FieldRef<"EmailCampaignContent", 'DateTime'>
    readonly emailCampaignId: FieldRef<"EmailCampaignContent", 'String'>
    readonly htmlContent: FieldRef<"EmailCampaignContent", 'String'>
    readonly plainContent: FieldRef<"EmailCampaignContent", 'String'>
    readonly sendTime: FieldRef<"EmailCampaignContent", 'DateTime'>
    readonly webId: FieldRef<"EmailCampaignContent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailCampaignContent findUnique
   */
  export type EmailCampaignContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaignContent to fetch.
     */
    where: EmailCampaignContentWhereUniqueInput
  }

  /**
   * EmailCampaignContent findUniqueOrThrow
   */
  export type EmailCampaignContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaignContent to fetch.
     */
    where: EmailCampaignContentWhereUniqueInput
  }

  /**
   * EmailCampaignContent findFirst
   */
  export type EmailCampaignContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaignContent to fetch.
     */
    where?: EmailCampaignContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaignContents to fetch.
     */
    orderBy?: EmailCampaignContentOrderByWithRelationInput | EmailCampaignContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCampaignContents.
     */
    cursor?: EmailCampaignContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaignContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaignContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCampaignContents.
     */
    distinct?: EmailCampaignContentScalarFieldEnum | EmailCampaignContentScalarFieldEnum[]
  }

  /**
   * EmailCampaignContent findFirstOrThrow
   */
  export type EmailCampaignContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaignContent to fetch.
     */
    where?: EmailCampaignContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaignContents to fetch.
     */
    orderBy?: EmailCampaignContentOrderByWithRelationInput | EmailCampaignContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCampaignContents.
     */
    cursor?: EmailCampaignContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaignContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaignContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCampaignContents.
     */
    distinct?: EmailCampaignContentScalarFieldEnum | EmailCampaignContentScalarFieldEnum[]
  }

  /**
   * EmailCampaignContent findMany
   */
  export type EmailCampaignContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaignContents to fetch.
     */
    where?: EmailCampaignContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaignContents to fetch.
     */
    orderBy?: EmailCampaignContentOrderByWithRelationInput | EmailCampaignContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailCampaignContents.
     */
    cursor?: EmailCampaignContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaignContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaignContents.
     */
    skip?: number
    distinct?: EmailCampaignContentScalarFieldEnum | EmailCampaignContentScalarFieldEnum[]
  }

  /**
   * EmailCampaignContent create
   */
  export type EmailCampaignContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailCampaignContent.
     */
    data: XOR<EmailCampaignContentCreateInput, EmailCampaignContentUncheckedCreateInput>
  }

  /**
   * EmailCampaignContent createMany
   */
  export type EmailCampaignContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailCampaignContents.
     */
    data: EmailCampaignContentCreateManyInput | EmailCampaignContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailCampaignContent createManyAndReturn
   */
  export type EmailCampaignContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * The data used to create many EmailCampaignContents.
     */
    data: EmailCampaignContentCreateManyInput | EmailCampaignContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailCampaignContent update
   */
  export type EmailCampaignContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailCampaignContent.
     */
    data: XOR<EmailCampaignContentUpdateInput, EmailCampaignContentUncheckedUpdateInput>
    /**
     * Choose, which EmailCampaignContent to update.
     */
    where: EmailCampaignContentWhereUniqueInput
  }

  /**
   * EmailCampaignContent updateMany
   */
  export type EmailCampaignContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailCampaignContents.
     */
    data: XOR<EmailCampaignContentUpdateManyMutationInput, EmailCampaignContentUncheckedUpdateManyInput>
    /**
     * Filter which EmailCampaignContents to update
     */
    where?: EmailCampaignContentWhereInput
    /**
     * Limit how many EmailCampaignContents to update.
     */
    limit?: number
  }

  /**
   * EmailCampaignContent updateManyAndReturn
   */
  export type EmailCampaignContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * The data used to update EmailCampaignContents.
     */
    data: XOR<EmailCampaignContentUpdateManyMutationInput, EmailCampaignContentUncheckedUpdateManyInput>
    /**
     * Filter which EmailCampaignContents to update
     */
    where?: EmailCampaignContentWhereInput
    /**
     * Limit how many EmailCampaignContents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailCampaignContent upsert
   */
  export type EmailCampaignContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailCampaignContent to update in case it exists.
     */
    where: EmailCampaignContentWhereUniqueInput
    /**
     * In case the EmailCampaignContent found by the `where` argument doesn't exist, create a new EmailCampaignContent with this data.
     */
    create: XOR<EmailCampaignContentCreateInput, EmailCampaignContentUncheckedCreateInput>
    /**
     * In case the EmailCampaignContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailCampaignContentUpdateInput, EmailCampaignContentUncheckedUpdateInput>
  }

  /**
   * EmailCampaignContent delete
   */
  export type EmailCampaignContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentInclude<ExtArgs> | null
    /**
     * Filter which EmailCampaignContent to delete.
     */
    where: EmailCampaignContentWhereUniqueInput
  }

  /**
   * EmailCampaignContent deleteMany
   */
  export type EmailCampaignContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCampaignContents to delete
     */
    where?: EmailCampaignContentWhereInput
    /**
     * Limit how many EmailCampaignContents to delete.
     */
    limit?: number
  }

  /**
   * EmailCampaignContent without action
   */
  export type EmailCampaignContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignContent
     */
    select?: EmailCampaignContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignContent
     */
    omit?: EmailCampaignContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignContentInclude<ExtArgs> | null
  }


  /**
   * Model EmailCampaignDailyStats
   */

  export type AggregateEmailCampaignDailyStats = {
    _count: EmailCampaignDailyStatsCountAggregateOutputType | null
    _avg: EmailCampaignDailyStatsAvgAggregateOutputType | null
    _sum: EmailCampaignDailyStatsSumAggregateOutputType | null
    _min: EmailCampaignDailyStatsMinAggregateOutputType | null
    _max: EmailCampaignDailyStatsMaxAggregateOutputType | null
  }

  export type EmailCampaignDailyStatsAvgAggregateOutputType = {
    opens: number | null
    clicks: number | null
    bounces: number | null
    unsubscribes: number | null
    requests: number | null
    delivered: number | null
    bounceDrops: number | null
    cumulativeBounceRate: number | null
    cumulativeSpamReportsRate: number | null
    cumulativeTotalClickRate: number | null
    cumulativeTotalOpenRate: number | null
    cumulativeUniqueClickRate: number | null
    cumulativeUniqueOpenRate: number | null
    cumulativeUnsubscribeRate: number | null
    dailyBounceRate: number | null
    dailySpamReportsRate: number | null
    dailyTotalClickRate: number | null
    dailyTotalClickToOpenRate: number | null
    dailyTotalOpenRate: number | null
    dailyUniqueClickRate: number | null
    dailyUniqueClickToOpenRate: number | null
    dailyUniqueOpenRate: number | null
    dailyUnsubscribeRate: number | null
    spamReportDrops: number | null
    spamReports: number | null
    totalClicks: number | null
    totalOpens: number | null
    uniqueClicks: number | null
    uniqueOpens: number | null
  }

  export type EmailCampaignDailyStatsSumAggregateOutputType = {
    opens: number | null
    clicks: number | null
    bounces: number | null
    unsubscribes: number | null
    requests: number | null
    delivered: number | null
    bounceDrops: number | null
    cumulativeBounceRate: number | null
    cumulativeSpamReportsRate: number | null
    cumulativeTotalClickRate: number | null
    cumulativeTotalOpenRate: number | null
    cumulativeUniqueClickRate: number | null
    cumulativeUniqueOpenRate: number | null
    cumulativeUnsubscribeRate: number | null
    dailyBounceRate: number | null
    dailySpamReportsRate: number | null
    dailyTotalClickRate: number | null
    dailyTotalClickToOpenRate: number | null
    dailyTotalOpenRate: number | null
    dailyUniqueClickRate: number | null
    dailyUniqueClickToOpenRate: number | null
    dailyUniqueOpenRate: number | null
    dailyUnsubscribeRate: number | null
    spamReportDrops: number | null
    spamReports: number | null
    totalClicks: number | null
    totalOpens: number | null
    uniqueClicks: number | null
    uniqueOpens: number | null
  }

  export type EmailCampaignDailyStatsMinAggregateOutputType = {
    id: string | null
    date: Date | null
    opens: number | null
    clicks: number | null
    bounces: number | null
    unsubscribes: number | null
    variation: string | null
    phase: string | null
    requests: number | null
    delivered: number | null
    createdAt: Date | null
    updatedAt: Date | null
    bounceDrops: number | null
    cumulativeBounceRate: number | null
    cumulativeSpamReportsRate: number | null
    cumulativeTotalClickRate: number | null
    cumulativeTotalOpenRate: number | null
    cumulativeUniqueClickRate: number | null
    cumulativeUniqueOpenRate: number | null
    cumulativeUnsubscribeRate: number | null
    dailyBounceRate: number | null
    dailySpamReportsRate: number | null
    dailyTotalClickRate: number | null
    dailyTotalClickToOpenRate: number | null
    dailyTotalOpenRate: number | null
    dailyUniqueClickRate: number | null
    dailyUniqueClickToOpenRate: number | null
    dailyUniqueOpenRate: number | null
    dailyUnsubscribeRate: number | null
    emailCampaignId: string | null
    emailClientId: string | null
    singleSendName: string | null
    spamReportDrops: number | null
    spamReports: number | null
    totalClicks: number | null
    totalOpens: number | null
    uniqueClicks: number | null
    uniqueOpens: number | null
  }

  export type EmailCampaignDailyStatsMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    opens: number | null
    clicks: number | null
    bounces: number | null
    unsubscribes: number | null
    variation: string | null
    phase: string | null
    requests: number | null
    delivered: number | null
    createdAt: Date | null
    updatedAt: Date | null
    bounceDrops: number | null
    cumulativeBounceRate: number | null
    cumulativeSpamReportsRate: number | null
    cumulativeTotalClickRate: number | null
    cumulativeTotalOpenRate: number | null
    cumulativeUniqueClickRate: number | null
    cumulativeUniqueOpenRate: number | null
    cumulativeUnsubscribeRate: number | null
    dailyBounceRate: number | null
    dailySpamReportsRate: number | null
    dailyTotalClickRate: number | null
    dailyTotalClickToOpenRate: number | null
    dailyTotalOpenRate: number | null
    dailyUniqueClickRate: number | null
    dailyUniqueClickToOpenRate: number | null
    dailyUniqueOpenRate: number | null
    dailyUnsubscribeRate: number | null
    emailCampaignId: string | null
    emailClientId: string | null
    singleSendName: string | null
    spamReportDrops: number | null
    spamReports: number | null
    totalClicks: number | null
    totalOpens: number | null
    uniqueClicks: number | null
    uniqueOpens: number | null
  }

  export type EmailCampaignDailyStatsCountAggregateOutputType = {
    id: number
    date: number
    opens: number
    clicks: number
    bounces: number
    unsubscribes: number
    variation: number
    phase: number
    requests: number
    delivered: number
    createdAt: number
    updatedAt: number
    bounceDrops: number
    cumulativeBounceRate: number
    cumulativeSpamReportsRate: number
    cumulativeTotalClickRate: number
    cumulativeTotalOpenRate: number
    cumulativeUniqueClickRate: number
    cumulativeUniqueOpenRate: number
    cumulativeUnsubscribeRate: number
    dailyBounceRate: number
    dailySpamReportsRate: number
    dailyTotalClickRate: number
    dailyTotalClickToOpenRate: number
    dailyTotalOpenRate: number
    dailyUniqueClickRate: number
    dailyUniqueClickToOpenRate: number
    dailyUniqueOpenRate: number
    dailyUnsubscribeRate: number
    emailCampaignId: number
    emailClientId: number
    singleSendName: number
    spamReportDrops: number
    spamReports: number
    totalClicks: number
    totalOpens: number
    uniqueClicks: number
    uniqueOpens: number
    _all: number
  }


  export type EmailCampaignDailyStatsAvgAggregateInputType = {
    opens?: true
    clicks?: true
    bounces?: true
    unsubscribes?: true
    requests?: true
    delivered?: true
    bounceDrops?: true
    cumulativeBounceRate?: true
    cumulativeSpamReportsRate?: true
    cumulativeTotalClickRate?: true
    cumulativeTotalOpenRate?: true
    cumulativeUniqueClickRate?: true
    cumulativeUniqueOpenRate?: true
    cumulativeUnsubscribeRate?: true
    dailyBounceRate?: true
    dailySpamReportsRate?: true
    dailyTotalClickRate?: true
    dailyTotalClickToOpenRate?: true
    dailyTotalOpenRate?: true
    dailyUniqueClickRate?: true
    dailyUniqueClickToOpenRate?: true
    dailyUniqueOpenRate?: true
    dailyUnsubscribeRate?: true
    spamReportDrops?: true
    spamReports?: true
    totalClicks?: true
    totalOpens?: true
    uniqueClicks?: true
    uniqueOpens?: true
  }

  export type EmailCampaignDailyStatsSumAggregateInputType = {
    opens?: true
    clicks?: true
    bounces?: true
    unsubscribes?: true
    requests?: true
    delivered?: true
    bounceDrops?: true
    cumulativeBounceRate?: true
    cumulativeSpamReportsRate?: true
    cumulativeTotalClickRate?: true
    cumulativeTotalOpenRate?: true
    cumulativeUniqueClickRate?: true
    cumulativeUniqueOpenRate?: true
    cumulativeUnsubscribeRate?: true
    dailyBounceRate?: true
    dailySpamReportsRate?: true
    dailyTotalClickRate?: true
    dailyTotalClickToOpenRate?: true
    dailyTotalOpenRate?: true
    dailyUniqueClickRate?: true
    dailyUniqueClickToOpenRate?: true
    dailyUniqueOpenRate?: true
    dailyUnsubscribeRate?: true
    spamReportDrops?: true
    spamReports?: true
    totalClicks?: true
    totalOpens?: true
    uniqueClicks?: true
    uniqueOpens?: true
  }

  export type EmailCampaignDailyStatsMinAggregateInputType = {
    id?: true
    date?: true
    opens?: true
    clicks?: true
    bounces?: true
    unsubscribes?: true
    variation?: true
    phase?: true
    requests?: true
    delivered?: true
    createdAt?: true
    updatedAt?: true
    bounceDrops?: true
    cumulativeBounceRate?: true
    cumulativeSpamReportsRate?: true
    cumulativeTotalClickRate?: true
    cumulativeTotalOpenRate?: true
    cumulativeUniqueClickRate?: true
    cumulativeUniqueOpenRate?: true
    cumulativeUnsubscribeRate?: true
    dailyBounceRate?: true
    dailySpamReportsRate?: true
    dailyTotalClickRate?: true
    dailyTotalClickToOpenRate?: true
    dailyTotalOpenRate?: true
    dailyUniqueClickRate?: true
    dailyUniqueClickToOpenRate?: true
    dailyUniqueOpenRate?: true
    dailyUnsubscribeRate?: true
    emailCampaignId?: true
    emailClientId?: true
    singleSendName?: true
    spamReportDrops?: true
    spamReports?: true
    totalClicks?: true
    totalOpens?: true
    uniqueClicks?: true
    uniqueOpens?: true
  }

  export type EmailCampaignDailyStatsMaxAggregateInputType = {
    id?: true
    date?: true
    opens?: true
    clicks?: true
    bounces?: true
    unsubscribes?: true
    variation?: true
    phase?: true
    requests?: true
    delivered?: true
    createdAt?: true
    updatedAt?: true
    bounceDrops?: true
    cumulativeBounceRate?: true
    cumulativeSpamReportsRate?: true
    cumulativeTotalClickRate?: true
    cumulativeTotalOpenRate?: true
    cumulativeUniqueClickRate?: true
    cumulativeUniqueOpenRate?: true
    cumulativeUnsubscribeRate?: true
    dailyBounceRate?: true
    dailySpamReportsRate?: true
    dailyTotalClickRate?: true
    dailyTotalClickToOpenRate?: true
    dailyTotalOpenRate?: true
    dailyUniqueClickRate?: true
    dailyUniqueClickToOpenRate?: true
    dailyUniqueOpenRate?: true
    dailyUnsubscribeRate?: true
    emailCampaignId?: true
    emailClientId?: true
    singleSendName?: true
    spamReportDrops?: true
    spamReports?: true
    totalClicks?: true
    totalOpens?: true
    uniqueClicks?: true
    uniqueOpens?: true
  }

  export type EmailCampaignDailyStatsCountAggregateInputType = {
    id?: true
    date?: true
    opens?: true
    clicks?: true
    bounces?: true
    unsubscribes?: true
    variation?: true
    phase?: true
    requests?: true
    delivered?: true
    createdAt?: true
    updatedAt?: true
    bounceDrops?: true
    cumulativeBounceRate?: true
    cumulativeSpamReportsRate?: true
    cumulativeTotalClickRate?: true
    cumulativeTotalOpenRate?: true
    cumulativeUniqueClickRate?: true
    cumulativeUniqueOpenRate?: true
    cumulativeUnsubscribeRate?: true
    dailyBounceRate?: true
    dailySpamReportsRate?: true
    dailyTotalClickRate?: true
    dailyTotalClickToOpenRate?: true
    dailyTotalOpenRate?: true
    dailyUniqueClickRate?: true
    dailyUniqueClickToOpenRate?: true
    dailyUniqueOpenRate?: true
    dailyUnsubscribeRate?: true
    emailCampaignId?: true
    emailClientId?: true
    singleSendName?: true
    spamReportDrops?: true
    spamReports?: true
    totalClicks?: true
    totalOpens?: true
    uniqueClicks?: true
    uniqueOpens?: true
    _all?: true
  }

  export type EmailCampaignDailyStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCampaignDailyStats to aggregate.
     */
    where?: EmailCampaignDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaignDailyStats to fetch.
     */
    orderBy?: EmailCampaignDailyStatsOrderByWithRelationInput | EmailCampaignDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailCampaignDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaignDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaignDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailCampaignDailyStats
    **/
    _count?: true | EmailCampaignDailyStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailCampaignDailyStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailCampaignDailyStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailCampaignDailyStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailCampaignDailyStatsMaxAggregateInputType
  }

  export type GetEmailCampaignDailyStatsAggregateType<T extends EmailCampaignDailyStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailCampaignDailyStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailCampaignDailyStats[P]>
      : GetScalarType<T[P], AggregateEmailCampaignDailyStats[P]>
  }




  export type EmailCampaignDailyStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailCampaignDailyStatsWhereInput
    orderBy?: EmailCampaignDailyStatsOrderByWithAggregationInput | EmailCampaignDailyStatsOrderByWithAggregationInput[]
    by: EmailCampaignDailyStatsScalarFieldEnum[] | EmailCampaignDailyStatsScalarFieldEnum
    having?: EmailCampaignDailyStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCampaignDailyStatsCountAggregateInputType | true
    _avg?: EmailCampaignDailyStatsAvgAggregateInputType
    _sum?: EmailCampaignDailyStatsSumAggregateInputType
    _min?: EmailCampaignDailyStatsMinAggregateInputType
    _max?: EmailCampaignDailyStatsMaxAggregateInputType
  }

  export type EmailCampaignDailyStatsGroupByOutputType = {
    id: string
    date: Date
    opens: number
    clicks: number
    bounces: number
    unsubscribes: number
    variation: string
    phase: string
    requests: number
    delivered: number
    createdAt: Date
    updatedAt: Date
    bounceDrops: number
    cumulativeBounceRate: number
    cumulativeSpamReportsRate: number
    cumulativeTotalClickRate: number
    cumulativeTotalOpenRate: number
    cumulativeUniqueClickRate: number
    cumulativeUniqueOpenRate: number
    cumulativeUnsubscribeRate: number
    dailyBounceRate: number
    dailySpamReportsRate: number
    dailyTotalClickRate: number
    dailyTotalClickToOpenRate: number
    dailyTotalOpenRate: number
    dailyUniqueClickRate: number
    dailyUniqueClickToOpenRate: number
    dailyUniqueOpenRate: number
    dailyUnsubscribeRate: number
    emailCampaignId: string
    emailClientId: string
    singleSendName: string
    spamReportDrops: number
    spamReports: number
    totalClicks: number
    totalOpens: number
    uniqueClicks: number
    uniqueOpens: number
    _count: EmailCampaignDailyStatsCountAggregateOutputType | null
    _avg: EmailCampaignDailyStatsAvgAggregateOutputType | null
    _sum: EmailCampaignDailyStatsSumAggregateOutputType | null
    _min: EmailCampaignDailyStatsMinAggregateOutputType | null
    _max: EmailCampaignDailyStatsMaxAggregateOutputType | null
  }

  type GetEmailCampaignDailyStatsGroupByPayload<T extends EmailCampaignDailyStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailCampaignDailyStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailCampaignDailyStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailCampaignDailyStatsGroupByOutputType[P]>
            : GetScalarType<T[P], EmailCampaignDailyStatsGroupByOutputType[P]>
        }
      >
    >


  export type EmailCampaignDailyStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    opens?: boolean
    clicks?: boolean
    bounces?: boolean
    unsubscribes?: boolean
    variation?: boolean
    phase?: boolean
    requests?: boolean
    delivered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bounceDrops?: boolean
    cumulativeBounceRate?: boolean
    cumulativeSpamReportsRate?: boolean
    cumulativeTotalClickRate?: boolean
    cumulativeTotalOpenRate?: boolean
    cumulativeUniqueClickRate?: boolean
    cumulativeUniqueOpenRate?: boolean
    cumulativeUnsubscribeRate?: boolean
    dailyBounceRate?: boolean
    dailySpamReportsRate?: boolean
    dailyTotalClickRate?: boolean
    dailyTotalClickToOpenRate?: boolean
    dailyTotalOpenRate?: boolean
    dailyUniqueClickRate?: boolean
    dailyUniqueClickToOpenRate?: boolean
    dailyUniqueOpenRate?: boolean
    dailyUnsubscribeRate?: boolean
    emailCampaignId?: boolean
    emailClientId?: boolean
    singleSendName?: boolean
    spamReportDrops?: boolean
    spamReports?: boolean
    totalClicks?: boolean
    totalOpens?: boolean
    uniqueClicks?: boolean
    uniqueOpens?: boolean
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaignDailyStats"]>

  export type EmailCampaignDailyStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    opens?: boolean
    clicks?: boolean
    bounces?: boolean
    unsubscribes?: boolean
    variation?: boolean
    phase?: boolean
    requests?: boolean
    delivered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bounceDrops?: boolean
    cumulativeBounceRate?: boolean
    cumulativeSpamReportsRate?: boolean
    cumulativeTotalClickRate?: boolean
    cumulativeTotalOpenRate?: boolean
    cumulativeUniqueClickRate?: boolean
    cumulativeUniqueOpenRate?: boolean
    cumulativeUnsubscribeRate?: boolean
    dailyBounceRate?: boolean
    dailySpamReportsRate?: boolean
    dailyTotalClickRate?: boolean
    dailyTotalClickToOpenRate?: boolean
    dailyTotalOpenRate?: boolean
    dailyUniqueClickRate?: boolean
    dailyUniqueClickToOpenRate?: boolean
    dailyUniqueOpenRate?: boolean
    dailyUnsubscribeRate?: boolean
    emailCampaignId?: boolean
    emailClientId?: boolean
    singleSendName?: boolean
    spamReportDrops?: boolean
    spamReports?: boolean
    totalClicks?: boolean
    totalOpens?: boolean
    uniqueClicks?: boolean
    uniqueOpens?: boolean
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaignDailyStats"]>

  export type EmailCampaignDailyStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    opens?: boolean
    clicks?: boolean
    bounces?: boolean
    unsubscribes?: boolean
    variation?: boolean
    phase?: boolean
    requests?: boolean
    delivered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bounceDrops?: boolean
    cumulativeBounceRate?: boolean
    cumulativeSpamReportsRate?: boolean
    cumulativeTotalClickRate?: boolean
    cumulativeTotalOpenRate?: boolean
    cumulativeUniqueClickRate?: boolean
    cumulativeUniqueOpenRate?: boolean
    cumulativeUnsubscribeRate?: boolean
    dailyBounceRate?: boolean
    dailySpamReportsRate?: boolean
    dailyTotalClickRate?: boolean
    dailyTotalClickToOpenRate?: boolean
    dailyTotalOpenRate?: boolean
    dailyUniqueClickRate?: boolean
    dailyUniqueClickToOpenRate?: boolean
    dailyUniqueOpenRate?: boolean
    dailyUnsubscribeRate?: boolean
    emailCampaignId?: boolean
    emailClientId?: boolean
    singleSendName?: boolean
    spamReportDrops?: boolean
    spamReports?: boolean
    totalClicks?: boolean
    totalOpens?: boolean
    uniqueClicks?: boolean
    uniqueOpens?: boolean
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailCampaignDailyStats"]>

  export type EmailCampaignDailyStatsSelectScalar = {
    id?: boolean
    date?: boolean
    opens?: boolean
    clicks?: boolean
    bounces?: boolean
    unsubscribes?: boolean
    variation?: boolean
    phase?: boolean
    requests?: boolean
    delivered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bounceDrops?: boolean
    cumulativeBounceRate?: boolean
    cumulativeSpamReportsRate?: boolean
    cumulativeTotalClickRate?: boolean
    cumulativeTotalOpenRate?: boolean
    cumulativeUniqueClickRate?: boolean
    cumulativeUniqueOpenRate?: boolean
    cumulativeUnsubscribeRate?: boolean
    dailyBounceRate?: boolean
    dailySpamReportsRate?: boolean
    dailyTotalClickRate?: boolean
    dailyTotalClickToOpenRate?: boolean
    dailyTotalOpenRate?: boolean
    dailyUniqueClickRate?: boolean
    dailyUniqueClickToOpenRate?: boolean
    dailyUniqueOpenRate?: boolean
    dailyUnsubscribeRate?: boolean
    emailCampaignId?: boolean
    emailClientId?: boolean
    singleSendName?: boolean
    spamReportDrops?: boolean
    spamReports?: boolean
    totalClicks?: boolean
    totalOpens?: boolean
    uniqueClicks?: boolean
    uniqueOpens?: boolean
  }

  export type EmailCampaignDailyStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "opens" | "clicks" | "bounces" | "unsubscribes" | "variation" | "phase" | "requests" | "delivered" | "createdAt" | "updatedAt" | "bounceDrops" | "cumulativeBounceRate" | "cumulativeSpamReportsRate" | "cumulativeTotalClickRate" | "cumulativeTotalOpenRate" | "cumulativeUniqueClickRate" | "cumulativeUniqueOpenRate" | "cumulativeUnsubscribeRate" | "dailyBounceRate" | "dailySpamReportsRate" | "dailyTotalClickRate" | "dailyTotalClickToOpenRate" | "dailyTotalOpenRate" | "dailyUniqueClickRate" | "dailyUniqueClickToOpenRate" | "dailyUniqueOpenRate" | "dailyUnsubscribeRate" | "emailCampaignId" | "emailClientId" | "singleSendName" | "spamReportDrops" | "spamReports" | "totalClicks" | "totalOpens" | "uniqueClicks" | "uniqueOpens", ExtArgs["result"]["emailCampaignDailyStats"]>
  export type EmailCampaignDailyStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }
  export type EmailCampaignDailyStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }
  export type EmailCampaignDailyStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailCampaign?: boolean | EmailCampaignDefaultArgs<ExtArgs>
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }

  export type $EmailCampaignDailyStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailCampaignDailyStats"
    objects: {
      emailCampaign: Prisma.$EmailCampaignPayload<ExtArgs>
      emailClient: Prisma.$EmailClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      opens: number
      clicks: number
      bounces: number
      unsubscribes: number
      variation: string
      phase: string
      requests: number
      delivered: number
      createdAt: Date
      updatedAt: Date
      bounceDrops: number
      cumulativeBounceRate: number
      cumulativeSpamReportsRate: number
      cumulativeTotalClickRate: number
      cumulativeTotalOpenRate: number
      cumulativeUniqueClickRate: number
      cumulativeUniqueOpenRate: number
      cumulativeUnsubscribeRate: number
      dailyBounceRate: number
      dailySpamReportsRate: number
      dailyTotalClickRate: number
      dailyTotalClickToOpenRate: number
      dailyTotalOpenRate: number
      dailyUniqueClickRate: number
      dailyUniqueClickToOpenRate: number
      dailyUniqueOpenRate: number
      dailyUnsubscribeRate: number
      emailCampaignId: string
      emailClientId: string
      singleSendName: string
      spamReportDrops: number
      spamReports: number
      totalClicks: number
      totalOpens: number
      uniqueClicks: number
      uniqueOpens: number
    }, ExtArgs["result"]["emailCampaignDailyStats"]>
    composites: {}
  }

  type EmailCampaignDailyStatsGetPayload<S extends boolean | null | undefined | EmailCampaignDailyStatsDefaultArgs> = $Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload, S>

  type EmailCampaignDailyStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailCampaignDailyStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailCampaignDailyStatsCountAggregateInputType | true
    }

  export interface EmailCampaignDailyStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailCampaignDailyStats'], meta: { name: 'EmailCampaignDailyStats' } }
    /**
     * Find zero or one EmailCampaignDailyStats that matches the filter.
     * @param {EmailCampaignDailyStatsFindUniqueArgs} args - Arguments to find a EmailCampaignDailyStats
     * @example
     * // Get one EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailCampaignDailyStatsFindUniqueArgs>(args: SelectSubset<T, EmailCampaignDailyStatsFindUniqueArgs<ExtArgs>>): Prisma__EmailCampaignDailyStatsClient<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailCampaignDailyStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailCampaignDailyStatsFindUniqueOrThrowArgs} args - Arguments to find a EmailCampaignDailyStats
     * @example
     * // Get one EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailCampaignDailyStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailCampaignDailyStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailCampaignDailyStatsClient<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailCampaignDailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignDailyStatsFindFirstArgs} args - Arguments to find a EmailCampaignDailyStats
     * @example
     * // Get one EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailCampaignDailyStatsFindFirstArgs>(args?: SelectSubset<T, EmailCampaignDailyStatsFindFirstArgs<ExtArgs>>): Prisma__EmailCampaignDailyStatsClient<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailCampaignDailyStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignDailyStatsFindFirstOrThrowArgs} args - Arguments to find a EmailCampaignDailyStats
     * @example
     * // Get one EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailCampaignDailyStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailCampaignDailyStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailCampaignDailyStatsClient<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailCampaignDailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignDailyStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.findMany()
     * 
     * // Get first 10 EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailCampaignDailyStatsWithIdOnly = await prisma.emailCampaignDailyStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailCampaignDailyStatsFindManyArgs>(args?: SelectSubset<T, EmailCampaignDailyStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailCampaignDailyStats.
     * @param {EmailCampaignDailyStatsCreateArgs} args - Arguments to create a EmailCampaignDailyStats.
     * @example
     * // Create one EmailCampaignDailyStats
     * const EmailCampaignDailyStats = await prisma.emailCampaignDailyStats.create({
     *   data: {
     *     // ... data to create a EmailCampaignDailyStats
     *   }
     * })
     * 
     */
    create<T extends EmailCampaignDailyStatsCreateArgs>(args: SelectSubset<T, EmailCampaignDailyStatsCreateArgs<ExtArgs>>): Prisma__EmailCampaignDailyStatsClient<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailCampaignDailyStats.
     * @param {EmailCampaignDailyStatsCreateManyArgs} args - Arguments to create many EmailCampaignDailyStats.
     * @example
     * // Create many EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailCampaignDailyStatsCreateManyArgs>(args?: SelectSubset<T, EmailCampaignDailyStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailCampaignDailyStats and returns the data saved in the database.
     * @param {EmailCampaignDailyStatsCreateManyAndReturnArgs} args - Arguments to create many EmailCampaignDailyStats.
     * @example
     * // Create many EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailCampaignDailyStats and only return the `id`
     * const emailCampaignDailyStatsWithIdOnly = await prisma.emailCampaignDailyStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailCampaignDailyStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailCampaignDailyStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailCampaignDailyStats.
     * @param {EmailCampaignDailyStatsDeleteArgs} args - Arguments to delete one EmailCampaignDailyStats.
     * @example
     * // Delete one EmailCampaignDailyStats
     * const EmailCampaignDailyStats = await prisma.emailCampaignDailyStats.delete({
     *   where: {
     *     // ... filter to delete one EmailCampaignDailyStats
     *   }
     * })
     * 
     */
    delete<T extends EmailCampaignDailyStatsDeleteArgs>(args: SelectSubset<T, EmailCampaignDailyStatsDeleteArgs<ExtArgs>>): Prisma__EmailCampaignDailyStatsClient<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailCampaignDailyStats.
     * @param {EmailCampaignDailyStatsUpdateArgs} args - Arguments to update one EmailCampaignDailyStats.
     * @example
     * // Update one EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailCampaignDailyStatsUpdateArgs>(args: SelectSubset<T, EmailCampaignDailyStatsUpdateArgs<ExtArgs>>): Prisma__EmailCampaignDailyStatsClient<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailCampaignDailyStats.
     * @param {EmailCampaignDailyStatsDeleteManyArgs} args - Arguments to filter EmailCampaignDailyStats to delete.
     * @example
     * // Delete a few EmailCampaignDailyStats
     * const { count } = await prisma.emailCampaignDailyStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailCampaignDailyStatsDeleteManyArgs>(args?: SelectSubset<T, EmailCampaignDailyStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailCampaignDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignDailyStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailCampaignDailyStatsUpdateManyArgs>(args: SelectSubset<T, EmailCampaignDailyStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailCampaignDailyStats and returns the data updated in the database.
     * @param {EmailCampaignDailyStatsUpdateManyAndReturnArgs} args - Arguments to update many EmailCampaignDailyStats.
     * @example
     * // Update many EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailCampaignDailyStats and only return the `id`
     * const emailCampaignDailyStatsWithIdOnly = await prisma.emailCampaignDailyStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailCampaignDailyStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailCampaignDailyStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailCampaignDailyStats.
     * @param {EmailCampaignDailyStatsUpsertArgs} args - Arguments to update or create a EmailCampaignDailyStats.
     * @example
     * // Update or create a EmailCampaignDailyStats
     * const emailCampaignDailyStats = await prisma.emailCampaignDailyStats.upsert({
     *   create: {
     *     // ... data to create a EmailCampaignDailyStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailCampaignDailyStats we want to update
     *   }
     * })
     */
    upsert<T extends EmailCampaignDailyStatsUpsertArgs>(args: SelectSubset<T, EmailCampaignDailyStatsUpsertArgs<ExtArgs>>): Prisma__EmailCampaignDailyStatsClient<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailCampaignDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignDailyStatsCountArgs} args - Arguments to filter EmailCampaignDailyStats to count.
     * @example
     * // Count the number of EmailCampaignDailyStats
     * const count = await prisma.emailCampaignDailyStats.count({
     *   where: {
     *     // ... the filter for the EmailCampaignDailyStats we want to count
     *   }
     * })
    **/
    count<T extends EmailCampaignDailyStatsCountArgs>(
      args?: Subset<T, EmailCampaignDailyStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCampaignDailyStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailCampaignDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignDailyStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailCampaignDailyStatsAggregateArgs>(args: Subset<T, EmailCampaignDailyStatsAggregateArgs>): Prisma.PrismaPromise<GetEmailCampaignDailyStatsAggregateType<T>>

    /**
     * Group by EmailCampaignDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignDailyStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailCampaignDailyStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailCampaignDailyStatsGroupByArgs['orderBy'] }
        : { orderBy?: EmailCampaignDailyStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailCampaignDailyStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailCampaignDailyStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailCampaignDailyStats model
   */
  readonly fields: EmailCampaignDailyStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailCampaignDailyStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailCampaignDailyStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailCampaign<T extends EmailCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailCampaignDefaultArgs<ExtArgs>>): Prisma__EmailCampaignClient<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emailClient<T extends EmailClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailClientDefaultArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailCampaignDailyStats model
   */
  interface EmailCampaignDailyStatsFieldRefs {
    readonly id: FieldRef<"EmailCampaignDailyStats", 'String'>
    readonly date: FieldRef<"EmailCampaignDailyStats", 'DateTime'>
    readonly opens: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly clicks: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly bounces: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly unsubscribes: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly variation: FieldRef<"EmailCampaignDailyStats", 'String'>
    readonly phase: FieldRef<"EmailCampaignDailyStats", 'String'>
    readonly requests: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly delivered: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly createdAt: FieldRef<"EmailCampaignDailyStats", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailCampaignDailyStats", 'DateTime'>
    readonly bounceDrops: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly cumulativeBounceRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly cumulativeSpamReportsRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly cumulativeTotalClickRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly cumulativeTotalOpenRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly cumulativeUniqueClickRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly cumulativeUniqueOpenRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly cumulativeUnsubscribeRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly dailyBounceRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly dailySpamReportsRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly dailyTotalClickRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly dailyTotalClickToOpenRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly dailyTotalOpenRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly dailyUniqueClickRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly dailyUniqueClickToOpenRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly dailyUniqueOpenRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly dailyUnsubscribeRate: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly emailCampaignId: FieldRef<"EmailCampaignDailyStats", 'String'>
    readonly emailClientId: FieldRef<"EmailCampaignDailyStats", 'String'>
    readonly singleSendName: FieldRef<"EmailCampaignDailyStats", 'String'>
    readonly spamReportDrops: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly spamReports: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly totalClicks: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly totalOpens: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly uniqueClicks: FieldRef<"EmailCampaignDailyStats", 'Int'>
    readonly uniqueOpens: FieldRef<"EmailCampaignDailyStats", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmailCampaignDailyStats findUnique
   */
  export type EmailCampaignDailyStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaignDailyStats to fetch.
     */
    where: EmailCampaignDailyStatsWhereUniqueInput
  }

  /**
   * EmailCampaignDailyStats findUniqueOrThrow
   */
  export type EmailCampaignDailyStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaignDailyStats to fetch.
     */
    where: EmailCampaignDailyStatsWhereUniqueInput
  }

  /**
   * EmailCampaignDailyStats findFirst
   */
  export type EmailCampaignDailyStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaignDailyStats to fetch.
     */
    where?: EmailCampaignDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaignDailyStats to fetch.
     */
    orderBy?: EmailCampaignDailyStatsOrderByWithRelationInput | EmailCampaignDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCampaignDailyStats.
     */
    cursor?: EmailCampaignDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaignDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaignDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCampaignDailyStats.
     */
    distinct?: EmailCampaignDailyStatsScalarFieldEnum | EmailCampaignDailyStatsScalarFieldEnum[]
  }

  /**
   * EmailCampaignDailyStats findFirstOrThrow
   */
  export type EmailCampaignDailyStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaignDailyStats to fetch.
     */
    where?: EmailCampaignDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaignDailyStats to fetch.
     */
    orderBy?: EmailCampaignDailyStatsOrderByWithRelationInput | EmailCampaignDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCampaignDailyStats.
     */
    cursor?: EmailCampaignDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaignDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaignDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCampaignDailyStats.
     */
    distinct?: EmailCampaignDailyStatsScalarFieldEnum | EmailCampaignDailyStatsScalarFieldEnum[]
  }

  /**
   * EmailCampaignDailyStats findMany
   */
  export type EmailCampaignDailyStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which EmailCampaignDailyStats to fetch.
     */
    where?: EmailCampaignDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaignDailyStats to fetch.
     */
    orderBy?: EmailCampaignDailyStatsOrderByWithRelationInput | EmailCampaignDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailCampaignDailyStats.
     */
    cursor?: EmailCampaignDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaignDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaignDailyStats.
     */
    skip?: number
    distinct?: EmailCampaignDailyStatsScalarFieldEnum | EmailCampaignDailyStatsScalarFieldEnum[]
  }

  /**
   * EmailCampaignDailyStats create
   */
  export type EmailCampaignDailyStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailCampaignDailyStats.
     */
    data: XOR<EmailCampaignDailyStatsCreateInput, EmailCampaignDailyStatsUncheckedCreateInput>
  }

  /**
   * EmailCampaignDailyStats createMany
   */
  export type EmailCampaignDailyStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailCampaignDailyStats.
     */
    data: EmailCampaignDailyStatsCreateManyInput | EmailCampaignDailyStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailCampaignDailyStats createManyAndReturn
   */
  export type EmailCampaignDailyStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * The data used to create many EmailCampaignDailyStats.
     */
    data: EmailCampaignDailyStatsCreateManyInput | EmailCampaignDailyStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailCampaignDailyStats update
   */
  export type EmailCampaignDailyStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailCampaignDailyStats.
     */
    data: XOR<EmailCampaignDailyStatsUpdateInput, EmailCampaignDailyStatsUncheckedUpdateInput>
    /**
     * Choose, which EmailCampaignDailyStats to update.
     */
    where: EmailCampaignDailyStatsWhereUniqueInput
  }

  /**
   * EmailCampaignDailyStats updateMany
   */
  export type EmailCampaignDailyStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailCampaignDailyStats.
     */
    data: XOR<EmailCampaignDailyStatsUpdateManyMutationInput, EmailCampaignDailyStatsUncheckedUpdateManyInput>
    /**
     * Filter which EmailCampaignDailyStats to update
     */
    where?: EmailCampaignDailyStatsWhereInput
    /**
     * Limit how many EmailCampaignDailyStats to update.
     */
    limit?: number
  }

  /**
   * EmailCampaignDailyStats updateManyAndReturn
   */
  export type EmailCampaignDailyStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * The data used to update EmailCampaignDailyStats.
     */
    data: XOR<EmailCampaignDailyStatsUpdateManyMutationInput, EmailCampaignDailyStatsUncheckedUpdateManyInput>
    /**
     * Filter which EmailCampaignDailyStats to update
     */
    where?: EmailCampaignDailyStatsWhereInput
    /**
     * Limit how many EmailCampaignDailyStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailCampaignDailyStats upsert
   */
  export type EmailCampaignDailyStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailCampaignDailyStats to update in case it exists.
     */
    where: EmailCampaignDailyStatsWhereUniqueInput
    /**
     * In case the EmailCampaignDailyStats found by the `where` argument doesn't exist, create a new EmailCampaignDailyStats with this data.
     */
    create: XOR<EmailCampaignDailyStatsCreateInput, EmailCampaignDailyStatsUncheckedCreateInput>
    /**
     * In case the EmailCampaignDailyStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailCampaignDailyStatsUpdateInput, EmailCampaignDailyStatsUncheckedUpdateInput>
  }

  /**
   * EmailCampaignDailyStats delete
   */
  export type EmailCampaignDailyStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
    /**
     * Filter which EmailCampaignDailyStats to delete.
     */
    where: EmailCampaignDailyStatsWhereUniqueInput
  }

  /**
   * EmailCampaignDailyStats deleteMany
   */
  export type EmailCampaignDailyStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCampaignDailyStats to delete
     */
    where?: EmailCampaignDailyStatsWhereInput
    /**
     * Limit how many EmailCampaignDailyStats to delete.
     */
    limit?: number
  }

  /**
   * EmailCampaignDailyStats without action
   */
  export type EmailCampaignDailyStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
  }


  /**
   * Model EmailClient
   */

  export type AggregateEmailClient = {
    _count: EmailClientCountAggregateOutputType | null
    _min: EmailClientMinAggregateOutputType | null
    _max: EmailClientMaxAggregateOutputType | null
  }

  export type EmailClientMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientName: string | null
  }

  export type EmailClientMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientName: string | null
  }

  export type EmailClientCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    clientName: number
    _all: number
  }


  export type EmailClientMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientName?: true
  }

  export type EmailClientMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientName?: true
  }

  export type EmailClientCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientName?: true
    _all?: true
  }

  export type EmailClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailClient to aggregate.
     */
    where?: EmailClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailClients to fetch.
     */
    orderBy?: EmailClientOrderByWithRelationInput | EmailClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailClients
    **/
    _count?: true | EmailClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailClientMaxAggregateInputType
  }

  export type GetEmailClientAggregateType<T extends EmailClientAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailClient[P]>
      : GetScalarType<T[P], AggregateEmailClient[P]>
  }




  export type EmailClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailClientWhereInput
    orderBy?: EmailClientOrderByWithAggregationInput | EmailClientOrderByWithAggregationInput[]
    by: EmailClientScalarFieldEnum[] | EmailClientScalarFieldEnum
    having?: EmailClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailClientCountAggregateInputType | true
    _min?: EmailClientMinAggregateInputType
    _max?: EmailClientMaxAggregateInputType
  }

  export type EmailClientGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    clientName: string
    _count: EmailClientCountAggregateOutputType | null
    _min: EmailClientMinAggregateOutputType | null
    _max: EmailClientMaxAggregateOutputType | null
  }

  type GetEmailClientGroupByPayload<T extends EmailClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailClientGroupByOutputType[P]>
            : GetScalarType<T[P], EmailClientGroupByOutputType[P]>
        }
      >
    >


  export type EmailClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientName?: boolean
    emailCampaigns?: boolean | EmailClient$emailCampaignsArgs<ExtArgs>
    emailCampaignDailyStats?: boolean | EmailClient$emailCampaignDailyStatsArgs<ExtArgs>
    emailClientCredentials?: boolean | EmailClient$emailClientCredentialsArgs<ExtArgs>
    emailGlobalDailyStats?: boolean | EmailClient$emailGlobalDailyStatsArgs<ExtArgs>
    users?: boolean | EmailClient$usersArgs<ExtArgs>
    _count?: boolean | EmailClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailClient"]>

  export type EmailClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientName?: boolean
  }, ExtArgs["result"]["emailClient"]>

  export type EmailClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientName?: boolean
  }, ExtArgs["result"]["emailClient"]>

  export type EmailClientSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientName?: boolean
  }

  export type EmailClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "clientName", ExtArgs["result"]["emailClient"]>
  export type EmailClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailCampaigns?: boolean | EmailClient$emailCampaignsArgs<ExtArgs>
    emailCampaignDailyStats?: boolean | EmailClient$emailCampaignDailyStatsArgs<ExtArgs>
    emailClientCredentials?: boolean | EmailClient$emailClientCredentialsArgs<ExtArgs>
    emailGlobalDailyStats?: boolean | EmailClient$emailGlobalDailyStatsArgs<ExtArgs>
    users?: boolean | EmailClient$usersArgs<ExtArgs>
    _count?: boolean | EmailClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmailClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmailClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailClient"
    objects: {
      emailCampaigns: Prisma.$EmailCampaignPayload<ExtArgs>[]
      emailCampaignDailyStats: Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>[]
      emailClientCredentials: Prisma.$EmailClientCredentialsPayload<ExtArgs>[]
      emailGlobalDailyStats: Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>[]
      users: Prisma.$UserToEmailClientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      clientName: string
    }, ExtArgs["result"]["emailClient"]>
    composites: {}
  }

  type EmailClientGetPayload<S extends boolean | null | undefined | EmailClientDefaultArgs> = $Result.GetResult<Prisma.$EmailClientPayload, S>

  type EmailClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailClientCountAggregateInputType | true
    }

  export interface EmailClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailClient'], meta: { name: 'EmailClient' } }
    /**
     * Find zero or one EmailClient that matches the filter.
     * @param {EmailClientFindUniqueArgs} args - Arguments to find a EmailClient
     * @example
     * // Get one EmailClient
     * const emailClient = await prisma.emailClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailClientFindUniqueArgs>(args: SelectSubset<T, EmailClientFindUniqueArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailClient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailClientFindUniqueOrThrowArgs} args - Arguments to find a EmailClient
     * @example
     * // Get one EmailClient
     * const emailClient = await prisma.emailClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailClientFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientFindFirstArgs} args - Arguments to find a EmailClient
     * @example
     * // Get one EmailClient
     * const emailClient = await prisma.emailClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailClientFindFirstArgs>(args?: SelectSubset<T, EmailClientFindFirstArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientFindFirstOrThrowArgs} args - Arguments to find a EmailClient
     * @example
     * // Get one EmailClient
     * const emailClient = await prisma.emailClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailClientFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailClients
     * const emailClients = await prisma.emailClient.findMany()
     * 
     * // Get first 10 EmailClients
     * const emailClients = await prisma.emailClient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailClientWithIdOnly = await prisma.emailClient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailClientFindManyArgs>(args?: SelectSubset<T, EmailClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailClient.
     * @param {EmailClientCreateArgs} args - Arguments to create a EmailClient.
     * @example
     * // Create one EmailClient
     * const EmailClient = await prisma.emailClient.create({
     *   data: {
     *     // ... data to create a EmailClient
     *   }
     * })
     * 
     */
    create<T extends EmailClientCreateArgs>(args: SelectSubset<T, EmailClientCreateArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailClients.
     * @param {EmailClientCreateManyArgs} args - Arguments to create many EmailClients.
     * @example
     * // Create many EmailClients
     * const emailClient = await prisma.emailClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailClientCreateManyArgs>(args?: SelectSubset<T, EmailClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailClients and returns the data saved in the database.
     * @param {EmailClientCreateManyAndReturnArgs} args - Arguments to create many EmailClients.
     * @example
     * // Create many EmailClients
     * const emailClient = await prisma.emailClient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailClients and only return the `id`
     * const emailClientWithIdOnly = await prisma.emailClient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailClientCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailClient.
     * @param {EmailClientDeleteArgs} args - Arguments to delete one EmailClient.
     * @example
     * // Delete one EmailClient
     * const EmailClient = await prisma.emailClient.delete({
     *   where: {
     *     // ... filter to delete one EmailClient
     *   }
     * })
     * 
     */
    delete<T extends EmailClientDeleteArgs>(args: SelectSubset<T, EmailClientDeleteArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailClient.
     * @param {EmailClientUpdateArgs} args - Arguments to update one EmailClient.
     * @example
     * // Update one EmailClient
     * const emailClient = await prisma.emailClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailClientUpdateArgs>(args: SelectSubset<T, EmailClientUpdateArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailClients.
     * @param {EmailClientDeleteManyArgs} args - Arguments to filter EmailClients to delete.
     * @example
     * // Delete a few EmailClients
     * const { count } = await prisma.emailClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailClientDeleteManyArgs>(args?: SelectSubset<T, EmailClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailClients
     * const emailClient = await prisma.emailClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailClientUpdateManyArgs>(args: SelectSubset<T, EmailClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailClients and returns the data updated in the database.
     * @param {EmailClientUpdateManyAndReturnArgs} args - Arguments to update many EmailClients.
     * @example
     * // Update many EmailClients
     * const emailClient = await prisma.emailClient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailClients and only return the `id`
     * const emailClientWithIdOnly = await prisma.emailClient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailClientUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailClient.
     * @param {EmailClientUpsertArgs} args - Arguments to update or create a EmailClient.
     * @example
     * // Update or create a EmailClient
     * const emailClient = await prisma.emailClient.upsert({
     *   create: {
     *     // ... data to create a EmailClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailClient we want to update
     *   }
     * })
     */
    upsert<T extends EmailClientUpsertArgs>(args: SelectSubset<T, EmailClientUpsertArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientCountArgs} args - Arguments to filter EmailClients to count.
     * @example
     * // Count the number of EmailClients
     * const count = await prisma.emailClient.count({
     *   where: {
     *     // ... the filter for the EmailClients we want to count
     *   }
     * })
    **/
    count<T extends EmailClientCountArgs>(
      args?: Subset<T, EmailClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailClientAggregateArgs>(args: Subset<T, EmailClientAggregateArgs>): Prisma.PrismaPromise<GetEmailClientAggregateType<T>>

    /**
     * Group by EmailClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailClientGroupByArgs['orderBy'] }
        : { orderBy?: EmailClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailClient model
   */
  readonly fields: EmailClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailCampaigns<T extends EmailClient$emailCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, EmailClient$emailCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailCampaignDailyStats<T extends EmailClient$emailCampaignDailyStatsArgs<ExtArgs> = {}>(args?: Subset<T, EmailClient$emailCampaignDailyStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailCampaignDailyStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailClientCredentials<T extends EmailClient$emailClientCredentialsArgs<ExtArgs> = {}>(args?: Subset<T, EmailClient$emailClientCredentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailGlobalDailyStats<T extends EmailClient$emailGlobalDailyStatsArgs<ExtArgs> = {}>(args?: Subset<T, EmailClient$emailGlobalDailyStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends EmailClient$usersArgs<ExtArgs> = {}>(args?: Subset<T, EmailClient$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailClient model
   */
  interface EmailClientFieldRefs {
    readonly id: FieldRef<"EmailClient", 'String'>
    readonly createdAt: FieldRef<"EmailClient", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailClient", 'DateTime'>
    readonly clientName: FieldRef<"EmailClient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailClient findUnique
   */
  export type EmailClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientInclude<ExtArgs> | null
    /**
     * Filter, which EmailClient to fetch.
     */
    where: EmailClientWhereUniqueInput
  }

  /**
   * EmailClient findUniqueOrThrow
   */
  export type EmailClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientInclude<ExtArgs> | null
    /**
     * Filter, which EmailClient to fetch.
     */
    where: EmailClientWhereUniqueInput
  }

  /**
   * EmailClient findFirst
   */
  export type EmailClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientInclude<ExtArgs> | null
    /**
     * Filter, which EmailClient to fetch.
     */
    where?: EmailClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailClients to fetch.
     */
    orderBy?: EmailClientOrderByWithRelationInput | EmailClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailClients.
     */
    cursor?: EmailClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailClients.
     */
    distinct?: EmailClientScalarFieldEnum | EmailClientScalarFieldEnum[]
  }

  /**
   * EmailClient findFirstOrThrow
   */
  export type EmailClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientInclude<ExtArgs> | null
    /**
     * Filter, which EmailClient to fetch.
     */
    where?: EmailClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailClients to fetch.
     */
    orderBy?: EmailClientOrderByWithRelationInput | EmailClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailClients.
     */
    cursor?: EmailClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailClients.
     */
    distinct?: EmailClientScalarFieldEnum | EmailClientScalarFieldEnum[]
  }

  /**
   * EmailClient findMany
   */
  export type EmailClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientInclude<ExtArgs> | null
    /**
     * Filter, which EmailClients to fetch.
     */
    where?: EmailClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailClients to fetch.
     */
    orderBy?: EmailClientOrderByWithRelationInput | EmailClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailClients.
     */
    cursor?: EmailClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailClients.
     */
    skip?: number
    distinct?: EmailClientScalarFieldEnum | EmailClientScalarFieldEnum[]
  }

  /**
   * EmailClient create
   */
  export type EmailClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailClient.
     */
    data: XOR<EmailClientCreateInput, EmailClientUncheckedCreateInput>
  }

  /**
   * EmailClient createMany
   */
  export type EmailClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailClients.
     */
    data: EmailClientCreateManyInput | EmailClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailClient createManyAndReturn
   */
  export type EmailClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * The data used to create many EmailClients.
     */
    data: EmailClientCreateManyInput | EmailClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailClient update
   */
  export type EmailClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailClient.
     */
    data: XOR<EmailClientUpdateInput, EmailClientUncheckedUpdateInput>
    /**
     * Choose, which EmailClient to update.
     */
    where: EmailClientWhereUniqueInput
  }

  /**
   * EmailClient updateMany
   */
  export type EmailClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailClients.
     */
    data: XOR<EmailClientUpdateManyMutationInput, EmailClientUncheckedUpdateManyInput>
    /**
     * Filter which EmailClients to update
     */
    where?: EmailClientWhereInput
    /**
     * Limit how many EmailClients to update.
     */
    limit?: number
  }

  /**
   * EmailClient updateManyAndReturn
   */
  export type EmailClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * The data used to update EmailClients.
     */
    data: XOR<EmailClientUpdateManyMutationInput, EmailClientUncheckedUpdateManyInput>
    /**
     * Filter which EmailClients to update
     */
    where?: EmailClientWhereInput
    /**
     * Limit how many EmailClients to update.
     */
    limit?: number
  }

  /**
   * EmailClient upsert
   */
  export type EmailClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailClient to update in case it exists.
     */
    where: EmailClientWhereUniqueInput
    /**
     * In case the EmailClient found by the `where` argument doesn't exist, create a new EmailClient with this data.
     */
    create: XOR<EmailClientCreateInput, EmailClientUncheckedCreateInput>
    /**
     * In case the EmailClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailClientUpdateInput, EmailClientUncheckedUpdateInput>
  }

  /**
   * EmailClient delete
   */
  export type EmailClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientInclude<ExtArgs> | null
    /**
     * Filter which EmailClient to delete.
     */
    where: EmailClientWhereUniqueInput
  }

  /**
   * EmailClient deleteMany
   */
  export type EmailClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailClients to delete
     */
    where?: EmailClientWhereInput
    /**
     * Limit how many EmailClients to delete.
     */
    limit?: number
  }

  /**
   * EmailClient.emailCampaigns
   */
  export type EmailClient$emailCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaign
     */
    omit?: EmailCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignInclude<ExtArgs> | null
    where?: EmailCampaignWhereInput
    orderBy?: EmailCampaignOrderByWithRelationInput | EmailCampaignOrderByWithRelationInput[]
    cursor?: EmailCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailCampaignScalarFieldEnum | EmailCampaignScalarFieldEnum[]
  }

  /**
   * EmailClient.emailCampaignDailyStats
   */
  export type EmailClient$emailCampaignDailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaignDailyStats
     */
    select?: EmailCampaignDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailCampaignDailyStats
     */
    omit?: EmailCampaignDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailCampaignDailyStatsInclude<ExtArgs> | null
    where?: EmailCampaignDailyStatsWhereInput
    orderBy?: EmailCampaignDailyStatsOrderByWithRelationInput | EmailCampaignDailyStatsOrderByWithRelationInput[]
    cursor?: EmailCampaignDailyStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailCampaignDailyStatsScalarFieldEnum | EmailCampaignDailyStatsScalarFieldEnum[]
  }

  /**
   * EmailClient.emailClientCredentials
   */
  export type EmailClient$emailClientCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsInclude<ExtArgs> | null
    where?: EmailClientCredentialsWhereInput
    orderBy?: EmailClientCredentialsOrderByWithRelationInput | EmailClientCredentialsOrderByWithRelationInput[]
    cursor?: EmailClientCredentialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailClientCredentialsScalarFieldEnum | EmailClientCredentialsScalarFieldEnum[]
  }

  /**
   * EmailClient.emailGlobalDailyStats
   */
  export type EmailClient$emailGlobalDailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsInclude<ExtArgs> | null
    where?: EmailGlobalDailyStatsWhereInput
    orderBy?: EmailGlobalDailyStatsOrderByWithRelationInput | EmailGlobalDailyStatsOrderByWithRelationInput[]
    cursor?: EmailGlobalDailyStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailGlobalDailyStatsScalarFieldEnum | EmailGlobalDailyStatsScalarFieldEnum[]
  }

  /**
   * EmailClient.users
   */
  export type EmailClient$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
    where?: UserToEmailClientWhereInput
    orderBy?: UserToEmailClientOrderByWithRelationInput | UserToEmailClientOrderByWithRelationInput[]
    cursor?: UserToEmailClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserToEmailClientScalarFieldEnum | UserToEmailClientScalarFieldEnum[]
  }

  /**
   * EmailClient without action
   */
  export type EmailClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClient
     */
    select?: EmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClient
     */
    omit?: EmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientInclude<ExtArgs> | null
  }


  /**
   * Model EmailClientCredentials
   */

  export type AggregateEmailClientCredentials = {
    _count: EmailClientCredentialsCountAggregateOutputType | null
    _min: EmailClientCredentialsMinAggregateOutputType | null
    _max: EmailClientCredentialsMaxAggregateOutputType | null
  }

  export type EmailClientCredentialsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    apiKey: string | null
    emailClientId: string | null
    platformName: string | null
  }

  export type EmailClientCredentialsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    apiKey: string | null
    emailClientId: string | null
    platformName: string | null
  }

  export type EmailClientCredentialsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    apiKey: number
    emailClientId: number
    platformName: number
    _all: number
  }


  export type EmailClientCredentialsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    apiKey?: true
    emailClientId?: true
    platformName?: true
  }

  export type EmailClientCredentialsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    apiKey?: true
    emailClientId?: true
    platformName?: true
  }

  export type EmailClientCredentialsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    apiKey?: true
    emailClientId?: true
    platformName?: true
    _all?: true
  }

  export type EmailClientCredentialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailClientCredentials to aggregate.
     */
    where?: EmailClientCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailClientCredentials to fetch.
     */
    orderBy?: EmailClientCredentialsOrderByWithRelationInput | EmailClientCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailClientCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailClientCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailClientCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailClientCredentials
    **/
    _count?: true | EmailClientCredentialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailClientCredentialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailClientCredentialsMaxAggregateInputType
  }

  export type GetEmailClientCredentialsAggregateType<T extends EmailClientCredentialsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailClientCredentials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailClientCredentials[P]>
      : GetScalarType<T[P], AggregateEmailClientCredentials[P]>
  }




  export type EmailClientCredentialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailClientCredentialsWhereInput
    orderBy?: EmailClientCredentialsOrderByWithAggregationInput | EmailClientCredentialsOrderByWithAggregationInput[]
    by: EmailClientCredentialsScalarFieldEnum[] | EmailClientCredentialsScalarFieldEnum
    having?: EmailClientCredentialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailClientCredentialsCountAggregateInputType | true
    _min?: EmailClientCredentialsMinAggregateInputType
    _max?: EmailClientCredentialsMaxAggregateInputType
  }

  export type EmailClientCredentialsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    apiKey: string
    emailClientId: string
    platformName: string
    _count: EmailClientCredentialsCountAggregateOutputType | null
    _min: EmailClientCredentialsMinAggregateOutputType | null
    _max: EmailClientCredentialsMaxAggregateOutputType | null
  }

  type GetEmailClientCredentialsGroupByPayload<T extends EmailClientCredentialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailClientCredentialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailClientCredentialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailClientCredentialsGroupByOutputType[P]>
            : GetScalarType<T[P], EmailClientCredentialsGroupByOutputType[P]>
        }
      >
    >


  export type EmailClientCredentialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiKey?: boolean
    emailClientId?: boolean
    platformName?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailClientCredentials"]>

  export type EmailClientCredentialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiKey?: boolean
    emailClientId?: boolean
    platformName?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailClientCredentials"]>

  export type EmailClientCredentialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiKey?: boolean
    emailClientId?: boolean
    platformName?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailClientCredentials"]>

  export type EmailClientCredentialsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiKey?: boolean
    emailClientId?: boolean
    platformName?: boolean
  }

  export type EmailClientCredentialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "apiKey" | "emailClientId" | "platformName", ExtArgs["result"]["emailClientCredentials"]>
  export type EmailClientCredentialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }
  export type EmailClientCredentialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }
  export type EmailClientCredentialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }

  export type $EmailClientCredentialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailClientCredentials"
    objects: {
      emailClient: Prisma.$EmailClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      apiKey: string
      emailClientId: string
      platformName: string
    }, ExtArgs["result"]["emailClientCredentials"]>
    composites: {}
  }

  type EmailClientCredentialsGetPayload<S extends boolean | null | undefined | EmailClientCredentialsDefaultArgs> = $Result.GetResult<Prisma.$EmailClientCredentialsPayload, S>

  type EmailClientCredentialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailClientCredentialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailClientCredentialsCountAggregateInputType | true
    }

  export interface EmailClientCredentialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailClientCredentials'], meta: { name: 'EmailClientCredentials' } }
    /**
     * Find zero or one EmailClientCredentials that matches the filter.
     * @param {EmailClientCredentialsFindUniqueArgs} args - Arguments to find a EmailClientCredentials
     * @example
     * // Get one EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailClientCredentialsFindUniqueArgs>(args: SelectSubset<T, EmailClientCredentialsFindUniqueArgs<ExtArgs>>): Prisma__EmailClientCredentialsClient<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailClientCredentials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailClientCredentialsFindUniqueOrThrowArgs} args - Arguments to find a EmailClientCredentials
     * @example
     * // Get one EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailClientCredentialsFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailClientCredentialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailClientCredentialsClient<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailClientCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientCredentialsFindFirstArgs} args - Arguments to find a EmailClientCredentials
     * @example
     * // Get one EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailClientCredentialsFindFirstArgs>(args?: SelectSubset<T, EmailClientCredentialsFindFirstArgs<ExtArgs>>): Prisma__EmailClientCredentialsClient<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailClientCredentials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientCredentialsFindFirstOrThrowArgs} args - Arguments to find a EmailClientCredentials
     * @example
     * // Get one EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailClientCredentialsFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailClientCredentialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailClientCredentialsClient<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailClientCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientCredentialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.findMany()
     * 
     * // Get first 10 EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailClientCredentialsWithIdOnly = await prisma.emailClientCredentials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailClientCredentialsFindManyArgs>(args?: SelectSubset<T, EmailClientCredentialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailClientCredentials.
     * @param {EmailClientCredentialsCreateArgs} args - Arguments to create a EmailClientCredentials.
     * @example
     * // Create one EmailClientCredentials
     * const EmailClientCredentials = await prisma.emailClientCredentials.create({
     *   data: {
     *     // ... data to create a EmailClientCredentials
     *   }
     * })
     * 
     */
    create<T extends EmailClientCredentialsCreateArgs>(args: SelectSubset<T, EmailClientCredentialsCreateArgs<ExtArgs>>): Prisma__EmailClientCredentialsClient<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailClientCredentials.
     * @param {EmailClientCredentialsCreateManyArgs} args - Arguments to create many EmailClientCredentials.
     * @example
     * // Create many EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailClientCredentialsCreateManyArgs>(args?: SelectSubset<T, EmailClientCredentialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailClientCredentials and returns the data saved in the database.
     * @param {EmailClientCredentialsCreateManyAndReturnArgs} args - Arguments to create many EmailClientCredentials.
     * @example
     * // Create many EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailClientCredentials and only return the `id`
     * const emailClientCredentialsWithIdOnly = await prisma.emailClientCredentials.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailClientCredentialsCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailClientCredentialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailClientCredentials.
     * @param {EmailClientCredentialsDeleteArgs} args - Arguments to delete one EmailClientCredentials.
     * @example
     * // Delete one EmailClientCredentials
     * const EmailClientCredentials = await prisma.emailClientCredentials.delete({
     *   where: {
     *     // ... filter to delete one EmailClientCredentials
     *   }
     * })
     * 
     */
    delete<T extends EmailClientCredentialsDeleteArgs>(args: SelectSubset<T, EmailClientCredentialsDeleteArgs<ExtArgs>>): Prisma__EmailClientCredentialsClient<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailClientCredentials.
     * @param {EmailClientCredentialsUpdateArgs} args - Arguments to update one EmailClientCredentials.
     * @example
     * // Update one EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailClientCredentialsUpdateArgs>(args: SelectSubset<T, EmailClientCredentialsUpdateArgs<ExtArgs>>): Prisma__EmailClientCredentialsClient<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailClientCredentials.
     * @param {EmailClientCredentialsDeleteManyArgs} args - Arguments to filter EmailClientCredentials to delete.
     * @example
     * // Delete a few EmailClientCredentials
     * const { count } = await prisma.emailClientCredentials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailClientCredentialsDeleteManyArgs>(args?: SelectSubset<T, EmailClientCredentialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailClientCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientCredentialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailClientCredentialsUpdateManyArgs>(args: SelectSubset<T, EmailClientCredentialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailClientCredentials and returns the data updated in the database.
     * @param {EmailClientCredentialsUpdateManyAndReturnArgs} args - Arguments to update many EmailClientCredentials.
     * @example
     * // Update many EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailClientCredentials and only return the `id`
     * const emailClientCredentialsWithIdOnly = await prisma.emailClientCredentials.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailClientCredentialsUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailClientCredentialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailClientCredentials.
     * @param {EmailClientCredentialsUpsertArgs} args - Arguments to update or create a EmailClientCredentials.
     * @example
     * // Update or create a EmailClientCredentials
     * const emailClientCredentials = await prisma.emailClientCredentials.upsert({
     *   create: {
     *     // ... data to create a EmailClientCredentials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailClientCredentials we want to update
     *   }
     * })
     */
    upsert<T extends EmailClientCredentialsUpsertArgs>(args: SelectSubset<T, EmailClientCredentialsUpsertArgs<ExtArgs>>): Prisma__EmailClientCredentialsClient<$Result.GetResult<Prisma.$EmailClientCredentialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailClientCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientCredentialsCountArgs} args - Arguments to filter EmailClientCredentials to count.
     * @example
     * // Count the number of EmailClientCredentials
     * const count = await prisma.emailClientCredentials.count({
     *   where: {
     *     // ... the filter for the EmailClientCredentials we want to count
     *   }
     * })
    **/
    count<T extends EmailClientCredentialsCountArgs>(
      args?: Subset<T, EmailClientCredentialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailClientCredentialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailClientCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientCredentialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailClientCredentialsAggregateArgs>(args: Subset<T, EmailClientCredentialsAggregateArgs>): Prisma.PrismaPromise<GetEmailClientCredentialsAggregateType<T>>

    /**
     * Group by EmailClientCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailClientCredentialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailClientCredentialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailClientCredentialsGroupByArgs['orderBy'] }
        : { orderBy?: EmailClientCredentialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailClientCredentialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailClientCredentialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailClientCredentials model
   */
  readonly fields: EmailClientCredentialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailClientCredentials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailClientCredentialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailClient<T extends EmailClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailClientDefaultArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailClientCredentials model
   */
  interface EmailClientCredentialsFieldRefs {
    readonly id: FieldRef<"EmailClientCredentials", 'String'>
    readonly createdAt: FieldRef<"EmailClientCredentials", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailClientCredentials", 'DateTime'>
    readonly apiKey: FieldRef<"EmailClientCredentials", 'String'>
    readonly emailClientId: FieldRef<"EmailClientCredentials", 'String'>
    readonly platformName: FieldRef<"EmailClientCredentials", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailClientCredentials findUnique
   */
  export type EmailClientCredentialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsInclude<ExtArgs> | null
    /**
     * Filter, which EmailClientCredentials to fetch.
     */
    where: EmailClientCredentialsWhereUniqueInput
  }

  /**
   * EmailClientCredentials findUniqueOrThrow
   */
  export type EmailClientCredentialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsInclude<ExtArgs> | null
    /**
     * Filter, which EmailClientCredentials to fetch.
     */
    where: EmailClientCredentialsWhereUniqueInput
  }

  /**
   * EmailClientCredentials findFirst
   */
  export type EmailClientCredentialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsInclude<ExtArgs> | null
    /**
     * Filter, which EmailClientCredentials to fetch.
     */
    where?: EmailClientCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailClientCredentials to fetch.
     */
    orderBy?: EmailClientCredentialsOrderByWithRelationInput | EmailClientCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailClientCredentials.
     */
    cursor?: EmailClientCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailClientCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailClientCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailClientCredentials.
     */
    distinct?: EmailClientCredentialsScalarFieldEnum | EmailClientCredentialsScalarFieldEnum[]
  }

  /**
   * EmailClientCredentials findFirstOrThrow
   */
  export type EmailClientCredentialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsInclude<ExtArgs> | null
    /**
     * Filter, which EmailClientCredentials to fetch.
     */
    where?: EmailClientCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailClientCredentials to fetch.
     */
    orderBy?: EmailClientCredentialsOrderByWithRelationInput | EmailClientCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailClientCredentials.
     */
    cursor?: EmailClientCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailClientCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailClientCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailClientCredentials.
     */
    distinct?: EmailClientCredentialsScalarFieldEnum | EmailClientCredentialsScalarFieldEnum[]
  }

  /**
   * EmailClientCredentials findMany
   */
  export type EmailClientCredentialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsInclude<ExtArgs> | null
    /**
     * Filter, which EmailClientCredentials to fetch.
     */
    where?: EmailClientCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailClientCredentials to fetch.
     */
    orderBy?: EmailClientCredentialsOrderByWithRelationInput | EmailClientCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailClientCredentials.
     */
    cursor?: EmailClientCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailClientCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailClientCredentials.
     */
    skip?: number
    distinct?: EmailClientCredentialsScalarFieldEnum | EmailClientCredentialsScalarFieldEnum[]
  }

  /**
   * EmailClientCredentials create
   */
  export type EmailClientCredentialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailClientCredentials.
     */
    data: XOR<EmailClientCredentialsCreateInput, EmailClientCredentialsUncheckedCreateInput>
  }

  /**
   * EmailClientCredentials createMany
   */
  export type EmailClientCredentialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailClientCredentials.
     */
    data: EmailClientCredentialsCreateManyInput | EmailClientCredentialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailClientCredentials createManyAndReturn
   */
  export type EmailClientCredentialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * The data used to create many EmailClientCredentials.
     */
    data: EmailClientCredentialsCreateManyInput | EmailClientCredentialsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailClientCredentials update
   */
  export type EmailClientCredentialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailClientCredentials.
     */
    data: XOR<EmailClientCredentialsUpdateInput, EmailClientCredentialsUncheckedUpdateInput>
    /**
     * Choose, which EmailClientCredentials to update.
     */
    where: EmailClientCredentialsWhereUniqueInput
  }

  /**
   * EmailClientCredentials updateMany
   */
  export type EmailClientCredentialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailClientCredentials.
     */
    data: XOR<EmailClientCredentialsUpdateManyMutationInput, EmailClientCredentialsUncheckedUpdateManyInput>
    /**
     * Filter which EmailClientCredentials to update
     */
    where?: EmailClientCredentialsWhereInput
    /**
     * Limit how many EmailClientCredentials to update.
     */
    limit?: number
  }

  /**
   * EmailClientCredentials updateManyAndReturn
   */
  export type EmailClientCredentialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * The data used to update EmailClientCredentials.
     */
    data: XOR<EmailClientCredentialsUpdateManyMutationInput, EmailClientCredentialsUncheckedUpdateManyInput>
    /**
     * Filter which EmailClientCredentials to update
     */
    where?: EmailClientCredentialsWhereInput
    /**
     * Limit how many EmailClientCredentials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailClientCredentials upsert
   */
  export type EmailClientCredentialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailClientCredentials to update in case it exists.
     */
    where: EmailClientCredentialsWhereUniqueInput
    /**
     * In case the EmailClientCredentials found by the `where` argument doesn't exist, create a new EmailClientCredentials with this data.
     */
    create: XOR<EmailClientCredentialsCreateInput, EmailClientCredentialsUncheckedCreateInput>
    /**
     * In case the EmailClientCredentials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailClientCredentialsUpdateInput, EmailClientCredentialsUncheckedUpdateInput>
  }

  /**
   * EmailClientCredentials delete
   */
  export type EmailClientCredentialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsInclude<ExtArgs> | null
    /**
     * Filter which EmailClientCredentials to delete.
     */
    where: EmailClientCredentialsWhereUniqueInput
  }

  /**
   * EmailClientCredentials deleteMany
   */
  export type EmailClientCredentialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailClientCredentials to delete
     */
    where?: EmailClientCredentialsWhereInput
    /**
     * Limit how many EmailClientCredentials to delete.
     */
    limit?: number
  }

  /**
   * EmailClientCredentials without action
   */
  export type EmailClientCredentialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailClientCredentials
     */
    select?: EmailClientCredentialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailClientCredentials
     */
    omit?: EmailClientCredentialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailClientCredentialsInclude<ExtArgs> | null
  }


  /**
   * Model EmailGlobalDailyStats
   */

  export type AggregateEmailGlobalDailyStats = {
    _count: EmailGlobalDailyStatsCountAggregateOutputType | null
    _avg: EmailGlobalDailyStatsAvgAggregateOutputType | null
    _sum: EmailGlobalDailyStatsSumAggregateOutputType | null
    _min: EmailGlobalDailyStatsMinAggregateOutputType | null
    _max: EmailGlobalDailyStatsMaxAggregateOutputType | null
  }

  export type EmailGlobalDailyStatsAvgAggregateOutputType = {
    bounces: number | null
    clicks: number | null
    opens: number | null
    unsubs: number | null
  }

  export type EmailGlobalDailyStatsSumAggregateOutputType = {
    bounces: number | null
    clicks: number | null
    opens: number | null
    unsubs: number | null
  }

  export type EmailGlobalDailyStatsMinAggregateOutputType = {
    id: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    bounces: number | null
    clicks: number | null
    emailClientId: string | null
    opens: number | null
    unsubs: number | null
  }

  export type EmailGlobalDailyStatsMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    bounces: number | null
    clicks: number | null
    emailClientId: string | null
    opens: number | null
    unsubs: number | null
  }

  export type EmailGlobalDailyStatsCountAggregateOutputType = {
    id: number
    date: number
    createdAt: number
    updatedAt: number
    bounces: number
    clicks: number
    emailClientId: number
    opens: number
    unsubs: number
    _all: number
  }


  export type EmailGlobalDailyStatsAvgAggregateInputType = {
    bounces?: true
    clicks?: true
    opens?: true
    unsubs?: true
  }

  export type EmailGlobalDailyStatsSumAggregateInputType = {
    bounces?: true
    clicks?: true
    opens?: true
    unsubs?: true
  }

  export type EmailGlobalDailyStatsMinAggregateInputType = {
    id?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    bounces?: true
    clicks?: true
    emailClientId?: true
    opens?: true
    unsubs?: true
  }

  export type EmailGlobalDailyStatsMaxAggregateInputType = {
    id?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    bounces?: true
    clicks?: true
    emailClientId?: true
    opens?: true
    unsubs?: true
  }

  export type EmailGlobalDailyStatsCountAggregateInputType = {
    id?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    bounces?: true
    clicks?: true
    emailClientId?: true
    opens?: true
    unsubs?: true
    _all?: true
  }

  export type EmailGlobalDailyStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailGlobalDailyStats to aggregate.
     */
    where?: EmailGlobalDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailGlobalDailyStats to fetch.
     */
    orderBy?: EmailGlobalDailyStatsOrderByWithRelationInput | EmailGlobalDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailGlobalDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailGlobalDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailGlobalDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailGlobalDailyStats
    **/
    _count?: true | EmailGlobalDailyStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailGlobalDailyStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailGlobalDailyStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailGlobalDailyStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailGlobalDailyStatsMaxAggregateInputType
  }

  export type GetEmailGlobalDailyStatsAggregateType<T extends EmailGlobalDailyStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailGlobalDailyStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailGlobalDailyStats[P]>
      : GetScalarType<T[P], AggregateEmailGlobalDailyStats[P]>
  }




  export type EmailGlobalDailyStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailGlobalDailyStatsWhereInput
    orderBy?: EmailGlobalDailyStatsOrderByWithAggregationInput | EmailGlobalDailyStatsOrderByWithAggregationInput[]
    by: EmailGlobalDailyStatsScalarFieldEnum[] | EmailGlobalDailyStatsScalarFieldEnum
    having?: EmailGlobalDailyStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailGlobalDailyStatsCountAggregateInputType | true
    _avg?: EmailGlobalDailyStatsAvgAggregateInputType
    _sum?: EmailGlobalDailyStatsSumAggregateInputType
    _min?: EmailGlobalDailyStatsMinAggregateInputType
    _max?: EmailGlobalDailyStatsMaxAggregateInputType
  }

  export type EmailGlobalDailyStatsGroupByOutputType = {
    id: string
    date: Date
    createdAt: Date
    updatedAt: Date
    bounces: number
    clicks: number
    emailClientId: string
    opens: number
    unsubs: number
    _count: EmailGlobalDailyStatsCountAggregateOutputType | null
    _avg: EmailGlobalDailyStatsAvgAggregateOutputType | null
    _sum: EmailGlobalDailyStatsSumAggregateOutputType | null
    _min: EmailGlobalDailyStatsMinAggregateOutputType | null
    _max: EmailGlobalDailyStatsMaxAggregateOutputType | null
  }

  type GetEmailGlobalDailyStatsGroupByPayload<T extends EmailGlobalDailyStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailGlobalDailyStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailGlobalDailyStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailGlobalDailyStatsGroupByOutputType[P]>
            : GetScalarType<T[P], EmailGlobalDailyStatsGroupByOutputType[P]>
        }
      >
    >


  export type EmailGlobalDailyStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bounces?: boolean
    clicks?: boolean
    emailClientId?: boolean
    opens?: boolean
    unsubs?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailGlobalDailyStats"]>

  export type EmailGlobalDailyStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bounces?: boolean
    clicks?: boolean
    emailClientId?: boolean
    opens?: boolean
    unsubs?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailGlobalDailyStats"]>

  export type EmailGlobalDailyStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bounces?: boolean
    clicks?: boolean
    emailClientId?: boolean
    opens?: boolean
    unsubs?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailGlobalDailyStats"]>

  export type EmailGlobalDailyStatsSelectScalar = {
    id?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bounces?: boolean
    clicks?: boolean
    emailClientId?: boolean
    opens?: boolean
    unsubs?: boolean
  }

  export type EmailGlobalDailyStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "createdAt" | "updatedAt" | "bounces" | "clicks" | "emailClientId" | "opens" | "unsubs", ExtArgs["result"]["emailGlobalDailyStats"]>
  export type EmailGlobalDailyStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }
  export type EmailGlobalDailyStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }
  export type EmailGlobalDailyStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
  }

  export type $EmailGlobalDailyStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailGlobalDailyStats"
    objects: {
      emailClient: Prisma.$EmailClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      createdAt: Date
      updatedAt: Date
      bounces: number
      clicks: number
      emailClientId: string
      opens: number
      unsubs: number
    }, ExtArgs["result"]["emailGlobalDailyStats"]>
    composites: {}
  }

  type EmailGlobalDailyStatsGetPayload<S extends boolean | null | undefined | EmailGlobalDailyStatsDefaultArgs> = $Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload, S>

  type EmailGlobalDailyStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailGlobalDailyStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailGlobalDailyStatsCountAggregateInputType | true
    }

  export interface EmailGlobalDailyStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailGlobalDailyStats'], meta: { name: 'EmailGlobalDailyStats' } }
    /**
     * Find zero or one EmailGlobalDailyStats that matches the filter.
     * @param {EmailGlobalDailyStatsFindUniqueArgs} args - Arguments to find a EmailGlobalDailyStats
     * @example
     * // Get one EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailGlobalDailyStatsFindUniqueArgs>(args: SelectSubset<T, EmailGlobalDailyStatsFindUniqueArgs<ExtArgs>>): Prisma__EmailGlobalDailyStatsClient<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailGlobalDailyStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailGlobalDailyStatsFindUniqueOrThrowArgs} args - Arguments to find a EmailGlobalDailyStats
     * @example
     * // Get one EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailGlobalDailyStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailGlobalDailyStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailGlobalDailyStatsClient<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailGlobalDailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGlobalDailyStatsFindFirstArgs} args - Arguments to find a EmailGlobalDailyStats
     * @example
     * // Get one EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailGlobalDailyStatsFindFirstArgs>(args?: SelectSubset<T, EmailGlobalDailyStatsFindFirstArgs<ExtArgs>>): Prisma__EmailGlobalDailyStatsClient<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailGlobalDailyStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGlobalDailyStatsFindFirstOrThrowArgs} args - Arguments to find a EmailGlobalDailyStats
     * @example
     * // Get one EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailGlobalDailyStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailGlobalDailyStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailGlobalDailyStatsClient<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailGlobalDailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGlobalDailyStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.findMany()
     * 
     * // Get first 10 EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailGlobalDailyStatsWithIdOnly = await prisma.emailGlobalDailyStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailGlobalDailyStatsFindManyArgs>(args?: SelectSubset<T, EmailGlobalDailyStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailGlobalDailyStats.
     * @param {EmailGlobalDailyStatsCreateArgs} args - Arguments to create a EmailGlobalDailyStats.
     * @example
     * // Create one EmailGlobalDailyStats
     * const EmailGlobalDailyStats = await prisma.emailGlobalDailyStats.create({
     *   data: {
     *     // ... data to create a EmailGlobalDailyStats
     *   }
     * })
     * 
     */
    create<T extends EmailGlobalDailyStatsCreateArgs>(args: SelectSubset<T, EmailGlobalDailyStatsCreateArgs<ExtArgs>>): Prisma__EmailGlobalDailyStatsClient<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailGlobalDailyStats.
     * @param {EmailGlobalDailyStatsCreateManyArgs} args - Arguments to create many EmailGlobalDailyStats.
     * @example
     * // Create many EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailGlobalDailyStatsCreateManyArgs>(args?: SelectSubset<T, EmailGlobalDailyStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailGlobalDailyStats and returns the data saved in the database.
     * @param {EmailGlobalDailyStatsCreateManyAndReturnArgs} args - Arguments to create many EmailGlobalDailyStats.
     * @example
     * // Create many EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailGlobalDailyStats and only return the `id`
     * const emailGlobalDailyStatsWithIdOnly = await prisma.emailGlobalDailyStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailGlobalDailyStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailGlobalDailyStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailGlobalDailyStats.
     * @param {EmailGlobalDailyStatsDeleteArgs} args - Arguments to delete one EmailGlobalDailyStats.
     * @example
     * // Delete one EmailGlobalDailyStats
     * const EmailGlobalDailyStats = await prisma.emailGlobalDailyStats.delete({
     *   where: {
     *     // ... filter to delete one EmailGlobalDailyStats
     *   }
     * })
     * 
     */
    delete<T extends EmailGlobalDailyStatsDeleteArgs>(args: SelectSubset<T, EmailGlobalDailyStatsDeleteArgs<ExtArgs>>): Prisma__EmailGlobalDailyStatsClient<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailGlobalDailyStats.
     * @param {EmailGlobalDailyStatsUpdateArgs} args - Arguments to update one EmailGlobalDailyStats.
     * @example
     * // Update one EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailGlobalDailyStatsUpdateArgs>(args: SelectSubset<T, EmailGlobalDailyStatsUpdateArgs<ExtArgs>>): Prisma__EmailGlobalDailyStatsClient<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailGlobalDailyStats.
     * @param {EmailGlobalDailyStatsDeleteManyArgs} args - Arguments to filter EmailGlobalDailyStats to delete.
     * @example
     * // Delete a few EmailGlobalDailyStats
     * const { count } = await prisma.emailGlobalDailyStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailGlobalDailyStatsDeleteManyArgs>(args?: SelectSubset<T, EmailGlobalDailyStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailGlobalDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGlobalDailyStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailGlobalDailyStatsUpdateManyArgs>(args: SelectSubset<T, EmailGlobalDailyStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailGlobalDailyStats and returns the data updated in the database.
     * @param {EmailGlobalDailyStatsUpdateManyAndReturnArgs} args - Arguments to update many EmailGlobalDailyStats.
     * @example
     * // Update many EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailGlobalDailyStats and only return the `id`
     * const emailGlobalDailyStatsWithIdOnly = await prisma.emailGlobalDailyStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailGlobalDailyStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailGlobalDailyStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailGlobalDailyStats.
     * @param {EmailGlobalDailyStatsUpsertArgs} args - Arguments to update or create a EmailGlobalDailyStats.
     * @example
     * // Update or create a EmailGlobalDailyStats
     * const emailGlobalDailyStats = await prisma.emailGlobalDailyStats.upsert({
     *   create: {
     *     // ... data to create a EmailGlobalDailyStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailGlobalDailyStats we want to update
     *   }
     * })
     */
    upsert<T extends EmailGlobalDailyStatsUpsertArgs>(args: SelectSubset<T, EmailGlobalDailyStatsUpsertArgs<ExtArgs>>): Prisma__EmailGlobalDailyStatsClient<$Result.GetResult<Prisma.$EmailGlobalDailyStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailGlobalDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGlobalDailyStatsCountArgs} args - Arguments to filter EmailGlobalDailyStats to count.
     * @example
     * // Count the number of EmailGlobalDailyStats
     * const count = await prisma.emailGlobalDailyStats.count({
     *   where: {
     *     // ... the filter for the EmailGlobalDailyStats we want to count
     *   }
     * })
    **/
    count<T extends EmailGlobalDailyStatsCountArgs>(
      args?: Subset<T, EmailGlobalDailyStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailGlobalDailyStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailGlobalDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGlobalDailyStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailGlobalDailyStatsAggregateArgs>(args: Subset<T, EmailGlobalDailyStatsAggregateArgs>): Prisma.PrismaPromise<GetEmailGlobalDailyStatsAggregateType<T>>

    /**
     * Group by EmailGlobalDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGlobalDailyStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailGlobalDailyStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailGlobalDailyStatsGroupByArgs['orderBy'] }
        : { orderBy?: EmailGlobalDailyStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailGlobalDailyStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailGlobalDailyStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailGlobalDailyStats model
   */
  readonly fields: EmailGlobalDailyStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailGlobalDailyStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailGlobalDailyStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailClient<T extends EmailClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailClientDefaultArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailGlobalDailyStats model
   */
  interface EmailGlobalDailyStatsFieldRefs {
    readonly id: FieldRef<"EmailGlobalDailyStats", 'String'>
    readonly date: FieldRef<"EmailGlobalDailyStats", 'DateTime'>
    readonly createdAt: FieldRef<"EmailGlobalDailyStats", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailGlobalDailyStats", 'DateTime'>
    readonly bounces: FieldRef<"EmailGlobalDailyStats", 'Int'>
    readonly clicks: FieldRef<"EmailGlobalDailyStats", 'Int'>
    readonly emailClientId: FieldRef<"EmailGlobalDailyStats", 'String'>
    readonly opens: FieldRef<"EmailGlobalDailyStats", 'Int'>
    readonly unsubs: FieldRef<"EmailGlobalDailyStats", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmailGlobalDailyStats findUnique
   */
  export type EmailGlobalDailyStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which EmailGlobalDailyStats to fetch.
     */
    where: EmailGlobalDailyStatsWhereUniqueInput
  }

  /**
   * EmailGlobalDailyStats findUniqueOrThrow
   */
  export type EmailGlobalDailyStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which EmailGlobalDailyStats to fetch.
     */
    where: EmailGlobalDailyStatsWhereUniqueInput
  }

  /**
   * EmailGlobalDailyStats findFirst
   */
  export type EmailGlobalDailyStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which EmailGlobalDailyStats to fetch.
     */
    where?: EmailGlobalDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailGlobalDailyStats to fetch.
     */
    orderBy?: EmailGlobalDailyStatsOrderByWithRelationInput | EmailGlobalDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailGlobalDailyStats.
     */
    cursor?: EmailGlobalDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailGlobalDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailGlobalDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailGlobalDailyStats.
     */
    distinct?: EmailGlobalDailyStatsScalarFieldEnum | EmailGlobalDailyStatsScalarFieldEnum[]
  }

  /**
   * EmailGlobalDailyStats findFirstOrThrow
   */
  export type EmailGlobalDailyStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which EmailGlobalDailyStats to fetch.
     */
    where?: EmailGlobalDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailGlobalDailyStats to fetch.
     */
    orderBy?: EmailGlobalDailyStatsOrderByWithRelationInput | EmailGlobalDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailGlobalDailyStats.
     */
    cursor?: EmailGlobalDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailGlobalDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailGlobalDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailGlobalDailyStats.
     */
    distinct?: EmailGlobalDailyStatsScalarFieldEnum | EmailGlobalDailyStatsScalarFieldEnum[]
  }

  /**
   * EmailGlobalDailyStats findMany
   */
  export type EmailGlobalDailyStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which EmailGlobalDailyStats to fetch.
     */
    where?: EmailGlobalDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailGlobalDailyStats to fetch.
     */
    orderBy?: EmailGlobalDailyStatsOrderByWithRelationInput | EmailGlobalDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailGlobalDailyStats.
     */
    cursor?: EmailGlobalDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailGlobalDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailGlobalDailyStats.
     */
    skip?: number
    distinct?: EmailGlobalDailyStatsScalarFieldEnum | EmailGlobalDailyStatsScalarFieldEnum[]
  }

  /**
   * EmailGlobalDailyStats create
   */
  export type EmailGlobalDailyStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailGlobalDailyStats.
     */
    data: XOR<EmailGlobalDailyStatsCreateInput, EmailGlobalDailyStatsUncheckedCreateInput>
  }

  /**
   * EmailGlobalDailyStats createMany
   */
  export type EmailGlobalDailyStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailGlobalDailyStats.
     */
    data: EmailGlobalDailyStatsCreateManyInput | EmailGlobalDailyStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailGlobalDailyStats createManyAndReturn
   */
  export type EmailGlobalDailyStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * The data used to create many EmailGlobalDailyStats.
     */
    data: EmailGlobalDailyStatsCreateManyInput | EmailGlobalDailyStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailGlobalDailyStats update
   */
  export type EmailGlobalDailyStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailGlobalDailyStats.
     */
    data: XOR<EmailGlobalDailyStatsUpdateInput, EmailGlobalDailyStatsUncheckedUpdateInput>
    /**
     * Choose, which EmailGlobalDailyStats to update.
     */
    where: EmailGlobalDailyStatsWhereUniqueInput
  }

  /**
   * EmailGlobalDailyStats updateMany
   */
  export type EmailGlobalDailyStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailGlobalDailyStats.
     */
    data: XOR<EmailGlobalDailyStatsUpdateManyMutationInput, EmailGlobalDailyStatsUncheckedUpdateManyInput>
    /**
     * Filter which EmailGlobalDailyStats to update
     */
    where?: EmailGlobalDailyStatsWhereInput
    /**
     * Limit how many EmailGlobalDailyStats to update.
     */
    limit?: number
  }

  /**
   * EmailGlobalDailyStats updateManyAndReturn
   */
  export type EmailGlobalDailyStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * The data used to update EmailGlobalDailyStats.
     */
    data: XOR<EmailGlobalDailyStatsUpdateManyMutationInput, EmailGlobalDailyStatsUncheckedUpdateManyInput>
    /**
     * Filter which EmailGlobalDailyStats to update
     */
    where?: EmailGlobalDailyStatsWhereInput
    /**
     * Limit how many EmailGlobalDailyStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailGlobalDailyStats upsert
   */
  export type EmailGlobalDailyStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailGlobalDailyStats to update in case it exists.
     */
    where: EmailGlobalDailyStatsWhereUniqueInput
    /**
     * In case the EmailGlobalDailyStats found by the `where` argument doesn't exist, create a new EmailGlobalDailyStats with this data.
     */
    create: XOR<EmailGlobalDailyStatsCreateInput, EmailGlobalDailyStatsUncheckedCreateInput>
    /**
     * In case the EmailGlobalDailyStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailGlobalDailyStatsUpdateInput, EmailGlobalDailyStatsUncheckedUpdateInput>
  }

  /**
   * EmailGlobalDailyStats delete
   */
  export type EmailGlobalDailyStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsInclude<ExtArgs> | null
    /**
     * Filter which EmailGlobalDailyStats to delete.
     */
    where: EmailGlobalDailyStatsWhereUniqueInput
  }

  /**
   * EmailGlobalDailyStats deleteMany
   */
  export type EmailGlobalDailyStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailGlobalDailyStats to delete
     */
    where?: EmailGlobalDailyStatsWhereInput
    /**
     * Limit how many EmailGlobalDailyStats to delete.
     */
    limit?: number
  }

  /**
   * EmailGlobalDailyStats without action
   */
  export type EmailGlobalDailyStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailGlobalDailyStats
     */
    select?: EmailGlobalDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailGlobalDailyStats
     */
    omit?: EmailGlobalDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailGlobalDailyStatsInclude<ExtArgs> | null
  }


  /**
   * Model GaAccount
   */

  export type AggregateGaAccount = {
    _count: GaAccountCountAggregateOutputType | null
    _min: GaAccountMinAggregateOutputType | null
    _max: GaAccountMaxAggregateOutputType | null
  }

  export type GaAccountMinAggregateOutputType = {
    id: string | null
    gaAccountId: string | null
    gaAccountName: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaAccountMaxAggregateOutputType = {
    id: string | null
    gaAccountId: string | null
    gaAccountName: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaAccountCountAggregateOutputType = {
    id: number
    gaAccountId: number
    gaAccountName: number
    deleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GaAccountMinAggregateInputType = {
    id?: true
    gaAccountId?: true
    gaAccountName?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaAccountMaxAggregateInputType = {
    id?: true
    gaAccountId?: true
    gaAccountName?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaAccountCountAggregateInputType = {
    id?: true
    gaAccountId?: true
    gaAccountName?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GaAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaAccount to aggregate.
     */
    where?: GaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaAccounts to fetch.
     */
    orderBy?: GaAccountOrderByWithRelationInput | GaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaAccounts
    **/
    _count?: true | GaAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaAccountMaxAggregateInputType
  }

  export type GetGaAccountAggregateType<T extends GaAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateGaAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaAccount[P]>
      : GetScalarType<T[P], AggregateGaAccount[P]>
  }




  export type GaAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaAccountWhereInput
    orderBy?: GaAccountOrderByWithAggregationInput | GaAccountOrderByWithAggregationInput[]
    by: GaAccountScalarFieldEnum[] | GaAccountScalarFieldEnum
    having?: GaAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaAccountCountAggregateInputType | true
    _min?: GaAccountMinAggregateInputType
    _max?: GaAccountMaxAggregateInputType
  }

  export type GaAccountGroupByOutputType = {
    id: string
    gaAccountId: string
    gaAccountName: string
    deleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: GaAccountCountAggregateOutputType | null
    _min: GaAccountMinAggregateOutputType | null
    _max: GaAccountMaxAggregateOutputType | null
  }

  type GetGaAccountGroupByPayload<T extends GaAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaAccountGroupByOutputType[P]>
            : GetScalarType<T[P], GaAccountGroupByOutputType[P]>
        }
      >
    >


  export type GaAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaAccountId?: boolean
    gaAccountName?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversations?: boolean | GaAccount$conversationsArgs<ExtArgs>
    gaProperties?: boolean | GaAccount$gaPropertiesArgs<ExtArgs>
    userToGaAccounts?: boolean | GaAccount$userToGaAccountsArgs<ExtArgs>
    _count?: boolean | GaAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaAccount"]>

  export type GaAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaAccountId?: boolean
    gaAccountName?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gaAccount"]>

  export type GaAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaAccountId?: boolean
    gaAccountName?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gaAccount"]>

  export type GaAccountSelectScalar = {
    id?: boolean
    gaAccountId?: boolean
    gaAccountName?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GaAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaAccountId" | "gaAccountName" | "deleted" | "createdAt" | "updatedAt", ExtArgs["result"]["gaAccount"]>
  export type GaAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | GaAccount$conversationsArgs<ExtArgs>
    gaProperties?: boolean | GaAccount$gaPropertiesArgs<ExtArgs>
    userToGaAccounts?: boolean | GaAccount$userToGaAccountsArgs<ExtArgs>
    _count?: boolean | GaAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GaAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GaAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GaAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaAccount"
    objects: {
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      gaProperties: Prisma.$GaPropertyPayload<ExtArgs>[]
      userToGaAccounts: Prisma.$UserToGaAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaAccountId: string
      gaAccountName: string
      deleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gaAccount"]>
    composites: {}
  }

  type GaAccountGetPayload<S extends boolean | null | undefined | GaAccountDefaultArgs> = $Result.GetResult<Prisma.$GaAccountPayload, S>

  type GaAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaAccountCountAggregateInputType | true
    }

  export interface GaAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaAccount'], meta: { name: 'GaAccount' } }
    /**
     * Find zero or one GaAccount that matches the filter.
     * @param {GaAccountFindUniqueArgs} args - Arguments to find a GaAccount
     * @example
     * // Get one GaAccount
     * const gaAccount = await prisma.gaAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaAccountFindUniqueArgs>(args: SelectSubset<T, GaAccountFindUniqueArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaAccountFindUniqueOrThrowArgs} args - Arguments to find a GaAccount
     * @example
     * // Get one GaAccount
     * const gaAccount = await prisma.gaAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, GaAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountFindFirstArgs} args - Arguments to find a GaAccount
     * @example
     * // Get one GaAccount
     * const gaAccount = await prisma.gaAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaAccountFindFirstArgs>(args?: SelectSubset<T, GaAccountFindFirstArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountFindFirstOrThrowArgs} args - Arguments to find a GaAccount
     * @example
     * // Get one GaAccount
     * const gaAccount = await prisma.gaAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, GaAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaAccounts
     * const gaAccounts = await prisma.gaAccount.findMany()
     * 
     * // Get first 10 GaAccounts
     * const gaAccounts = await prisma.gaAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaAccountWithIdOnly = await prisma.gaAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaAccountFindManyArgs>(args?: SelectSubset<T, GaAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaAccount.
     * @param {GaAccountCreateArgs} args - Arguments to create a GaAccount.
     * @example
     * // Create one GaAccount
     * const GaAccount = await prisma.gaAccount.create({
     *   data: {
     *     // ... data to create a GaAccount
     *   }
     * })
     * 
     */
    create<T extends GaAccountCreateArgs>(args: SelectSubset<T, GaAccountCreateArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaAccounts.
     * @param {GaAccountCreateManyArgs} args - Arguments to create many GaAccounts.
     * @example
     * // Create many GaAccounts
     * const gaAccount = await prisma.gaAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaAccountCreateManyArgs>(args?: SelectSubset<T, GaAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaAccounts and returns the data saved in the database.
     * @param {GaAccountCreateManyAndReturnArgs} args - Arguments to create many GaAccounts.
     * @example
     * // Create many GaAccounts
     * const gaAccount = await prisma.gaAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaAccounts and only return the `id`
     * const gaAccountWithIdOnly = await prisma.gaAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, GaAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaAccount.
     * @param {GaAccountDeleteArgs} args - Arguments to delete one GaAccount.
     * @example
     * // Delete one GaAccount
     * const GaAccount = await prisma.gaAccount.delete({
     *   where: {
     *     // ... filter to delete one GaAccount
     *   }
     * })
     * 
     */
    delete<T extends GaAccountDeleteArgs>(args: SelectSubset<T, GaAccountDeleteArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaAccount.
     * @param {GaAccountUpdateArgs} args - Arguments to update one GaAccount.
     * @example
     * // Update one GaAccount
     * const gaAccount = await prisma.gaAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaAccountUpdateArgs>(args: SelectSubset<T, GaAccountUpdateArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaAccounts.
     * @param {GaAccountDeleteManyArgs} args - Arguments to filter GaAccounts to delete.
     * @example
     * // Delete a few GaAccounts
     * const { count } = await prisma.gaAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaAccountDeleteManyArgs>(args?: SelectSubset<T, GaAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaAccounts
     * const gaAccount = await prisma.gaAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaAccountUpdateManyArgs>(args: SelectSubset<T, GaAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaAccounts and returns the data updated in the database.
     * @param {GaAccountUpdateManyAndReturnArgs} args - Arguments to update many GaAccounts.
     * @example
     * // Update many GaAccounts
     * const gaAccount = await prisma.gaAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaAccounts and only return the `id`
     * const gaAccountWithIdOnly = await prisma.gaAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, GaAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaAccount.
     * @param {GaAccountUpsertArgs} args - Arguments to update or create a GaAccount.
     * @example
     * // Update or create a GaAccount
     * const gaAccount = await prisma.gaAccount.upsert({
     *   create: {
     *     // ... data to create a GaAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaAccount we want to update
     *   }
     * })
     */
    upsert<T extends GaAccountUpsertArgs>(args: SelectSubset<T, GaAccountUpsertArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountCountArgs} args - Arguments to filter GaAccounts to count.
     * @example
     * // Count the number of GaAccounts
     * const count = await prisma.gaAccount.count({
     *   where: {
     *     // ... the filter for the GaAccounts we want to count
     *   }
     * })
    **/
    count<T extends GaAccountCountArgs>(
      args?: Subset<T, GaAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaAccountAggregateArgs>(args: Subset<T, GaAccountAggregateArgs>): Prisma.PrismaPromise<GetGaAccountAggregateType<T>>

    /**
     * Group by GaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaAccountGroupByArgs['orderBy'] }
        : { orderBy?: GaAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaAccount model
   */
  readonly fields: GaAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversations<T extends GaAccount$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, GaAccount$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gaProperties<T extends GaAccount$gaPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, GaAccount$gaPropertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userToGaAccounts<T extends GaAccount$userToGaAccountsArgs<ExtArgs> = {}>(args?: Subset<T, GaAccount$userToGaAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaAccount model
   */
  interface GaAccountFieldRefs {
    readonly id: FieldRef<"GaAccount", 'String'>
    readonly gaAccountId: FieldRef<"GaAccount", 'String'>
    readonly gaAccountName: FieldRef<"GaAccount", 'String'>
    readonly deleted: FieldRef<"GaAccount", 'Boolean'>
    readonly createdAt: FieldRef<"GaAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"GaAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaAccount findUnique
   */
  export type GaAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter, which GaAccount to fetch.
     */
    where: GaAccountWhereUniqueInput
  }

  /**
   * GaAccount findUniqueOrThrow
   */
  export type GaAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter, which GaAccount to fetch.
     */
    where: GaAccountWhereUniqueInput
  }

  /**
   * GaAccount findFirst
   */
  export type GaAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter, which GaAccount to fetch.
     */
    where?: GaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaAccounts to fetch.
     */
    orderBy?: GaAccountOrderByWithRelationInput | GaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaAccounts.
     */
    cursor?: GaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaAccounts.
     */
    distinct?: GaAccountScalarFieldEnum | GaAccountScalarFieldEnum[]
  }

  /**
   * GaAccount findFirstOrThrow
   */
  export type GaAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter, which GaAccount to fetch.
     */
    where?: GaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaAccounts to fetch.
     */
    orderBy?: GaAccountOrderByWithRelationInput | GaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaAccounts.
     */
    cursor?: GaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaAccounts.
     */
    distinct?: GaAccountScalarFieldEnum | GaAccountScalarFieldEnum[]
  }

  /**
   * GaAccount findMany
   */
  export type GaAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter, which GaAccounts to fetch.
     */
    where?: GaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaAccounts to fetch.
     */
    orderBy?: GaAccountOrderByWithRelationInput | GaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaAccounts.
     */
    cursor?: GaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaAccounts.
     */
    skip?: number
    distinct?: GaAccountScalarFieldEnum | GaAccountScalarFieldEnum[]
  }

  /**
   * GaAccount create
   */
  export type GaAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a GaAccount.
     */
    data: XOR<GaAccountCreateInput, GaAccountUncheckedCreateInput>
  }

  /**
   * GaAccount createMany
   */
  export type GaAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaAccounts.
     */
    data: GaAccountCreateManyInput | GaAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaAccount createManyAndReturn
   */
  export type GaAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * The data used to create many GaAccounts.
     */
    data: GaAccountCreateManyInput | GaAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaAccount update
   */
  export type GaAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a GaAccount.
     */
    data: XOR<GaAccountUpdateInput, GaAccountUncheckedUpdateInput>
    /**
     * Choose, which GaAccount to update.
     */
    where: GaAccountWhereUniqueInput
  }

  /**
   * GaAccount updateMany
   */
  export type GaAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaAccounts.
     */
    data: XOR<GaAccountUpdateManyMutationInput, GaAccountUncheckedUpdateManyInput>
    /**
     * Filter which GaAccounts to update
     */
    where?: GaAccountWhereInput
    /**
     * Limit how many GaAccounts to update.
     */
    limit?: number
  }

  /**
   * GaAccount updateManyAndReturn
   */
  export type GaAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * The data used to update GaAccounts.
     */
    data: XOR<GaAccountUpdateManyMutationInput, GaAccountUncheckedUpdateManyInput>
    /**
     * Filter which GaAccounts to update
     */
    where?: GaAccountWhereInput
    /**
     * Limit how many GaAccounts to update.
     */
    limit?: number
  }

  /**
   * GaAccount upsert
   */
  export type GaAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the GaAccount to update in case it exists.
     */
    where: GaAccountWhereUniqueInput
    /**
     * In case the GaAccount found by the `where` argument doesn't exist, create a new GaAccount with this data.
     */
    create: XOR<GaAccountCreateInput, GaAccountUncheckedCreateInput>
    /**
     * In case the GaAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaAccountUpdateInput, GaAccountUncheckedUpdateInput>
  }

  /**
   * GaAccount delete
   */
  export type GaAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
    /**
     * Filter which GaAccount to delete.
     */
    where: GaAccountWhereUniqueInput
  }

  /**
   * GaAccount deleteMany
   */
  export type GaAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaAccounts to delete
     */
    where?: GaAccountWhereInput
    /**
     * Limit how many GaAccounts to delete.
     */
    limit?: number
  }

  /**
   * GaAccount.conversations
   */
  export type GaAccount$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * GaAccount.gaProperties
   */
  export type GaAccount$gaPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    where?: GaPropertyWhereInput
    orderBy?: GaPropertyOrderByWithRelationInput | GaPropertyOrderByWithRelationInput[]
    cursor?: GaPropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaPropertyScalarFieldEnum | GaPropertyScalarFieldEnum[]
  }

  /**
   * GaAccount.userToGaAccounts
   */
  export type GaAccount$userToGaAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
    where?: UserToGaAccountWhereInput
    orderBy?: UserToGaAccountOrderByWithRelationInput | UserToGaAccountOrderByWithRelationInput[]
    cursor?: UserToGaAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserToGaAccountScalarFieldEnum | UserToGaAccountScalarFieldEnum[]
  }

  /**
   * GaAccount without action
   */
  export type GaAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaAccount
     */
    select?: GaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaAccount
     */
    omit?: GaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaAccountInclude<ExtArgs> | null
  }


  /**
   * Model GaProperty
   */

  export type AggregateGaProperty = {
    _count: GaPropertyCountAggregateOutputType | null
    _min: GaPropertyMinAggregateOutputType | null
    _max: GaPropertyMaxAggregateOutputType | null
  }

  export type GaPropertyMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    gaPropertyName: string | null
    gaAccountId: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaPropertyMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    gaPropertyName: string | null
    gaAccountId: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaPropertyCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    gaPropertyName: number
    gaAccountId: number
    deleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GaPropertyMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    gaPropertyName?: true
    gaAccountId?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaPropertyMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    gaPropertyName?: true
    gaAccountId?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaPropertyCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    gaPropertyName?: true
    gaAccountId?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GaPropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaProperty to aggregate.
     */
    where?: GaPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaProperties to fetch.
     */
    orderBy?: GaPropertyOrderByWithRelationInput | GaPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaProperties
    **/
    _count?: true | GaPropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaPropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaPropertyMaxAggregateInputType
  }

  export type GetGaPropertyAggregateType<T extends GaPropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateGaProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaProperty[P]>
      : GetScalarType<T[P], AggregateGaProperty[P]>
  }




  export type GaPropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaPropertyWhereInput
    orderBy?: GaPropertyOrderByWithAggregationInput | GaPropertyOrderByWithAggregationInput[]
    by: GaPropertyScalarFieldEnum[] | GaPropertyScalarFieldEnum
    having?: GaPropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaPropertyCountAggregateInputType | true
    _min?: GaPropertyMinAggregateInputType
    _max?: GaPropertyMaxAggregateInputType
  }

  export type GaPropertyGroupByOutputType = {
    id: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    deleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: GaPropertyCountAggregateOutputType | null
    _min: GaPropertyMinAggregateOutputType | null
    _max: GaPropertyMaxAggregateOutputType | null
  }

  type GetGaPropertyGroupByPayload<T extends GaPropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaPropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaPropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaPropertyGroupByOutputType[P]>
            : GetScalarType<T[P], GaPropertyGroupByOutputType[P]>
        }
      >
    >


  export type GaPropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    gaPropertyName?: boolean
    gaAccountId?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversations?: boolean | GaProperty$conversationsArgs<ExtArgs>
    channelDaily?: boolean | GaProperty$channelDailyArgs<ExtArgs>
    imports?: boolean | GaProperty$importsArgs<ExtArgs>
    kpiDaily?: boolean | GaProperty$kpiDailyArgs<ExtArgs>
    kpiMonthly?: boolean | GaProperty$kpiMonthlyArgs<ExtArgs>
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
    sourceDaily?: boolean | GaProperty$sourceDailyArgs<ExtArgs>
    _count?: boolean | GaPropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaProperty"]>

  export type GaPropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    gaPropertyName?: boolean
    gaAccountId?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaProperty"]>

  export type GaPropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    gaPropertyName?: boolean
    gaAccountId?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaProperty"]>

  export type GaPropertySelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    gaPropertyName?: boolean
    gaAccountId?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GaPropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "gaPropertyName" | "gaAccountId" | "deleted" | "createdAt" | "updatedAt", ExtArgs["result"]["gaProperty"]>
  export type GaPropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | GaProperty$conversationsArgs<ExtArgs>
    channelDaily?: boolean | GaProperty$channelDailyArgs<ExtArgs>
    imports?: boolean | GaProperty$importsArgs<ExtArgs>
    kpiDaily?: boolean | GaProperty$kpiDailyArgs<ExtArgs>
    kpiMonthly?: boolean | GaProperty$kpiMonthlyArgs<ExtArgs>
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
    sourceDaily?: boolean | GaProperty$sourceDailyArgs<ExtArgs>
    _count?: boolean | GaPropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GaPropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
  }
  export type GaPropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
  }

  export type $GaPropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaProperty"
    objects: {
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      channelDaily: Prisma.$GaChannelDailyPayload<ExtArgs>[]
      imports: Prisma.$GaImportRunPayload<ExtArgs>[]
      kpiDaily: Prisma.$GaKpiDailyPayload<ExtArgs>[]
      kpiMonthly: Prisma.$GaKpiMonthlyPayload<ExtArgs>[]
      gaAccount: Prisma.$GaAccountPayload<ExtArgs>
      sourceDaily: Prisma.$GaSourceDailyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      gaPropertyName: string
      gaAccountId: string
      deleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gaProperty"]>
    composites: {}
  }

  type GaPropertyGetPayload<S extends boolean | null | undefined | GaPropertyDefaultArgs> = $Result.GetResult<Prisma.$GaPropertyPayload, S>

  type GaPropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaPropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaPropertyCountAggregateInputType | true
    }

  export interface GaPropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaProperty'], meta: { name: 'GaProperty' } }
    /**
     * Find zero or one GaProperty that matches the filter.
     * @param {GaPropertyFindUniqueArgs} args - Arguments to find a GaProperty
     * @example
     * // Get one GaProperty
     * const gaProperty = await prisma.gaProperty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaPropertyFindUniqueArgs>(args: SelectSubset<T, GaPropertyFindUniqueArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaProperty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaPropertyFindUniqueOrThrowArgs} args - Arguments to find a GaProperty
     * @example
     * // Get one GaProperty
     * const gaProperty = await prisma.gaProperty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaPropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, GaPropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaProperty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyFindFirstArgs} args - Arguments to find a GaProperty
     * @example
     * // Get one GaProperty
     * const gaProperty = await prisma.gaProperty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaPropertyFindFirstArgs>(args?: SelectSubset<T, GaPropertyFindFirstArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaProperty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyFindFirstOrThrowArgs} args - Arguments to find a GaProperty
     * @example
     * // Get one GaProperty
     * const gaProperty = await prisma.gaProperty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaPropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, GaPropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaProperties
     * const gaProperties = await prisma.gaProperty.findMany()
     * 
     * // Get first 10 GaProperties
     * const gaProperties = await prisma.gaProperty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaPropertyWithIdOnly = await prisma.gaProperty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaPropertyFindManyArgs>(args?: SelectSubset<T, GaPropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaProperty.
     * @param {GaPropertyCreateArgs} args - Arguments to create a GaProperty.
     * @example
     * // Create one GaProperty
     * const GaProperty = await prisma.gaProperty.create({
     *   data: {
     *     // ... data to create a GaProperty
     *   }
     * })
     * 
     */
    create<T extends GaPropertyCreateArgs>(args: SelectSubset<T, GaPropertyCreateArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaProperties.
     * @param {GaPropertyCreateManyArgs} args - Arguments to create many GaProperties.
     * @example
     * // Create many GaProperties
     * const gaProperty = await prisma.gaProperty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaPropertyCreateManyArgs>(args?: SelectSubset<T, GaPropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaProperties and returns the data saved in the database.
     * @param {GaPropertyCreateManyAndReturnArgs} args - Arguments to create many GaProperties.
     * @example
     * // Create many GaProperties
     * const gaProperty = await prisma.gaProperty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaProperties and only return the `id`
     * const gaPropertyWithIdOnly = await prisma.gaProperty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaPropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, GaPropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaProperty.
     * @param {GaPropertyDeleteArgs} args - Arguments to delete one GaProperty.
     * @example
     * // Delete one GaProperty
     * const GaProperty = await prisma.gaProperty.delete({
     *   where: {
     *     // ... filter to delete one GaProperty
     *   }
     * })
     * 
     */
    delete<T extends GaPropertyDeleteArgs>(args: SelectSubset<T, GaPropertyDeleteArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaProperty.
     * @param {GaPropertyUpdateArgs} args - Arguments to update one GaProperty.
     * @example
     * // Update one GaProperty
     * const gaProperty = await prisma.gaProperty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaPropertyUpdateArgs>(args: SelectSubset<T, GaPropertyUpdateArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaProperties.
     * @param {GaPropertyDeleteManyArgs} args - Arguments to filter GaProperties to delete.
     * @example
     * // Delete a few GaProperties
     * const { count } = await prisma.gaProperty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaPropertyDeleteManyArgs>(args?: SelectSubset<T, GaPropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaProperties
     * const gaProperty = await prisma.gaProperty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaPropertyUpdateManyArgs>(args: SelectSubset<T, GaPropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaProperties and returns the data updated in the database.
     * @param {GaPropertyUpdateManyAndReturnArgs} args - Arguments to update many GaProperties.
     * @example
     * // Update many GaProperties
     * const gaProperty = await prisma.gaProperty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaProperties and only return the `id`
     * const gaPropertyWithIdOnly = await prisma.gaProperty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaPropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, GaPropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaProperty.
     * @param {GaPropertyUpsertArgs} args - Arguments to update or create a GaProperty.
     * @example
     * // Update or create a GaProperty
     * const gaProperty = await prisma.gaProperty.upsert({
     *   create: {
     *     // ... data to create a GaProperty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaProperty we want to update
     *   }
     * })
     */
    upsert<T extends GaPropertyUpsertArgs>(args: SelectSubset<T, GaPropertyUpsertArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyCountArgs} args - Arguments to filter GaProperties to count.
     * @example
     * // Count the number of GaProperties
     * const count = await prisma.gaProperty.count({
     *   where: {
     *     // ... the filter for the GaProperties we want to count
     *   }
     * })
    **/
    count<T extends GaPropertyCountArgs>(
      args?: Subset<T, GaPropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaPropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaProperty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaPropertyAggregateArgs>(args: Subset<T, GaPropertyAggregateArgs>): Prisma.PrismaPromise<GetGaPropertyAggregateType<T>>

    /**
     * Group by GaProperty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaPropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaPropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaPropertyGroupByArgs['orderBy'] }
        : { orderBy?: GaPropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaPropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaProperty model
   */
  readonly fields: GaPropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaProperty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaPropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversations<T extends GaProperty$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    channelDaily<T extends GaProperty$channelDailyArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$channelDailyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imports<T extends GaProperty$importsArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$importsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kpiDaily<T extends GaProperty$kpiDailyArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$kpiDailyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kpiMonthly<T extends GaProperty$kpiMonthlyArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$kpiMonthlyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gaAccount<T extends GaAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaAccountDefaultArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sourceDaily<T extends GaProperty$sourceDailyArgs<ExtArgs> = {}>(args?: Subset<T, GaProperty$sourceDailyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaProperty model
   */
  interface GaPropertyFieldRefs {
    readonly id: FieldRef<"GaProperty", 'String'>
    readonly gaPropertyId: FieldRef<"GaProperty", 'String'>
    readonly gaPropertyName: FieldRef<"GaProperty", 'String'>
    readonly gaAccountId: FieldRef<"GaProperty", 'String'>
    readonly deleted: FieldRef<"GaProperty", 'Boolean'>
    readonly createdAt: FieldRef<"GaProperty", 'DateTime'>
    readonly updatedAt: FieldRef<"GaProperty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaProperty findUnique
   */
  export type GaPropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter, which GaProperty to fetch.
     */
    where: GaPropertyWhereUniqueInput
  }

  /**
   * GaProperty findUniqueOrThrow
   */
  export type GaPropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter, which GaProperty to fetch.
     */
    where: GaPropertyWhereUniqueInput
  }

  /**
   * GaProperty findFirst
   */
  export type GaPropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter, which GaProperty to fetch.
     */
    where?: GaPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaProperties to fetch.
     */
    orderBy?: GaPropertyOrderByWithRelationInput | GaPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaProperties.
     */
    cursor?: GaPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaProperties.
     */
    distinct?: GaPropertyScalarFieldEnum | GaPropertyScalarFieldEnum[]
  }

  /**
   * GaProperty findFirstOrThrow
   */
  export type GaPropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter, which GaProperty to fetch.
     */
    where?: GaPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaProperties to fetch.
     */
    orderBy?: GaPropertyOrderByWithRelationInput | GaPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaProperties.
     */
    cursor?: GaPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaProperties.
     */
    distinct?: GaPropertyScalarFieldEnum | GaPropertyScalarFieldEnum[]
  }

  /**
   * GaProperty findMany
   */
  export type GaPropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter, which GaProperties to fetch.
     */
    where?: GaPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaProperties to fetch.
     */
    orderBy?: GaPropertyOrderByWithRelationInput | GaPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaProperties.
     */
    cursor?: GaPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaProperties.
     */
    skip?: number
    distinct?: GaPropertyScalarFieldEnum | GaPropertyScalarFieldEnum[]
  }

  /**
   * GaProperty create
   */
  export type GaPropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a GaProperty.
     */
    data: XOR<GaPropertyCreateInput, GaPropertyUncheckedCreateInput>
  }

  /**
   * GaProperty createMany
   */
  export type GaPropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaProperties.
     */
    data: GaPropertyCreateManyInput | GaPropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaProperty createManyAndReturn
   */
  export type GaPropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * The data used to create many GaProperties.
     */
    data: GaPropertyCreateManyInput | GaPropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaProperty update
   */
  export type GaPropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a GaProperty.
     */
    data: XOR<GaPropertyUpdateInput, GaPropertyUncheckedUpdateInput>
    /**
     * Choose, which GaProperty to update.
     */
    where: GaPropertyWhereUniqueInput
  }

  /**
   * GaProperty updateMany
   */
  export type GaPropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaProperties.
     */
    data: XOR<GaPropertyUpdateManyMutationInput, GaPropertyUncheckedUpdateManyInput>
    /**
     * Filter which GaProperties to update
     */
    where?: GaPropertyWhereInput
    /**
     * Limit how many GaProperties to update.
     */
    limit?: number
  }

  /**
   * GaProperty updateManyAndReturn
   */
  export type GaPropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * The data used to update GaProperties.
     */
    data: XOR<GaPropertyUpdateManyMutationInput, GaPropertyUncheckedUpdateManyInput>
    /**
     * Filter which GaProperties to update
     */
    where?: GaPropertyWhereInput
    /**
     * Limit how many GaProperties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaProperty upsert
   */
  export type GaPropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the GaProperty to update in case it exists.
     */
    where: GaPropertyWhereUniqueInput
    /**
     * In case the GaProperty found by the `where` argument doesn't exist, create a new GaProperty with this data.
     */
    create: XOR<GaPropertyCreateInput, GaPropertyUncheckedCreateInput>
    /**
     * In case the GaProperty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaPropertyUpdateInput, GaPropertyUncheckedUpdateInput>
  }

  /**
   * GaProperty delete
   */
  export type GaPropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
    /**
     * Filter which GaProperty to delete.
     */
    where: GaPropertyWhereUniqueInput
  }

  /**
   * GaProperty deleteMany
   */
  export type GaPropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaProperties to delete
     */
    where?: GaPropertyWhereInput
    /**
     * Limit how many GaProperties to delete.
     */
    limit?: number
  }

  /**
   * GaProperty.conversations
   */
  export type GaProperty$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * GaProperty.channelDaily
   */
  export type GaProperty$channelDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    where?: GaChannelDailyWhereInput
    orderBy?: GaChannelDailyOrderByWithRelationInput | GaChannelDailyOrderByWithRelationInput[]
    cursor?: GaChannelDailyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaChannelDailyScalarFieldEnum | GaChannelDailyScalarFieldEnum[]
  }

  /**
   * GaProperty.imports
   */
  export type GaProperty$importsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    where?: GaImportRunWhereInput
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    cursor?: GaImportRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaImportRunScalarFieldEnum | GaImportRunScalarFieldEnum[]
  }

  /**
   * GaProperty.kpiDaily
   */
  export type GaProperty$kpiDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    where?: GaKpiDailyWhereInput
    orderBy?: GaKpiDailyOrderByWithRelationInput | GaKpiDailyOrderByWithRelationInput[]
    cursor?: GaKpiDailyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaKpiDailyScalarFieldEnum | GaKpiDailyScalarFieldEnum[]
  }

  /**
   * GaProperty.kpiMonthly
   */
  export type GaProperty$kpiMonthlyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    where?: GaKpiMonthlyWhereInput
    orderBy?: GaKpiMonthlyOrderByWithRelationInput | GaKpiMonthlyOrderByWithRelationInput[]
    cursor?: GaKpiMonthlyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaKpiMonthlyScalarFieldEnum | GaKpiMonthlyScalarFieldEnum[]
  }

  /**
   * GaProperty.sourceDaily
   */
  export type GaProperty$sourceDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    where?: GaSourceDailyWhereInput
    orderBy?: GaSourceDailyOrderByWithRelationInput | GaSourceDailyOrderByWithRelationInput[]
    cursor?: GaSourceDailyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaSourceDailyScalarFieldEnum | GaSourceDailyScalarFieldEnum[]
  }

  /**
   * GaProperty without action
   */
  export type GaPropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaProperty
     */
    select?: GaPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaProperty
     */
    omit?: GaPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaPropertyInclude<ExtArgs> | null
  }


  /**
   * Model GaImportRun
   */

  export type AggregateGaImportRun = {
    _count: GaImportRunCountAggregateOutputType | null
    _min: GaImportRunMinAggregateOutputType | null
    _max: GaImportRunMaxAggregateOutputType | null
  }

  export type GaImportRunMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    dateStart: Date | null
    dateEnd: Date | null
    status: $Enums.ImportStatus | null
    errorMessage: string | null
    requestedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaImportRunMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    dateStart: Date | null
    dateEnd: Date | null
    status: $Enums.ImportStatus | null
    errorMessage: string | null
    requestedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaImportRunCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    dateStart: number
    dateEnd: number
    status: number
    errorMessage: number
    requestedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GaImportRunMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    dateStart?: true
    dateEnd?: true
    status?: true
    errorMessage?: true
    requestedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaImportRunMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    dateStart?: true
    dateEnd?: true
    status?: true
    errorMessage?: true
    requestedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaImportRunCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    dateStart?: true
    dateEnd?: true
    status?: true
    errorMessage?: true
    requestedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GaImportRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaImportRun to aggregate.
     */
    where?: GaImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaImportRuns to fetch.
     */
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaImportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaImportRuns
    **/
    _count?: true | GaImportRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaImportRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaImportRunMaxAggregateInputType
  }

  export type GetGaImportRunAggregateType<T extends GaImportRunAggregateArgs> = {
        [P in keyof T & keyof AggregateGaImportRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaImportRun[P]>
      : GetScalarType<T[P], AggregateGaImportRun[P]>
  }




  export type GaImportRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaImportRunWhereInput
    orderBy?: GaImportRunOrderByWithAggregationInput | GaImportRunOrderByWithAggregationInput[]
    by: GaImportRunScalarFieldEnum[] | GaImportRunScalarFieldEnum
    having?: GaImportRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaImportRunCountAggregateInputType | true
    _min?: GaImportRunMinAggregateInputType
    _max?: GaImportRunMaxAggregateInputType
  }

  export type GaImportRunGroupByOutputType = {
    id: string
    gaPropertyId: string
    dateStart: Date
    dateEnd: Date
    status: $Enums.ImportStatus
    errorMessage: string | null
    requestedByUserId: string
    createdAt: Date
    updatedAt: Date
    _count: GaImportRunCountAggregateOutputType | null
    _min: GaImportRunMinAggregateOutputType | null
    _max: GaImportRunMaxAggregateOutputType | null
  }

  type GetGaImportRunGroupByPayload<T extends GaImportRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaImportRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaImportRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaImportRunGroupByOutputType[P]>
            : GetScalarType<T[P], GaImportRunGroupByOutputType[P]>
        }
      >
    >


  export type GaImportRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    errorMessage?: boolean
    requestedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaImportRun"]>

  export type GaImportRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    errorMessage?: boolean
    requestedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaImportRun"]>

  export type GaImportRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    errorMessage?: boolean
    requestedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaImportRun"]>

  export type GaImportRunSelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    errorMessage?: boolean
    requestedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GaImportRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "dateStart" | "dateEnd" | "status" | "errorMessage" | "requestedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["gaImportRun"]>
  export type GaImportRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GaImportRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GaImportRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GaImportRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaImportRun"
    objects: {
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs>
      requestedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      dateStart: Date
      dateEnd: Date
      status: $Enums.ImportStatus
      errorMessage: string | null
      requestedByUserId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gaImportRun"]>
    composites: {}
  }

  type GaImportRunGetPayload<S extends boolean | null | undefined | GaImportRunDefaultArgs> = $Result.GetResult<Prisma.$GaImportRunPayload, S>

  type GaImportRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaImportRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaImportRunCountAggregateInputType | true
    }

  export interface GaImportRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaImportRun'], meta: { name: 'GaImportRun' } }
    /**
     * Find zero or one GaImportRun that matches the filter.
     * @param {GaImportRunFindUniqueArgs} args - Arguments to find a GaImportRun
     * @example
     * // Get one GaImportRun
     * const gaImportRun = await prisma.gaImportRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaImportRunFindUniqueArgs>(args: SelectSubset<T, GaImportRunFindUniqueArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaImportRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaImportRunFindUniqueOrThrowArgs} args - Arguments to find a GaImportRun
     * @example
     * // Get one GaImportRun
     * const gaImportRun = await prisma.gaImportRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaImportRunFindUniqueOrThrowArgs>(args: SelectSubset<T, GaImportRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaImportRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunFindFirstArgs} args - Arguments to find a GaImportRun
     * @example
     * // Get one GaImportRun
     * const gaImportRun = await prisma.gaImportRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaImportRunFindFirstArgs>(args?: SelectSubset<T, GaImportRunFindFirstArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaImportRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunFindFirstOrThrowArgs} args - Arguments to find a GaImportRun
     * @example
     * // Get one GaImportRun
     * const gaImportRun = await prisma.gaImportRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaImportRunFindFirstOrThrowArgs>(args?: SelectSubset<T, GaImportRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaImportRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaImportRuns
     * const gaImportRuns = await prisma.gaImportRun.findMany()
     * 
     * // Get first 10 GaImportRuns
     * const gaImportRuns = await prisma.gaImportRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaImportRunWithIdOnly = await prisma.gaImportRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaImportRunFindManyArgs>(args?: SelectSubset<T, GaImportRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaImportRun.
     * @param {GaImportRunCreateArgs} args - Arguments to create a GaImportRun.
     * @example
     * // Create one GaImportRun
     * const GaImportRun = await prisma.gaImportRun.create({
     *   data: {
     *     // ... data to create a GaImportRun
     *   }
     * })
     * 
     */
    create<T extends GaImportRunCreateArgs>(args: SelectSubset<T, GaImportRunCreateArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaImportRuns.
     * @param {GaImportRunCreateManyArgs} args - Arguments to create many GaImportRuns.
     * @example
     * // Create many GaImportRuns
     * const gaImportRun = await prisma.gaImportRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaImportRunCreateManyArgs>(args?: SelectSubset<T, GaImportRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaImportRuns and returns the data saved in the database.
     * @param {GaImportRunCreateManyAndReturnArgs} args - Arguments to create many GaImportRuns.
     * @example
     * // Create many GaImportRuns
     * const gaImportRun = await prisma.gaImportRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaImportRuns and only return the `id`
     * const gaImportRunWithIdOnly = await prisma.gaImportRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaImportRunCreateManyAndReturnArgs>(args?: SelectSubset<T, GaImportRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaImportRun.
     * @param {GaImportRunDeleteArgs} args - Arguments to delete one GaImportRun.
     * @example
     * // Delete one GaImportRun
     * const GaImportRun = await prisma.gaImportRun.delete({
     *   where: {
     *     // ... filter to delete one GaImportRun
     *   }
     * })
     * 
     */
    delete<T extends GaImportRunDeleteArgs>(args: SelectSubset<T, GaImportRunDeleteArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaImportRun.
     * @param {GaImportRunUpdateArgs} args - Arguments to update one GaImportRun.
     * @example
     * // Update one GaImportRun
     * const gaImportRun = await prisma.gaImportRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaImportRunUpdateArgs>(args: SelectSubset<T, GaImportRunUpdateArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaImportRuns.
     * @param {GaImportRunDeleteManyArgs} args - Arguments to filter GaImportRuns to delete.
     * @example
     * // Delete a few GaImportRuns
     * const { count } = await prisma.gaImportRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaImportRunDeleteManyArgs>(args?: SelectSubset<T, GaImportRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaImportRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaImportRuns
     * const gaImportRun = await prisma.gaImportRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaImportRunUpdateManyArgs>(args: SelectSubset<T, GaImportRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaImportRuns and returns the data updated in the database.
     * @param {GaImportRunUpdateManyAndReturnArgs} args - Arguments to update many GaImportRuns.
     * @example
     * // Update many GaImportRuns
     * const gaImportRun = await prisma.gaImportRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaImportRuns and only return the `id`
     * const gaImportRunWithIdOnly = await prisma.gaImportRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaImportRunUpdateManyAndReturnArgs>(args: SelectSubset<T, GaImportRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaImportRun.
     * @param {GaImportRunUpsertArgs} args - Arguments to update or create a GaImportRun.
     * @example
     * // Update or create a GaImportRun
     * const gaImportRun = await prisma.gaImportRun.upsert({
     *   create: {
     *     // ... data to create a GaImportRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaImportRun we want to update
     *   }
     * })
     */
    upsert<T extends GaImportRunUpsertArgs>(args: SelectSubset<T, GaImportRunUpsertArgs<ExtArgs>>): Prisma__GaImportRunClient<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaImportRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunCountArgs} args - Arguments to filter GaImportRuns to count.
     * @example
     * // Count the number of GaImportRuns
     * const count = await prisma.gaImportRun.count({
     *   where: {
     *     // ... the filter for the GaImportRuns we want to count
     *   }
     * })
    **/
    count<T extends GaImportRunCountArgs>(
      args?: Subset<T, GaImportRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaImportRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaImportRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaImportRunAggregateArgs>(args: Subset<T, GaImportRunAggregateArgs>): Prisma.PrismaPromise<GetGaImportRunAggregateType<T>>

    /**
     * Group by GaImportRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaImportRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaImportRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaImportRunGroupByArgs['orderBy'] }
        : { orderBy?: GaImportRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaImportRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaImportRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaImportRun model
   */
  readonly fields: GaImportRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaImportRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaImportRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaProperty<T extends GaPropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaPropertyDefaultArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requestedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaImportRun model
   */
  interface GaImportRunFieldRefs {
    readonly id: FieldRef<"GaImportRun", 'String'>
    readonly gaPropertyId: FieldRef<"GaImportRun", 'String'>
    readonly dateStart: FieldRef<"GaImportRun", 'DateTime'>
    readonly dateEnd: FieldRef<"GaImportRun", 'DateTime'>
    readonly status: FieldRef<"GaImportRun", 'ImportStatus'>
    readonly errorMessage: FieldRef<"GaImportRun", 'String'>
    readonly requestedByUserId: FieldRef<"GaImportRun", 'String'>
    readonly createdAt: FieldRef<"GaImportRun", 'DateTime'>
    readonly updatedAt: FieldRef<"GaImportRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaImportRun findUnique
   */
  export type GaImportRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter, which GaImportRun to fetch.
     */
    where: GaImportRunWhereUniqueInput
  }

  /**
   * GaImportRun findUniqueOrThrow
   */
  export type GaImportRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter, which GaImportRun to fetch.
     */
    where: GaImportRunWhereUniqueInput
  }

  /**
   * GaImportRun findFirst
   */
  export type GaImportRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter, which GaImportRun to fetch.
     */
    where?: GaImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaImportRuns to fetch.
     */
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaImportRuns.
     */
    cursor?: GaImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaImportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaImportRuns.
     */
    distinct?: GaImportRunScalarFieldEnum | GaImportRunScalarFieldEnum[]
  }

  /**
   * GaImportRun findFirstOrThrow
   */
  export type GaImportRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter, which GaImportRun to fetch.
     */
    where?: GaImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaImportRuns to fetch.
     */
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaImportRuns.
     */
    cursor?: GaImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaImportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaImportRuns.
     */
    distinct?: GaImportRunScalarFieldEnum | GaImportRunScalarFieldEnum[]
  }

  /**
   * GaImportRun findMany
   */
  export type GaImportRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter, which GaImportRuns to fetch.
     */
    where?: GaImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaImportRuns to fetch.
     */
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaImportRuns.
     */
    cursor?: GaImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaImportRuns.
     */
    skip?: number
    distinct?: GaImportRunScalarFieldEnum | GaImportRunScalarFieldEnum[]
  }

  /**
   * GaImportRun create
   */
  export type GaImportRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * The data needed to create a GaImportRun.
     */
    data: XOR<GaImportRunCreateInput, GaImportRunUncheckedCreateInput>
  }

  /**
   * GaImportRun createMany
   */
  export type GaImportRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaImportRuns.
     */
    data: GaImportRunCreateManyInput | GaImportRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaImportRun createManyAndReturn
   */
  export type GaImportRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * The data used to create many GaImportRuns.
     */
    data: GaImportRunCreateManyInput | GaImportRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaImportRun update
   */
  export type GaImportRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * The data needed to update a GaImportRun.
     */
    data: XOR<GaImportRunUpdateInput, GaImportRunUncheckedUpdateInput>
    /**
     * Choose, which GaImportRun to update.
     */
    where: GaImportRunWhereUniqueInput
  }

  /**
   * GaImportRun updateMany
   */
  export type GaImportRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaImportRuns.
     */
    data: XOR<GaImportRunUpdateManyMutationInput, GaImportRunUncheckedUpdateManyInput>
    /**
     * Filter which GaImportRuns to update
     */
    where?: GaImportRunWhereInput
    /**
     * Limit how many GaImportRuns to update.
     */
    limit?: number
  }

  /**
   * GaImportRun updateManyAndReturn
   */
  export type GaImportRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * The data used to update GaImportRuns.
     */
    data: XOR<GaImportRunUpdateManyMutationInput, GaImportRunUncheckedUpdateManyInput>
    /**
     * Filter which GaImportRuns to update
     */
    where?: GaImportRunWhereInput
    /**
     * Limit how many GaImportRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaImportRun upsert
   */
  export type GaImportRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * The filter to search for the GaImportRun to update in case it exists.
     */
    where: GaImportRunWhereUniqueInput
    /**
     * In case the GaImportRun found by the `where` argument doesn't exist, create a new GaImportRun with this data.
     */
    create: XOR<GaImportRunCreateInput, GaImportRunUncheckedCreateInput>
    /**
     * In case the GaImportRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaImportRunUpdateInput, GaImportRunUncheckedUpdateInput>
  }

  /**
   * GaImportRun delete
   */
  export type GaImportRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    /**
     * Filter which GaImportRun to delete.
     */
    where: GaImportRunWhereUniqueInput
  }

  /**
   * GaImportRun deleteMany
   */
  export type GaImportRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaImportRuns to delete
     */
    where?: GaImportRunWhereInput
    /**
     * Limit how many GaImportRuns to delete.
     */
    limit?: number
  }

  /**
   * GaImportRun without action
   */
  export type GaImportRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
  }


  /**
   * Model GaKpiDaily
   */

  export type AggregateGaKpiDaily = {
    _count: GaKpiDailyCountAggregateOutputType | null
    _avg: GaKpiDailyAvgAggregateOutputType | null
    _sum: GaKpiDailySumAggregateOutputType | null
    _min: GaKpiDailyMinAggregateOutputType | null
    _max: GaKpiDailyMaxAggregateOutputType | null
  }

  export type GaKpiDailyAvgAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaKpiDailySumAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaKpiDailyMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaKpiDailyMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaKpiDailyCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    date: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GaKpiDailyAvgAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaKpiDailySumAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaKpiDailyMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaKpiDailyMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaKpiDailyCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GaKpiDailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaKpiDaily to aggregate.
     */
    where?: GaKpiDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiDailies to fetch.
     */
    orderBy?: GaKpiDailyOrderByWithRelationInput | GaKpiDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaKpiDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaKpiDailies
    **/
    _count?: true | GaKpiDailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GaKpiDailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GaKpiDailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaKpiDailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaKpiDailyMaxAggregateInputType
  }

  export type GetGaKpiDailyAggregateType<T extends GaKpiDailyAggregateArgs> = {
        [P in keyof T & keyof AggregateGaKpiDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaKpiDaily[P]>
      : GetScalarType<T[P], AggregateGaKpiDaily[P]>
  }




  export type GaKpiDailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaKpiDailyWhereInput
    orderBy?: GaKpiDailyOrderByWithAggregationInput | GaKpiDailyOrderByWithAggregationInput[]
    by: GaKpiDailyScalarFieldEnum[] | GaKpiDailyScalarFieldEnum
    having?: GaKpiDailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaKpiDailyCountAggregateInputType | true
    _avg?: GaKpiDailyAvgAggregateInputType
    _sum?: GaKpiDailySumAggregateInputType
    _min?: GaKpiDailyMinAggregateInputType
    _max?: GaKpiDailyMaxAggregateInputType
  }

  export type GaKpiDailyGroupByOutputType = {
    id: string
    gaPropertyId: string
    date: Date
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: Date
    updatedAt: Date
    _count: GaKpiDailyCountAggregateOutputType | null
    _avg: GaKpiDailyAvgAggregateOutputType | null
    _sum: GaKpiDailySumAggregateOutputType | null
    _min: GaKpiDailyMinAggregateOutputType | null
    _max: GaKpiDailyMaxAggregateOutputType | null
  }

  type GetGaKpiDailyGroupByPayload<T extends GaKpiDailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaKpiDailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaKpiDailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaKpiDailyGroupByOutputType[P]>
            : GetScalarType<T[P], GaKpiDailyGroupByOutputType[P]>
        }
      >
    >


  export type GaKpiDailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiDaily"]>

  export type GaKpiDailySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiDaily"]>

  export type GaKpiDailySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiDaily"]>

  export type GaKpiDailySelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GaKpiDailyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "date" | "sessions" | "screenPageViewsPerSession" | "engagementRate" | "avgSessionDurationSec" | "goalCompletions" | "goalCompletionRate" | "createdAt" | "updatedAt", ExtArgs["result"]["gaKpiDaily"]>
  export type GaKpiDailyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaKpiDailyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaKpiDailyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }

  export type $GaKpiDailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaKpiDaily"
    objects: {
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      date: Date
      sessions: number
      screenPageViewsPerSession: number
      engagementRate: number
      avgSessionDurationSec: number
      goalCompletions: number
      goalCompletionRate: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gaKpiDaily"]>
    composites: {}
  }

  type GaKpiDailyGetPayload<S extends boolean | null | undefined | GaKpiDailyDefaultArgs> = $Result.GetResult<Prisma.$GaKpiDailyPayload, S>

  type GaKpiDailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaKpiDailyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaKpiDailyCountAggregateInputType | true
    }

  export interface GaKpiDailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaKpiDaily'], meta: { name: 'GaKpiDaily' } }
    /**
     * Find zero or one GaKpiDaily that matches the filter.
     * @param {GaKpiDailyFindUniqueArgs} args - Arguments to find a GaKpiDaily
     * @example
     * // Get one GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaKpiDailyFindUniqueArgs>(args: SelectSubset<T, GaKpiDailyFindUniqueArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaKpiDaily that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaKpiDailyFindUniqueOrThrowArgs} args - Arguments to find a GaKpiDaily
     * @example
     * // Get one GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaKpiDailyFindUniqueOrThrowArgs>(args: SelectSubset<T, GaKpiDailyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaKpiDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyFindFirstArgs} args - Arguments to find a GaKpiDaily
     * @example
     * // Get one GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaKpiDailyFindFirstArgs>(args?: SelectSubset<T, GaKpiDailyFindFirstArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaKpiDaily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyFindFirstOrThrowArgs} args - Arguments to find a GaKpiDaily
     * @example
     * // Get one GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaKpiDailyFindFirstOrThrowArgs>(args?: SelectSubset<T, GaKpiDailyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaKpiDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaKpiDailies
     * const gaKpiDailies = await prisma.gaKpiDaily.findMany()
     * 
     * // Get first 10 GaKpiDailies
     * const gaKpiDailies = await prisma.gaKpiDaily.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaKpiDailyWithIdOnly = await prisma.gaKpiDaily.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaKpiDailyFindManyArgs>(args?: SelectSubset<T, GaKpiDailyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaKpiDaily.
     * @param {GaKpiDailyCreateArgs} args - Arguments to create a GaKpiDaily.
     * @example
     * // Create one GaKpiDaily
     * const GaKpiDaily = await prisma.gaKpiDaily.create({
     *   data: {
     *     // ... data to create a GaKpiDaily
     *   }
     * })
     * 
     */
    create<T extends GaKpiDailyCreateArgs>(args: SelectSubset<T, GaKpiDailyCreateArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaKpiDailies.
     * @param {GaKpiDailyCreateManyArgs} args - Arguments to create many GaKpiDailies.
     * @example
     * // Create many GaKpiDailies
     * const gaKpiDaily = await prisma.gaKpiDaily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaKpiDailyCreateManyArgs>(args?: SelectSubset<T, GaKpiDailyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaKpiDailies and returns the data saved in the database.
     * @param {GaKpiDailyCreateManyAndReturnArgs} args - Arguments to create many GaKpiDailies.
     * @example
     * // Create many GaKpiDailies
     * const gaKpiDaily = await prisma.gaKpiDaily.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaKpiDailies and only return the `id`
     * const gaKpiDailyWithIdOnly = await prisma.gaKpiDaily.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaKpiDailyCreateManyAndReturnArgs>(args?: SelectSubset<T, GaKpiDailyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaKpiDaily.
     * @param {GaKpiDailyDeleteArgs} args - Arguments to delete one GaKpiDaily.
     * @example
     * // Delete one GaKpiDaily
     * const GaKpiDaily = await prisma.gaKpiDaily.delete({
     *   where: {
     *     // ... filter to delete one GaKpiDaily
     *   }
     * })
     * 
     */
    delete<T extends GaKpiDailyDeleteArgs>(args: SelectSubset<T, GaKpiDailyDeleteArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaKpiDaily.
     * @param {GaKpiDailyUpdateArgs} args - Arguments to update one GaKpiDaily.
     * @example
     * // Update one GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaKpiDailyUpdateArgs>(args: SelectSubset<T, GaKpiDailyUpdateArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaKpiDailies.
     * @param {GaKpiDailyDeleteManyArgs} args - Arguments to filter GaKpiDailies to delete.
     * @example
     * // Delete a few GaKpiDailies
     * const { count } = await prisma.gaKpiDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaKpiDailyDeleteManyArgs>(args?: SelectSubset<T, GaKpiDailyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaKpiDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaKpiDailies
     * const gaKpiDaily = await prisma.gaKpiDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaKpiDailyUpdateManyArgs>(args: SelectSubset<T, GaKpiDailyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaKpiDailies and returns the data updated in the database.
     * @param {GaKpiDailyUpdateManyAndReturnArgs} args - Arguments to update many GaKpiDailies.
     * @example
     * // Update many GaKpiDailies
     * const gaKpiDaily = await prisma.gaKpiDaily.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaKpiDailies and only return the `id`
     * const gaKpiDailyWithIdOnly = await prisma.gaKpiDaily.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaKpiDailyUpdateManyAndReturnArgs>(args: SelectSubset<T, GaKpiDailyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaKpiDaily.
     * @param {GaKpiDailyUpsertArgs} args - Arguments to update or create a GaKpiDaily.
     * @example
     * // Update or create a GaKpiDaily
     * const gaKpiDaily = await prisma.gaKpiDaily.upsert({
     *   create: {
     *     // ... data to create a GaKpiDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaKpiDaily we want to update
     *   }
     * })
     */
    upsert<T extends GaKpiDailyUpsertArgs>(args: SelectSubset<T, GaKpiDailyUpsertArgs<ExtArgs>>): Prisma__GaKpiDailyClient<$Result.GetResult<Prisma.$GaKpiDailyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaKpiDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyCountArgs} args - Arguments to filter GaKpiDailies to count.
     * @example
     * // Count the number of GaKpiDailies
     * const count = await prisma.gaKpiDaily.count({
     *   where: {
     *     // ... the filter for the GaKpiDailies we want to count
     *   }
     * })
    **/
    count<T extends GaKpiDailyCountArgs>(
      args?: Subset<T, GaKpiDailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaKpiDailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaKpiDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaKpiDailyAggregateArgs>(args: Subset<T, GaKpiDailyAggregateArgs>): Prisma.PrismaPromise<GetGaKpiDailyAggregateType<T>>

    /**
     * Group by GaKpiDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaKpiDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaKpiDailyGroupByArgs['orderBy'] }
        : { orderBy?: GaKpiDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaKpiDailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaKpiDailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaKpiDaily model
   */
  readonly fields: GaKpiDailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaKpiDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaKpiDailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaProperty<T extends GaPropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaPropertyDefaultArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaKpiDaily model
   */
  interface GaKpiDailyFieldRefs {
    readonly id: FieldRef<"GaKpiDaily", 'String'>
    readonly gaPropertyId: FieldRef<"GaKpiDaily", 'String'>
    readonly date: FieldRef<"GaKpiDaily", 'DateTime'>
    readonly sessions: FieldRef<"GaKpiDaily", 'Int'>
    readonly screenPageViewsPerSession: FieldRef<"GaKpiDaily", 'Float'>
    readonly engagementRate: FieldRef<"GaKpiDaily", 'Float'>
    readonly avgSessionDurationSec: FieldRef<"GaKpiDaily", 'Int'>
    readonly goalCompletions: FieldRef<"GaKpiDaily", 'Int'>
    readonly goalCompletionRate: FieldRef<"GaKpiDaily", 'Float'>
    readonly createdAt: FieldRef<"GaKpiDaily", 'DateTime'>
    readonly updatedAt: FieldRef<"GaKpiDaily", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaKpiDaily findUnique
   */
  export type GaKpiDailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiDaily to fetch.
     */
    where: GaKpiDailyWhereUniqueInput
  }

  /**
   * GaKpiDaily findUniqueOrThrow
   */
  export type GaKpiDailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiDaily to fetch.
     */
    where: GaKpiDailyWhereUniqueInput
  }

  /**
   * GaKpiDaily findFirst
   */
  export type GaKpiDailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiDaily to fetch.
     */
    where?: GaKpiDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiDailies to fetch.
     */
    orderBy?: GaKpiDailyOrderByWithRelationInput | GaKpiDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaKpiDailies.
     */
    cursor?: GaKpiDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaKpiDailies.
     */
    distinct?: GaKpiDailyScalarFieldEnum | GaKpiDailyScalarFieldEnum[]
  }

  /**
   * GaKpiDaily findFirstOrThrow
   */
  export type GaKpiDailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiDaily to fetch.
     */
    where?: GaKpiDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiDailies to fetch.
     */
    orderBy?: GaKpiDailyOrderByWithRelationInput | GaKpiDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaKpiDailies.
     */
    cursor?: GaKpiDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaKpiDailies.
     */
    distinct?: GaKpiDailyScalarFieldEnum | GaKpiDailyScalarFieldEnum[]
  }

  /**
   * GaKpiDaily findMany
   */
  export type GaKpiDailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiDailies to fetch.
     */
    where?: GaKpiDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiDailies to fetch.
     */
    orderBy?: GaKpiDailyOrderByWithRelationInput | GaKpiDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaKpiDailies.
     */
    cursor?: GaKpiDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiDailies.
     */
    skip?: number
    distinct?: GaKpiDailyScalarFieldEnum | GaKpiDailyScalarFieldEnum[]
  }

  /**
   * GaKpiDaily create
   */
  export type GaKpiDailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * The data needed to create a GaKpiDaily.
     */
    data: XOR<GaKpiDailyCreateInput, GaKpiDailyUncheckedCreateInput>
  }

  /**
   * GaKpiDaily createMany
   */
  export type GaKpiDailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaKpiDailies.
     */
    data: GaKpiDailyCreateManyInput | GaKpiDailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaKpiDaily createManyAndReturn
   */
  export type GaKpiDailyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * The data used to create many GaKpiDailies.
     */
    data: GaKpiDailyCreateManyInput | GaKpiDailyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaKpiDaily update
   */
  export type GaKpiDailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * The data needed to update a GaKpiDaily.
     */
    data: XOR<GaKpiDailyUpdateInput, GaKpiDailyUncheckedUpdateInput>
    /**
     * Choose, which GaKpiDaily to update.
     */
    where: GaKpiDailyWhereUniqueInput
  }

  /**
   * GaKpiDaily updateMany
   */
  export type GaKpiDailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaKpiDailies.
     */
    data: XOR<GaKpiDailyUpdateManyMutationInput, GaKpiDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaKpiDailies to update
     */
    where?: GaKpiDailyWhereInput
    /**
     * Limit how many GaKpiDailies to update.
     */
    limit?: number
  }

  /**
   * GaKpiDaily updateManyAndReturn
   */
  export type GaKpiDailyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * The data used to update GaKpiDailies.
     */
    data: XOR<GaKpiDailyUpdateManyMutationInput, GaKpiDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaKpiDailies to update
     */
    where?: GaKpiDailyWhereInput
    /**
     * Limit how many GaKpiDailies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaKpiDaily upsert
   */
  export type GaKpiDailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * The filter to search for the GaKpiDaily to update in case it exists.
     */
    where: GaKpiDailyWhereUniqueInput
    /**
     * In case the GaKpiDaily found by the `where` argument doesn't exist, create a new GaKpiDaily with this data.
     */
    create: XOR<GaKpiDailyCreateInput, GaKpiDailyUncheckedCreateInput>
    /**
     * In case the GaKpiDaily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaKpiDailyUpdateInput, GaKpiDailyUncheckedUpdateInput>
  }

  /**
   * GaKpiDaily delete
   */
  export type GaKpiDailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
    /**
     * Filter which GaKpiDaily to delete.
     */
    where: GaKpiDailyWhereUniqueInput
  }

  /**
   * GaKpiDaily deleteMany
   */
  export type GaKpiDailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaKpiDailies to delete
     */
    where?: GaKpiDailyWhereInput
    /**
     * Limit how many GaKpiDailies to delete.
     */
    limit?: number
  }

  /**
   * GaKpiDaily without action
   */
  export type GaKpiDailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiDaily
     */
    select?: GaKpiDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiDaily
     */
    omit?: GaKpiDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiDailyInclude<ExtArgs> | null
  }


  /**
   * Model GaKpiMonthly
   */

  export type AggregateGaKpiMonthly = {
    _count: GaKpiMonthlyCountAggregateOutputType | null
    _avg: GaKpiMonthlyAvgAggregateOutputType | null
    _sum: GaKpiMonthlySumAggregateOutputType | null
    _min: GaKpiMonthlyMinAggregateOutputType | null
    _max: GaKpiMonthlyMaxAggregateOutputType | null
  }

  export type GaKpiMonthlyAvgAggregateOutputType = {
    month: number | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaKpiMonthlySumAggregateOutputType = {
    month: number | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaKpiMonthlyMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    month: number | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaKpiMonthlyMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    month: number | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaKpiMonthlyCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GaKpiMonthlyAvgAggregateInputType = {
    month?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaKpiMonthlySumAggregateInputType = {
    month?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaKpiMonthlyMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    month?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaKpiMonthlyMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    month?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaKpiMonthlyCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    month?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GaKpiMonthlyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaKpiMonthly to aggregate.
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiMonthlies to fetch.
     */
    orderBy?: GaKpiMonthlyOrderByWithRelationInput | GaKpiMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaKpiMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiMonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaKpiMonthlies
    **/
    _count?: true | GaKpiMonthlyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GaKpiMonthlyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GaKpiMonthlySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaKpiMonthlyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaKpiMonthlyMaxAggregateInputType
  }

  export type GetGaKpiMonthlyAggregateType<T extends GaKpiMonthlyAggregateArgs> = {
        [P in keyof T & keyof AggregateGaKpiMonthly]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaKpiMonthly[P]>
      : GetScalarType<T[P], AggregateGaKpiMonthly[P]>
  }




  export type GaKpiMonthlyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaKpiMonthlyWhereInput
    orderBy?: GaKpiMonthlyOrderByWithAggregationInput | GaKpiMonthlyOrderByWithAggregationInput[]
    by: GaKpiMonthlyScalarFieldEnum[] | GaKpiMonthlyScalarFieldEnum
    having?: GaKpiMonthlyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaKpiMonthlyCountAggregateInputType | true
    _avg?: GaKpiMonthlyAvgAggregateInputType
    _sum?: GaKpiMonthlySumAggregateInputType
    _min?: GaKpiMonthlyMinAggregateInputType
    _max?: GaKpiMonthlyMaxAggregateInputType
  }

  export type GaKpiMonthlyGroupByOutputType = {
    id: string
    gaPropertyId: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: Date
    updatedAt: Date
    _count: GaKpiMonthlyCountAggregateOutputType | null
    _avg: GaKpiMonthlyAvgAggregateOutputType | null
    _sum: GaKpiMonthlySumAggregateOutputType | null
    _min: GaKpiMonthlyMinAggregateOutputType | null
    _max: GaKpiMonthlyMaxAggregateOutputType | null
  }

  type GetGaKpiMonthlyGroupByPayload<T extends GaKpiMonthlyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaKpiMonthlyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaKpiMonthlyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaKpiMonthlyGroupByOutputType[P]>
            : GetScalarType<T[P], GaKpiMonthlyGroupByOutputType[P]>
        }
      >
    >


  export type GaKpiMonthlySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    month?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiMonthly"]>

  export type GaKpiMonthlySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    month?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiMonthly"]>

  export type GaKpiMonthlySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    month?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaKpiMonthly"]>

  export type GaKpiMonthlySelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    month?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GaKpiMonthlyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "month" | "sessions" | "screenPageViewsPerSession" | "engagementRate" | "avgSessionDurationSec" | "goalCompletions" | "goalCompletionRate" | "createdAt" | "updatedAt", ExtArgs["result"]["gaKpiMonthly"]>
  export type GaKpiMonthlyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaKpiMonthlyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaKpiMonthlyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }

  export type $GaKpiMonthlyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaKpiMonthly"
    objects: {
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      month: number
      sessions: number
      screenPageViewsPerSession: number
      engagementRate: number
      avgSessionDurationSec: number
      goalCompletions: number
      goalCompletionRate: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gaKpiMonthly"]>
    composites: {}
  }

  type GaKpiMonthlyGetPayload<S extends boolean | null | undefined | GaKpiMonthlyDefaultArgs> = $Result.GetResult<Prisma.$GaKpiMonthlyPayload, S>

  type GaKpiMonthlyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaKpiMonthlyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaKpiMonthlyCountAggregateInputType | true
    }

  export interface GaKpiMonthlyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaKpiMonthly'], meta: { name: 'GaKpiMonthly' } }
    /**
     * Find zero or one GaKpiMonthly that matches the filter.
     * @param {GaKpiMonthlyFindUniqueArgs} args - Arguments to find a GaKpiMonthly
     * @example
     * // Get one GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaKpiMonthlyFindUniqueArgs>(args: SelectSubset<T, GaKpiMonthlyFindUniqueArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaKpiMonthly that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaKpiMonthlyFindUniqueOrThrowArgs} args - Arguments to find a GaKpiMonthly
     * @example
     * // Get one GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaKpiMonthlyFindUniqueOrThrowArgs>(args: SelectSubset<T, GaKpiMonthlyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaKpiMonthly that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyFindFirstArgs} args - Arguments to find a GaKpiMonthly
     * @example
     * // Get one GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaKpiMonthlyFindFirstArgs>(args?: SelectSubset<T, GaKpiMonthlyFindFirstArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaKpiMonthly that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyFindFirstOrThrowArgs} args - Arguments to find a GaKpiMonthly
     * @example
     * // Get one GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaKpiMonthlyFindFirstOrThrowArgs>(args?: SelectSubset<T, GaKpiMonthlyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaKpiMonthlies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaKpiMonthlies
     * const gaKpiMonthlies = await prisma.gaKpiMonthly.findMany()
     * 
     * // Get first 10 GaKpiMonthlies
     * const gaKpiMonthlies = await prisma.gaKpiMonthly.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaKpiMonthlyWithIdOnly = await prisma.gaKpiMonthly.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaKpiMonthlyFindManyArgs>(args?: SelectSubset<T, GaKpiMonthlyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaKpiMonthly.
     * @param {GaKpiMonthlyCreateArgs} args - Arguments to create a GaKpiMonthly.
     * @example
     * // Create one GaKpiMonthly
     * const GaKpiMonthly = await prisma.gaKpiMonthly.create({
     *   data: {
     *     // ... data to create a GaKpiMonthly
     *   }
     * })
     * 
     */
    create<T extends GaKpiMonthlyCreateArgs>(args: SelectSubset<T, GaKpiMonthlyCreateArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaKpiMonthlies.
     * @param {GaKpiMonthlyCreateManyArgs} args - Arguments to create many GaKpiMonthlies.
     * @example
     * // Create many GaKpiMonthlies
     * const gaKpiMonthly = await prisma.gaKpiMonthly.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaKpiMonthlyCreateManyArgs>(args?: SelectSubset<T, GaKpiMonthlyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaKpiMonthlies and returns the data saved in the database.
     * @param {GaKpiMonthlyCreateManyAndReturnArgs} args - Arguments to create many GaKpiMonthlies.
     * @example
     * // Create many GaKpiMonthlies
     * const gaKpiMonthly = await prisma.gaKpiMonthly.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaKpiMonthlies and only return the `id`
     * const gaKpiMonthlyWithIdOnly = await prisma.gaKpiMonthly.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaKpiMonthlyCreateManyAndReturnArgs>(args?: SelectSubset<T, GaKpiMonthlyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaKpiMonthly.
     * @param {GaKpiMonthlyDeleteArgs} args - Arguments to delete one GaKpiMonthly.
     * @example
     * // Delete one GaKpiMonthly
     * const GaKpiMonthly = await prisma.gaKpiMonthly.delete({
     *   where: {
     *     // ... filter to delete one GaKpiMonthly
     *   }
     * })
     * 
     */
    delete<T extends GaKpiMonthlyDeleteArgs>(args: SelectSubset<T, GaKpiMonthlyDeleteArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaKpiMonthly.
     * @param {GaKpiMonthlyUpdateArgs} args - Arguments to update one GaKpiMonthly.
     * @example
     * // Update one GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaKpiMonthlyUpdateArgs>(args: SelectSubset<T, GaKpiMonthlyUpdateArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaKpiMonthlies.
     * @param {GaKpiMonthlyDeleteManyArgs} args - Arguments to filter GaKpiMonthlies to delete.
     * @example
     * // Delete a few GaKpiMonthlies
     * const { count } = await prisma.gaKpiMonthly.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaKpiMonthlyDeleteManyArgs>(args?: SelectSubset<T, GaKpiMonthlyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaKpiMonthlies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaKpiMonthlies
     * const gaKpiMonthly = await prisma.gaKpiMonthly.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaKpiMonthlyUpdateManyArgs>(args: SelectSubset<T, GaKpiMonthlyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaKpiMonthlies and returns the data updated in the database.
     * @param {GaKpiMonthlyUpdateManyAndReturnArgs} args - Arguments to update many GaKpiMonthlies.
     * @example
     * // Update many GaKpiMonthlies
     * const gaKpiMonthly = await prisma.gaKpiMonthly.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaKpiMonthlies and only return the `id`
     * const gaKpiMonthlyWithIdOnly = await prisma.gaKpiMonthly.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaKpiMonthlyUpdateManyAndReturnArgs>(args: SelectSubset<T, GaKpiMonthlyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaKpiMonthly.
     * @param {GaKpiMonthlyUpsertArgs} args - Arguments to update or create a GaKpiMonthly.
     * @example
     * // Update or create a GaKpiMonthly
     * const gaKpiMonthly = await prisma.gaKpiMonthly.upsert({
     *   create: {
     *     // ... data to create a GaKpiMonthly
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaKpiMonthly we want to update
     *   }
     * })
     */
    upsert<T extends GaKpiMonthlyUpsertArgs>(args: SelectSubset<T, GaKpiMonthlyUpsertArgs<ExtArgs>>): Prisma__GaKpiMonthlyClient<$Result.GetResult<Prisma.$GaKpiMonthlyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaKpiMonthlies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyCountArgs} args - Arguments to filter GaKpiMonthlies to count.
     * @example
     * // Count the number of GaKpiMonthlies
     * const count = await prisma.gaKpiMonthly.count({
     *   where: {
     *     // ... the filter for the GaKpiMonthlies we want to count
     *   }
     * })
    **/
    count<T extends GaKpiMonthlyCountArgs>(
      args?: Subset<T, GaKpiMonthlyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaKpiMonthlyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaKpiMonthly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaKpiMonthlyAggregateArgs>(args: Subset<T, GaKpiMonthlyAggregateArgs>): Prisma.PrismaPromise<GetGaKpiMonthlyAggregateType<T>>

    /**
     * Group by GaKpiMonthly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaKpiMonthlyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaKpiMonthlyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaKpiMonthlyGroupByArgs['orderBy'] }
        : { orderBy?: GaKpiMonthlyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaKpiMonthlyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaKpiMonthlyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaKpiMonthly model
   */
  readonly fields: GaKpiMonthlyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaKpiMonthly.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaKpiMonthlyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaProperty<T extends GaPropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaPropertyDefaultArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaKpiMonthly model
   */
  interface GaKpiMonthlyFieldRefs {
    readonly id: FieldRef<"GaKpiMonthly", 'String'>
    readonly gaPropertyId: FieldRef<"GaKpiMonthly", 'String'>
    readonly month: FieldRef<"GaKpiMonthly", 'Int'>
    readonly sessions: FieldRef<"GaKpiMonthly", 'Int'>
    readonly screenPageViewsPerSession: FieldRef<"GaKpiMonthly", 'Float'>
    readonly engagementRate: FieldRef<"GaKpiMonthly", 'Float'>
    readonly avgSessionDurationSec: FieldRef<"GaKpiMonthly", 'Int'>
    readonly goalCompletions: FieldRef<"GaKpiMonthly", 'Int'>
    readonly goalCompletionRate: FieldRef<"GaKpiMonthly", 'Float'>
    readonly createdAt: FieldRef<"GaKpiMonthly", 'DateTime'>
    readonly updatedAt: FieldRef<"GaKpiMonthly", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaKpiMonthly findUnique
   */
  export type GaKpiMonthlyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiMonthly to fetch.
     */
    where: GaKpiMonthlyWhereUniqueInput
  }

  /**
   * GaKpiMonthly findUniqueOrThrow
   */
  export type GaKpiMonthlyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiMonthly to fetch.
     */
    where: GaKpiMonthlyWhereUniqueInput
  }

  /**
   * GaKpiMonthly findFirst
   */
  export type GaKpiMonthlyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiMonthly to fetch.
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiMonthlies to fetch.
     */
    orderBy?: GaKpiMonthlyOrderByWithRelationInput | GaKpiMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaKpiMonthlies.
     */
    cursor?: GaKpiMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiMonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaKpiMonthlies.
     */
    distinct?: GaKpiMonthlyScalarFieldEnum | GaKpiMonthlyScalarFieldEnum[]
  }

  /**
   * GaKpiMonthly findFirstOrThrow
   */
  export type GaKpiMonthlyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiMonthly to fetch.
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiMonthlies to fetch.
     */
    orderBy?: GaKpiMonthlyOrderByWithRelationInput | GaKpiMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaKpiMonthlies.
     */
    cursor?: GaKpiMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiMonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaKpiMonthlies.
     */
    distinct?: GaKpiMonthlyScalarFieldEnum | GaKpiMonthlyScalarFieldEnum[]
  }

  /**
   * GaKpiMonthly findMany
   */
  export type GaKpiMonthlyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter, which GaKpiMonthlies to fetch.
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaKpiMonthlies to fetch.
     */
    orderBy?: GaKpiMonthlyOrderByWithRelationInput | GaKpiMonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaKpiMonthlies.
     */
    cursor?: GaKpiMonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaKpiMonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaKpiMonthlies.
     */
    skip?: number
    distinct?: GaKpiMonthlyScalarFieldEnum | GaKpiMonthlyScalarFieldEnum[]
  }

  /**
   * GaKpiMonthly create
   */
  export type GaKpiMonthlyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * The data needed to create a GaKpiMonthly.
     */
    data: XOR<GaKpiMonthlyCreateInput, GaKpiMonthlyUncheckedCreateInput>
  }

  /**
   * GaKpiMonthly createMany
   */
  export type GaKpiMonthlyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaKpiMonthlies.
     */
    data: GaKpiMonthlyCreateManyInput | GaKpiMonthlyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaKpiMonthly createManyAndReturn
   */
  export type GaKpiMonthlyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * The data used to create many GaKpiMonthlies.
     */
    data: GaKpiMonthlyCreateManyInput | GaKpiMonthlyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaKpiMonthly update
   */
  export type GaKpiMonthlyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * The data needed to update a GaKpiMonthly.
     */
    data: XOR<GaKpiMonthlyUpdateInput, GaKpiMonthlyUncheckedUpdateInput>
    /**
     * Choose, which GaKpiMonthly to update.
     */
    where: GaKpiMonthlyWhereUniqueInput
  }

  /**
   * GaKpiMonthly updateMany
   */
  export type GaKpiMonthlyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaKpiMonthlies.
     */
    data: XOR<GaKpiMonthlyUpdateManyMutationInput, GaKpiMonthlyUncheckedUpdateManyInput>
    /**
     * Filter which GaKpiMonthlies to update
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * Limit how many GaKpiMonthlies to update.
     */
    limit?: number
  }

  /**
   * GaKpiMonthly updateManyAndReturn
   */
  export type GaKpiMonthlyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * The data used to update GaKpiMonthlies.
     */
    data: XOR<GaKpiMonthlyUpdateManyMutationInput, GaKpiMonthlyUncheckedUpdateManyInput>
    /**
     * Filter which GaKpiMonthlies to update
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * Limit how many GaKpiMonthlies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaKpiMonthly upsert
   */
  export type GaKpiMonthlyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * The filter to search for the GaKpiMonthly to update in case it exists.
     */
    where: GaKpiMonthlyWhereUniqueInput
    /**
     * In case the GaKpiMonthly found by the `where` argument doesn't exist, create a new GaKpiMonthly with this data.
     */
    create: XOR<GaKpiMonthlyCreateInput, GaKpiMonthlyUncheckedCreateInput>
    /**
     * In case the GaKpiMonthly was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaKpiMonthlyUpdateInput, GaKpiMonthlyUncheckedUpdateInput>
  }

  /**
   * GaKpiMonthly delete
   */
  export type GaKpiMonthlyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
    /**
     * Filter which GaKpiMonthly to delete.
     */
    where: GaKpiMonthlyWhereUniqueInput
  }

  /**
   * GaKpiMonthly deleteMany
   */
  export type GaKpiMonthlyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaKpiMonthlies to delete
     */
    where?: GaKpiMonthlyWhereInput
    /**
     * Limit how many GaKpiMonthlies to delete.
     */
    limit?: number
  }

  /**
   * GaKpiMonthly without action
   */
  export type GaKpiMonthlyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaKpiMonthly
     */
    select?: GaKpiMonthlySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaKpiMonthly
     */
    omit?: GaKpiMonthlyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaKpiMonthlyInclude<ExtArgs> | null
  }


  /**
   * Model GaChannelDaily
   */

  export type AggregateGaChannelDaily = {
    _count: GaChannelDailyCountAggregateOutputType | null
    _avg: GaChannelDailyAvgAggregateOutputType | null
    _sum: GaChannelDailySumAggregateOutputType | null
    _min: GaChannelDailyMinAggregateOutputType | null
    _max: GaChannelDailyMaxAggregateOutputType | null
  }

  export type GaChannelDailyAvgAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaChannelDailySumAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaChannelDailyMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    channelGroup: string | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaChannelDailyMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    channelGroup: string | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaChannelDailyCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    date: number
    channelGroup: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GaChannelDailyAvgAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaChannelDailySumAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaChannelDailyMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    channelGroup?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaChannelDailyMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    channelGroup?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaChannelDailyCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    channelGroup?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GaChannelDailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaChannelDaily to aggregate.
     */
    where?: GaChannelDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaChannelDailies to fetch.
     */
    orderBy?: GaChannelDailyOrderByWithRelationInput | GaChannelDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaChannelDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaChannelDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaChannelDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaChannelDailies
    **/
    _count?: true | GaChannelDailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GaChannelDailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GaChannelDailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaChannelDailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaChannelDailyMaxAggregateInputType
  }

  export type GetGaChannelDailyAggregateType<T extends GaChannelDailyAggregateArgs> = {
        [P in keyof T & keyof AggregateGaChannelDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaChannelDaily[P]>
      : GetScalarType<T[P], AggregateGaChannelDaily[P]>
  }




  export type GaChannelDailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaChannelDailyWhereInput
    orderBy?: GaChannelDailyOrderByWithAggregationInput | GaChannelDailyOrderByWithAggregationInput[]
    by: GaChannelDailyScalarFieldEnum[] | GaChannelDailyScalarFieldEnum
    having?: GaChannelDailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaChannelDailyCountAggregateInputType | true
    _avg?: GaChannelDailyAvgAggregateInputType
    _sum?: GaChannelDailySumAggregateInputType
    _min?: GaChannelDailyMinAggregateInputType
    _max?: GaChannelDailyMaxAggregateInputType
  }

  export type GaChannelDailyGroupByOutputType = {
    id: string
    gaPropertyId: string
    date: Date
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: Date
    updatedAt: Date
    _count: GaChannelDailyCountAggregateOutputType | null
    _avg: GaChannelDailyAvgAggregateOutputType | null
    _sum: GaChannelDailySumAggregateOutputType | null
    _min: GaChannelDailyMinAggregateOutputType | null
    _max: GaChannelDailyMaxAggregateOutputType | null
  }

  type GetGaChannelDailyGroupByPayload<T extends GaChannelDailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaChannelDailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaChannelDailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaChannelDailyGroupByOutputType[P]>
            : GetScalarType<T[P], GaChannelDailyGroupByOutputType[P]>
        }
      >
    >


  export type GaChannelDailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    channelGroup?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaChannelDaily"]>

  export type GaChannelDailySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    channelGroup?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaChannelDaily"]>

  export type GaChannelDailySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    channelGroup?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaChannelDaily"]>

  export type GaChannelDailySelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    channelGroup?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GaChannelDailyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "date" | "channelGroup" | "sessions" | "screenPageViewsPerSession" | "engagementRate" | "avgSessionDurationSec" | "goalCompletions" | "goalCompletionRate" | "createdAt" | "updatedAt", ExtArgs["result"]["gaChannelDaily"]>
  export type GaChannelDailyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaChannelDailyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaChannelDailyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }

  export type $GaChannelDailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaChannelDaily"
    objects: {
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      date: Date
      channelGroup: string
      sessions: number
      screenPageViewsPerSession: number
      engagementRate: number
      avgSessionDurationSec: number
      goalCompletions: number
      goalCompletionRate: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gaChannelDaily"]>
    composites: {}
  }

  type GaChannelDailyGetPayload<S extends boolean | null | undefined | GaChannelDailyDefaultArgs> = $Result.GetResult<Prisma.$GaChannelDailyPayload, S>

  type GaChannelDailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaChannelDailyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaChannelDailyCountAggregateInputType | true
    }

  export interface GaChannelDailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaChannelDaily'], meta: { name: 'GaChannelDaily' } }
    /**
     * Find zero or one GaChannelDaily that matches the filter.
     * @param {GaChannelDailyFindUniqueArgs} args - Arguments to find a GaChannelDaily
     * @example
     * // Get one GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaChannelDailyFindUniqueArgs>(args: SelectSubset<T, GaChannelDailyFindUniqueArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaChannelDaily that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaChannelDailyFindUniqueOrThrowArgs} args - Arguments to find a GaChannelDaily
     * @example
     * // Get one GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaChannelDailyFindUniqueOrThrowArgs>(args: SelectSubset<T, GaChannelDailyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaChannelDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyFindFirstArgs} args - Arguments to find a GaChannelDaily
     * @example
     * // Get one GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaChannelDailyFindFirstArgs>(args?: SelectSubset<T, GaChannelDailyFindFirstArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaChannelDaily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyFindFirstOrThrowArgs} args - Arguments to find a GaChannelDaily
     * @example
     * // Get one GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaChannelDailyFindFirstOrThrowArgs>(args?: SelectSubset<T, GaChannelDailyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaChannelDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaChannelDailies
     * const gaChannelDailies = await prisma.gaChannelDaily.findMany()
     * 
     * // Get first 10 GaChannelDailies
     * const gaChannelDailies = await prisma.gaChannelDaily.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaChannelDailyWithIdOnly = await prisma.gaChannelDaily.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaChannelDailyFindManyArgs>(args?: SelectSubset<T, GaChannelDailyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaChannelDaily.
     * @param {GaChannelDailyCreateArgs} args - Arguments to create a GaChannelDaily.
     * @example
     * // Create one GaChannelDaily
     * const GaChannelDaily = await prisma.gaChannelDaily.create({
     *   data: {
     *     // ... data to create a GaChannelDaily
     *   }
     * })
     * 
     */
    create<T extends GaChannelDailyCreateArgs>(args: SelectSubset<T, GaChannelDailyCreateArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaChannelDailies.
     * @param {GaChannelDailyCreateManyArgs} args - Arguments to create many GaChannelDailies.
     * @example
     * // Create many GaChannelDailies
     * const gaChannelDaily = await prisma.gaChannelDaily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaChannelDailyCreateManyArgs>(args?: SelectSubset<T, GaChannelDailyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaChannelDailies and returns the data saved in the database.
     * @param {GaChannelDailyCreateManyAndReturnArgs} args - Arguments to create many GaChannelDailies.
     * @example
     * // Create many GaChannelDailies
     * const gaChannelDaily = await prisma.gaChannelDaily.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaChannelDailies and only return the `id`
     * const gaChannelDailyWithIdOnly = await prisma.gaChannelDaily.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaChannelDailyCreateManyAndReturnArgs>(args?: SelectSubset<T, GaChannelDailyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaChannelDaily.
     * @param {GaChannelDailyDeleteArgs} args - Arguments to delete one GaChannelDaily.
     * @example
     * // Delete one GaChannelDaily
     * const GaChannelDaily = await prisma.gaChannelDaily.delete({
     *   where: {
     *     // ... filter to delete one GaChannelDaily
     *   }
     * })
     * 
     */
    delete<T extends GaChannelDailyDeleteArgs>(args: SelectSubset<T, GaChannelDailyDeleteArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaChannelDaily.
     * @param {GaChannelDailyUpdateArgs} args - Arguments to update one GaChannelDaily.
     * @example
     * // Update one GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaChannelDailyUpdateArgs>(args: SelectSubset<T, GaChannelDailyUpdateArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaChannelDailies.
     * @param {GaChannelDailyDeleteManyArgs} args - Arguments to filter GaChannelDailies to delete.
     * @example
     * // Delete a few GaChannelDailies
     * const { count } = await prisma.gaChannelDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaChannelDailyDeleteManyArgs>(args?: SelectSubset<T, GaChannelDailyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaChannelDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaChannelDailies
     * const gaChannelDaily = await prisma.gaChannelDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaChannelDailyUpdateManyArgs>(args: SelectSubset<T, GaChannelDailyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaChannelDailies and returns the data updated in the database.
     * @param {GaChannelDailyUpdateManyAndReturnArgs} args - Arguments to update many GaChannelDailies.
     * @example
     * // Update many GaChannelDailies
     * const gaChannelDaily = await prisma.gaChannelDaily.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaChannelDailies and only return the `id`
     * const gaChannelDailyWithIdOnly = await prisma.gaChannelDaily.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaChannelDailyUpdateManyAndReturnArgs>(args: SelectSubset<T, GaChannelDailyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaChannelDaily.
     * @param {GaChannelDailyUpsertArgs} args - Arguments to update or create a GaChannelDaily.
     * @example
     * // Update or create a GaChannelDaily
     * const gaChannelDaily = await prisma.gaChannelDaily.upsert({
     *   create: {
     *     // ... data to create a GaChannelDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaChannelDaily we want to update
     *   }
     * })
     */
    upsert<T extends GaChannelDailyUpsertArgs>(args: SelectSubset<T, GaChannelDailyUpsertArgs<ExtArgs>>): Prisma__GaChannelDailyClient<$Result.GetResult<Prisma.$GaChannelDailyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaChannelDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyCountArgs} args - Arguments to filter GaChannelDailies to count.
     * @example
     * // Count the number of GaChannelDailies
     * const count = await prisma.gaChannelDaily.count({
     *   where: {
     *     // ... the filter for the GaChannelDailies we want to count
     *   }
     * })
    **/
    count<T extends GaChannelDailyCountArgs>(
      args?: Subset<T, GaChannelDailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaChannelDailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaChannelDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaChannelDailyAggregateArgs>(args: Subset<T, GaChannelDailyAggregateArgs>): Prisma.PrismaPromise<GetGaChannelDailyAggregateType<T>>

    /**
     * Group by GaChannelDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaChannelDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaChannelDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaChannelDailyGroupByArgs['orderBy'] }
        : { orderBy?: GaChannelDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaChannelDailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaChannelDailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaChannelDaily model
   */
  readonly fields: GaChannelDailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaChannelDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaChannelDailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaProperty<T extends GaPropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaPropertyDefaultArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaChannelDaily model
   */
  interface GaChannelDailyFieldRefs {
    readonly id: FieldRef<"GaChannelDaily", 'String'>
    readonly gaPropertyId: FieldRef<"GaChannelDaily", 'String'>
    readonly date: FieldRef<"GaChannelDaily", 'DateTime'>
    readonly channelGroup: FieldRef<"GaChannelDaily", 'String'>
    readonly sessions: FieldRef<"GaChannelDaily", 'Int'>
    readonly screenPageViewsPerSession: FieldRef<"GaChannelDaily", 'Float'>
    readonly engagementRate: FieldRef<"GaChannelDaily", 'Float'>
    readonly avgSessionDurationSec: FieldRef<"GaChannelDaily", 'Int'>
    readonly goalCompletions: FieldRef<"GaChannelDaily", 'Int'>
    readonly goalCompletionRate: FieldRef<"GaChannelDaily", 'Float'>
    readonly createdAt: FieldRef<"GaChannelDaily", 'DateTime'>
    readonly updatedAt: FieldRef<"GaChannelDaily", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaChannelDaily findUnique
   */
  export type GaChannelDailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaChannelDaily to fetch.
     */
    where: GaChannelDailyWhereUniqueInput
  }

  /**
   * GaChannelDaily findUniqueOrThrow
   */
  export type GaChannelDailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaChannelDaily to fetch.
     */
    where: GaChannelDailyWhereUniqueInput
  }

  /**
   * GaChannelDaily findFirst
   */
  export type GaChannelDailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaChannelDaily to fetch.
     */
    where?: GaChannelDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaChannelDailies to fetch.
     */
    orderBy?: GaChannelDailyOrderByWithRelationInput | GaChannelDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaChannelDailies.
     */
    cursor?: GaChannelDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaChannelDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaChannelDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaChannelDailies.
     */
    distinct?: GaChannelDailyScalarFieldEnum | GaChannelDailyScalarFieldEnum[]
  }

  /**
   * GaChannelDaily findFirstOrThrow
   */
  export type GaChannelDailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaChannelDaily to fetch.
     */
    where?: GaChannelDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaChannelDailies to fetch.
     */
    orderBy?: GaChannelDailyOrderByWithRelationInput | GaChannelDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaChannelDailies.
     */
    cursor?: GaChannelDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaChannelDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaChannelDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaChannelDailies.
     */
    distinct?: GaChannelDailyScalarFieldEnum | GaChannelDailyScalarFieldEnum[]
  }

  /**
   * GaChannelDaily findMany
   */
  export type GaChannelDailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaChannelDailies to fetch.
     */
    where?: GaChannelDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaChannelDailies to fetch.
     */
    orderBy?: GaChannelDailyOrderByWithRelationInput | GaChannelDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaChannelDailies.
     */
    cursor?: GaChannelDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaChannelDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaChannelDailies.
     */
    skip?: number
    distinct?: GaChannelDailyScalarFieldEnum | GaChannelDailyScalarFieldEnum[]
  }

  /**
   * GaChannelDaily create
   */
  export type GaChannelDailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * The data needed to create a GaChannelDaily.
     */
    data: XOR<GaChannelDailyCreateInput, GaChannelDailyUncheckedCreateInput>
  }

  /**
   * GaChannelDaily createMany
   */
  export type GaChannelDailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaChannelDailies.
     */
    data: GaChannelDailyCreateManyInput | GaChannelDailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaChannelDaily createManyAndReturn
   */
  export type GaChannelDailyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * The data used to create many GaChannelDailies.
     */
    data: GaChannelDailyCreateManyInput | GaChannelDailyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaChannelDaily update
   */
  export type GaChannelDailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * The data needed to update a GaChannelDaily.
     */
    data: XOR<GaChannelDailyUpdateInput, GaChannelDailyUncheckedUpdateInput>
    /**
     * Choose, which GaChannelDaily to update.
     */
    where: GaChannelDailyWhereUniqueInput
  }

  /**
   * GaChannelDaily updateMany
   */
  export type GaChannelDailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaChannelDailies.
     */
    data: XOR<GaChannelDailyUpdateManyMutationInput, GaChannelDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaChannelDailies to update
     */
    where?: GaChannelDailyWhereInput
    /**
     * Limit how many GaChannelDailies to update.
     */
    limit?: number
  }

  /**
   * GaChannelDaily updateManyAndReturn
   */
  export type GaChannelDailyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * The data used to update GaChannelDailies.
     */
    data: XOR<GaChannelDailyUpdateManyMutationInput, GaChannelDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaChannelDailies to update
     */
    where?: GaChannelDailyWhereInput
    /**
     * Limit how many GaChannelDailies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaChannelDaily upsert
   */
  export type GaChannelDailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * The filter to search for the GaChannelDaily to update in case it exists.
     */
    where: GaChannelDailyWhereUniqueInput
    /**
     * In case the GaChannelDaily found by the `where` argument doesn't exist, create a new GaChannelDaily with this data.
     */
    create: XOR<GaChannelDailyCreateInput, GaChannelDailyUncheckedCreateInput>
    /**
     * In case the GaChannelDaily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaChannelDailyUpdateInput, GaChannelDailyUncheckedUpdateInput>
  }

  /**
   * GaChannelDaily delete
   */
  export type GaChannelDailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
    /**
     * Filter which GaChannelDaily to delete.
     */
    where: GaChannelDailyWhereUniqueInput
  }

  /**
   * GaChannelDaily deleteMany
   */
  export type GaChannelDailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaChannelDailies to delete
     */
    where?: GaChannelDailyWhereInput
    /**
     * Limit how many GaChannelDailies to delete.
     */
    limit?: number
  }

  /**
   * GaChannelDaily without action
   */
  export type GaChannelDailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaChannelDaily
     */
    select?: GaChannelDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaChannelDaily
     */
    omit?: GaChannelDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaChannelDailyInclude<ExtArgs> | null
  }


  /**
   * Model GaSourceDaily
   */

  export type AggregateGaSourceDaily = {
    _count: GaSourceDailyCountAggregateOutputType | null
    _avg: GaSourceDailyAvgAggregateOutputType | null
    _sum: GaSourceDailySumAggregateOutputType | null
    _min: GaSourceDailyMinAggregateOutputType | null
    _max: GaSourceDailyMaxAggregateOutputType | null
  }

  export type GaSourceDailyAvgAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaSourceDailySumAggregateOutputType = {
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
  }

  export type GaSourceDailyMinAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    trafficSource: string | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaSourceDailyMaxAggregateOutputType = {
    id: string | null
    gaPropertyId: string | null
    date: Date | null
    trafficSource: string | null
    sessions: number | null
    screenPageViewsPerSession: number | null
    engagementRate: number | null
    avgSessionDurationSec: number | null
    goalCompletions: number | null
    goalCompletionRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaSourceDailyCountAggregateOutputType = {
    id: number
    gaPropertyId: number
    date: number
    trafficSource: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GaSourceDailyAvgAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaSourceDailySumAggregateInputType = {
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
  }

  export type GaSourceDailyMinAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    trafficSource?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaSourceDailyMaxAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    trafficSource?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaSourceDailyCountAggregateInputType = {
    id?: true
    gaPropertyId?: true
    date?: true
    trafficSource?: true
    sessions?: true
    screenPageViewsPerSession?: true
    engagementRate?: true
    avgSessionDurationSec?: true
    goalCompletions?: true
    goalCompletionRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GaSourceDailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaSourceDaily to aggregate.
     */
    where?: GaSourceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaSourceDailies to fetch.
     */
    orderBy?: GaSourceDailyOrderByWithRelationInput | GaSourceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaSourceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaSourceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaSourceDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GaSourceDailies
    **/
    _count?: true | GaSourceDailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GaSourceDailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GaSourceDailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaSourceDailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaSourceDailyMaxAggregateInputType
  }

  export type GetGaSourceDailyAggregateType<T extends GaSourceDailyAggregateArgs> = {
        [P in keyof T & keyof AggregateGaSourceDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaSourceDaily[P]>
      : GetScalarType<T[P], AggregateGaSourceDaily[P]>
  }




  export type GaSourceDailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaSourceDailyWhereInput
    orderBy?: GaSourceDailyOrderByWithAggregationInput | GaSourceDailyOrderByWithAggregationInput[]
    by: GaSourceDailyScalarFieldEnum[] | GaSourceDailyScalarFieldEnum
    having?: GaSourceDailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaSourceDailyCountAggregateInputType | true
    _avg?: GaSourceDailyAvgAggregateInputType
    _sum?: GaSourceDailySumAggregateInputType
    _min?: GaSourceDailyMinAggregateInputType
    _max?: GaSourceDailyMaxAggregateInputType
  }

  export type GaSourceDailyGroupByOutputType = {
    id: string
    gaPropertyId: string
    date: Date
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt: Date
    updatedAt: Date
    _count: GaSourceDailyCountAggregateOutputType | null
    _avg: GaSourceDailyAvgAggregateOutputType | null
    _sum: GaSourceDailySumAggregateOutputType | null
    _min: GaSourceDailyMinAggregateOutputType | null
    _max: GaSourceDailyMaxAggregateOutputType | null
  }

  type GetGaSourceDailyGroupByPayload<T extends GaSourceDailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaSourceDailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaSourceDailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaSourceDailyGroupByOutputType[P]>
            : GetScalarType<T[P], GaSourceDailyGroupByOutputType[P]>
        }
      >
    >


  export type GaSourceDailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    trafficSource?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaSourceDaily"]>

  export type GaSourceDailySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    trafficSource?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaSourceDaily"]>

  export type GaSourceDailySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    trafficSource?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gaSourceDaily"]>

  export type GaSourceDailySelectScalar = {
    id?: boolean
    gaPropertyId?: boolean
    date?: boolean
    trafficSource?: boolean
    sessions?: boolean
    screenPageViewsPerSession?: boolean
    engagementRate?: boolean
    avgSessionDurationSec?: boolean
    goalCompletions?: boolean
    goalCompletionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GaSourceDailyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gaPropertyId" | "date" | "trafficSource" | "sessions" | "screenPageViewsPerSession" | "engagementRate" | "avgSessionDurationSec" | "goalCompletions" | "goalCompletionRate" | "createdAt" | "updatedAt", ExtArgs["result"]["gaSourceDaily"]>
  export type GaSourceDailyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaSourceDailyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }
  export type GaSourceDailyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaProperty?: boolean | GaPropertyDefaultArgs<ExtArgs>
  }

  export type $GaSourceDailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GaSourceDaily"
    objects: {
      gaProperty: Prisma.$GaPropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gaPropertyId: string
      date: Date
      trafficSource: string
      sessions: number
      screenPageViewsPerSession: number
      engagementRate: number
      avgSessionDurationSec: number
      goalCompletions: number
      goalCompletionRate: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gaSourceDaily"]>
    composites: {}
  }

  type GaSourceDailyGetPayload<S extends boolean | null | undefined | GaSourceDailyDefaultArgs> = $Result.GetResult<Prisma.$GaSourceDailyPayload, S>

  type GaSourceDailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaSourceDailyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaSourceDailyCountAggregateInputType | true
    }

  export interface GaSourceDailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GaSourceDaily'], meta: { name: 'GaSourceDaily' } }
    /**
     * Find zero or one GaSourceDaily that matches the filter.
     * @param {GaSourceDailyFindUniqueArgs} args - Arguments to find a GaSourceDaily
     * @example
     * // Get one GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaSourceDailyFindUniqueArgs>(args: SelectSubset<T, GaSourceDailyFindUniqueArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GaSourceDaily that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaSourceDailyFindUniqueOrThrowArgs} args - Arguments to find a GaSourceDaily
     * @example
     * // Get one GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaSourceDailyFindUniqueOrThrowArgs>(args: SelectSubset<T, GaSourceDailyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaSourceDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyFindFirstArgs} args - Arguments to find a GaSourceDaily
     * @example
     * // Get one GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaSourceDailyFindFirstArgs>(args?: SelectSubset<T, GaSourceDailyFindFirstArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GaSourceDaily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyFindFirstOrThrowArgs} args - Arguments to find a GaSourceDaily
     * @example
     * // Get one GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaSourceDailyFindFirstOrThrowArgs>(args?: SelectSubset<T, GaSourceDailyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GaSourceDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GaSourceDailies
     * const gaSourceDailies = await prisma.gaSourceDaily.findMany()
     * 
     * // Get first 10 GaSourceDailies
     * const gaSourceDailies = await prisma.gaSourceDaily.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaSourceDailyWithIdOnly = await prisma.gaSourceDaily.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaSourceDailyFindManyArgs>(args?: SelectSubset<T, GaSourceDailyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GaSourceDaily.
     * @param {GaSourceDailyCreateArgs} args - Arguments to create a GaSourceDaily.
     * @example
     * // Create one GaSourceDaily
     * const GaSourceDaily = await prisma.gaSourceDaily.create({
     *   data: {
     *     // ... data to create a GaSourceDaily
     *   }
     * })
     * 
     */
    create<T extends GaSourceDailyCreateArgs>(args: SelectSubset<T, GaSourceDailyCreateArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GaSourceDailies.
     * @param {GaSourceDailyCreateManyArgs} args - Arguments to create many GaSourceDailies.
     * @example
     * // Create many GaSourceDailies
     * const gaSourceDaily = await prisma.gaSourceDaily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaSourceDailyCreateManyArgs>(args?: SelectSubset<T, GaSourceDailyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GaSourceDailies and returns the data saved in the database.
     * @param {GaSourceDailyCreateManyAndReturnArgs} args - Arguments to create many GaSourceDailies.
     * @example
     * // Create many GaSourceDailies
     * const gaSourceDaily = await prisma.gaSourceDaily.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GaSourceDailies and only return the `id`
     * const gaSourceDailyWithIdOnly = await prisma.gaSourceDaily.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GaSourceDailyCreateManyAndReturnArgs>(args?: SelectSubset<T, GaSourceDailyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GaSourceDaily.
     * @param {GaSourceDailyDeleteArgs} args - Arguments to delete one GaSourceDaily.
     * @example
     * // Delete one GaSourceDaily
     * const GaSourceDaily = await prisma.gaSourceDaily.delete({
     *   where: {
     *     // ... filter to delete one GaSourceDaily
     *   }
     * })
     * 
     */
    delete<T extends GaSourceDailyDeleteArgs>(args: SelectSubset<T, GaSourceDailyDeleteArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GaSourceDaily.
     * @param {GaSourceDailyUpdateArgs} args - Arguments to update one GaSourceDaily.
     * @example
     * // Update one GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaSourceDailyUpdateArgs>(args: SelectSubset<T, GaSourceDailyUpdateArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GaSourceDailies.
     * @param {GaSourceDailyDeleteManyArgs} args - Arguments to filter GaSourceDailies to delete.
     * @example
     * // Delete a few GaSourceDailies
     * const { count } = await prisma.gaSourceDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaSourceDailyDeleteManyArgs>(args?: SelectSubset<T, GaSourceDailyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaSourceDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GaSourceDailies
     * const gaSourceDaily = await prisma.gaSourceDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaSourceDailyUpdateManyArgs>(args: SelectSubset<T, GaSourceDailyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GaSourceDailies and returns the data updated in the database.
     * @param {GaSourceDailyUpdateManyAndReturnArgs} args - Arguments to update many GaSourceDailies.
     * @example
     * // Update many GaSourceDailies
     * const gaSourceDaily = await prisma.gaSourceDaily.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GaSourceDailies and only return the `id`
     * const gaSourceDailyWithIdOnly = await prisma.gaSourceDaily.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GaSourceDailyUpdateManyAndReturnArgs>(args: SelectSubset<T, GaSourceDailyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GaSourceDaily.
     * @param {GaSourceDailyUpsertArgs} args - Arguments to update or create a GaSourceDaily.
     * @example
     * // Update or create a GaSourceDaily
     * const gaSourceDaily = await prisma.gaSourceDaily.upsert({
     *   create: {
     *     // ... data to create a GaSourceDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GaSourceDaily we want to update
     *   }
     * })
     */
    upsert<T extends GaSourceDailyUpsertArgs>(args: SelectSubset<T, GaSourceDailyUpsertArgs<ExtArgs>>): Prisma__GaSourceDailyClient<$Result.GetResult<Prisma.$GaSourceDailyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GaSourceDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyCountArgs} args - Arguments to filter GaSourceDailies to count.
     * @example
     * // Count the number of GaSourceDailies
     * const count = await prisma.gaSourceDaily.count({
     *   where: {
     *     // ... the filter for the GaSourceDailies we want to count
     *   }
     * })
    **/
    count<T extends GaSourceDailyCountArgs>(
      args?: Subset<T, GaSourceDailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaSourceDailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GaSourceDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaSourceDailyAggregateArgs>(args: Subset<T, GaSourceDailyAggregateArgs>): Prisma.PrismaPromise<GetGaSourceDailyAggregateType<T>>

    /**
     * Group by GaSourceDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaSourceDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaSourceDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaSourceDailyGroupByArgs['orderBy'] }
        : { orderBy?: GaSourceDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaSourceDailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaSourceDailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GaSourceDaily model
   */
  readonly fields: GaSourceDailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GaSourceDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaSourceDailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaProperty<T extends GaPropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaPropertyDefaultArgs<ExtArgs>>): Prisma__GaPropertyClient<$Result.GetResult<Prisma.$GaPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GaSourceDaily model
   */
  interface GaSourceDailyFieldRefs {
    readonly id: FieldRef<"GaSourceDaily", 'String'>
    readonly gaPropertyId: FieldRef<"GaSourceDaily", 'String'>
    readonly date: FieldRef<"GaSourceDaily", 'DateTime'>
    readonly trafficSource: FieldRef<"GaSourceDaily", 'String'>
    readonly sessions: FieldRef<"GaSourceDaily", 'Int'>
    readonly screenPageViewsPerSession: FieldRef<"GaSourceDaily", 'Float'>
    readonly engagementRate: FieldRef<"GaSourceDaily", 'Float'>
    readonly avgSessionDurationSec: FieldRef<"GaSourceDaily", 'Int'>
    readonly goalCompletions: FieldRef<"GaSourceDaily", 'Int'>
    readonly goalCompletionRate: FieldRef<"GaSourceDaily", 'Float'>
    readonly createdAt: FieldRef<"GaSourceDaily", 'DateTime'>
    readonly updatedAt: FieldRef<"GaSourceDaily", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GaSourceDaily findUnique
   */
  export type GaSourceDailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaSourceDaily to fetch.
     */
    where: GaSourceDailyWhereUniqueInput
  }

  /**
   * GaSourceDaily findUniqueOrThrow
   */
  export type GaSourceDailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaSourceDaily to fetch.
     */
    where: GaSourceDailyWhereUniqueInput
  }

  /**
   * GaSourceDaily findFirst
   */
  export type GaSourceDailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaSourceDaily to fetch.
     */
    where?: GaSourceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaSourceDailies to fetch.
     */
    orderBy?: GaSourceDailyOrderByWithRelationInput | GaSourceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaSourceDailies.
     */
    cursor?: GaSourceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaSourceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaSourceDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaSourceDailies.
     */
    distinct?: GaSourceDailyScalarFieldEnum | GaSourceDailyScalarFieldEnum[]
  }

  /**
   * GaSourceDaily findFirstOrThrow
   */
  export type GaSourceDailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaSourceDaily to fetch.
     */
    where?: GaSourceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaSourceDailies to fetch.
     */
    orderBy?: GaSourceDailyOrderByWithRelationInput | GaSourceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GaSourceDailies.
     */
    cursor?: GaSourceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaSourceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaSourceDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GaSourceDailies.
     */
    distinct?: GaSourceDailyScalarFieldEnum | GaSourceDailyScalarFieldEnum[]
  }

  /**
   * GaSourceDaily findMany
   */
  export type GaSourceDailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter, which GaSourceDailies to fetch.
     */
    where?: GaSourceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GaSourceDailies to fetch.
     */
    orderBy?: GaSourceDailyOrderByWithRelationInput | GaSourceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GaSourceDailies.
     */
    cursor?: GaSourceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GaSourceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GaSourceDailies.
     */
    skip?: number
    distinct?: GaSourceDailyScalarFieldEnum | GaSourceDailyScalarFieldEnum[]
  }

  /**
   * GaSourceDaily create
   */
  export type GaSourceDailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * The data needed to create a GaSourceDaily.
     */
    data: XOR<GaSourceDailyCreateInput, GaSourceDailyUncheckedCreateInput>
  }

  /**
   * GaSourceDaily createMany
   */
  export type GaSourceDailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GaSourceDailies.
     */
    data: GaSourceDailyCreateManyInput | GaSourceDailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GaSourceDaily createManyAndReturn
   */
  export type GaSourceDailyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * The data used to create many GaSourceDailies.
     */
    data: GaSourceDailyCreateManyInput | GaSourceDailyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaSourceDaily update
   */
  export type GaSourceDailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * The data needed to update a GaSourceDaily.
     */
    data: XOR<GaSourceDailyUpdateInput, GaSourceDailyUncheckedUpdateInput>
    /**
     * Choose, which GaSourceDaily to update.
     */
    where: GaSourceDailyWhereUniqueInput
  }

  /**
   * GaSourceDaily updateMany
   */
  export type GaSourceDailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GaSourceDailies.
     */
    data: XOR<GaSourceDailyUpdateManyMutationInput, GaSourceDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaSourceDailies to update
     */
    where?: GaSourceDailyWhereInput
    /**
     * Limit how many GaSourceDailies to update.
     */
    limit?: number
  }

  /**
   * GaSourceDaily updateManyAndReturn
   */
  export type GaSourceDailyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * The data used to update GaSourceDailies.
     */
    data: XOR<GaSourceDailyUpdateManyMutationInput, GaSourceDailyUncheckedUpdateManyInput>
    /**
     * Filter which GaSourceDailies to update
     */
    where?: GaSourceDailyWhereInput
    /**
     * Limit how many GaSourceDailies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GaSourceDaily upsert
   */
  export type GaSourceDailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * The filter to search for the GaSourceDaily to update in case it exists.
     */
    where: GaSourceDailyWhereUniqueInput
    /**
     * In case the GaSourceDaily found by the `where` argument doesn't exist, create a new GaSourceDaily with this data.
     */
    create: XOR<GaSourceDailyCreateInput, GaSourceDailyUncheckedCreateInput>
    /**
     * In case the GaSourceDaily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaSourceDailyUpdateInput, GaSourceDailyUncheckedUpdateInput>
  }

  /**
   * GaSourceDaily delete
   */
  export type GaSourceDailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
    /**
     * Filter which GaSourceDaily to delete.
     */
    where: GaSourceDailyWhereUniqueInput
  }

  /**
   * GaSourceDaily deleteMany
   */
  export type GaSourceDailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GaSourceDailies to delete
     */
    where?: GaSourceDailyWhereInput
    /**
     * Limit how many GaSourceDailies to delete.
     */
    limit?: number
  }

  /**
   * GaSourceDaily without action
   */
  export type GaSourceDailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaSourceDaily
     */
    select?: GaSourceDailySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaSourceDaily
     */
    omit?: GaSourceDailyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaSourceDailyInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    expires: Date | null
    sessionToken: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    expires: Date | null
    sessionToken: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    expires: number
    sessionToken: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    expires: Date
    sessionToken: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expires?: boolean
    sessionToken?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expires?: boolean
    sessionToken?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expires?: boolean
    sessionToken?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    expires?: boolean
    sessionToken?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "expires" | "sessionToken", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      expires: Date
      sessionToken: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly sessionToken: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    senderId: string | null
    recipientId: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    archived: boolean | null
    isThreadStart: boolean | null
    parentId: string | null
    threadId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    senderId: string | null
    recipientId: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    archived: boolean | null
    isThreadStart: boolean | null
    parentId: string | null
    threadId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    senderId: number
    recipientId: number
    isRead: number
    createdAt: number
    updatedAt: number
    archived: number
    isThreadStart: number
    parentId: number
    threadId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    recipientId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    isThreadStart?: true
    parentId?: true
    threadId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    recipientId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    isThreadStart?: true
    parentId?: true
    threadId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    recipientId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    archived?: true
    isThreadStart?: true
    parentId?: true
    threadId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string
    senderId: string
    recipientId: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    archived: boolean
    isThreadStart: boolean
    parentId: string | null
    threadId: string | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderId?: boolean
    recipientId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    isThreadStart?: boolean
    parentId?: boolean
    threadId?: boolean
    parent?: boolean | Message$parentArgs<ExtArgs>
    replies?: boolean | Message$repliesArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderId?: boolean
    recipientId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    isThreadStart?: boolean
    parentId?: boolean
    threadId?: boolean
    parent?: boolean | Message$parentArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderId?: boolean
    recipientId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    isThreadStart?: boolean
    parentId?: boolean
    threadId?: boolean
    parent?: boolean | Message$parentArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    senderId?: boolean
    recipientId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archived?: boolean
    isThreadStart?: boolean
    parentId?: boolean
    threadId?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "senderId" | "recipientId" | "isRead" | "createdAt" | "updatedAt" | "archived" | "isThreadStart" | "parentId" | "threadId", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Message$parentArgs<ExtArgs>
    replies?: boolean | Message$repliesArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Message$parentArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Message$parentArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      parent: Prisma.$MessagePayload<ExtArgs> | null
      replies: Prisma.$MessagePayload<ExtArgs>[]
      recipient: Prisma.$UserPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$MessageAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      senderId: string
      recipientId: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
      archived: boolean
      isThreadStart: boolean
      parentId: string | null
      threadId: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Message$parentArgs<ExtArgs> = {}>(args?: Subset<T, Message$parentArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Message$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Message$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Message$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly recipientId: FieldRef<"Message", 'String'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly archived: FieldRef<"Message", 'Boolean'>
    readonly isThreadStart: FieldRef<"Message", 'Boolean'>
    readonly parentId: FieldRef<"Message", 'String'>
    readonly threadId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.parent
   */
  export type Message$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Message.replies
   */
  export type Message$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message.attachments
   */
  export type Message$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    cursor?: MessageAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    content: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "content" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      content: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ParsedPieGraphData
   */

  export type AggregateParsedPieGraphData = {
    _count: ParsedPieGraphDataCountAggregateOutputType | null
    _avg: ParsedPieGraphDataAvgAggregateOutputType | null
    _sum: ParsedPieGraphDataSumAggregateOutputType | null
    _min: ParsedPieGraphDataMinAggregateOutputType | null
    _max: ParsedPieGraphDataMaxAggregateOutputType | null
  }

  export type ParsedPieGraphDataAvgAggregateOutputType = {
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    prevSessionsDiff: number | null
    prevConversionRateDiff: number | null
    prevConversionsDiff: number | null
    prevBouncesDiff: number | null
    yearSessionsDiff: number | null
    yearConversionRateDiff: number | null
    yearConversionsDiff: number | null
    yearBouncesDiff: number | null
  }

  export type ParsedPieGraphDataSumAggregateOutputType = {
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    prevSessionsDiff: number | null
    prevConversionRateDiff: number | null
    prevConversionsDiff: number | null
    prevBouncesDiff: number | null
    yearSessionsDiff: number | null
    yearConversionRateDiff: number | null
    yearConversionsDiff: number | null
    yearBouncesDiff: number | null
  }

  export type ParsedPieGraphDataMinAggregateOutputType = {
    id: string | null
    queryId: string | null
    channel: string | null
    source: string | null
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    prevSessionsDiff: number | null
    prevConversionRateDiff: number | null
    prevConversionsDiff: number | null
    prevBouncesDiff: number | null
    yearSessionsDiff: number | null
    yearConversionRateDiff: number | null
    yearConversionsDiff: number | null
    yearBouncesDiff: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParsedPieGraphDataMaxAggregateOutputType = {
    id: string | null
    queryId: string | null
    channel: string | null
    source: string | null
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    prevSessionsDiff: number | null
    prevConversionRateDiff: number | null
    prevConversionsDiff: number | null
    prevBouncesDiff: number | null
    yearSessionsDiff: number | null
    yearConversionRateDiff: number | null
    yearConversionsDiff: number | null
    yearBouncesDiff: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParsedPieGraphDataCountAggregateOutputType = {
    id: number
    queryId: number
    channel: number
    source: number
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParsedPieGraphDataAvgAggregateInputType = {
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    prevSessionsDiff?: true
    prevConversionRateDiff?: true
    prevConversionsDiff?: true
    prevBouncesDiff?: true
    yearSessionsDiff?: true
    yearConversionRateDiff?: true
    yearConversionsDiff?: true
    yearBouncesDiff?: true
  }

  export type ParsedPieGraphDataSumAggregateInputType = {
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    prevSessionsDiff?: true
    prevConversionRateDiff?: true
    prevConversionsDiff?: true
    prevBouncesDiff?: true
    yearSessionsDiff?: true
    yearConversionRateDiff?: true
    yearConversionsDiff?: true
    yearBouncesDiff?: true
  }

  export type ParsedPieGraphDataMinAggregateInputType = {
    id?: true
    queryId?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    prevSessionsDiff?: true
    prevConversionRateDiff?: true
    prevConversionsDiff?: true
    prevBouncesDiff?: true
    yearSessionsDiff?: true
    yearConversionRateDiff?: true
    yearConversionsDiff?: true
    yearBouncesDiff?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParsedPieGraphDataMaxAggregateInputType = {
    id?: true
    queryId?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    prevSessionsDiff?: true
    prevConversionRateDiff?: true
    prevConversionsDiff?: true
    prevBouncesDiff?: true
    yearSessionsDiff?: true
    yearConversionRateDiff?: true
    yearConversionsDiff?: true
    yearBouncesDiff?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParsedPieGraphDataCountAggregateInputType = {
    id?: true
    queryId?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    prevSessionsDiff?: true
    prevConversionRateDiff?: true
    prevConversionsDiff?: true
    prevBouncesDiff?: true
    yearSessionsDiff?: true
    yearConversionRateDiff?: true
    yearConversionsDiff?: true
    yearBouncesDiff?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParsedPieGraphDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedPieGraphData to aggregate.
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedPieGraphData to fetch.
     */
    orderBy?: ParsedPieGraphDataOrderByWithRelationInput | ParsedPieGraphDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParsedPieGraphDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedPieGraphData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedPieGraphData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParsedPieGraphData
    **/
    _count?: true | ParsedPieGraphDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParsedPieGraphDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParsedPieGraphDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParsedPieGraphDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParsedPieGraphDataMaxAggregateInputType
  }

  export type GetParsedPieGraphDataAggregateType<T extends ParsedPieGraphDataAggregateArgs> = {
        [P in keyof T & keyof AggregateParsedPieGraphData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsedPieGraphData[P]>
      : GetScalarType<T[P], AggregateParsedPieGraphData[P]>
  }




  export type ParsedPieGraphDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedPieGraphDataWhereInput
    orderBy?: ParsedPieGraphDataOrderByWithAggregationInput | ParsedPieGraphDataOrderByWithAggregationInput[]
    by: ParsedPieGraphDataScalarFieldEnum[] | ParsedPieGraphDataScalarFieldEnum
    having?: ParsedPieGraphDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParsedPieGraphDataCountAggregateInputType | true
    _avg?: ParsedPieGraphDataAvgAggregateInputType
    _sum?: ParsedPieGraphDataSumAggregateInputType
    _min?: ParsedPieGraphDataMinAggregateInputType
    _max?: ParsedPieGraphDataMaxAggregateInputType
  }

  export type ParsedPieGraphDataGroupByOutputType = {
    id: string
    queryId: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt: Date
    updatedAt: Date
    _count: ParsedPieGraphDataCountAggregateOutputType | null
    _avg: ParsedPieGraphDataAvgAggregateOutputType | null
    _sum: ParsedPieGraphDataSumAggregateOutputType | null
    _min: ParsedPieGraphDataMinAggregateOutputType | null
    _max: ParsedPieGraphDataMaxAggregateOutputType | null
  }

  type GetParsedPieGraphDataGroupByPayload<T extends ParsedPieGraphDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParsedPieGraphDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParsedPieGraphDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParsedPieGraphDataGroupByOutputType[P]>
            : GetScalarType<T[P], ParsedPieGraphDataGroupByOutputType[P]>
        }
      >
    >


  export type ParsedPieGraphDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    prevSessionsDiff?: boolean
    prevConversionRateDiff?: boolean
    prevConversionsDiff?: boolean
    prevBouncesDiff?: boolean
    yearSessionsDiff?: boolean
    yearConversionRateDiff?: boolean
    yearConversionsDiff?: boolean
    yearBouncesDiff?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedPieGraphData"]>

  export type ParsedPieGraphDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    prevSessionsDiff?: boolean
    prevConversionRateDiff?: boolean
    prevConversionsDiff?: boolean
    prevBouncesDiff?: boolean
    yearSessionsDiff?: boolean
    yearConversionRateDiff?: boolean
    yearConversionsDiff?: boolean
    yearBouncesDiff?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedPieGraphData"]>

  export type ParsedPieGraphDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    prevSessionsDiff?: boolean
    prevConversionRateDiff?: boolean
    prevConversionsDiff?: boolean
    prevBouncesDiff?: boolean
    yearSessionsDiff?: boolean
    yearConversionRateDiff?: boolean
    yearConversionsDiff?: boolean
    yearBouncesDiff?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedPieGraphData"]>

  export type ParsedPieGraphDataSelectScalar = {
    id?: boolean
    queryId?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    prevSessionsDiff?: boolean
    prevConversionRateDiff?: boolean
    prevConversionsDiff?: boolean
    prevBouncesDiff?: boolean
    yearSessionsDiff?: boolean
    yearConversionRateDiff?: boolean
    yearConversionsDiff?: boolean
    yearBouncesDiff?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParsedPieGraphDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queryId" | "channel" | "source" | "sessions" | "conversionRate" | "conversions" | "bounces" | "prevSessionsDiff" | "prevConversionRateDiff" | "prevConversionsDiff" | "prevBouncesDiff" | "yearSessionsDiff" | "yearConversionRateDiff" | "yearConversionsDiff" | "yearBouncesDiff" | "createdAt" | "updatedAt", ExtArgs["result"]["parsedPieGraphData"]>
  export type ParsedPieGraphDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedPieGraphDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedPieGraphDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }

  export type $ParsedPieGraphDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParsedPieGraphData"
    objects: {
      query: Prisma.$QueryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queryId: string
      channel: string
      source: string
      sessions: number
      conversionRate: number
      conversions: number
      bounces: number
      prevSessionsDiff: number
      prevConversionRateDiff: number
      prevConversionsDiff: number
      prevBouncesDiff: number
      yearSessionsDiff: number
      yearConversionRateDiff: number
      yearConversionsDiff: number
      yearBouncesDiff: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parsedPieGraphData"]>
    composites: {}
  }

  type ParsedPieGraphDataGetPayload<S extends boolean | null | undefined | ParsedPieGraphDataDefaultArgs> = $Result.GetResult<Prisma.$ParsedPieGraphDataPayload, S>

  type ParsedPieGraphDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParsedPieGraphDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParsedPieGraphDataCountAggregateInputType | true
    }

  export interface ParsedPieGraphDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParsedPieGraphData'], meta: { name: 'ParsedPieGraphData' } }
    /**
     * Find zero or one ParsedPieGraphData that matches the filter.
     * @param {ParsedPieGraphDataFindUniqueArgs} args - Arguments to find a ParsedPieGraphData
     * @example
     * // Get one ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParsedPieGraphDataFindUniqueArgs>(args: SelectSubset<T, ParsedPieGraphDataFindUniqueArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParsedPieGraphData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParsedPieGraphDataFindUniqueOrThrowArgs} args - Arguments to find a ParsedPieGraphData
     * @example
     * // Get one ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParsedPieGraphDataFindUniqueOrThrowArgs>(args: SelectSubset<T, ParsedPieGraphDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedPieGraphData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataFindFirstArgs} args - Arguments to find a ParsedPieGraphData
     * @example
     * // Get one ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParsedPieGraphDataFindFirstArgs>(args?: SelectSubset<T, ParsedPieGraphDataFindFirstArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedPieGraphData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataFindFirstOrThrowArgs} args - Arguments to find a ParsedPieGraphData
     * @example
     * // Get one ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParsedPieGraphDataFindFirstOrThrowArgs>(args?: SelectSubset<T, ParsedPieGraphDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParsedPieGraphData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findMany()
     * 
     * // Get first 10 ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsedPieGraphDataWithIdOnly = await prisma.parsedPieGraphData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParsedPieGraphDataFindManyArgs>(args?: SelectSubset<T, ParsedPieGraphDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParsedPieGraphData.
     * @param {ParsedPieGraphDataCreateArgs} args - Arguments to create a ParsedPieGraphData.
     * @example
     * // Create one ParsedPieGraphData
     * const ParsedPieGraphData = await prisma.parsedPieGraphData.create({
     *   data: {
     *     // ... data to create a ParsedPieGraphData
     *   }
     * })
     * 
     */
    create<T extends ParsedPieGraphDataCreateArgs>(args: SelectSubset<T, ParsedPieGraphDataCreateArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParsedPieGraphData.
     * @param {ParsedPieGraphDataCreateManyArgs} args - Arguments to create many ParsedPieGraphData.
     * @example
     * // Create many ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParsedPieGraphDataCreateManyArgs>(args?: SelectSubset<T, ParsedPieGraphDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParsedPieGraphData and returns the data saved in the database.
     * @param {ParsedPieGraphDataCreateManyAndReturnArgs} args - Arguments to create many ParsedPieGraphData.
     * @example
     * // Create many ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParsedPieGraphData and only return the `id`
     * const parsedPieGraphDataWithIdOnly = await prisma.parsedPieGraphData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParsedPieGraphDataCreateManyAndReturnArgs>(args?: SelectSubset<T, ParsedPieGraphDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParsedPieGraphData.
     * @param {ParsedPieGraphDataDeleteArgs} args - Arguments to delete one ParsedPieGraphData.
     * @example
     * // Delete one ParsedPieGraphData
     * const ParsedPieGraphData = await prisma.parsedPieGraphData.delete({
     *   where: {
     *     // ... filter to delete one ParsedPieGraphData
     *   }
     * })
     * 
     */
    delete<T extends ParsedPieGraphDataDeleteArgs>(args: SelectSubset<T, ParsedPieGraphDataDeleteArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParsedPieGraphData.
     * @param {ParsedPieGraphDataUpdateArgs} args - Arguments to update one ParsedPieGraphData.
     * @example
     * // Update one ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParsedPieGraphDataUpdateArgs>(args: SelectSubset<T, ParsedPieGraphDataUpdateArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParsedPieGraphData.
     * @param {ParsedPieGraphDataDeleteManyArgs} args - Arguments to filter ParsedPieGraphData to delete.
     * @example
     * // Delete a few ParsedPieGraphData
     * const { count } = await prisma.parsedPieGraphData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParsedPieGraphDataDeleteManyArgs>(args?: SelectSubset<T, ParsedPieGraphDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedPieGraphData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParsedPieGraphDataUpdateManyArgs>(args: SelectSubset<T, ParsedPieGraphDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedPieGraphData and returns the data updated in the database.
     * @param {ParsedPieGraphDataUpdateManyAndReturnArgs} args - Arguments to update many ParsedPieGraphData.
     * @example
     * // Update many ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParsedPieGraphData and only return the `id`
     * const parsedPieGraphDataWithIdOnly = await prisma.parsedPieGraphData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParsedPieGraphDataUpdateManyAndReturnArgs>(args: SelectSubset<T, ParsedPieGraphDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParsedPieGraphData.
     * @param {ParsedPieGraphDataUpsertArgs} args - Arguments to update or create a ParsedPieGraphData.
     * @example
     * // Update or create a ParsedPieGraphData
     * const parsedPieGraphData = await prisma.parsedPieGraphData.upsert({
     *   create: {
     *     // ... data to create a ParsedPieGraphData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParsedPieGraphData we want to update
     *   }
     * })
     */
    upsert<T extends ParsedPieGraphDataUpsertArgs>(args: SelectSubset<T, ParsedPieGraphDataUpsertArgs<ExtArgs>>): Prisma__ParsedPieGraphDataClient<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParsedPieGraphData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataCountArgs} args - Arguments to filter ParsedPieGraphData to count.
     * @example
     * // Count the number of ParsedPieGraphData
     * const count = await prisma.parsedPieGraphData.count({
     *   where: {
     *     // ... the filter for the ParsedPieGraphData we want to count
     *   }
     * })
    **/
    count<T extends ParsedPieGraphDataCountArgs>(
      args?: Subset<T, ParsedPieGraphDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParsedPieGraphDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParsedPieGraphData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParsedPieGraphDataAggregateArgs>(args: Subset<T, ParsedPieGraphDataAggregateArgs>): Prisma.PrismaPromise<GetParsedPieGraphDataAggregateType<T>>

    /**
     * Group by ParsedPieGraphData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedPieGraphDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParsedPieGraphDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParsedPieGraphDataGroupByArgs['orderBy'] }
        : { orderBy?: ParsedPieGraphDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParsedPieGraphDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsedPieGraphDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParsedPieGraphData model
   */
  readonly fields: ParsedPieGraphDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParsedPieGraphData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParsedPieGraphDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    query<T extends QueryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueryDefaultArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParsedPieGraphData model
   */
  interface ParsedPieGraphDataFieldRefs {
    readonly id: FieldRef<"ParsedPieGraphData", 'String'>
    readonly queryId: FieldRef<"ParsedPieGraphData", 'String'>
    readonly channel: FieldRef<"ParsedPieGraphData", 'String'>
    readonly source: FieldRef<"ParsedPieGraphData", 'String'>
    readonly sessions: FieldRef<"ParsedPieGraphData", 'Int'>
    readonly conversionRate: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly conversions: FieldRef<"ParsedPieGraphData", 'Int'>
    readonly bounces: FieldRef<"ParsedPieGraphData", 'Int'>
    readonly prevSessionsDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly prevConversionRateDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly prevConversionsDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly prevBouncesDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly yearSessionsDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly yearConversionRateDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly yearConversionsDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly yearBouncesDiff: FieldRef<"ParsedPieGraphData", 'Float'>
    readonly createdAt: FieldRef<"ParsedPieGraphData", 'DateTime'>
    readonly updatedAt: FieldRef<"ParsedPieGraphData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParsedPieGraphData findUnique
   */
  export type ParsedPieGraphDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedPieGraphData to fetch.
     */
    where: ParsedPieGraphDataWhereUniqueInput
  }

  /**
   * ParsedPieGraphData findUniqueOrThrow
   */
  export type ParsedPieGraphDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedPieGraphData to fetch.
     */
    where: ParsedPieGraphDataWhereUniqueInput
  }

  /**
   * ParsedPieGraphData findFirst
   */
  export type ParsedPieGraphDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedPieGraphData to fetch.
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedPieGraphData to fetch.
     */
    orderBy?: ParsedPieGraphDataOrderByWithRelationInput | ParsedPieGraphDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedPieGraphData.
     */
    cursor?: ParsedPieGraphDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedPieGraphData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedPieGraphData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedPieGraphData.
     */
    distinct?: ParsedPieGraphDataScalarFieldEnum | ParsedPieGraphDataScalarFieldEnum[]
  }

  /**
   * ParsedPieGraphData findFirstOrThrow
   */
  export type ParsedPieGraphDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedPieGraphData to fetch.
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedPieGraphData to fetch.
     */
    orderBy?: ParsedPieGraphDataOrderByWithRelationInput | ParsedPieGraphDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedPieGraphData.
     */
    cursor?: ParsedPieGraphDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedPieGraphData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedPieGraphData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedPieGraphData.
     */
    distinct?: ParsedPieGraphDataScalarFieldEnum | ParsedPieGraphDataScalarFieldEnum[]
  }

  /**
   * ParsedPieGraphData findMany
   */
  export type ParsedPieGraphDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedPieGraphData to fetch.
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedPieGraphData to fetch.
     */
    orderBy?: ParsedPieGraphDataOrderByWithRelationInput | ParsedPieGraphDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParsedPieGraphData.
     */
    cursor?: ParsedPieGraphDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedPieGraphData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedPieGraphData.
     */
    skip?: number
    distinct?: ParsedPieGraphDataScalarFieldEnum | ParsedPieGraphDataScalarFieldEnum[]
  }

  /**
   * ParsedPieGraphData create
   */
  export type ParsedPieGraphDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * The data needed to create a ParsedPieGraphData.
     */
    data: XOR<ParsedPieGraphDataCreateInput, ParsedPieGraphDataUncheckedCreateInput>
  }

  /**
   * ParsedPieGraphData createMany
   */
  export type ParsedPieGraphDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParsedPieGraphData.
     */
    data: ParsedPieGraphDataCreateManyInput | ParsedPieGraphDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParsedPieGraphData createManyAndReturn
   */
  export type ParsedPieGraphDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * The data used to create many ParsedPieGraphData.
     */
    data: ParsedPieGraphDataCreateManyInput | ParsedPieGraphDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedPieGraphData update
   */
  export type ParsedPieGraphDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * The data needed to update a ParsedPieGraphData.
     */
    data: XOR<ParsedPieGraphDataUpdateInput, ParsedPieGraphDataUncheckedUpdateInput>
    /**
     * Choose, which ParsedPieGraphData to update.
     */
    where: ParsedPieGraphDataWhereUniqueInput
  }

  /**
   * ParsedPieGraphData updateMany
   */
  export type ParsedPieGraphDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParsedPieGraphData.
     */
    data: XOR<ParsedPieGraphDataUpdateManyMutationInput, ParsedPieGraphDataUncheckedUpdateManyInput>
    /**
     * Filter which ParsedPieGraphData to update
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * Limit how many ParsedPieGraphData to update.
     */
    limit?: number
  }

  /**
   * ParsedPieGraphData updateManyAndReturn
   */
  export type ParsedPieGraphDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * The data used to update ParsedPieGraphData.
     */
    data: XOR<ParsedPieGraphDataUpdateManyMutationInput, ParsedPieGraphDataUncheckedUpdateManyInput>
    /**
     * Filter which ParsedPieGraphData to update
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * Limit how many ParsedPieGraphData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedPieGraphData upsert
   */
  export type ParsedPieGraphDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * The filter to search for the ParsedPieGraphData to update in case it exists.
     */
    where: ParsedPieGraphDataWhereUniqueInput
    /**
     * In case the ParsedPieGraphData found by the `where` argument doesn't exist, create a new ParsedPieGraphData with this data.
     */
    create: XOR<ParsedPieGraphDataCreateInput, ParsedPieGraphDataUncheckedCreateInput>
    /**
     * In case the ParsedPieGraphData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParsedPieGraphDataUpdateInput, ParsedPieGraphDataUncheckedUpdateInput>
  }

  /**
   * ParsedPieGraphData delete
   */
  export type ParsedPieGraphDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    /**
     * Filter which ParsedPieGraphData to delete.
     */
    where: ParsedPieGraphDataWhereUniqueInput
  }

  /**
   * ParsedPieGraphData deleteMany
   */
  export type ParsedPieGraphDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedPieGraphData to delete
     */
    where?: ParsedPieGraphDataWhereInput
    /**
     * Limit how many ParsedPieGraphData to delete.
     */
    limit?: number
  }

  /**
   * ParsedPieGraphData without action
   */
  export type ParsedPieGraphDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
  }


  /**
   * Model ParsedQueryData
   */

  export type AggregateParsedQueryData = {
    _count: ParsedQueryDataCountAggregateOutputType | null
    _avg: ParsedQueryDataAvgAggregateOutputType | null
    _sum: ParsedQueryDataSumAggregateOutputType | null
    _min: ParsedQueryDataMinAggregateOutputType | null
    _max: ParsedQueryDataMaxAggregateOutputType | null
  }

  export type ParsedQueryDataAvgAggregateOutputType = {
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    bounceRate: number | null
    engagedSessions: number | null
    newUsers: number | null
  }

  export type ParsedQueryDataSumAggregateOutputType = {
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    bounceRate: number | null
    engagedSessions: number | null
    newUsers: number | null
  }

  export type ParsedQueryDataMinAggregateOutputType = {
    id: string | null
    queryId: string | null
    date: Date | null
    channel: string | null
    source: string | null
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    createdAt: Date | null
    bounceRate: number | null
    engagedSessions: number | null
    newUsers: number | null
  }

  export type ParsedQueryDataMaxAggregateOutputType = {
    id: string | null
    queryId: string | null
    date: Date | null
    channel: string | null
    source: string | null
    sessions: number | null
    conversionRate: number | null
    conversions: number | null
    bounces: number | null
    createdAt: Date | null
    bounceRate: number | null
    engagedSessions: number | null
    newUsers: number | null
  }

  export type ParsedQueryDataCountAggregateOutputType = {
    id: number
    queryId: number
    date: number
    channel: number
    source: number
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt: number
    bounceRate: number
    engagedSessions: number
    newUsers: number
    _all: number
  }


  export type ParsedQueryDataAvgAggregateInputType = {
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    bounceRate?: true
    engagedSessions?: true
    newUsers?: true
  }

  export type ParsedQueryDataSumAggregateInputType = {
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    bounceRate?: true
    engagedSessions?: true
    newUsers?: true
  }

  export type ParsedQueryDataMinAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    createdAt?: true
    bounceRate?: true
    engagedSessions?: true
    newUsers?: true
  }

  export type ParsedQueryDataMaxAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    createdAt?: true
    bounceRate?: true
    engagedSessions?: true
    newUsers?: true
  }

  export type ParsedQueryDataCountAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    channel?: true
    source?: true
    sessions?: true
    conversionRate?: true
    conversions?: true
    bounces?: true
    createdAt?: true
    bounceRate?: true
    engagedSessions?: true
    newUsers?: true
    _all?: true
  }

  export type ParsedQueryDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedQueryData to aggregate.
     */
    where?: ParsedQueryDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQueryData to fetch.
     */
    orderBy?: ParsedQueryDataOrderByWithRelationInput | ParsedQueryDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParsedQueryDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQueryData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQueryData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParsedQueryData
    **/
    _count?: true | ParsedQueryDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParsedQueryDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParsedQueryDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParsedQueryDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParsedQueryDataMaxAggregateInputType
  }

  export type GetParsedQueryDataAggregateType<T extends ParsedQueryDataAggregateArgs> = {
        [P in keyof T & keyof AggregateParsedQueryData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsedQueryData[P]>
      : GetScalarType<T[P], AggregateParsedQueryData[P]>
  }




  export type ParsedQueryDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedQueryDataWhereInput
    orderBy?: ParsedQueryDataOrderByWithAggregationInput | ParsedQueryDataOrderByWithAggregationInput[]
    by: ParsedQueryDataScalarFieldEnum[] | ParsedQueryDataScalarFieldEnum
    having?: ParsedQueryDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParsedQueryDataCountAggregateInputType | true
    _avg?: ParsedQueryDataAvgAggregateInputType
    _sum?: ParsedQueryDataSumAggregateInputType
    _min?: ParsedQueryDataMinAggregateInputType
    _max?: ParsedQueryDataMaxAggregateInputType
  }

  export type ParsedQueryDataGroupByOutputType = {
    id: string
    queryId: string
    date: Date
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt: Date
    bounceRate: number | null
    engagedSessions: number | null
    newUsers: number | null
    _count: ParsedQueryDataCountAggregateOutputType | null
    _avg: ParsedQueryDataAvgAggregateOutputType | null
    _sum: ParsedQueryDataSumAggregateOutputType | null
    _min: ParsedQueryDataMinAggregateOutputType | null
    _max: ParsedQueryDataMaxAggregateOutputType | null
  }

  type GetParsedQueryDataGroupByPayload<T extends ParsedQueryDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParsedQueryDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParsedQueryDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParsedQueryDataGroupByOutputType[P]>
            : GetScalarType<T[P], ParsedQueryDataGroupByOutputType[P]>
        }
      >
    >


  export type ParsedQueryDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    createdAt?: boolean
    bounceRate?: boolean
    engagedSessions?: boolean
    newUsers?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQueryData"]>

  export type ParsedQueryDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    createdAt?: boolean
    bounceRate?: boolean
    engagedSessions?: boolean
    newUsers?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQueryData"]>

  export type ParsedQueryDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    createdAt?: boolean
    bounceRate?: boolean
    engagedSessions?: boolean
    newUsers?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQueryData"]>

  export type ParsedQueryDataSelectScalar = {
    id?: boolean
    queryId?: boolean
    date?: boolean
    channel?: boolean
    source?: boolean
    sessions?: boolean
    conversionRate?: boolean
    conversions?: boolean
    bounces?: boolean
    createdAt?: boolean
    bounceRate?: boolean
    engagedSessions?: boolean
    newUsers?: boolean
  }

  export type ParsedQueryDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queryId" | "date" | "channel" | "source" | "sessions" | "conversionRate" | "conversions" | "bounces" | "createdAt" | "bounceRate" | "engagedSessions" | "newUsers", ExtArgs["result"]["parsedQueryData"]>
  export type ParsedQueryDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedQueryDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedQueryDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }

  export type $ParsedQueryDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParsedQueryData"
    objects: {
      query: Prisma.$QueryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queryId: string
      date: Date
      channel: string
      source: string
      sessions: number
      conversionRate: number
      conversions: number
      bounces: number
      createdAt: Date
      bounceRate: number | null
      engagedSessions: number | null
      newUsers: number | null
    }, ExtArgs["result"]["parsedQueryData"]>
    composites: {}
  }

  type ParsedQueryDataGetPayload<S extends boolean | null | undefined | ParsedQueryDataDefaultArgs> = $Result.GetResult<Prisma.$ParsedQueryDataPayload, S>

  type ParsedQueryDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParsedQueryDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParsedQueryDataCountAggregateInputType | true
    }

  export interface ParsedQueryDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParsedQueryData'], meta: { name: 'ParsedQueryData' } }
    /**
     * Find zero or one ParsedQueryData that matches the filter.
     * @param {ParsedQueryDataFindUniqueArgs} args - Arguments to find a ParsedQueryData
     * @example
     * // Get one ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParsedQueryDataFindUniqueArgs>(args: SelectSubset<T, ParsedQueryDataFindUniqueArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParsedQueryData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParsedQueryDataFindUniqueOrThrowArgs} args - Arguments to find a ParsedQueryData
     * @example
     * // Get one ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParsedQueryDataFindUniqueOrThrowArgs>(args: SelectSubset<T, ParsedQueryDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedQueryData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataFindFirstArgs} args - Arguments to find a ParsedQueryData
     * @example
     * // Get one ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParsedQueryDataFindFirstArgs>(args?: SelectSubset<T, ParsedQueryDataFindFirstArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedQueryData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataFindFirstOrThrowArgs} args - Arguments to find a ParsedQueryData
     * @example
     * // Get one ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParsedQueryDataFindFirstOrThrowArgs>(args?: SelectSubset<T, ParsedQueryDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParsedQueryData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findMany()
     * 
     * // Get first 10 ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsedQueryDataWithIdOnly = await prisma.parsedQueryData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParsedQueryDataFindManyArgs>(args?: SelectSubset<T, ParsedQueryDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParsedQueryData.
     * @param {ParsedQueryDataCreateArgs} args - Arguments to create a ParsedQueryData.
     * @example
     * // Create one ParsedQueryData
     * const ParsedQueryData = await prisma.parsedQueryData.create({
     *   data: {
     *     // ... data to create a ParsedQueryData
     *   }
     * })
     * 
     */
    create<T extends ParsedQueryDataCreateArgs>(args: SelectSubset<T, ParsedQueryDataCreateArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParsedQueryData.
     * @param {ParsedQueryDataCreateManyArgs} args - Arguments to create many ParsedQueryData.
     * @example
     * // Create many ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParsedQueryDataCreateManyArgs>(args?: SelectSubset<T, ParsedQueryDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParsedQueryData and returns the data saved in the database.
     * @param {ParsedQueryDataCreateManyAndReturnArgs} args - Arguments to create many ParsedQueryData.
     * @example
     * // Create many ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParsedQueryData and only return the `id`
     * const parsedQueryDataWithIdOnly = await prisma.parsedQueryData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParsedQueryDataCreateManyAndReturnArgs>(args?: SelectSubset<T, ParsedQueryDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParsedQueryData.
     * @param {ParsedQueryDataDeleteArgs} args - Arguments to delete one ParsedQueryData.
     * @example
     * // Delete one ParsedQueryData
     * const ParsedQueryData = await prisma.parsedQueryData.delete({
     *   where: {
     *     // ... filter to delete one ParsedQueryData
     *   }
     * })
     * 
     */
    delete<T extends ParsedQueryDataDeleteArgs>(args: SelectSubset<T, ParsedQueryDataDeleteArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParsedQueryData.
     * @param {ParsedQueryDataUpdateArgs} args - Arguments to update one ParsedQueryData.
     * @example
     * // Update one ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParsedQueryDataUpdateArgs>(args: SelectSubset<T, ParsedQueryDataUpdateArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParsedQueryData.
     * @param {ParsedQueryDataDeleteManyArgs} args - Arguments to filter ParsedQueryData to delete.
     * @example
     * // Delete a few ParsedQueryData
     * const { count } = await prisma.parsedQueryData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParsedQueryDataDeleteManyArgs>(args?: SelectSubset<T, ParsedQueryDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedQueryData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParsedQueryDataUpdateManyArgs>(args: SelectSubset<T, ParsedQueryDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedQueryData and returns the data updated in the database.
     * @param {ParsedQueryDataUpdateManyAndReturnArgs} args - Arguments to update many ParsedQueryData.
     * @example
     * // Update many ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParsedQueryData and only return the `id`
     * const parsedQueryDataWithIdOnly = await prisma.parsedQueryData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParsedQueryDataUpdateManyAndReturnArgs>(args: SelectSubset<T, ParsedQueryDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParsedQueryData.
     * @param {ParsedQueryDataUpsertArgs} args - Arguments to update or create a ParsedQueryData.
     * @example
     * // Update or create a ParsedQueryData
     * const parsedQueryData = await prisma.parsedQueryData.upsert({
     *   create: {
     *     // ... data to create a ParsedQueryData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParsedQueryData we want to update
     *   }
     * })
     */
    upsert<T extends ParsedQueryDataUpsertArgs>(args: SelectSubset<T, ParsedQueryDataUpsertArgs<ExtArgs>>): Prisma__ParsedQueryDataClient<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParsedQueryData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataCountArgs} args - Arguments to filter ParsedQueryData to count.
     * @example
     * // Count the number of ParsedQueryData
     * const count = await prisma.parsedQueryData.count({
     *   where: {
     *     // ... the filter for the ParsedQueryData we want to count
     *   }
     * })
    **/
    count<T extends ParsedQueryDataCountArgs>(
      args?: Subset<T, ParsedQueryDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParsedQueryDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParsedQueryData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParsedQueryDataAggregateArgs>(args: Subset<T, ParsedQueryDataAggregateArgs>): Prisma.PrismaPromise<GetParsedQueryDataAggregateType<T>>

    /**
     * Group by ParsedQueryData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQueryDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParsedQueryDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParsedQueryDataGroupByArgs['orderBy'] }
        : { orderBy?: ParsedQueryDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParsedQueryDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsedQueryDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParsedQueryData model
   */
  readonly fields: ParsedQueryDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParsedQueryData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParsedQueryDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    query<T extends QueryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueryDefaultArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParsedQueryData model
   */
  interface ParsedQueryDataFieldRefs {
    readonly id: FieldRef<"ParsedQueryData", 'String'>
    readonly queryId: FieldRef<"ParsedQueryData", 'String'>
    readonly date: FieldRef<"ParsedQueryData", 'DateTime'>
    readonly channel: FieldRef<"ParsedQueryData", 'String'>
    readonly source: FieldRef<"ParsedQueryData", 'String'>
    readonly sessions: FieldRef<"ParsedQueryData", 'Int'>
    readonly conversionRate: FieldRef<"ParsedQueryData", 'Float'>
    readonly conversions: FieldRef<"ParsedQueryData", 'Int'>
    readonly bounces: FieldRef<"ParsedQueryData", 'Int'>
    readonly createdAt: FieldRef<"ParsedQueryData", 'DateTime'>
    readonly bounceRate: FieldRef<"ParsedQueryData", 'Float'>
    readonly engagedSessions: FieldRef<"ParsedQueryData", 'Int'>
    readonly newUsers: FieldRef<"ParsedQueryData", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ParsedQueryData findUnique
   */
  export type ParsedQueryDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQueryData to fetch.
     */
    where: ParsedQueryDataWhereUniqueInput
  }

  /**
   * ParsedQueryData findUniqueOrThrow
   */
  export type ParsedQueryDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQueryData to fetch.
     */
    where: ParsedQueryDataWhereUniqueInput
  }

  /**
   * ParsedQueryData findFirst
   */
  export type ParsedQueryDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQueryData to fetch.
     */
    where?: ParsedQueryDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQueryData to fetch.
     */
    orderBy?: ParsedQueryDataOrderByWithRelationInput | ParsedQueryDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedQueryData.
     */
    cursor?: ParsedQueryDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQueryData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQueryData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedQueryData.
     */
    distinct?: ParsedQueryDataScalarFieldEnum | ParsedQueryDataScalarFieldEnum[]
  }

  /**
   * ParsedQueryData findFirstOrThrow
   */
  export type ParsedQueryDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQueryData to fetch.
     */
    where?: ParsedQueryDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQueryData to fetch.
     */
    orderBy?: ParsedQueryDataOrderByWithRelationInput | ParsedQueryDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedQueryData.
     */
    cursor?: ParsedQueryDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQueryData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQueryData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedQueryData.
     */
    distinct?: ParsedQueryDataScalarFieldEnum | ParsedQueryDataScalarFieldEnum[]
  }

  /**
   * ParsedQueryData findMany
   */
  export type ParsedQueryDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQueryData to fetch.
     */
    where?: ParsedQueryDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQueryData to fetch.
     */
    orderBy?: ParsedQueryDataOrderByWithRelationInput | ParsedQueryDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParsedQueryData.
     */
    cursor?: ParsedQueryDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQueryData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQueryData.
     */
    skip?: number
    distinct?: ParsedQueryDataScalarFieldEnum | ParsedQueryDataScalarFieldEnum[]
  }

  /**
   * ParsedQueryData create
   */
  export type ParsedQueryDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * The data needed to create a ParsedQueryData.
     */
    data: XOR<ParsedQueryDataCreateInput, ParsedQueryDataUncheckedCreateInput>
  }

  /**
   * ParsedQueryData createMany
   */
  export type ParsedQueryDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParsedQueryData.
     */
    data: ParsedQueryDataCreateManyInput | ParsedQueryDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParsedQueryData createManyAndReturn
   */
  export type ParsedQueryDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * The data used to create many ParsedQueryData.
     */
    data: ParsedQueryDataCreateManyInput | ParsedQueryDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedQueryData update
   */
  export type ParsedQueryDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * The data needed to update a ParsedQueryData.
     */
    data: XOR<ParsedQueryDataUpdateInput, ParsedQueryDataUncheckedUpdateInput>
    /**
     * Choose, which ParsedQueryData to update.
     */
    where: ParsedQueryDataWhereUniqueInput
  }

  /**
   * ParsedQueryData updateMany
   */
  export type ParsedQueryDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParsedQueryData.
     */
    data: XOR<ParsedQueryDataUpdateManyMutationInput, ParsedQueryDataUncheckedUpdateManyInput>
    /**
     * Filter which ParsedQueryData to update
     */
    where?: ParsedQueryDataWhereInput
    /**
     * Limit how many ParsedQueryData to update.
     */
    limit?: number
  }

  /**
   * ParsedQueryData updateManyAndReturn
   */
  export type ParsedQueryDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * The data used to update ParsedQueryData.
     */
    data: XOR<ParsedQueryDataUpdateManyMutationInput, ParsedQueryDataUncheckedUpdateManyInput>
    /**
     * Filter which ParsedQueryData to update
     */
    where?: ParsedQueryDataWhereInput
    /**
     * Limit how many ParsedQueryData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedQueryData upsert
   */
  export type ParsedQueryDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * The filter to search for the ParsedQueryData to update in case it exists.
     */
    where: ParsedQueryDataWhereUniqueInput
    /**
     * In case the ParsedQueryData found by the `where` argument doesn't exist, create a new ParsedQueryData with this data.
     */
    create: XOR<ParsedQueryDataCreateInput, ParsedQueryDataUncheckedCreateInput>
    /**
     * In case the ParsedQueryData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParsedQueryDataUpdateInput, ParsedQueryDataUncheckedUpdateInput>
  }

  /**
   * ParsedQueryData delete
   */
  export type ParsedQueryDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    /**
     * Filter which ParsedQueryData to delete.
     */
    where: ParsedQueryDataWhereUniqueInput
  }

  /**
   * ParsedQueryData deleteMany
   */
  export type ParsedQueryDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedQueryData to delete
     */
    where?: ParsedQueryDataWhereInput
    /**
     * Limit how many ParsedQueryData to delete.
     */
    limit?: number
  }

  /**
   * ParsedQueryData without action
   */
  export type ParsedQueryDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
  }


  /**
   * Model ParsedQuerySummary
   */

  export type AggregateParsedQuerySummary = {
    _count: ParsedQuerySummaryCountAggregateOutputType | null
    _avg: ParsedQuerySummaryAvgAggregateOutputType | null
    _sum: ParsedQuerySummarySumAggregateOutputType | null
    _min: ParsedQuerySummaryMinAggregateOutputType | null
    _max: ParsedQuerySummaryMaxAggregateOutputType | null
  }

  export type ParsedQuerySummaryAvgAggregateOutputType = {
    totalEngagedSessions: number | null
    averageBounceRate: number | null
    totalNewUsers: number | null
    totalConversions: number | null
  }

  export type ParsedQuerySummarySumAggregateOutputType = {
    totalEngagedSessions: number | null
    averageBounceRate: number | null
    totalNewUsers: number | null
    totalConversions: number | null
  }

  export type ParsedQuerySummaryMinAggregateOutputType = {
    id: string | null
    queryId: string | null
    date: Date | null
    totalEngagedSessions: number | null
    averageBounceRate: number | null
    totalNewUsers: number | null
    totalConversions: number | null
    createdAt: Date | null
  }

  export type ParsedQuerySummaryMaxAggregateOutputType = {
    id: string | null
    queryId: string | null
    date: Date | null
    totalEngagedSessions: number | null
    averageBounceRate: number | null
    totalNewUsers: number | null
    totalConversions: number | null
    createdAt: Date | null
  }

  export type ParsedQuerySummaryCountAggregateOutputType = {
    id: number
    queryId: number
    date: number
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt: number
    _all: number
  }


  export type ParsedQuerySummaryAvgAggregateInputType = {
    totalEngagedSessions?: true
    averageBounceRate?: true
    totalNewUsers?: true
    totalConversions?: true
  }

  export type ParsedQuerySummarySumAggregateInputType = {
    totalEngagedSessions?: true
    averageBounceRate?: true
    totalNewUsers?: true
    totalConversions?: true
  }

  export type ParsedQuerySummaryMinAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    totalEngagedSessions?: true
    averageBounceRate?: true
    totalNewUsers?: true
    totalConversions?: true
    createdAt?: true
  }

  export type ParsedQuerySummaryMaxAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    totalEngagedSessions?: true
    averageBounceRate?: true
    totalNewUsers?: true
    totalConversions?: true
    createdAt?: true
  }

  export type ParsedQuerySummaryCountAggregateInputType = {
    id?: true
    queryId?: true
    date?: true
    totalEngagedSessions?: true
    averageBounceRate?: true
    totalNewUsers?: true
    totalConversions?: true
    createdAt?: true
    _all?: true
  }

  export type ParsedQuerySummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedQuerySummary to aggregate.
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQuerySummaries to fetch.
     */
    orderBy?: ParsedQuerySummaryOrderByWithRelationInput | ParsedQuerySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParsedQuerySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQuerySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQuerySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParsedQuerySummaries
    **/
    _count?: true | ParsedQuerySummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParsedQuerySummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParsedQuerySummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParsedQuerySummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParsedQuerySummaryMaxAggregateInputType
  }

  export type GetParsedQuerySummaryAggregateType<T extends ParsedQuerySummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateParsedQuerySummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsedQuerySummary[P]>
      : GetScalarType<T[P], AggregateParsedQuerySummary[P]>
  }




  export type ParsedQuerySummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedQuerySummaryWhereInput
    orderBy?: ParsedQuerySummaryOrderByWithAggregationInput | ParsedQuerySummaryOrderByWithAggregationInput[]
    by: ParsedQuerySummaryScalarFieldEnum[] | ParsedQuerySummaryScalarFieldEnum
    having?: ParsedQuerySummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParsedQuerySummaryCountAggregateInputType | true
    _avg?: ParsedQuerySummaryAvgAggregateInputType
    _sum?: ParsedQuerySummarySumAggregateInputType
    _min?: ParsedQuerySummaryMinAggregateInputType
    _max?: ParsedQuerySummaryMaxAggregateInputType
  }

  export type ParsedQuerySummaryGroupByOutputType = {
    id: string
    queryId: string
    date: Date
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt: Date
    _count: ParsedQuerySummaryCountAggregateOutputType | null
    _avg: ParsedQuerySummaryAvgAggregateOutputType | null
    _sum: ParsedQuerySummarySumAggregateOutputType | null
    _min: ParsedQuerySummaryMinAggregateOutputType | null
    _max: ParsedQuerySummaryMaxAggregateOutputType | null
  }

  type GetParsedQuerySummaryGroupByPayload<T extends ParsedQuerySummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParsedQuerySummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParsedQuerySummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParsedQuerySummaryGroupByOutputType[P]>
            : GetScalarType<T[P], ParsedQuerySummaryGroupByOutputType[P]>
        }
      >
    >


  export type ParsedQuerySummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    totalEngagedSessions?: boolean
    averageBounceRate?: boolean
    totalNewUsers?: boolean
    totalConversions?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQuerySummary"]>

  export type ParsedQuerySummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    totalEngagedSessions?: boolean
    averageBounceRate?: boolean
    totalNewUsers?: boolean
    totalConversions?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQuerySummary"]>

  export type ParsedQuerySummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    date?: boolean
    totalEngagedSessions?: boolean
    averageBounceRate?: boolean
    totalNewUsers?: boolean
    totalConversions?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedQuerySummary"]>

  export type ParsedQuerySummarySelectScalar = {
    id?: boolean
    queryId?: boolean
    date?: boolean
    totalEngagedSessions?: boolean
    averageBounceRate?: boolean
    totalNewUsers?: boolean
    totalConversions?: boolean
    createdAt?: boolean
  }

  export type ParsedQuerySummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queryId" | "date" | "totalEngagedSessions" | "averageBounceRate" | "totalNewUsers" | "totalConversions" | "createdAt", ExtArgs["result"]["parsedQuerySummary"]>
  export type ParsedQuerySummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedQuerySummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type ParsedQuerySummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }

  export type $ParsedQuerySummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParsedQuerySummary"
    objects: {
      query: Prisma.$QueryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queryId: string
      date: Date
      totalEngagedSessions: number
      averageBounceRate: number
      totalNewUsers: number
      totalConversions: number
      createdAt: Date
    }, ExtArgs["result"]["parsedQuerySummary"]>
    composites: {}
  }

  type ParsedQuerySummaryGetPayload<S extends boolean | null | undefined | ParsedQuerySummaryDefaultArgs> = $Result.GetResult<Prisma.$ParsedQuerySummaryPayload, S>

  type ParsedQuerySummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParsedQuerySummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParsedQuerySummaryCountAggregateInputType | true
    }

  export interface ParsedQuerySummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParsedQuerySummary'], meta: { name: 'ParsedQuerySummary' } }
    /**
     * Find zero or one ParsedQuerySummary that matches the filter.
     * @param {ParsedQuerySummaryFindUniqueArgs} args - Arguments to find a ParsedQuerySummary
     * @example
     * // Get one ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParsedQuerySummaryFindUniqueArgs>(args: SelectSubset<T, ParsedQuerySummaryFindUniqueArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParsedQuerySummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParsedQuerySummaryFindUniqueOrThrowArgs} args - Arguments to find a ParsedQuerySummary
     * @example
     * // Get one ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParsedQuerySummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, ParsedQuerySummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedQuerySummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryFindFirstArgs} args - Arguments to find a ParsedQuerySummary
     * @example
     * // Get one ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParsedQuerySummaryFindFirstArgs>(args?: SelectSubset<T, ParsedQuerySummaryFindFirstArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedQuerySummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryFindFirstOrThrowArgs} args - Arguments to find a ParsedQuerySummary
     * @example
     * // Get one ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParsedQuerySummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, ParsedQuerySummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParsedQuerySummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParsedQuerySummaries
     * const parsedQuerySummaries = await prisma.parsedQuerySummary.findMany()
     * 
     * // Get first 10 ParsedQuerySummaries
     * const parsedQuerySummaries = await prisma.parsedQuerySummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsedQuerySummaryWithIdOnly = await prisma.parsedQuerySummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParsedQuerySummaryFindManyArgs>(args?: SelectSubset<T, ParsedQuerySummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParsedQuerySummary.
     * @param {ParsedQuerySummaryCreateArgs} args - Arguments to create a ParsedQuerySummary.
     * @example
     * // Create one ParsedQuerySummary
     * const ParsedQuerySummary = await prisma.parsedQuerySummary.create({
     *   data: {
     *     // ... data to create a ParsedQuerySummary
     *   }
     * })
     * 
     */
    create<T extends ParsedQuerySummaryCreateArgs>(args: SelectSubset<T, ParsedQuerySummaryCreateArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParsedQuerySummaries.
     * @param {ParsedQuerySummaryCreateManyArgs} args - Arguments to create many ParsedQuerySummaries.
     * @example
     * // Create many ParsedQuerySummaries
     * const parsedQuerySummary = await prisma.parsedQuerySummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParsedQuerySummaryCreateManyArgs>(args?: SelectSubset<T, ParsedQuerySummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParsedQuerySummaries and returns the data saved in the database.
     * @param {ParsedQuerySummaryCreateManyAndReturnArgs} args - Arguments to create many ParsedQuerySummaries.
     * @example
     * // Create many ParsedQuerySummaries
     * const parsedQuerySummary = await prisma.parsedQuerySummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParsedQuerySummaries and only return the `id`
     * const parsedQuerySummaryWithIdOnly = await prisma.parsedQuerySummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParsedQuerySummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, ParsedQuerySummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParsedQuerySummary.
     * @param {ParsedQuerySummaryDeleteArgs} args - Arguments to delete one ParsedQuerySummary.
     * @example
     * // Delete one ParsedQuerySummary
     * const ParsedQuerySummary = await prisma.parsedQuerySummary.delete({
     *   where: {
     *     // ... filter to delete one ParsedQuerySummary
     *   }
     * })
     * 
     */
    delete<T extends ParsedQuerySummaryDeleteArgs>(args: SelectSubset<T, ParsedQuerySummaryDeleteArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParsedQuerySummary.
     * @param {ParsedQuerySummaryUpdateArgs} args - Arguments to update one ParsedQuerySummary.
     * @example
     * // Update one ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParsedQuerySummaryUpdateArgs>(args: SelectSubset<T, ParsedQuerySummaryUpdateArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParsedQuerySummaries.
     * @param {ParsedQuerySummaryDeleteManyArgs} args - Arguments to filter ParsedQuerySummaries to delete.
     * @example
     * // Delete a few ParsedQuerySummaries
     * const { count } = await prisma.parsedQuerySummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParsedQuerySummaryDeleteManyArgs>(args?: SelectSubset<T, ParsedQuerySummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedQuerySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParsedQuerySummaries
     * const parsedQuerySummary = await prisma.parsedQuerySummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParsedQuerySummaryUpdateManyArgs>(args: SelectSubset<T, ParsedQuerySummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedQuerySummaries and returns the data updated in the database.
     * @param {ParsedQuerySummaryUpdateManyAndReturnArgs} args - Arguments to update many ParsedQuerySummaries.
     * @example
     * // Update many ParsedQuerySummaries
     * const parsedQuerySummary = await prisma.parsedQuerySummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParsedQuerySummaries and only return the `id`
     * const parsedQuerySummaryWithIdOnly = await prisma.parsedQuerySummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParsedQuerySummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, ParsedQuerySummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParsedQuerySummary.
     * @param {ParsedQuerySummaryUpsertArgs} args - Arguments to update or create a ParsedQuerySummary.
     * @example
     * // Update or create a ParsedQuerySummary
     * const parsedQuerySummary = await prisma.parsedQuerySummary.upsert({
     *   create: {
     *     // ... data to create a ParsedQuerySummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParsedQuerySummary we want to update
     *   }
     * })
     */
    upsert<T extends ParsedQuerySummaryUpsertArgs>(args: SelectSubset<T, ParsedQuerySummaryUpsertArgs<ExtArgs>>): Prisma__ParsedQuerySummaryClient<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParsedQuerySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryCountArgs} args - Arguments to filter ParsedQuerySummaries to count.
     * @example
     * // Count the number of ParsedQuerySummaries
     * const count = await prisma.parsedQuerySummary.count({
     *   where: {
     *     // ... the filter for the ParsedQuerySummaries we want to count
     *   }
     * })
    **/
    count<T extends ParsedQuerySummaryCountArgs>(
      args?: Subset<T, ParsedQuerySummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParsedQuerySummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParsedQuerySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParsedQuerySummaryAggregateArgs>(args: Subset<T, ParsedQuerySummaryAggregateArgs>): Prisma.PrismaPromise<GetParsedQuerySummaryAggregateType<T>>

    /**
     * Group by ParsedQuerySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedQuerySummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParsedQuerySummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParsedQuerySummaryGroupByArgs['orderBy'] }
        : { orderBy?: ParsedQuerySummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParsedQuerySummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsedQuerySummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParsedQuerySummary model
   */
  readonly fields: ParsedQuerySummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParsedQuerySummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParsedQuerySummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    query<T extends QueryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueryDefaultArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParsedQuerySummary model
   */
  interface ParsedQuerySummaryFieldRefs {
    readonly id: FieldRef<"ParsedQuerySummary", 'String'>
    readonly queryId: FieldRef<"ParsedQuerySummary", 'String'>
    readonly date: FieldRef<"ParsedQuerySummary", 'DateTime'>
    readonly totalEngagedSessions: FieldRef<"ParsedQuerySummary", 'Int'>
    readonly averageBounceRate: FieldRef<"ParsedQuerySummary", 'Float'>
    readonly totalNewUsers: FieldRef<"ParsedQuerySummary", 'Int'>
    readonly totalConversions: FieldRef<"ParsedQuerySummary", 'Int'>
    readonly createdAt: FieldRef<"ParsedQuerySummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParsedQuerySummary findUnique
   */
  export type ParsedQuerySummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQuerySummary to fetch.
     */
    where: ParsedQuerySummaryWhereUniqueInput
  }

  /**
   * ParsedQuerySummary findUniqueOrThrow
   */
  export type ParsedQuerySummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQuerySummary to fetch.
     */
    where: ParsedQuerySummaryWhereUniqueInput
  }

  /**
   * ParsedQuerySummary findFirst
   */
  export type ParsedQuerySummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQuerySummary to fetch.
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQuerySummaries to fetch.
     */
    orderBy?: ParsedQuerySummaryOrderByWithRelationInput | ParsedQuerySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedQuerySummaries.
     */
    cursor?: ParsedQuerySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQuerySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQuerySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedQuerySummaries.
     */
    distinct?: ParsedQuerySummaryScalarFieldEnum | ParsedQuerySummaryScalarFieldEnum[]
  }

  /**
   * ParsedQuerySummary findFirstOrThrow
   */
  export type ParsedQuerySummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQuerySummary to fetch.
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQuerySummaries to fetch.
     */
    orderBy?: ParsedQuerySummaryOrderByWithRelationInput | ParsedQuerySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedQuerySummaries.
     */
    cursor?: ParsedQuerySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQuerySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQuerySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedQuerySummaries.
     */
    distinct?: ParsedQuerySummaryScalarFieldEnum | ParsedQuerySummaryScalarFieldEnum[]
  }

  /**
   * ParsedQuerySummary findMany
   */
  export type ParsedQuerySummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ParsedQuerySummaries to fetch.
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedQuerySummaries to fetch.
     */
    orderBy?: ParsedQuerySummaryOrderByWithRelationInput | ParsedQuerySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParsedQuerySummaries.
     */
    cursor?: ParsedQuerySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedQuerySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedQuerySummaries.
     */
    skip?: number
    distinct?: ParsedQuerySummaryScalarFieldEnum | ParsedQuerySummaryScalarFieldEnum[]
  }

  /**
   * ParsedQuerySummary create
   */
  export type ParsedQuerySummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a ParsedQuerySummary.
     */
    data: XOR<ParsedQuerySummaryCreateInput, ParsedQuerySummaryUncheckedCreateInput>
  }

  /**
   * ParsedQuerySummary createMany
   */
  export type ParsedQuerySummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParsedQuerySummaries.
     */
    data: ParsedQuerySummaryCreateManyInput | ParsedQuerySummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParsedQuerySummary createManyAndReturn
   */
  export type ParsedQuerySummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * The data used to create many ParsedQuerySummaries.
     */
    data: ParsedQuerySummaryCreateManyInput | ParsedQuerySummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedQuerySummary update
   */
  export type ParsedQuerySummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a ParsedQuerySummary.
     */
    data: XOR<ParsedQuerySummaryUpdateInput, ParsedQuerySummaryUncheckedUpdateInput>
    /**
     * Choose, which ParsedQuerySummary to update.
     */
    where: ParsedQuerySummaryWhereUniqueInput
  }

  /**
   * ParsedQuerySummary updateMany
   */
  export type ParsedQuerySummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParsedQuerySummaries.
     */
    data: XOR<ParsedQuerySummaryUpdateManyMutationInput, ParsedQuerySummaryUncheckedUpdateManyInput>
    /**
     * Filter which ParsedQuerySummaries to update
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * Limit how many ParsedQuerySummaries to update.
     */
    limit?: number
  }

  /**
   * ParsedQuerySummary updateManyAndReturn
   */
  export type ParsedQuerySummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * The data used to update ParsedQuerySummaries.
     */
    data: XOR<ParsedQuerySummaryUpdateManyMutationInput, ParsedQuerySummaryUncheckedUpdateManyInput>
    /**
     * Filter which ParsedQuerySummaries to update
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * Limit how many ParsedQuerySummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedQuerySummary upsert
   */
  export type ParsedQuerySummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the ParsedQuerySummary to update in case it exists.
     */
    where: ParsedQuerySummaryWhereUniqueInput
    /**
     * In case the ParsedQuerySummary found by the `where` argument doesn't exist, create a new ParsedQuerySummary with this data.
     */
    create: XOR<ParsedQuerySummaryCreateInput, ParsedQuerySummaryUncheckedCreateInput>
    /**
     * In case the ParsedQuerySummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParsedQuerySummaryUpdateInput, ParsedQuerySummaryUncheckedUpdateInput>
  }

  /**
   * ParsedQuerySummary delete
   */
  export type ParsedQuerySummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    /**
     * Filter which ParsedQuerySummary to delete.
     */
    where: ParsedQuerySummaryWhereUniqueInput
  }

  /**
   * ParsedQuerySummary deleteMany
   */
  export type ParsedQuerySummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedQuerySummaries to delete
     */
    where?: ParsedQuerySummaryWhereInput
    /**
     * Limit how many ParsedQuerySummaries to delete.
     */
    limit?: number
  }

  /**
   * ParsedQuerySummary without action
   */
  export type ParsedQuerySummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
  }


  /**
   * Model Query
   */

  export type AggregateQuery = {
    _count: QueryCountAggregateOutputType | null
    _avg: QueryAvgAggregateOutputType | null
    _sum: QuerySumAggregateOutputType | null
    _min: QueryMinAggregateOutputType | null
    _max: QueryMaxAggregateOutputType | null
  }

  export type QueryAvgAggregateOutputType = {
    rating: number | null
  }

  export type QuerySumAggregateOutputType = {
    rating: number | null
  }

  export type QueryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    status: $Enums.QueryStatus | null
    conversationId: string | null
    rating: number | null
  }

  export type QueryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    status: $Enums.QueryStatus | null
    conversationId: string | null
    rating: number | null
  }

  export type QueryCountAggregateOutputType = {
    id: number
    userId: number
    response: number
    createdAt: number
    updatedAt: number
    content: number
    status: number
    conversationId: number
    rating: number
    metadata: number
    lineGraphData: number
    pieGraphData: number
    _all: number
  }


  export type QueryAvgAggregateInputType = {
    rating?: true
  }

  export type QuerySumAggregateInputType = {
    rating?: true
  }

  export type QueryMinAggregateInputType = {
    id?: true
    userId?: true
    response?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    status?: true
    conversationId?: true
    rating?: true
  }

  export type QueryMaxAggregateInputType = {
    id?: true
    userId?: true
    response?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    status?: true
    conversationId?: true
    rating?: true
  }

  export type QueryCountAggregateInputType = {
    id?: true
    userId?: true
    response?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    status?: true
    conversationId?: true
    rating?: true
    metadata?: true
    lineGraphData?: true
    pieGraphData?: true
    _all?: true
  }

  export type QueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Query to aggregate.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Queries
    **/
    _count?: true | QueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueryMaxAggregateInputType
  }

  export type GetQueryAggregateType<T extends QueryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuery[P]>
      : GetScalarType<T[P], AggregateQuery[P]>
  }




  export type QueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithAggregationInput | QueryOrderByWithAggregationInput[]
    by: QueryScalarFieldEnum[] | QueryScalarFieldEnum
    having?: QueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueryCountAggregateInputType | true
    _avg?: QueryAvgAggregateInputType
    _sum?: QuerySumAggregateInputType
    _min?: QueryMinAggregateInputType
    _max?: QueryMaxAggregateInputType
  }

  export type QueryGroupByOutputType = {
    id: string
    userId: string
    response: string | null
    createdAt: Date
    updatedAt: Date
    content: string
    status: $Enums.QueryStatus
    conversationId: string | null
    rating: number
    metadata: JsonValue | null
    lineGraphData: JsonValue | null
    pieGraphData: JsonValue | null
    _count: QueryCountAggregateOutputType | null
    _avg: QueryAvgAggregateOutputType | null
    _sum: QuerySumAggregateOutputType | null
    _min: QueryMinAggregateOutputType | null
    _max: QueryMaxAggregateOutputType | null
  }

  type GetQueryGroupByPayload<T extends QueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueryGroupByOutputType[P]>
            : GetScalarType<T[P], QueryGroupByOutputType[P]>
        }
      >
    >


  export type QuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    status?: boolean
    conversationId?: boolean
    rating?: boolean
    metadata?: boolean
    lineGraphData?: boolean
    pieGraphData?: boolean
    parsedPieData?: boolean | Query$parsedPieDataArgs<ExtArgs>
    parsedData?: boolean | Query$parsedDataArgs<ExtArgs>
    parsedSummary?: boolean | Query$parsedSummaryArgs<ExtArgs>
    conversation?: boolean | Query$conversationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | QueryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["query"]>

  export type QuerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    status?: boolean
    conversationId?: boolean
    rating?: boolean
    metadata?: boolean
    lineGraphData?: boolean
    pieGraphData?: boolean
    conversation?: boolean | Query$conversationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["query"]>

  export type QuerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    status?: boolean
    conversationId?: boolean
    rating?: boolean
    metadata?: boolean
    lineGraphData?: boolean
    pieGraphData?: boolean
    conversation?: boolean | Query$conversationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["query"]>

  export type QuerySelectScalar = {
    id?: boolean
    userId?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    status?: boolean
    conversationId?: boolean
    rating?: boolean
    metadata?: boolean
    lineGraphData?: boolean
    pieGraphData?: boolean
  }

  export type QueryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "response" | "createdAt" | "updatedAt" | "content" | "status" | "conversationId" | "rating" | "metadata" | "lineGraphData" | "pieGraphData", ExtArgs["result"]["query"]>
  export type QueryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parsedPieData?: boolean | Query$parsedPieDataArgs<ExtArgs>
    parsedData?: boolean | Query$parsedDataArgs<ExtArgs>
    parsedSummary?: boolean | Query$parsedSummaryArgs<ExtArgs>
    conversation?: boolean | Query$conversationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | QueryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QueryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | Query$conversationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QueryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | Query$conversationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Query"
    objects: {
      parsedPieData: Prisma.$ParsedPieGraphDataPayload<ExtArgs>[]
      parsedData: Prisma.$ParsedQueryDataPayload<ExtArgs>[]
      parsedSummary: Prisma.$ParsedQuerySummaryPayload<ExtArgs>[]
      conversation: Prisma.$ConversationPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      response: string | null
      createdAt: Date
      updatedAt: Date
      content: string
      status: $Enums.QueryStatus
      conversationId: string | null
      rating: number
      metadata: Prisma.JsonValue | null
      lineGraphData: Prisma.JsonValue | null
      pieGraphData: Prisma.JsonValue | null
    }, ExtArgs["result"]["query"]>
    composites: {}
  }

  type QueryGetPayload<S extends boolean | null | undefined | QueryDefaultArgs> = $Result.GetResult<Prisma.$QueryPayload, S>

  type QueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueryCountAggregateInputType | true
    }

  export interface QueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Query'], meta: { name: 'Query' } }
    /**
     * Find zero or one Query that matches the filter.
     * @param {QueryFindUniqueArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueryFindUniqueArgs>(args: SelectSubset<T, QueryFindUniqueArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Query that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueryFindUniqueOrThrowArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueryFindUniqueOrThrowArgs>(args: SelectSubset<T, QueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Query that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindFirstArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueryFindFirstArgs>(args?: SelectSubset<T, QueryFindFirstArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Query that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindFirstOrThrowArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueryFindFirstOrThrowArgs>(args?: SelectSubset<T, QueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Queries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Queries
     * const queries = await prisma.query.findMany()
     * 
     * // Get first 10 Queries
     * const queries = await prisma.query.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queryWithIdOnly = await prisma.query.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueryFindManyArgs>(args?: SelectSubset<T, QueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Query.
     * @param {QueryCreateArgs} args - Arguments to create a Query.
     * @example
     * // Create one Query
     * const Query = await prisma.query.create({
     *   data: {
     *     // ... data to create a Query
     *   }
     * })
     * 
     */
    create<T extends QueryCreateArgs>(args: SelectSubset<T, QueryCreateArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Queries.
     * @param {QueryCreateManyArgs} args - Arguments to create many Queries.
     * @example
     * // Create many Queries
     * const query = await prisma.query.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueryCreateManyArgs>(args?: SelectSubset<T, QueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Queries and returns the data saved in the database.
     * @param {QueryCreateManyAndReturnArgs} args - Arguments to create many Queries.
     * @example
     * // Create many Queries
     * const query = await prisma.query.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Queries and only return the `id`
     * const queryWithIdOnly = await prisma.query.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueryCreateManyAndReturnArgs>(args?: SelectSubset<T, QueryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Query.
     * @param {QueryDeleteArgs} args - Arguments to delete one Query.
     * @example
     * // Delete one Query
     * const Query = await prisma.query.delete({
     *   where: {
     *     // ... filter to delete one Query
     *   }
     * })
     * 
     */
    delete<T extends QueryDeleteArgs>(args: SelectSubset<T, QueryDeleteArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Query.
     * @param {QueryUpdateArgs} args - Arguments to update one Query.
     * @example
     * // Update one Query
     * const query = await prisma.query.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueryUpdateArgs>(args: SelectSubset<T, QueryUpdateArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Queries.
     * @param {QueryDeleteManyArgs} args - Arguments to filter Queries to delete.
     * @example
     * // Delete a few Queries
     * const { count } = await prisma.query.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueryDeleteManyArgs>(args?: SelectSubset<T, QueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Queries
     * const query = await prisma.query.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueryUpdateManyArgs>(args: SelectSubset<T, QueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queries and returns the data updated in the database.
     * @param {QueryUpdateManyAndReturnArgs} args - Arguments to update many Queries.
     * @example
     * // Update many Queries
     * const query = await prisma.query.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Queries and only return the `id`
     * const queryWithIdOnly = await prisma.query.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueryUpdateManyAndReturnArgs>(args: SelectSubset<T, QueryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Query.
     * @param {QueryUpsertArgs} args - Arguments to update or create a Query.
     * @example
     * // Update or create a Query
     * const query = await prisma.query.upsert({
     *   create: {
     *     // ... data to create a Query
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Query we want to update
     *   }
     * })
     */
    upsert<T extends QueryUpsertArgs>(args: SelectSubset<T, QueryUpsertArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryCountArgs} args - Arguments to filter Queries to count.
     * @example
     * // Count the number of Queries
     * const count = await prisma.query.count({
     *   where: {
     *     // ... the filter for the Queries we want to count
     *   }
     * })
    **/
    count<T extends QueryCountArgs>(
      args?: Subset<T, QueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Query.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueryAggregateArgs>(args: Subset<T, QueryAggregateArgs>): Prisma.PrismaPromise<GetQueryAggregateType<T>>

    /**
     * Group by Query.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueryGroupByArgs['orderBy'] }
        : { orderBy?: QueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Query model
   */
  readonly fields: QueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Query.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parsedPieData<T extends Query$parsedPieDataArgs<ExtArgs> = {}>(args?: Subset<T, Query$parsedPieDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedPieGraphDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parsedData<T extends Query$parsedDataArgs<ExtArgs> = {}>(args?: Subset<T, Query$parsedDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQueryDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parsedSummary<T extends Query$parsedSummaryArgs<ExtArgs> = {}>(args?: Subset<T, Query$parsedSummaryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedQuerySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversation<T extends Query$conversationArgs<ExtArgs> = {}>(args?: Subset<T, Query$conversationArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Query model
   */
  interface QueryFieldRefs {
    readonly id: FieldRef<"Query", 'String'>
    readonly userId: FieldRef<"Query", 'String'>
    readonly response: FieldRef<"Query", 'String'>
    readonly createdAt: FieldRef<"Query", 'DateTime'>
    readonly updatedAt: FieldRef<"Query", 'DateTime'>
    readonly content: FieldRef<"Query", 'String'>
    readonly status: FieldRef<"Query", 'QueryStatus'>
    readonly conversationId: FieldRef<"Query", 'String'>
    readonly rating: FieldRef<"Query", 'Int'>
    readonly metadata: FieldRef<"Query", 'Json'>
    readonly lineGraphData: FieldRef<"Query", 'Json'>
    readonly pieGraphData: FieldRef<"Query", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Query findUnique
   */
  export type QueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query findUniqueOrThrow
   */
  export type QueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query findFirst
   */
  export type QueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queries.
     */
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query findFirstOrThrow
   */
  export type QueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queries.
     */
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query findMany
   */
  export type QueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Queries to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query create
   */
  export type QueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The data needed to create a Query.
     */
    data: XOR<QueryCreateInput, QueryUncheckedCreateInput>
  }

  /**
   * Query createMany
   */
  export type QueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Queries.
     */
    data: QueryCreateManyInput | QueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Query createManyAndReturn
   */
  export type QueryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * The data used to create many Queries.
     */
    data: QueryCreateManyInput | QueryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Query update
   */
  export type QueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The data needed to update a Query.
     */
    data: XOR<QueryUpdateInput, QueryUncheckedUpdateInput>
    /**
     * Choose, which Query to update.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query updateMany
   */
  export type QueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Queries.
     */
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyInput>
    /**
     * Filter which Queries to update
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to update.
     */
    limit?: number
  }

  /**
   * Query updateManyAndReturn
   */
  export type QueryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * The data used to update Queries.
     */
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyInput>
    /**
     * Filter which Queries to update
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Query upsert
   */
  export type QueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The filter to search for the Query to update in case it exists.
     */
    where: QueryWhereUniqueInput
    /**
     * In case the Query found by the `where` argument doesn't exist, create a new Query with this data.
     */
    create: XOR<QueryCreateInput, QueryUncheckedCreateInput>
    /**
     * In case the Query was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueryUpdateInput, QueryUncheckedUpdateInput>
  }

  /**
   * Query delete
   */
  export type QueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter which Query to delete.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query deleteMany
   */
  export type QueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Queries to delete
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to delete.
     */
    limit?: number
  }

  /**
   * Query.parsedPieData
   */
  export type Query$parsedPieDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedPieGraphData
     */
    select?: ParsedPieGraphDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedPieGraphData
     */
    omit?: ParsedPieGraphDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedPieGraphDataInclude<ExtArgs> | null
    where?: ParsedPieGraphDataWhereInput
    orderBy?: ParsedPieGraphDataOrderByWithRelationInput | ParsedPieGraphDataOrderByWithRelationInput[]
    cursor?: ParsedPieGraphDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParsedPieGraphDataScalarFieldEnum | ParsedPieGraphDataScalarFieldEnum[]
  }

  /**
   * Query.parsedData
   */
  export type Query$parsedDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQueryData
     */
    select?: ParsedQueryDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQueryData
     */
    omit?: ParsedQueryDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQueryDataInclude<ExtArgs> | null
    where?: ParsedQueryDataWhereInput
    orderBy?: ParsedQueryDataOrderByWithRelationInput | ParsedQueryDataOrderByWithRelationInput[]
    cursor?: ParsedQueryDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParsedQueryDataScalarFieldEnum | ParsedQueryDataScalarFieldEnum[]
  }

  /**
   * Query.parsedSummary
   */
  export type Query$parsedSummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedQuerySummary
     */
    select?: ParsedQuerySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedQuerySummary
     */
    omit?: ParsedQuerySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedQuerySummaryInclude<ExtArgs> | null
    where?: ParsedQuerySummaryWhereInput
    orderBy?: ParsedQuerySummaryOrderByWithRelationInput | ParsedQuerySummaryOrderByWithRelationInput[]
    cursor?: ParsedQuerySummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParsedQuerySummaryScalarFieldEnum | ParsedQuerySummaryScalarFieldEnum[]
  }

  /**
   * Query.conversation
   */
  export type Query$conversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
  }

  /**
   * Query without action
   */
  export type QueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
  }


  /**
   * Model SproutFacebookAnalytics
   */

  export type AggregateSproutFacebookAnalytics = {
    _count: SproutFacebookAnalyticsCountAggregateOutputType | null
    _avg: SproutFacebookAnalyticsAvgAggregateOutputType | null
    _sum: SproutFacebookAnalyticsSumAggregateOutputType | null
    _min: SproutFacebookAnalyticsMinAggregateOutputType | null
    _max: SproutFacebookAnalyticsMaxAggregateOutputType | null
  }

  export type SproutFacebookAnalyticsAvgAggregateOutputType = {
    customerProfileId: number | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    postContentClicks: number | null
    postContentClicksOther: number | null
    postLinkClicks: number | null
    postPhotoViewClicks: number | null
    tabViews: number | null
    videoViews: number | null
    videoViews10s: number | null
    videoViewsOrganic: number | null
    videoViewsPaid: number | null
    videoViewsUnique: number | null
    netFollowerGrowth: number | null
  }

  export type SproutFacebookAnalyticsSumAggregateOutputType = {
    customerProfileId: number | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    postContentClicks: number | null
    postContentClicksOther: number | null
    postLinkClicks: number | null
    postPhotoViewClicks: number | null
    tabViews: number | null
    videoViews: number | null
    videoViews10s: number | null
    videoViewsOrganic: number | null
    videoViewsPaid: number | null
    videoViewsUnique: number | null
    netFollowerGrowth: number | null
  }

  export type SproutFacebookAnalyticsMinAggregateOutputType = {
    id: string | null
    sproutSocialAccountId: string | null
    customerProfileId: number | null
    reportingDate: Date | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    postContentClicks: number | null
    postContentClicksOther: number | null
    postLinkClicks: number | null
    postPhotoViewClicks: number | null
    tabViews: number | null
    videoViews: number | null
    videoViews10s: number | null
    videoViewsOrganic: number | null
    videoViewsPaid: number | null
    videoViewsUnique: number | null
    createdAt: Date | null
    updatedAt: Date | null
    netFollowerGrowth: number | null
  }

  export type SproutFacebookAnalyticsMaxAggregateOutputType = {
    id: string | null
    sproutSocialAccountId: string | null
    customerProfileId: number | null
    reportingDate: Date | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    postContentClicks: number | null
    postContentClicksOther: number | null
    postLinkClicks: number | null
    postPhotoViewClicks: number | null
    tabViews: number | null
    videoViews: number | null
    videoViews10s: number | null
    videoViewsOrganic: number | null
    videoViewsPaid: number | null
    videoViewsUnique: number | null
    createdAt: Date | null
    updatedAt: Date | null
    netFollowerGrowth: number | null
  }

  export type SproutFacebookAnalyticsCountAggregateOutputType = {
    id: number
    sproutSocialAccountId: number
    customerProfileId: number
    reportingDate: number
    engagements: number
    impressions: number
    impressionsUnique: number
    followersCount: number
    postContentClicks: number
    postContentClicksOther: number
    postLinkClicks: number
    postPhotoViewClicks: number
    tabViews: number
    videoViews: number
    videoViews10s: number
    videoViewsOrganic: number
    videoViewsPaid: number
    videoViewsUnique: number
    createdAt: number
    updatedAt: number
    netFollowerGrowth: number
    _all: number
  }


  export type SproutFacebookAnalyticsAvgAggregateInputType = {
    customerProfileId?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    postContentClicks?: true
    postContentClicksOther?: true
    postLinkClicks?: true
    postPhotoViewClicks?: true
    tabViews?: true
    videoViews?: true
    videoViews10s?: true
    videoViewsOrganic?: true
    videoViewsPaid?: true
    videoViewsUnique?: true
    netFollowerGrowth?: true
  }

  export type SproutFacebookAnalyticsSumAggregateInputType = {
    customerProfileId?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    postContentClicks?: true
    postContentClicksOther?: true
    postLinkClicks?: true
    postPhotoViewClicks?: true
    tabViews?: true
    videoViews?: true
    videoViews10s?: true
    videoViewsOrganic?: true
    videoViewsPaid?: true
    videoViewsUnique?: true
    netFollowerGrowth?: true
  }

  export type SproutFacebookAnalyticsMinAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    postContentClicks?: true
    postContentClicksOther?: true
    postLinkClicks?: true
    postPhotoViewClicks?: true
    tabViews?: true
    videoViews?: true
    videoViews10s?: true
    videoViewsOrganic?: true
    videoViewsPaid?: true
    videoViewsUnique?: true
    createdAt?: true
    updatedAt?: true
    netFollowerGrowth?: true
  }

  export type SproutFacebookAnalyticsMaxAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    postContentClicks?: true
    postContentClicksOther?: true
    postLinkClicks?: true
    postPhotoViewClicks?: true
    tabViews?: true
    videoViews?: true
    videoViews10s?: true
    videoViewsOrganic?: true
    videoViewsPaid?: true
    videoViewsUnique?: true
    createdAt?: true
    updatedAt?: true
    netFollowerGrowth?: true
  }

  export type SproutFacebookAnalyticsCountAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    postContentClicks?: true
    postContentClicksOther?: true
    postLinkClicks?: true
    postPhotoViewClicks?: true
    tabViews?: true
    videoViews?: true
    videoViews10s?: true
    videoViewsOrganic?: true
    videoViewsPaid?: true
    videoViewsUnique?: true
    createdAt?: true
    updatedAt?: true
    netFollowerGrowth?: true
    _all?: true
  }

  export type SproutFacebookAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutFacebookAnalytics to aggregate.
     */
    where?: SproutFacebookAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookAnalytics to fetch.
     */
    orderBy?: SproutFacebookAnalyticsOrderByWithRelationInput | SproutFacebookAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SproutFacebookAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SproutFacebookAnalytics
    **/
    _count?: true | SproutFacebookAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SproutFacebookAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SproutFacebookAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SproutFacebookAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SproutFacebookAnalyticsMaxAggregateInputType
  }

  export type GetSproutFacebookAnalyticsAggregateType<T extends SproutFacebookAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateSproutFacebookAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSproutFacebookAnalytics[P]>
      : GetScalarType<T[P], AggregateSproutFacebookAnalytics[P]>
  }




  export type SproutFacebookAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutFacebookAnalyticsWhereInput
    orderBy?: SproutFacebookAnalyticsOrderByWithAggregationInput | SproutFacebookAnalyticsOrderByWithAggregationInput[]
    by: SproutFacebookAnalyticsScalarFieldEnum[] | SproutFacebookAnalyticsScalarFieldEnum
    having?: SproutFacebookAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SproutFacebookAnalyticsCountAggregateInputType | true
    _avg?: SproutFacebookAnalyticsAvgAggregateInputType
    _sum?: SproutFacebookAnalyticsSumAggregateInputType
    _min?: SproutFacebookAnalyticsMinAggregateInputType
    _max?: SproutFacebookAnalyticsMaxAggregateInputType
  }

  export type SproutFacebookAnalyticsGroupByOutputType = {
    id: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    postContentClicks: number | null
    postContentClicksOther: number | null
    postLinkClicks: number | null
    postPhotoViewClicks: number | null
    tabViews: number | null
    videoViews: number | null
    videoViews10s: number | null
    videoViewsOrganic: number | null
    videoViewsPaid: number | null
    videoViewsUnique: number | null
    createdAt: Date
    updatedAt: Date
    netFollowerGrowth: number | null
    _count: SproutFacebookAnalyticsCountAggregateOutputType | null
    _avg: SproutFacebookAnalyticsAvgAggregateOutputType | null
    _sum: SproutFacebookAnalyticsSumAggregateOutputType | null
    _min: SproutFacebookAnalyticsMinAggregateOutputType | null
    _max: SproutFacebookAnalyticsMaxAggregateOutputType | null
  }

  type GetSproutFacebookAnalyticsGroupByPayload<T extends SproutFacebookAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SproutFacebookAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SproutFacebookAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SproutFacebookAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], SproutFacebookAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type SproutFacebookAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    postContentClicks?: boolean
    postContentClicksOther?: boolean
    postLinkClicks?: boolean
    postPhotoViewClicks?: boolean
    tabViews?: boolean
    videoViews?: boolean
    videoViews10s?: boolean
    videoViewsOrganic?: boolean
    videoViewsPaid?: boolean
    videoViewsUnique?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    netFollowerGrowth?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutFacebookAnalytics"]>

  export type SproutFacebookAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    postContentClicks?: boolean
    postContentClicksOther?: boolean
    postLinkClicks?: boolean
    postPhotoViewClicks?: boolean
    tabViews?: boolean
    videoViews?: boolean
    videoViews10s?: boolean
    videoViewsOrganic?: boolean
    videoViewsPaid?: boolean
    videoViewsUnique?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    netFollowerGrowth?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutFacebookAnalytics"]>

  export type SproutFacebookAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    postContentClicks?: boolean
    postContentClicksOther?: boolean
    postLinkClicks?: boolean
    postPhotoViewClicks?: boolean
    tabViews?: boolean
    videoViews?: boolean
    videoViews10s?: boolean
    videoViewsOrganic?: boolean
    videoViewsPaid?: boolean
    videoViewsUnique?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    netFollowerGrowth?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutFacebookAnalytics"]>

  export type SproutFacebookAnalyticsSelectScalar = {
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    postContentClicks?: boolean
    postContentClicksOther?: boolean
    postLinkClicks?: boolean
    postPhotoViewClicks?: boolean
    tabViews?: boolean
    videoViews?: boolean
    videoViews10s?: boolean
    videoViewsOrganic?: boolean
    videoViewsPaid?: boolean
    videoViewsUnique?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    netFollowerGrowth?: boolean
  }

  export type SproutFacebookAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sproutSocialAccountId" | "customerProfileId" | "reportingDate" | "engagements" | "impressions" | "impressionsUnique" | "followersCount" | "postContentClicks" | "postContentClicksOther" | "postLinkClicks" | "postPhotoViewClicks" | "tabViews" | "videoViews" | "videoViews10s" | "videoViewsOrganic" | "videoViewsPaid" | "videoViewsUnique" | "createdAt" | "updatedAt" | "netFollowerGrowth", ExtArgs["result"]["sproutFacebookAnalytics"]>
  export type SproutFacebookAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }
  export type SproutFacebookAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }
  export type SproutFacebookAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }

  export type $SproutFacebookAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SproutFacebookAnalytics"
    objects: {
      sproutSocialAccount: Prisma.$SproutSocialAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sproutSocialAccountId: string
      customerProfileId: number
      reportingDate: Date
      engagements: number | null
      impressions: number | null
      impressionsUnique: number | null
      followersCount: number | null
      postContentClicks: number | null
      postContentClicksOther: number | null
      postLinkClicks: number | null
      postPhotoViewClicks: number | null
      tabViews: number | null
      videoViews: number | null
      videoViews10s: number | null
      videoViewsOrganic: number | null
      videoViewsPaid: number | null
      videoViewsUnique: number | null
      createdAt: Date
      updatedAt: Date
      netFollowerGrowth: number | null
    }, ExtArgs["result"]["sproutFacebookAnalytics"]>
    composites: {}
  }

  type SproutFacebookAnalyticsGetPayload<S extends boolean | null | undefined | SproutFacebookAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload, S>

  type SproutFacebookAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SproutFacebookAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SproutFacebookAnalyticsCountAggregateInputType | true
    }

  export interface SproutFacebookAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SproutFacebookAnalytics'], meta: { name: 'SproutFacebookAnalytics' } }
    /**
     * Find zero or one SproutFacebookAnalytics that matches the filter.
     * @param {SproutFacebookAnalyticsFindUniqueArgs} args - Arguments to find a SproutFacebookAnalytics
     * @example
     * // Get one SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SproutFacebookAnalyticsFindUniqueArgs>(args: SelectSubset<T, SproutFacebookAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__SproutFacebookAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SproutFacebookAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SproutFacebookAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a SproutFacebookAnalytics
     * @example
     * // Get one SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SproutFacebookAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, SproutFacebookAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SproutFacebookAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutFacebookAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookAnalyticsFindFirstArgs} args - Arguments to find a SproutFacebookAnalytics
     * @example
     * // Get one SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SproutFacebookAnalyticsFindFirstArgs>(args?: SelectSubset<T, SproutFacebookAnalyticsFindFirstArgs<ExtArgs>>): Prisma__SproutFacebookAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutFacebookAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookAnalyticsFindFirstOrThrowArgs} args - Arguments to find a SproutFacebookAnalytics
     * @example
     * // Get one SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SproutFacebookAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, SproutFacebookAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SproutFacebookAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SproutFacebookAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.findMany()
     * 
     * // Get first 10 SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sproutFacebookAnalyticsWithIdOnly = await prisma.sproutFacebookAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SproutFacebookAnalyticsFindManyArgs>(args?: SelectSubset<T, SproutFacebookAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SproutFacebookAnalytics.
     * @param {SproutFacebookAnalyticsCreateArgs} args - Arguments to create a SproutFacebookAnalytics.
     * @example
     * // Create one SproutFacebookAnalytics
     * const SproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.create({
     *   data: {
     *     // ... data to create a SproutFacebookAnalytics
     *   }
     * })
     * 
     */
    create<T extends SproutFacebookAnalyticsCreateArgs>(args: SelectSubset<T, SproutFacebookAnalyticsCreateArgs<ExtArgs>>): Prisma__SproutFacebookAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SproutFacebookAnalytics.
     * @param {SproutFacebookAnalyticsCreateManyArgs} args - Arguments to create many SproutFacebookAnalytics.
     * @example
     * // Create many SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SproutFacebookAnalyticsCreateManyArgs>(args?: SelectSubset<T, SproutFacebookAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SproutFacebookAnalytics and returns the data saved in the database.
     * @param {SproutFacebookAnalyticsCreateManyAndReturnArgs} args - Arguments to create many SproutFacebookAnalytics.
     * @example
     * // Create many SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SproutFacebookAnalytics and only return the `id`
     * const sproutFacebookAnalyticsWithIdOnly = await prisma.sproutFacebookAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SproutFacebookAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, SproutFacebookAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SproutFacebookAnalytics.
     * @param {SproutFacebookAnalyticsDeleteArgs} args - Arguments to delete one SproutFacebookAnalytics.
     * @example
     * // Delete one SproutFacebookAnalytics
     * const SproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.delete({
     *   where: {
     *     // ... filter to delete one SproutFacebookAnalytics
     *   }
     * })
     * 
     */
    delete<T extends SproutFacebookAnalyticsDeleteArgs>(args: SelectSubset<T, SproutFacebookAnalyticsDeleteArgs<ExtArgs>>): Prisma__SproutFacebookAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SproutFacebookAnalytics.
     * @param {SproutFacebookAnalyticsUpdateArgs} args - Arguments to update one SproutFacebookAnalytics.
     * @example
     * // Update one SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SproutFacebookAnalyticsUpdateArgs>(args: SelectSubset<T, SproutFacebookAnalyticsUpdateArgs<ExtArgs>>): Prisma__SproutFacebookAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SproutFacebookAnalytics.
     * @param {SproutFacebookAnalyticsDeleteManyArgs} args - Arguments to filter SproutFacebookAnalytics to delete.
     * @example
     * // Delete a few SproutFacebookAnalytics
     * const { count } = await prisma.sproutFacebookAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SproutFacebookAnalyticsDeleteManyArgs>(args?: SelectSubset<T, SproutFacebookAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutFacebookAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SproutFacebookAnalyticsUpdateManyArgs>(args: SelectSubset<T, SproutFacebookAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutFacebookAnalytics and returns the data updated in the database.
     * @param {SproutFacebookAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many SproutFacebookAnalytics.
     * @example
     * // Update many SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SproutFacebookAnalytics and only return the `id`
     * const sproutFacebookAnalyticsWithIdOnly = await prisma.sproutFacebookAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SproutFacebookAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, SproutFacebookAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SproutFacebookAnalytics.
     * @param {SproutFacebookAnalyticsUpsertArgs} args - Arguments to update or create a SproutFacebookAnalytics.
     * @example
     * // Update or create a SproutFacebookAnalytics
     * const sproutFacebookAnalytics = await prisma.sproutFacebookAnalytics.upsert({
     *   create: {
     *     // ... data to create a SproutFacebookAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SproutFacebookAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends SproutFacebookAnalyticsUpsertArgs>(args: SelectSubset<T, SproutFacebookAnalyticsUpsertArgs<ExtArgs>>): Prisma__SproutFacebookAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SproutFacebookAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookAnalyticsCountArgs} args - Arguments to filter SproutFacebookAnalytics to count.
     * @example
     * // Count the number of SproutFacebookAnalytics
     * const count = await prisma.sproutFacebookAnalytics.count({
     *   where: {
     *     // ... the filter for the SproutFacebookAnalytics we want to count
     *   }
     * })
    **/
    count<T extends SproutFacebookAnalyticsCountArgs>(
      args?: Subset<T, SproutFacebookAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SproutFacebookAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SproutFacebookAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SproutFacebookAnalyticsAggregateArgs>(args: Subset<T, SproutFacebookAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetSproutFacebookAnalyticsAggregateType<T>>

    /**
     * Group by SproutFacebookAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SproutFacebookAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SproutFacebookAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: SproutFacebookAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SproutFacebookAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSproutFacebookAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SproutFacebookAnalytics model
   */
  readonly fields: SproutFacebookAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SproutFacebookAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SproutFacebookAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sproutSocialAccount<T extends SproutSocialAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccountDefaultArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SproutFacebookAnalytics model
   */
  interface SproutFacebookAnalyticsFieldRefs {
    readonly id: FieldRef<"SproutFacebookAnalytics", 'String'>
    readonly sproutSocialAccountId: FieldRef<"SproutFacebookAnalytics", 'String'>
    readonly customerProfileId: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly reportingDate: FieldRef<"SproutFacebookAnalytics", 'DateTime'>
    readonly engagements: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly impressions: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly impressionsUnique: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly followersCount: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly postContentClicks: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly postContentClicksOther: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly postLinkClicks: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly postPhotoViewClicks: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly tabViews: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly videoViews: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly videoViews10s: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly videoViewsOrganic: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly videoViewsPaid: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly videoViewsUnique: FieldRef<"SproutFacebookAnalytics", 'Int'>
    readonly createdAt: FieldRef<"SproutFacebookAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"SproutFacebookAnalytics", 'DateTime'>
    readonly netFollowerGrowth: FieldRef<"SproutFacebookAnalytics", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SproutFacebookAnalytics findUnique
   */
  export type SproutFacebookAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookAnalytics to fetch.
     */
    where: SproutFacebookAnalyticsWhereUniqueInput
  }

  /**
   * SproutFacebookAnalytics findUniqueOrThrow
   */
  export type SproutFacebookAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookAnalytics to fetch.
     */
    where: SproutFacebookAnalyticsWhereUniqueInput
  }

  /**
   * SproutFacebookAnalytics findFirst
   */
  export type SproutFacebookAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookAnalytics to fetch.
     */
    where?: SproutFacebookAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookAnalytics to fetch.
     */
    orderBy?: SproutFacebookAnalyticsOrderByWithRelationInput | SproutFacebookAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutFacebookAnalytics.
     */
    cursor?: SproutFacebookAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutFacebookAnalytics.
     */
    distinct?: SproutFacebookAnalyticsScalarFieldEnum | SproutFacebookAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutFacebookAnalytics findFirstOrThrow
   */
  export type SproutFacebookAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookAnalytics to fetch.
     */
    where?: SproutFacebookAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookAnalytics to fetch.
     */
    orderBy?: SproutFacebookAnalyticsOrderByWithRelationInput | SproutFacebookAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutFacebookAnalytics.
     */
    cursor?: SproutFacebookAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutFacebookAnalytics.
     */
    distinct?: SproutFacebookAnalyticsScalarFieldEnum | SproutFacebookAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutFacebookAnalytics findMany
   */
  export type SproutFacebookAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookAnalytics to fetch.
     */
    where?: SproutFacebookAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookAnalytics to fetch.
     */
    orderBy?: SproutFacebookAnalyticsOrderByWithRelationInput | SproutFacebookAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SproutFacebookAnalytics.
     */
    cursor?: SproutFacebookAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookAnalytics.
     */
    skip?: number
    distinct?: SproutFacebookAnalyticsScalarFieldEnum | SproutFacebookAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutFacebookAnalytics create
   */
  export type SproutFacebookAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a SproutFacebookAnalytics.
     */
    data: XOR<SproutFacebookAnalyticsCreateInput, SproutFacebookAnalyticsUncheckedCreateInput>
  }

  /**
   * SproutFacebookAnalytics createMany
   */
  export type SproutFacebookAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SproutFacebookAnalytics.
     */
    data: SproutFacebookAnalyticsCreateManyInput | SproutFacebookAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SproutFacebookAnalytics createManyAndReturn
   */
  export type SproutFacebookAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many SproutFacebookAnalytics.
     */
    data: SproutFacebookAnalyticsCreateManyInput | SproutFacebookAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutFacebookAnalytics update
   */
  export type SproutFacebookAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a SproutFacebookAnalytics.
     */
    data: XOR<SproutFacebookAnalyticsUpdateInput, SproutFacebookAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which SproutFacebookAnalytics to update.
     */
    where: SproutFacebookAnalyticsWhereUniqueInput
  }

  /**
   * SproutFacebookAnalytics updateMany
   */
  export type SproutFacebookAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SproutFacebookAnalytics.
     */
    data: XOR<SproutFacebookAnalyticsUpdateManyMutationInput, SproutFacebookAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SproutFacebookAnalytics to update
     */
    where?: SproutFacebookAnalyticsWhereInput
    /**
     * Limit how many SproutFacebookAnalytics to update.
     */
    limit?: number
  }

  /**
   * SproutFacebookAnalytics updateManyAndReturn
   */
  export type SproutFacebookAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update SproutFacebookAnalytics.
     */
    data: XOR<SproutFacebookAnalyticsUpdateManyMutationInput, SproutFacebookAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SproutFacebookAnalytics to update
     */
    where?: SproutFacebookAnalyticsWhereInput
    /**
     * Limit how many SproutFacebookAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutFacebookAnalytics upsert
   */
  export type SproutFacebookAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the SproutFacebookAnalytics to update in case it exists.
     */
    where: SproutFacebookAnalyticsWhereUniqueInput
    /**
     * In case the SproutFacebookAnalytics found by the `where` argument doesn't exist, create a new SproutFacebookAnalytics with this data.
     */
    create: XOR<SproutFacebookAnalyticsCreateInput, SproutFacebookAnalyticsUncheckedCreateInput>
    /**
     * In case the SproutFacebookAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SproutFacebookAnalyticsUpdateInput, SproutFacebookAnalyticsUncheckedUpdateInput>
  }

  /**
   * SproutFacebookAnalytics delete
   */
  export type SproutFacebookAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which SproutFacebookAnalytics to delete.
     */
    where: SproutFacebookAnalyticsWhereUniqueInput
  }

  /**
   * SproutFacebookAnalytics deleteMany
   */
  export type SproutFacebookAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutFacebookAnalytics to delete
     */
    where?: SproutFacebookAnalyticsWhereInput
    /**
     * Limit how many SproutFacebookAnalytics to delete.
     */
    limit?: number
  }

  /**
   * SproutFacebookAnalytics without action
   */
  export type SproutFacebookAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model SproutFacebookPost
   */

  export type AggregateSproutFacebookPost = {
    _count: SproutFacebookPostCountAggregateOutputType | null
    _min: SproutFacebookPostMinAggregateOutputType | null
    _max: SproutFacebookPostMaxAggregateOutputType | null
  }

  export type SproutFacebookPostMinAggregateOutputType = {
    id: string | null
    sproutSocialAccountId: string | null
    postType: string | null
    postStatus: string | null
    postLink: string | null
    postText: string | null
    postNativeId: string | null
    postCreatedTime: Date | null
    postSentTime: Date | null
    postLastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutFacebookPostMaxAggregateOutputType = {
    id: string | null
    sproutSocialAccountId: string | null
    postType: string | null
    postStatus: string | null
    postLink: string | null
    postText: string | null
    postNativeId: string | null
    postCreatedTime: Date | null
    postSentTime: Date | null
    postLastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutFacebookPostCountAggregateOutputType = {
    id: number
    sproutSocialAccountId: number
    postType: number
    postStatus: number
    postLink: number
    postText: number
    postNativeId: number
    postCreatedTime: number
    postSentTime: number
    postLastUpdated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SproutFacebookPostMinAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    postType?: true
    postStatus?: true
    postLink?: true
    postText?: true
    postNativeId?: true
    postCreatedTime?: true
    postSentTime?: true
    postLastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutFacebookPostMaxAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    postType?: true
    postStatus?: true
    postLink?: true
    postText?: true
    postNativeId?: true
    postCreatedTime?: true
    postSentTime?: true
    postLastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutFacebookPostCountAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    postType?: true
    postStatus?: true
    postLink?: true
    postText?: true
    postNativeId?: true
    postCreatedTime?: true
    postSentTime?: true
    postLastUpdated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SproutFacebookPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutFacebookPost to aggregate.
     */
    where?: SproutFacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookPosts to fetch.
     */
    orderBy?: SproutFacebookPostOrderByWithRelationInput | SproutFacebookPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SproutFacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SproutFacebookPosts
    **/
    _count?: true | SproutFacebookPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SproutFacebookPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SproutFacebookPostMaxAggregateInputType
  }

  export type GetSproutFacebookPostAggregateType<T extends SproutFacebookPostAggregateArgs> = {
        [P in keyof T & keyof AggregateSproutFacebookPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSproutFacebookPost[P]>
      : GetScalarType<T[P], AggregateSproutFacebookPost[P]>
  }




  export type SproutFacebookPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutFacebookPostWhereInput
    orderBy?: SproutFacebookPostOrderByWithAggregationInput | SproutFacebookPostOrderByWithAggregationInput[]
    by: SproutFacebookPostScalarFieldEnum[] | SproutFacebookPostScalarFieldEnum
    having?: SproutFacebookPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SproutFacebookPostCountAggregateInputType | true
    _min?: SproutFacebookPostMinAggregateInputType
    _max?: SproutFacebookPostMaxAggregateInputType
  }

  export type SproutFacebookPostGroupByOutputType = {
    id: string
    sproutSocialAccountId: string
    postType: string
    postStatus: string
    postLink: string
    postText: string
    postNativeId: string
    postCreatedTime: Date
    postSentTime: Date
    postLastUpdated: Date
    createdAt: Date
    updatedAt: Date
    _count: SproutFacebookPostCountAggregateOutputType | null
    _min: SproutFacebookPostMinAggregateOutputType | null
    _max: SproutFacebookPostMaxAggregateOutputType | null
  }

  type GetSproutFacebookPostGroupByPayload<T extends SproutFacebookPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SproutFacebookPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SproutFacebookPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SproutFacebookPostGroupByOutputType[P]>
            : GetScalarType<T[P], SproutFacebookPostGroupByOutputType[P]>
        }
      >
    >


  export type SproutFacebookPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    postType?: boolean
    postStatus?: boolean
    postLink?: boolean
    postText?: boolean
    postNativeId?: boolean
    postCreatedTime?: boolean
    postSentTime?: boolean
    postLastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutFacebookPost"]>

  export type SproutFacebookPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    postType?: boolean
    postStatus?: boolean
    postLink?: boolean
    postText?: boolean
    postNativeId?: boolean
    postCreatedTime?: boolean
    postSentTime?: boolean
    postLastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutFacebookPost"]>

  export type SproutFacebookPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    postType?: boolean
    postStatus?: boolean
    postLink?: boolean
    postText?: boolean
    postNativeId?: boolean
    postCreatedTime?: boolean
    postSentTime?: boolean
    postLastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutFacebookPost"]>

  export type SproutFacebookPostSelectScalar = {
    id?: boolean
    sproutSocialAccountId?: boolean
    postType?: boolean
    postStatus?: boolean
    postLink?: boolean
    postText?: boolean
    postNativeId?: boolean
    postCreatedTime?: boolean
    postSentTime?: boolean
    postLastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SproutFacebookPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sproutSocialAccountId" | "postType" | "postStatus" | "postLink" | "postText" | "postNativeId" | "postCreatedTime" | "postSentTime" | "postLastUpdated" | "createdAt" | "updatedAt", ExtArgs["result"]["sproutFacebookPost"]>
  export type SproutFacebookPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }
  export type SproutFacebookPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }
  export type SproutFacebookPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }

  export type $SproutFacebookPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SproutFacebookPost"
    objects: {
      sproutSocialAccount: Prisma.$SproutSocialAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sproutSocialAccountId: string
      postType: string
      postStatus: string
      postLink: string
      postText: string
      postNativeId: string
      postCreatedTime: Date
      postSentTime: Date
      postLastUpdated: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sproutFacebookPost"]>
    composites: {}
  }

  type SproutFacebookPostGetPayload<S extends boolean | null | undefined | SproutFacebookPostDefaultArgs> = $Result.GetResult<Prisma.$SproutFacebookPostPayload, S>

  type SproutFacebookPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SproutFacebookPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SproutFacebookPostCountAggregateInputType | true
    }

  export interface SproutFacebookPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SproutFacebookPost'], meta: { name: 'SproutFacebookPost' } }
    /**
     * Find zero or one SproutFacebookPost that matches the filter.
     * @param {SproutFacebookPostFindUniqueArgs} args - Arguments to find a SproutFacebookPost
     * @example
     * // Get one SproutFacebookPost
     * const sproutFacebookPost = await prisma.sproutFacebookPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SproutFacebookPostFindUniqueArgs>(args: SelectSubset<T, SproutFacebookPostFindUniqueArgs<ExtArgs>>): Prisma__SproutFacebookPostClient<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SproutFacebookPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SproutFacebookPostFindUniqueOrThrowArgs} args - Arguments to find a SproutFacebookPost
     * @example
     * // Get one SproutFacebookPost
     * const sproutFacebookPost = await prisma.sproutFacebookPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SproutFacebookPostFindUniqueOrThrowArgs>(args: SelectSubset<T, SproutFacebookPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SproutFacebookPostClient<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutFacebookPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostFindFirstArgs} args - Arguments to find a SproutFacebookPost
     * @example
     * // Get one SproutFacebookPost
     * const sproutFacebookPost = await prisma.sproutFacebookPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SproutFacebookPostFindFirstArgs>(args?: SelectSubset<T, SproutFacebookPostFindFirstArgs<ExtArgs>>): Prisma__SproutFacebookPostClient<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutFacebookPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostFindFirstOrThrowArgs} args - Arguments to find a SproutFacebookPost
     * @example
     * // Get one SproutFacebookPost
     * const sproutFacebookPost = await prisma.sproutFacebookPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SproutFacebookPostFindFirstOrThrowArgs>(args?: SelectSubset<T, SproutFacebookPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__SproutFacebookPostClient<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SproutFacebookPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SproutFacebookPosts
     * const sproutFacebookPosts = await prisma.sproutFacebookPost.findMany()
     * 
     * // Get first 10 SproutFacebookPosts
     * const sproutFacebookPosts = await prisma.sproutFacebookPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sproutFacebookPostWithIdOnly = await prisma.sproutFacebookPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SproutFacebookPostFindManyArgs>(args?: SelectSubset<T, SproutFacebookPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SproutFacebookPost.
     * @param {SproutFacebookPostCreateArgs} args - Arguments to create a SproutFacebookPost.
     * @example
     * // Create one SproutFacebookPost
     * const SproutFacebookPost = await prisma.sproutFacebookPost.create({
     *   data: {
     *     // ... data to create a SproutFacebookPost
     *   }
     * })
     * 
     */
    create<T extends SproutFacebookPostCreateArgs>(args: SelectSubset<T, SproutFacebookPostCreateArgs<ExtArgs>>): Prisma__SproutFacebookPostClient<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SproutFacebookPosts.
     * @param {SproutFacebookPostCreateManyArgs} args - Arguments to create many SproutFacebookPosts.
     * @example
     * // Create many SproutFacebookPosts
     * const sproutFacebookPost = await prisma.sproutFacebookPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SproutFacebookPostCreateManyArgs>(args?: SelectSubset<T, SproutFacebookPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SproutFacebookPosts and returns the data saved in the database.
     * @param {SproutFacebookPostCreateManyAndReturnArgs} args - Arguments to create many SproutFacebookPosts.
     * @example
     * // Create many SproutFacebookPosts
     * const sproutFacebookPost = await prisma.sproutFacebookPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SproutFacebookPosts and only return the `id`
     * const sproutFacebookPostWithIdOnly = await prisma.sproutFacebookPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SproutFacebookPostCreateManyAndReturnArgs>(args?: SelectSubset<T, SproutFacebookPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SproutFacebookPost.
     * @param {SproutFacebookPostDeleteArgs} args - Arguments to delete one SproutFacebookPost.
     * @example
     * // Delete one SproutFacebookPost
     * const SproutFacebookPost = await prisma.sproutFacebookPost.delete({
     *   where: {
     *     // ... filter to delete one SproutFacebookPost
     *   }
     * })
     * 
     */
    delete<T extends SproutFacebookPostDeleteArgs>(args: SelectSubset<T, SproutFacebookPostDeleteArgs<ExtArgs>>): Prisma__SproutFacebookPostClient<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SproutFacebookPost.
     * @param {SproutFacebookPostUpdateArgs} args - Arguments to update one SproutFacebookPost.
     * @example
     * // Update one SproutFacebookPost
     * const sproutFacebookPost = await prisma.sproutFacebookPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SproutFacebookPostUpdateArgs>(args: SelectSubset<T, SproutFacebookPostUpdateArgs<ExtArgs>>): Prisma__SproutFacebookPostClient<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SproutFacebookPosts.
     * @param {SproutFacebookPostDeleteManyArgs} args - Arguments to filter SproutFacebookPosts to delete.
     * @example
     * // Delete a few SproutFacebookPosts
     * const { count } = await prisma.sproutFacebookPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SproutFacebookPostDeleteManyArgs>(args?: SelectSubset<T, SproutFacebookPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutFacebookPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SproutFacebookPosts
     * const sproutFacebookPost = await prisma.sproutFacebookPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SproutFacebookPostUpdateManyArgs>(args: SelectSubset<T, SproutFacebookPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutFacebookPosts and returns the data updated in the database.
     * @param {SproutFacebookPostUpdateManyAndReturnArgs} args - Arguments to update many SproutFacebookPosts.
     * @example
     * // Update many SproutFacebookPosts
     * const sproutFacebookPost = await prisma.sproutFacebookPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SproutFacebookPosts and only return the `id`
     * const sproutFacebookPostWithIdOnly = await prisma.sproutFacebookPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SproutFacebookPostUpdateManyAndReturnArgs>(args: SelectSubset<T, SproutFacebookPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SproutFacebookPost.
     * @param {SproutFacebookPostUpsertArgs} args - Arguments to update or create a SproutFacebookPost.
     * @example
     * // Update or create a SproutFacebookPost
     * const sproutFacebookPost = await prisma.sproutFacebookPost.upsert({
     *   create: {
     *     // ... data to create a SproutFacebookPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SproutFacebookPost we want to update
     *   }
     * })
     */
    upsert<T extends SproutFacebookPostUpsertArgs>(args: SelectSubset<T, SproutFacebookPostUpsertArgs<ExtArgs>>): Prisma__SproutFacebookPostClient<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SproutFacebookPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostCountArgs} args - Arguments to filter SproutFacebookPosts to count.
     * @example
     * // Count the number of SproutFacebookPosts
     * const count = await prisma.sproutFacebookPost.count({
     *   where: {
     *     // ... the filter for the SproutFacebookPosts we want to count
     *   }
     * })
    **/
    count<T extends SproutFacebookPostCountArgs>(
      args?: Subset<T, SproutFacebookPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SproutFacebookPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SproutFacebookPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SproutFacebookPostAggregateArgs>(args: Subset<T, SproutFacebookPostAggregateArgs>): Prisma.PrismaPromise<GetSproutFacebookPostAggregateType<T>>

    /**
     * Group by SproutFacebookPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SproutFacebookPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SproutFacebookPostGroupByArgs['orderBy'] }
        : { orderBy?: SproutFacebookPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SproutFacebookPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSproutFacebookPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SproutFacebookPost model
   */
  readonly fields: SproutFacebookPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SproutFacebookPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SproutFacebookPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sproutSocialAccount<T extends SproutSocialAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccountDefaultArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SproutFacebookPost model
   */
  interface SproutFacebookPostFieldRefs {
    readonly id: FieldRef<"SproutFacebookPost", 'String'>
    readonly sproutSocialAccountId: FieldRef<"SproutFacebookPost", 'String'>
    readonly postType: FieldRef<"SproutFacebookPost", 'String'>
    readonly postStatus: FieldRef<"SproutFacebookPost", 'String'>
    readonly postLink: FieldRef<"SproutFacebookPost", 'String'>
    readonly postText: FieldRef<"SproutFacebookPost", 'String'>
    readonly postNativeId: FieldRef<"SproutFacebookPost", 'String'>
    readonly postCreatedTime: FieldRef<"SproutFacebookPost", 'DateTime'>
    readonly postSentTime: FieldRef<"SproutFacebookPost", 'DateTime'>
    readonly postLastUpdated: FieldRef<"SproutFacebookPost", 'DateTime'>
    readonly createdAt: FieldRef<"SproutFacebookPost", 'DateTime'>
    readonly updatedAt: FieldRef<"SproutFacebookPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SproutFacebookPost findUnique
   */
  export type SproutFacebookPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookPost to fetch.
     */
    where: SproutFacebookPostWhereUniqueInput
  }

  /**
   * SproutFacebookPost findUniqueOrThrow
   */
  export type SproutFacebookPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookPost to fetch.
     */
    where: SproutFacebookPostWhereUniqueInput
  }

  /**
   * SproutFacebookPost findFirst
   */
  export type SproutFacebookPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookPost to fetch.
     */
    where?: SproutFacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookPosts to fetch.
     */
    orderBy?: SproutFacebookPostOrderByWithRelationInput | SproutFacebookPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutFacebookPosts.
     */
    cursor?: SproutFacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutFacebookPosts.
     */
    distinct?: SproutFacebookPostScalarFieldEnum | SproutFacebookPostScalarFieldEnum[]
  }

  /**
   * SproutFacebookPost findFirstOrThrow
   */
  export type SproutFacebookPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookPost to fetch.
     */
    where?: SproutFacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookPosts to fetch.
     */
    orderBy?: SproutFacebookPostOrderByWithRelationInput | SproutFacebookPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutFacebookPosts.
     */
    cursor?: SproutFacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutFacebookPosts.
     */
    distinct?: SproutFacebookPostScalarFieldEnum | SproutFacebookPostScalarFieldEnum[]
  }

  /**
   * SproutFacebookPost findMany
   */
  export type SproutFacebookPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookPosts to fetch.
     */
    where?: SproutFacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookPosts to fetch.
     */
    orderBy?: SproutFacebookPostOrderByWithRelationInput | SproutFacebookPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SproutFacebookPosts.
     */
    cursor?: SproutFacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookPosts.
     */
    skip?: number
    distinct?: SproutFacebookPostScalarFieldEnum | SproutFacebookPostScalarFieldEnum[]
  }

  /**
   * SproutFacebookPost create
   */
  export type SproutFacebookPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostInclude<ExtArgs> | null
    /**
     * The data needed to create a SproutFacebookPost.
     */
    data: XOR<SproutFacebookPostCreateInput, SproutFacebookPostUncheckedCreateInput>
  }

  /**
   * SproutFacebookPost createMany
   */
  export type SproutFacebookPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SproutFacebookPosts.
     */
    data: SproutFacebookPostCreateManyInput | SproutFacebookPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SproutFacebookPost createManyAndReturn
   */
  export type SproutFacebookPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * The data used to create many SproutFacebookPosts.
     */
    data: SproutFacebookPostCreateManyInput | SproutFacebookPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutFacebookPost update
   */
  export type SproutFacebookPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostInclude<ExtArgs> | null
    /**
     * The data needed to update a SproutFacebookPost.
     */
    data: XOR<SproutFacebookPostUpdateInput, SproutFacebookPostUncheckedUpdateInput>
    /**
     * Choose, which SproutFacebookPost to update.
     */
    where: SproutFacebookPostWhereUniqueInput
  }

  /**
   * SproutFacebookPost updateMany
   */
  export type SproutFacebookPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SproutFacebookPosts.
     */
    data: XOR<SproutFacebookPostUpdateManyMutationInput, SproutFacebookPostUncheckedUpdateManyInput>
    /**
     * Filter which SproutFacebookPosts to update
     */
    where?: SproutFacebookPostWhereInput
    /**
     * Limit how many SproutFacebookPosts to update.
     */
    limit?: number
  }

  /**
   * SproutFacebookPost updateManyAndReturn
   */
  export type SproutFacebookPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * The data used to update SproutFacebookPosts.
     */
    data: XOR<SproutFacebookPostUpdateManyMutationInput, SproutFacebookPostUncheckedUpdateManyInput>
    /**
     * Filter which SproutFacebookPosts to update
     */
    where?: SproutFacebookPostWhereInput
    /**
     * Limit how many SproutFacebookPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutFacebookPost upsert
   */
  export type SproutFacebookPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostInclude<ExtArgs> | null
    /**
     * The filter to search for the SproutFacebookPost to update in case it exists.
     */
    where: SproutFacebookPostWhereUniqueInput
    /**
     * In case the SproutFacebookPost found by the `where` argument doesn't exist, create a new SproutFacebookPost with this data.
     */
    create: XOR<SproutFacebookPostCreateInput, SproutFacebookPostUncheckedCreateInput>
    /**
     * In case the SproutFacebookPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SproutFacebookPostUpdateInput, SproutFacebookPostUncheckedUpdateInput>
  }

  /**
   * SproutFacebookPost delete
   */
  export type SproutFacebookPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostInclude<ExtArgs> | null
    /**
     * Filter which SproutFacebookPost to delete.
     */
    where: SproutFacebookPostWhereUniqueInput
  }

  /**
   * SproutFacebookPost deleteMany
   */
  export type SproutFacebookPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutFacebookPosts to delete
     */
    where?: SproutFacebookPostWhereInput
    /**
     * Limit how many SproutFacebookPosts to delete.
     */
    limit?: number
  }

  /**
   * SproutFacebookPost without action
   */
  export type SproutFacebookPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostInclude<ExtArgs> | null
  }


  /**
   * Model SproutFacebookPostAnalytics
   */

  export type AggregateSproutFacebookPostAnalytics = {
    _count: SproutFacebookPostAnalyticsCountAggregateOutputType | null
    _avg: SproutFacebookPostAnalyticsAvgAggregateOutputType | null
    _sum: SproutFacebookPostAnalyticsSumAggregateOutputType | null
    _min: SproutFacebookPostAnalyticsMinAggregateOutputType | null
    _max: SproutFacebookPostAnalyticsMaxAggregateOutputType | null
  }

  export type SproutFacebookPostAnalyticsAvgAggregateOutputType = {
    angryReactions: number | null
    commentsCount: number | null
    hahaReactions: number | null
    impressions: number | null
    impressionsFollower: number | null
    impressionsNonFollower: number | null
    impressionsNonViral: number | null
    impressionsOrganic: number | null
    impressionsPaid: number | null
    impressionsViral: number | null
    likes: number | null
    loveReactions: number | null
    postContentClicks: number | null
    postContentClicksOther: number | null
    postLinkClicks: number | null
    postPhotoViewClicks: number | null
    postVideoPlayClicks: number | null
    questionAnswers: number | null
    reach: number | null
    reachFollower: number | null
    reachNonViral: number | null
    reachOrganic: number | null
    reachPaid: number | null
    reachViral: number | null
    reactions: number | null
    sadReactions: number | null
    sharesCount: number | null
    videoLength: number | null
    videoViews: number | null
    videoViewsAutoplay: number | null
    videoViewsOrganic: number | null
    videoViewsPaid: number | null
    wowReactions: number | null
  }

  export type SproutFacebookPostAnalyticsSumAggregateOutputType = {
    angryReactions: number | null
    commentsCount: number | null
    hahaReactions: number | null
    impressions: number | null
    impressionsFollower: number | null
    impressionsNonFollower: number | null
    impressionsNonViral: number | null
    impressionsOrganic: number | null
    impressionsPaid: number | null
    impressionsViral: number | null
    likes: number | null
    loveReactions: number | null
    postContentClicks: number | null
    postContentClicksOther: number | null
    postLinkClicks: number | null
    postPhotoViewClicks: number | null
    postVideoPlayClicks: number | null
    questionAnswers: number | null
    reach: number | null
    reachFollower: number | null
    reachNonViral: number | null
    reachOrganic: number | null
    reachPaid: number | null
    reachViral: number | null
    reactions: number | null
    sadReactions: number | null
    sharesCount: number | null
    videoLength: number | null
    videoViews: number | null
    videoViewsAutoplay: number | null
    videoViewsOrganic: number | null
    videoViewsPaid: number | null
    wowReactions: number | null
  }

  export type SproutFacebookPostAnalyticsMinAggregateOutputType = {
    id: string | null
    angryReactions: number | null
    clientNativeId: string | null
    commentsCount: number | null
    hahaReactions: number | null
    impressions: number | null
    impressionsFollower: number | null
    impressionsNonFollower: number | null
    impressionsNonViral: number | null
    impressionsOrganic: number | null
    impressionsPaid: number | null
    impressionsViral: number | null
    likes: number | null
    loveReactions: number | null
    postContentClicks: number | null
    postContentClicksOther: number | null
    postLinkClicks: number | null
    postNativeId: string | null
    postPhotoViewClicks: number | null
    postVideoPlayClicks: number | null
    questionAnswers: number | null
    reach: number | null
    reachFollower: number | null
    reachNonViral: number | null
    reachOrganic: number | null
    reachPaid: number | null
    reachViral: number | null
    reactions: number | null
    reportingDate: Date | null
    sadReactions: number | null
    sharesCount: number | null
    sproutSocialAccountId: string | null
    videoLength: number | null
    videoViews: number | null
    videoViewsAutoplay: number | null
    videoViewsOrganic: number | null
    videoViewsPaid: number | null
    wowReactions: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutFacebookPostAnalyticsMaxAggregateOutputType = {
    id: string | null
    angryReactions: number | null
    clientNativeId: string | null
    commentsCount: number | null
    hahaReactions: number | null
    impressions: number | null
    impressionsFollower: number | null
    impressionsNonFollower: number | null
    impressionsNonViral: number | null
    impressionsOrganic: number | null
    impressionsPaid: number | null
    impressionsViral: number | null
    likes: number | null
    loveReactions: number | null
    postContentClicks: number | null
    postContentClicksOther: number | null
    postLinkClicks: number | null
    postNativeId: string | null
    postPhotoViewClicks: number | null
    postVideoPlayClicks: number | null
    questionAnswers: number | null
    reach: number | null
    reachFollower: number | null
    reachNonViral: number | null
    reachOrganic: number | null
    reachPaid: number | null
    reachViral: number | null
    reactions: number | null
    reportingDate: Date | null
    sadReactions: number | null
    sharesCount: number | null
    sproutSocialAccountId: string | null
    videoLength: number | null
    videoViews: number | null
    videoViewsAutoplay: number | null
    videoViewsOrganic: number | null
    videoViewsPaid: number | null
    wowReactions: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutFacebookPostAnalyticsCountAggregateOutputType = {
    id: number
    angryReactions: number
    clientNativeId: number
    commentsCount: number
    hahaReactions: number
    impressions: number
    impressionsFollower: number
    impressionsNonFollower: number
    impressionsNonViral: number
    impressionsOrganic: number
    impressionsPaid: number
    impressionsViral: number
    likes: number
    loveReactions: number
    postContentClicks: number
    postContentClicksOther: number
    postLinkClicks: number
    postNativeId: number
    postPhotoViewClicks: number
    postVideoPlayClicks: number
    questionAnswers: number
    reach: number
    reachFollower: number
    reachNonViral: number
    reachOrganic: number
    reachPaid: number
    reachViral: number
    reactions: number
    reportingDate: number
    sadReactions: number
    sharesCount: number
    sproutSocialAccountId: number
    videoLength: number
    videoViews: number
    videoViewsAutoplay: number
    videoViewsOrganic: number
    videoViewsPaid: number
    wowReactions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SproutFacebookPostAnalyticsAvgAggregateInputType = {
    angryReactions?: true
    commentsCount?: true
    hahaReactions?: true
    impressions?: true
    impressionsFollower?: true
    impressionsNonFollower?: true
    impressionsNonViral?: true
    impressionsOrganic?: true
    impressionsPaid?: true
    impressionsViral?: true
    likes?: true
    loveReactions?: true
    postContentClicks?: true
    postContentClicksOther?: true
    postLinkClicks?: true
    postPhotoViewClicks?: true
    postVideoPlayClicks?: true
    questionAnswers?: true
    reach?: true
    reachFollower?: true
    reachNonViral?: true
    reachOrganic?: true
    reachPaid?: true
    reachViral?: true
    reactions?: true
    sadReactions?: true
    sharesCount?: true
    videoLength?: true
    videoViews?: true
    videoViewsAutoplay?: true
    videoViewsOrganic?: true
    videoViewsPaid?: true
    wowReactions?: true
  }

  export type SproutFacebookPostAnalyticsSumAggregateInputType = {
    angryReactions?: true
    commentsCount?: true
    hahaReactions?: true
    impressions?: true
    impressionsFollower?: true
    impressionsNonFollower?: true
    impressionsNonViral?: true
    impressionsOrganic?: true
    impressionsPaid?: true
    impressionsViral?: true
    likes?: true
    loveReactions?: true
    postContentClicks?: true
    postContentClicksOther?: true
    postLinkClicks?: true
    postPhotoViewClicks?: true
    postVideoPlayClicks?: true
    questionAnswers?: true
    reach?: true
    reachFollower?: true
    reachNonViral?: true
    reachOrganic?: true
    reachPaid?: true
    reachViral?: true
    reactions?: true
    sadReactions?: true
    sharesCount?: true
    videoLength?: true
    videoViews?: true
    videoViewsAutoplay?: true
    videoViewsOrganic?: true
    videoViewsPaid?: true
    wowReactions?: true
  }

  export type SproutFacebookPostAnalyticsMinAggregateInputType = {
    id?: true
    angryReactions?: true
    clientNativeId?: true
    commentsCount?: true
    hahaReactions?: true
    impressions?: true
    impressionsFollower?: true
    impressionsNonFollower?: true
    impressionsNonViral?: true
    impressionsOrganic?: true
    impressionsPaid?: true
    impressionsViral?: true
    likes?: true
    loveReactions?: true
    postContentClicks?: true
    postContentClicksOther?: true
    postLinkClicks?: true
    postNativeId?: true
    postPhotoViewClicks?: true
    postVideoPlayClicks?: true
    questionAnswers?: true
    reach?: true
    reachFollower?: true
    reachNonViral?: true
    reachOrganic?: true
    reachPaid?: true
    reachViral?: true
    reactions?: true
    reportingDate?: true
    sadReactions?: true
    sharesCount?: true
    sproutSocialAccountId?: true
    videoLength?: true
    videoViews?: true
    videoViewsAutoplay?: true
    videoViewsOrganic?: true
    videoViewsPaid?: true
    wowReactions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutFacebookPostAnalyticsMaxAggregateInputType = {
    id?: true
    angryReactions?: true
    clientNativeId?: true
    commentsCount?: true
    hahaReactions?: true
    impressions?: true
    impressionsFollower?: true
    impressionsNonFollower?: true
    impressionsNonViral?: true
    impressionsOrganic?: true
    impressionsPaid?: true
    impressionsViral?: true
    likes?: true
    loveReactions?: true
    postContentClicks?: true
    postContentClicksOther?: true
    postLinkClicks?: true
    postNativeId?: true
    postPhotoViewClicks?: true
    postVideoPlayClicks?: true
    questionAnswers?: true
    reach?: true
    reachFollower?: true
    reachNonViral?: true
    reachOrganic?: true
    reachPaid?: true
    reachViral?: true
    reactions?: true
    reportingDate?: true
    sadReactions?: true
    sharesCount?: true
    sproutSocialAccountId?: true
    videoLength?: true
    videoViews?: true
    videoViewsAutoplay?: true
    videoViewsOrganic?: true
    videoViewsPaid?: true
    wowReactions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutFacebookPostAnalyticsCountAggregateInputType = {
    id?: true
    angryReactions?: true
    clientNativeId?: true
    commentsCount?: true
    hahaReactions?: true
    impressions?: true
    impressionsFollower?: true
    impressionsNonFollower?: true
    impressionsNonViral?: true
    impressionsOrganic?: true
    impressionsPaid?: true
    impressionsViral?: true
    likes?: true
    loveReactions?: true
    postContentClicks?: true
    postContentClicksOther?: true
    postLinkClicks?: true
    postNativeId?: true
    postPhotoViewClicks?: true
    postVideoPlayClicks?: true
    questionAnswers?: true
    reach?: true
    reachFollower?: true
    reachNonViral?: true
    reachOrganic?: true
    reachPaid?: true
    reachViral?: true
    reactions?: true
    reportingDate?: true
    sadReactions?: true
    sharesCount?: true
    sproutSocialAccountId?: true
    videoLength?: true
    videoViews?: true
    videoViewsAutoplay?: true
    videoViewsOrganic?: true
    videoViewsPaid?: true
    wowReactions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SproutFacebookPostAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutFacebookPostAnalytics to aggregate.
     */
    where?: SproutFacebookPostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookPostAnalytics to fetch.
     */
    orderBy?: SproutFacebookPostAnalyticsOrderByWithRelationInput | SproutFacebookPostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SproutFacebookPostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookPostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookPostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SproutFacebookPostAnalytics
    **/
    _count?: true | SproutFacebookPostAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SproutFacebookPostAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SproutFacebookPostAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SproutFacebookPostAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SproutFacebookPostAnalyticsMaxAggregateInputType
  }

  export type GetSproutFacebookPostAnalyticsAggregateType<T extends SproutFacebookPostAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateSproutFacebookPostAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSproutFacebookPostAnalytics[P]>
      : GetScalarType<T[P], AggregateSproutFacebookPostAnalytics[P]>
  }




  export type SproutFacebookPostAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutFacebookPostAnalyticsWhereInput
    orderBy?: SproutFacebookPostAnalyticsOrderByWithAggregationInput | SproutFacebookPostAnalyticsOrderByWithAggregationInput[]
    by: SproutFacebookPostAnalyticsScalarFieldEnum[] | SproutFacebookPostAnalyticsScalarFieldEnum
    having?: SproutFacebookPostAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SproutFacebookPostAnalyticsCountAggregateInputType | true
    _avg?: SproutFacebookPostAnalyticsAvgAggregateInputType
    _sum?: SproutFacebookPostAnalyticsSumAggregateInputType
    _min?: SproutFacebookPostAnalyticsMinAggregateInputType
    _max?: SproutFacebookPostAnalyticsMaxAggregateInputType
  }

  export type SproutFacebookPostAnalyticsGroupByOutputType = {
    id: string
    angryReactions: number | null
    clientNativeId: string
    commentsCount: number | null
    hahaReactions: number | null
    impressions: number | null
    impressionsFollower: number | null
    impressionsNonFollower: number | null
    impressionsNonViral: number | null
    impressionsOrganic: number | null
    impressionsPaid: number | null
    impressionsViral: number | null
    likes: number | null
    loveReactions: number | null
    postContentClicks: number | null
    postContentClicksOther: number | null
    postLinkClicks: number | null
    postNativeId: string
    postPhotoViewClicks: number | null
    postVideoPlayClicks: number | null
    questionAnswers: number | null
    reach: number | null
    reachFollower: number | null
    reachNonViral: number | null
    reachOrganic: number | null
    reachPaid: number | null
    reachViral: number | null
    reactions: number | null
    reportingDate: Date
    sadReactions: number | null
    sharesCount: number | null
    sproutSocialAccountId: string
    videoLength: number | null
    videoViews: number | null
    videoViewsAutoplay: number | null
    videoViewsOrganic: number | null
    videoViewsPaid: number | null
    wowReactions: number | null
    createdAt: Date
    updatedAt: Date
    _count: SproutFacebookPostAnalyticsCountAggregateOutputType | null
    _avg: SproutFacebookPostAnalyticsAvgAggregateOutputType | null
    _sum: SproutFacebookPostAnalyticsSumAggregateOutputType | null
    _min: SproutFacebookPostAnalyticsMinAggregateOutputType | null
    _max: SproutFacebookPostAnalyticsMaxAggregateOutputType | null
  }

  type GetSproutFacebookPostAnalyticsGroupByPayload<T extends SproutFacebookPostAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SproutFacebookPostAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SproutFacebookPostAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SproutFacebookPostAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], SproutFacebookPostAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type SproutFacebookPostAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    angryReactions?: boolean
    clientNativeId?: boolean
    commentsCount?: boolean
    hahaReactions?: boolean
    impressions?: boolean
    impressionsFollower?: boolean
    impressionsNonFollower?: boolean
    impressionsNonViral?: boolean
    impressionsOrganic?: boolean
    impressionsPaid?: boolean
    impressionsViral?: boolean
    likes?: boolean
    loveReactions?: boolean
    postContentClicks?: boolean
    postContentClicksOther?: boolean
    postLinkClicks?: boolean
    postNativeId?: boolean
    postPhotoViewClicks?: boolean
    postVideoPlayClicks?: boolean
    questionAnswers?: boolean
    reach?: boolean
    reachFollower?: boolean
    reachNonViral?: boolean
    reachOrganic?: boolean
    reachPaid?: boolean
    reachViral?: boolean
    reactions?: boolean
    reportingDate?: boolean
    sadReactions?: boolean
    sharesCount?: boolean
    sproutSocialAccountId?: boolean
    videoLength?: boolean
    videoViews?: boolean
    videoViewsAutoplay?: boolean
    videoViewsOrganic?: boolean
    videoViewsPaid?: boolean
    wowReactions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutFacebookPostAnalytics"]>

  export type SproutFacebookPostAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    angryReactions?: boolean
    clientNativeId?: boolean
    commentsCount?: boolean
    hahaReactions?: boolean
    impressions?: boolean
    impressionsFollower?: boolean
    impressionsNonFollower?: boolean
    impressionsNonViral?: boolean
    impressionsOrganic?: boolean
    impressionsPaid?: boolean
    impressionsViral?: boolean
    likes?: boolean
    loveReactions?: boolean
    postContentClicks?: boolean
    postContentClicksOther?: boolean
    postLinkClicks?: boolean
    postNativeId?: boolean
    postPhotoViewClicks?: boolean
    postVideoPlayClicks?: boolean
    questionAnswers?: boolean
    reach?: boolean
    reachFollower?: boolean
    reachNonViral?: boolean
    reachOrganic?: boolean
    reachPaid?: boolean
    reachViral?: boolean
    reactions?: boolean
    reportingDate?: boolean
    sadReactions?: boolean
    sharesCount?: boolean
    sproutSocialAccountId?: boolean
    videoLength?: boolean
    videoViews?: boolean
    videoViewsAutoplay?: boolean
    videoViewsOrganic?: boolean
    videoViewsPaid?: boolean
    wowReactions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutFacebookPostAnalytics"]>

  export type SproutFacebookPostAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    angryReactions?: boolean
    clientNativeId?: boolean
    commentsCount?: boolean
    hahaReactions?: boolean
    impressions?: boolean
    impressionsFollower?: boolean
    impressionsNonFollower?: boolean
    impressionsNonViral?: boolean
    impressionsOrganic?: boolean
    impressionsPaid?: boolean
    impressionsViral?: boolean
    likes?: boolean
    loveReactions?: boolean
    postContentClicks?: boolean
    postContentClicksOther?: boolean
    postLinkClicks?: boolean
    postNativeId?: boolean
    postPhotoViewClicks?: boolean
    postVideoPlayClicks?: boolean
    questionAnswers?: boolean
    reach?: boolean
    reachFollower?: boolean
    reachNonViral?: boolean
    reachOrganic?: boolean
    reachPaid?: boolean
    reachViral?: boolean
    reactions?: boolean
    reportingDate?: boolean
    sadReactions?: boolean
    sharesCount?: boolean
    sproutSocialAccountId?: boolean
    videoLength?: boolean
    videoViews?: boolean
    videoViewsAutoplay?: boolean
    videoViewsOrganic?: boolean
    videoViewsPaid?: boolean
    wowReactions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutFacebookPostAnalytics"]>

  export type SproutFacebookPostAnalyticsSelectScalar = {
    id?: boolean
    angryReactions?: boolean
    clientNativeId?: boolean
    commentsCount?: boolean
    hahaReactions?: boolean
    impressions?: boolean
    impressionsFollower?: boolean
    impressionsNonFollower?: boolean
    impressionsNonViral?: boolean
    impressionsOrganic?: boolean
    impressionsPaid?: boolean
    impressionsViral?: boolean
    likes?: boolean
    loveReactions?: boolean
    postContentClicks?: boolean
    postContentClicksOther?: boolean
    postLinkClicks?: boolean
    postNativeId?: boolean
    postPhotoViewClicks?: boolean
    postVideoPlayClicks?: boolean
    questionAnswers?: boolean
    reach?: boolean
    reachFollower?: boolean
    reachNonViral?: boolean
    reachOrganic?: boolean
    reachPaid?: boolean
    reachViral?: boolean
    reactions?: boolean
    reportingDate?: boolean
    sadReactions?: boolean
    sharesCount?: boolean
    sproutSocialAccountId?: boolean
    videoLength?: boolean
    videoViews?: boolean
    videoViewsAutoplay?: boolean
    videoViewsOrganic?: boolean
    videoViewsPaid?: boolean
    wowReactions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SproutFacebookPostAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "angryReactions" | "clientNativeId" | "commentsCount" | "hahaReactions" | "impressions" | "impressionsFollower" | "impressionsNonFollower" | "impressionsNonViral" | "impressionsOrganic" | "impressionsPaid" | "impressionsViral" | "likes" | "loveReactions" | "postContentClicks" | "postContentClicksOther" | "postLinkClicks" | "postNativeId" | "postPhotoViewClicks" | "postVideoPlayClicks" | "questionAnswers" | "reach" | "reachFollower" | "reachNonViral" | "reachOrganic" | "reachPaid" | "reachViral" | "reactions" | "reportingDate" | "sadReactions" | "sharesCount" | "sproutSocialAccountId" | "videoLength" | "videoViews" | "videoViewsAutoplay" | "videoViewsOrganic" | "videoViewsPaid" | "wowReactions" | "createdAt" | "updatedAt", ExtArgs["result"]["sproutFacebookPostAnalytics"]>
  export type SproutFacebookPostAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }
  export type SproutFacebookPostAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }
  export type SproutFacebookPostAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }

  export type $SproutFacebookPostAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SproutFacebookPostAnalytics"
    objects: {
      sproutSocialAccount: Prisma.$SproutSocialAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      angryReactions: number | null
      clientNativeId: string
      commentsCount: number | null
      hahaReactions: number | null
      impressions: number | null
      impressionsFollower: number | null
      impressionsNonFollower: number | null
      impressionsNonViral: number | null
      impressionsOrganic: number | null
      impressionsPaid: number | null
      impressionsViral: number | null
      likes: number | null
      loveReactions: number | null
      postContentClicks: number | null
      postContentClicksOther: number | null
      postLinkClicks: number | null
      postNativeId: string
      postPhotoViewClicks: number | null
      postVideoPlayClicks: number | null
      questionAnswers: number | null
      reach: number | null
      reachFollower: number | null
      reachNonViral: number | null
      reachOrganic: number | null
      reachPaid: number | null
      reachViral: number | null
      reactions: number | null
      reportingDate: Date
      sadReactions: number | null
      sharesCount: number | null
      sproutSocialAccountId: string
      videoLength: number | null
      videoViews: number | null
      videoViewsAutoplay: number | null
      videoViewsOrganic: number | null
      videoViewsPaid: number | null
      wowReactions: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sproutFacebookPostAnalytics"]>
    composites: {}
  }

  type SproutFacebookPostAnalyticsGetPayload<S extends boolean | null | undefined | SproutFacebookPostAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload, S>

  type SproutFacebookPostAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SproutFacebookPostAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SproutFacebookPostAnalyticsCountAggregateInputType | true
    }

  export interface SproutFacebookPostAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SproutFacebookPostAnalytics'], meta: { name: 'SproutFacebookPostAnalytics' } }
    /**
     * Find zero or one SproutFacebookPostAnalytics that matches the filter.
     * @param {SproutFacebookPostAnalyticsFindUniqueArgs} args - Arguments to find a SproutFacebookPostAnalytics
     * @example
     * // Get one SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SproutFacebookPostAnalyticsFindUniqueArgs>(args: SelectSubset<T, SproutFacebookPostAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__SproutFacebookPostAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SproutFacebookPostAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SproutFacebookPostAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a SproutFacebookPostAnalytics
     * @example
     * // Get one SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SproutFacebookPostAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, SproutFacebookPostAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SproutFacebookPostAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutFacebookPostAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostAnalyticsFindFirstArgs} args - Arguments to find a SproutFacebookPostAnalytics
     * @example
     * // Get one SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SproutFacebookPostAnalyticsFindFirstArgs>(args?: SelectSubset<T, SproutFacebookPostAnalyticsFindFirstArgs<ExtArgs>>): Prisma__SproutFacebookPostAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutFacebookPostAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostAnalyticsFindFirstOrThrowArgs} args - Arguments to find a SproutFacebookPostAnalytics
     * @example
     * // Get one SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SproutFacebookPostAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, SproutFacebookPostAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SproutFacebookPostAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SproutFacebookPostAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.findMany()
     * 
     * // Get first 10 SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sproutFacebookPostAnalyticsWithIdOnly = await prisma.sproutFacebookPostAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SproutFacebookPostAnalyticsFindManyArgs>(args?: SelectSubset<T, SproutFacebookPostAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SproutFacebookPostAnalytics.
     * @param {SproutFacebookPostAnalyticsCreateArgs} args - Arguments to create a SproutFacebookPostAnalytics.
     * @example
     * // Create one SproutFacebookPostAnalytics
     * const SproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.create({
     *   data: {
     *     // ... data to create a SproutFacebookPostAnalytics
     *   }
     * })
     * 
     */
    create<T extends SproutFacebookPostAnalyticsCreateArgs>(args: SelectSubset<T, SproutFacebookPostAnalyticsCreateArgs<ExtArgs>>): Prisma__SproutFacebookPostAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SproutFacebookPostAnalytics.
     * @param {SproutFacebookPostAnalyticsCreateManyArgs} args - Arguments to create many SproutFacebookPostAnalytics.
     * @example
     * // Create many SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SproutFacebookPostAnalyticsCreateManyArgs>(args?: SelectSubset<T, SproutFacebookPostAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SproutFacebookPostAnalytics and returns the data saved in the database.
     * @param {SproutFacebookPostAnalyticsCreateManyAndReturnArgs} args - Arguments to create many SproutFacebookPostAnalytics.
     * @example
     * // Create many SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SproutFacebookPostAnalytics and only return the `id`
     * const sproutFacebookPostAnalyticsWithIdOnly = await prisma.sproutFacebookPostAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SproutFacebookPostAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, SproutFacebookPostAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SproutFacebookPostAnalytics.
     * @param {SproutFacebookPostAnalyticsDeleteArgs} args - Arguments to delete one SproutFacebookPostAnalytics.
     * @example
     * // Delete one SproutFacebookPostAnalytics
     * const SproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.delete({
     *   where: {
     *     // ... filter to delete one SproutFacebookPostAnalytics
     *   }
     * })
     * 
     */
    delete<T extends SproutFacebookPostAnalyticsDeleteArgs>(args: SelectSubset<T, SproutFacebookPostAnalyticsDeleteArgs<ExtArgs>>): Prisma__SproutFacebookPostAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SproutFacebookPostAnalytics.
     * @param {SproutFacebookPostAnalyticsUpdateArgs} args - Arguments to update one SproutFacebookPostAnalytics.
     * @example
     * // Update one SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SproutFacebookPostAnalyticsUpdateArgs>(args: SelectSubset<T, SproutFacebookPostAnalyticsUpdateArgs<ExtArgs>>): Prisma__SproutFacebookPostAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SproutFacebookPostAnalytics.
     * @param {SproutFacebookPostAnalyticsDeleteManyArgs} args - Arguments to filter SproutFacebookPostAnalytics to delete.
     * @example
     * // Delete a few SproutFacebookPostAnalytics
     * const { count } = await prisma.sproutFacebookPostAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SproutFacebookPostAnalyticsDeleteManyArgs>(args?: SelectSubset<T, SproutFacebookPostAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutFacebookPostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SproutFacebookPostAnalyticsUpdateManyArgs>(args: SelectSubset<T, SproutFacebookPostAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutFacebookPostAnalytics and returns the data updated in the database.
     * @param {SproutFacebookPostAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many SproutFacebookPostAnalytics.
     * @example
     * // Update many SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SproutFacebookPostAnalytics and only return the `id`
     * const sproutFacebookPostAnalyticsWithIdOnly = await prisma.sproutFacebookPostAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SproutFacebookPostAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, SproutFacebookPostAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SproutFacebookPostAnalytics.
     * @param {SproutFacebookPostAnalyticsUpsertArgs} args - Arguments to update or create a SproutFacebookPostAnalytics.
     * @example
     * // Update or create a SproutFacebookPostAnalytics
     * const sproutFacebookPostAnalytics = await prisma.sproutFacebookPostAnalytics.upsert({
     *   create: {
     *     // ... data to create a SproutFacebookPostAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SproutFacebookPostAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends SproutFacebookPostAnalyticsUpsertArgs>(args: SelectSubset<T, SproutFacebookPostAnalyticsUpsertArgs<ExtArgs>>): Prisma__SproutFacebookPostAnalyticsClient<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SproutFacebookPostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostAnalyticsCountArgs} args - Arguments to filter SproutFacebookPostAnalytics to count.
     * @example
     * // Count the number of SproutFacebookPostAnalytics
     * const count = await prisma.sproutFacebookPostAnalytics.count({
     *   where: {
     *     // ... the filter for the SproutFacebookPostAnalytics we want to count
     *   }
     * })
    **/
    count<T extends SproutFacebookPostAnalyticsCountArgs>(
      args?: Subset<T, SproutFacebookPostAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SproutFacebookPostAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SproutFacebookPostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SproutFacebookPostAnalyticsAggregateArgs>(args: Subset<T, SproutFacebookPostAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetSproutFacebookPostAnalyticsAggregateType<T>>

    /**
     * Group by SproutFacebookPostAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutFacebookPostAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SproutFacebookPostAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SproutFacebookPostAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: SproutFacebookPostAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SproutFacebookPostAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSproutFacebookPostAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SproutFacebookPostAnalytics model
   */
  readonly fields: SproutFacebookPostAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SproutFacebookPostAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SproutFacebookPostAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sproutSocialAccount<T extends SproutSocialAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccountDefaultArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SproutFacebookPostAnalytics model
   */
  interface SproutFacebookPostAnalyticsFieldRefs {
    readonly id: FieldRef<"SproutFacebookPostAnalytics", 'String'>
    readonly angryReactions: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly clientNativeId: FieldRef<"SproutFacebookPostAnalytics", 'String'>
    readonly commentsCount: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly hahaReactions: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly impressions: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly impressionsFollower: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly impressionsNonFollower: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly impressionsNonViral: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly impressionsOrganic: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly impressionsPaid: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly impressionsViral: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly likes: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly loveReactions: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly postContentClicks: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly postContentClicksOther: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly postLinkClicks: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly postNativeId: FieldRef<"SproutFacebookPostAnalytics", 'String'>
    readonly postPhotoViewClicks: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly postVideoPlayClicks: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly questionAnswers: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly reach: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly reachFollower: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly reachNonViral: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly reachOrganic: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly reachPaid: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly reachViral: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly reactions: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly reportingDate: FieldRef<"SproutFacebookPostAnalytics", 'DateTime'>
    readonly sadReactions: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly sharesCount: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly sproutSocialAccountId: FieldRef<"SproutFacebookPostAnalytics", 'String'>
    readonly videoLength: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly videoViews: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly videoViewsAutoplay: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly videoViewsOrganic: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly videoViewsPaid: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly wowReactions: FieldRef<"SproutFacebookPostAnalytics", 'Int'>
    readonly createdAt: FieldRef<"SproutFacebookPostAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"SproutFacebookPostAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SproutFacebookPostAnalytics findUnique
   */
  export type SproutFacebookPostAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookPostAnalytics to fetch.
     */
    where: SproutFacebookPostAnalyticsWhereUniqueInput
  }

  /**
   * SproutFacebookPostAnalytics findUniqueOrThrow
   */
  export type SproutFacebookPostAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookPostAnalytics to fetch.
     */
    where: SproutFacebookPostAnalyticsWhereUniqueInput
  }

  /**
   * SproutFacebookPostAnalytics findFirst
   */
  export type SproutFacebookPostAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookPostAnalytics to fetch.
     */
    where?: SproutFacebookPostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookPostAnalytics to fetch.
     */
    orderBy?: SproutFacebookPostAnalyticsOrderByWithRelationInput | SproutFacebookPostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutFacebookPostAnalytics.
     */
    cursor?: SproutFacebookPostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookPostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookPostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutFacebookPostAnalytics.
     */
    distinct?: SproutFacebookPostAnalyticsScalarFieldEnum | SproutFacebookPostAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutFacebookPostAnalytics findFirstOrThrow
   */
  export type SproutFacebookPostAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookPostAnalytics to fetch.
     */
    where?: SproutFacebookPostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookPostAnalytics to fetch.
     */
    orderBy?: SproutFacebookPostAnalyticsOrderByWithRelationInput | SproutFacebookPostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutFacebookPostAnalytics.
     */
    cursor?: SproutFacebookPostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookPostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookPostAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutFacebookPostAnalytics.
     */
    distinct?: SproutFacebookPostAnalyticsScalarFieldEnum | SproutFacebookPostAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutFacebookPostAnalytics findMany
   */
  export type SproutFacebookPostAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutFacebookPostAnalytics to fetch.
     */
    where?: SproutFacebookPostAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutFacebookPostAnalytics to fetch.
     */
    orderBy?: SproutFacebookPostAnalyticsOrderByWithRelationInput | SproutFacebookPostAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SproutFacebookPostAnalytics.
     */
    cursor?: SproutFacebookPostAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutFacebookPostAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutFacebookPostAnalytics.
     */
    skip?: number
    distinct?: SproutFacebookPostAnalyticsScalarFieldEnum | SproutFacebookPostAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutFacebookPostAnalytics create
   */
  export type SproutFacebookPostAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a SproutFacebookPostAnalytics.
     */
    data: XOR<SproutFacebookPostAnalyticsCreateInput, SproutFacebookPostAnalyticsUncheckedCreateInput>
  }

  /**
   * SproutFacebookPostAnalytics createMany
   */
  export type SproutFacebookPostAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SproutFacebookPostAnalytics.
     */
    data: SproutFacebookPostAnalyticsCreateManyInput | SproutFacebookPostAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SproutFacebookPostAnalytics createManyAndReturn
   */
  export type SproutFacebookPostAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many SproutFacebookPostAnalytics.
     */
    data: SproutFacebookPostAnalyticsCreateManyInput | SproutFacebookPostAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutFacebookPostAnalytics update
   */
  export type SproutFacebookPostAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a SproutFacebookPostAnalytics.
     */
    data: XOR<SproutFacebookPostAnalyticsUpdateInput, SproutFacebookPostAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which SproutFacebookPostAnalytics to update.
     */
    where: SproutFacebookPostAnalyticsWhereUniqueInput
  }

  /**
   * SproutFacebookPostAnalytics updateMany
   */
  export type SproutFacebookPostAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SproutFacebookPostAnalytics.
     */
    data: XOR<SproutFacebookPostAnalyticsUpdateManyMutationInput, SproutFacebookPostAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SproutFacebookPostAnalytics to update
     */
    where?: SproutFacebookPostAnalyticsWhereInput
    /**
     * Limit how many SproutFacebookPostAnalytics to update.
     */
    limit?: number
  }

  /**
   * SproutFacebookPostAnalytics updateManyAndReturn
   */
  export type SproutFacebookPostAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update SproutFacebookPostAnalytics.
     */
    data: XOR<SproutFacebookPostAnalyticsUpdateManyMutationInput, SproutFacebookPostAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SproutFacebookPostAnalytics to update
     */
    where?: SproutFacebookPostAnalyticsWhereInput
    /**
     * Limit how many SproutFacebookPostAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutFacebookPostAnalytics upsert
   */
  export type SproutFacebookPostAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the SproutFacebookPostAnalytics to update in case it exists.
     */
    where: SproutFacebookPostAnalyticsWhereUniqueInput
    /**
     * In case the SproutFacebookPostAnalytics found by the `where` argument doesn't exist, create a new SproutFacebookPostAnalytics with this data.
     */
    create: XOR<SproutFacebookPostAnalyticsCreateInput, SproutFacebookPostAnalyticsUncheckedCreateInput>
    /**
     * In case the SproutFacebookPostAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SproutFacebookPostAnalyticsUpdateInput, SproutFacebookPostAnalyticsUncheckedUpdateInput>
  }

  /**
   * SproutFacebookPostAnalytics delete
   */
  export type SproutFacebookPostAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which SproutFacebookPostAnalytics to delete.
     */
    where: SproutFacebookPostAnalyticsWhereUniqueInput
  }

  /**
   * SproutFacebookPostAnalytics deleteMany
   */
  export type SproutFacebookPostAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutFacebookPostAnalytics to delete
     */
    where?: SproutFacebookPostAnalyticsWhereInput
    /**
     * Limit how many SproutFacebookPostAnalytics to delete.
     */
    limit?: number
  }

  /**
   * SproutFacebookPostAnalytics without action
   */
  export type SproutFacebookPostAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model SproutInstagramAnalytics
   */

  export type AggregateSproutInstagramAnalytics = {
    _count: SproutInstagramAnalyticsCountAggregateOutputType | null
    _avg: SproutInstagramAnalyticsAvgAggregateOutputType | null
    _sum: SproutInstagramAnalyticsSumAggregateOutputType | null
    _min: SproutInstagramAnalyticsMinAggregateOutputType | null
    _max: SproutInstagramAnalyticsMaxAggregateOutputType | null
  }

  export type SproutInstagramAnalyticsAvgAggregateOutputType = {
    customerProfileId: number | null
    commentsCount: number | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    likes: number | null
    saves: number | null
    videoViews: number | null
    emailContacts: number | null
    getDirectionsClicks: number | null
    phoneCallClicks: number | null
    postsSentCount: number | null
    profileFollowerAdds: number | null
    profileFollowers: number | null
    profileImpressionsUnique: number | null
    profileReachUnique: number | null
    profileViews: number | null
    profileViewsUnique: number | null
    websiteClicks: number | null
  }

  export type SproutInstagramAnalyticsSumAggregateOutputType = {
    customerProfileId: number | null
    commentsCount: number | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    likes: number | null
    saves: number | null
    videoViews: number | null
    emailContacts: number | null
    getDirectionsClicks: number | null
    phoneCallClicks: number | null
    postsSentCount: number | null
    profileFollowerAdds: number | null
    profileFollowers: number | null
    profileImpressionsUnique: number | null
    profileReachUnique: number | null
    profileViews: number | null
    profileViewsUnique: number | null
    websiteClicks: number | null
  }

  export type SproutInstagramAnalyticsMinAggregateOutputType = {
    id: string | null
    sproutSocialAccountId: string | null
    customerProfileId: number | null
    reportingDate: Date | null
    commentsCount: number | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    likes: number | null
    saves: number | null
    videoViews: number | null
    createdAt: Date | null
    updatedAt: Date | null
    emailContacts: number | null
    getDirectionsClicks: number | null
    phoneCallClicks: number | null
    postsSentCount: number | null
    profileFollowerAdds: number | null
    profileFollowers: number | null
    profileImpressionsUnique: number | null
    profileReachUnique: number | null
    profileViews: number | null
    profileViewsUnique: number | null
    websiteClicks: number | null
  }

  export type SproutInstagramAnalyticsMaxAggregateOutputType = {
    id: string | null
    sproutSocialAccountId: string | null
    customerProfileId: number | null
    reportingDate: Date | null
    commentsCount: number | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    likes: number | null
    saves: number | null
    videoViews: number | null
    createdAt: Date | null
    updatedAt: Date | null
    emailContacts: number | null
    getDirectionsClicks: number | null
    phoneCallClicks: number | null
    postsSentCount: number | null
    profileFollowerAdds: number | null
    profileFollowers: number | null
    profileImpressionsUnique: number | null
    profileReachUnique: number | null
    profileViews: number | null
    profileViewsUnique: number | null
    websiteClicks: number | null
  }

  export type SproutInstagramAnalyticsCountAggregateOutputType = {
    id: number
    sproutSocialAccountId: number
    customerProfileId: number
    reportingDate: number
    commentsCount: number
    engagements: number
    impressions: number
    impressionsUnique: number
    followersCount: number
    likes: number
    saves: number
    videoViews: number
    createdAt: number
    updatedAt: number
    emailContacts: number
    getDirectionsClicks: number
    phoneCallClicks: number
    postsSendByContentType: number
    postsSentByPostType: number
    postsSentCount: number
    profileFollowerAdds: number
    profileFollowers: number
    profileImpressionsUnique: number
    profileReachUnique: number
    profileViews: number
    profileViewsUnique: number
    websiteClicks: number
    _all: number
  }


  export type SproutInstagramAnalyticsAvgAggregateInputType = {
    customerProfileId?: true
    commentsCount?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    likes?: true
    saves?: true
    videoViews?: true
    emailContacts?: true
    getDirectionsClicks?: true
    phoneCallClicks?: true
    postsSentCount?: true
    profileFollowerAdds?: true
    profileFollowers?: true
    profileImpressionsUnique?: true
    profileReachUnique?: true
    profileViews?: true
    profileViewsUnique?: true
    websiteClicks?: true
  }

  export type SproutInstagramAnalyticsSumAggregateInputType = {
    customerProfileId?: true
    commentsCount?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    likes?: true
    saves?: true
    videoViews?: true
    emailContacts?: true
    getDirectionsClicks?: true
    phoneCallClicks?: true
    postsSentCount?: true
    profileFollowerAdds?: true
    profileFollowers?: true
    profileImpressionsUnique?: true
    profileReachUnique?: true
    profileViews?: true
    profileViewsUnique?: true
    websiteClicks?: true
  }

  export type SproutInstagramAnalyticsMinAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    commentsCount?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    likes?: true
    saves?: true
    videoViews?: true
    createdAt?: true
    updatedAt?: true
    emailContacts?: true
    getDirectionsClicks?: true
    phoneCallClicks?: true
    postsSentCount?: true
    profileFollowerAdds?: true
    profileFollowers?: true
    profileImpressionsUnique?: true
    profileReachUnique?: true
    profileViews?: true
    profileViewsUnique?: true
    websiteClicks?: true
  }

  export type SproutInstagramAnalyticsMaxAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    commentsCount?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    likes?: true
    saves?: true
    videoViews?: true
    createdAt?: true
    updatedAt?: true
    emailContacts?: true
    getDirectionsClicks?: true
    phoneCallClicks?: true
    postsSentCount?: true
    profileFollowerAdds?: true
    profileFollowers?: true
    profileImpressionsUnique?: true
    profileReachUnique?: true
    profileViews?: true
    profileViewsUnique?: true
    websiteClicks?: true
  }

  export type SproutInstagramAnalyticsCountAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    commentsCount?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    likes?: true
    saves?: true
    videoViews?: true
    createdAt?: true
    updatedAt?: true
    emailContacts?: true
    getDirectionsClicks?: true
    phoneCallClicks?: true
    postsSendByContentType?: true
    postsSentByPostType?: true
    postsSentCount?: true
    profileFollowerAdds?: true
    profileFollowers?: true
    profileImpressionsUnique?: true
    profileReachUnique?: true
    profileViews?: true
    profileViewsUnique?: true
    websiteClicks?: true
    _all?: true
  }

  export type SproutInstagramAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutInstagramAnalytics to aggregate.
     */
    where?: SproutInstagramAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramAnalytics to fetch.
     */
    orderBy?: SproutInstagramAnalyticsOrderByWithRelationInput | SproutInstagramAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SproutInstagramAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SproutInstagramAnalytics
    **/
    _count?: true | SproutInstagramAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SproutInstagramAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SproutInstagramAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SproutInstagramAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SproutInstagramAnalyticsMaxAggregateInputType
  }

  export type GetSproutInstagramAnalyticsAggregateType<T extends SproutInstagramAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateSproutInstagramAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSproutInstagramAnalytics[P]>
      : GetScalarType<T[P], AggregateSproutInstagramAnalytics[P]>
  }




  export type SproutInstagramAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutInstagramAnalyticsWhereInput
    orderBy?: SproutInstagramAnalyticsOrderByWithAggregationInput | SproutInstagramAnalyticsOrderByWithAggregationInput[]
    by: SproutInstagramAnalyticsScalarFieldEnum[] | SproutInstagramAnalyticsScalarFieldEnum
    having?: SproutInstagramAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SproutInstagramAnalyticsCountAggregateInputType | true
    _avg?: SproutInstagramAnalyticsAvgAggregateInputType
    _sum?: SproutInstagramAnalyticsSumAggregateInputType
    _min?: SproutInstagramAnalyticsMinAggregateInputType
    _max?: SproutInstagramAnalyticsMaxAggregateInputType
  }

  export type SproutInstagramAnalyticsGroupByOutputType = {
    id: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date
    commentsCount: number | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    likes: number | null
    saves: number | null
    videoViews: number | null
    createdAt: Date
    updatedAt: Date
    emailContacts: number | null
    getDirectionsClicks: number | null
    phoneCallClicks: number | null
    postsSendByContentType: JsonValue | null
    postsSentByPostType: JsonValue | null
    postsSentCount: number | null
    profileFollowerAdds: number | null
    profileFollowers: number | null
    profileImpressionsUnique: number | null
    profileReachUnique: number | null
    profileViews: number | null
    profileViewsUnique: number | null
    websiteClicks: number | null
    _count: SproutInstagramAnalyticsCountAggregateOutputType | null
    _avg: SproutInstagramAnalyticsAvgAggregateOutputType | null
    _sum: SproutInstagramAnalyticsSumAggregateOutputType | null
    _min: SproutInstagramAnalyticsMinAggregateOutputType | null
    _max: SproutInstagramAnalyticsMaxAggregateOutputType | null
  }

  type GetSproutInstagramAnalyticsGroupByPayload<T extends SproutInstagramAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SproutInstagramAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SproutInstagramAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SproutInstagramAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], SproutInstagramAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type SproutInstagramAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    commentsCount?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    likes?: boolean
    saves?: boolean
    videoViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailContacts?: boolean
    getDirectionsClicks?: boolean
    phoneCallClicks?: boolean
    postsSendByContentType?: boolean
    postsSentByPostType?: boolean
    postsSentCount?: boolean
    profileFollowerAdds?: boolean
    profileFollowers?: boolean
    profileImpressionsUnique?: boolean
    profileReachUnique?: boolean
    profileViews?: boolean
    profileViewsUnique?: boolean
    websiteClicks?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
    followersByCity?: boolean | SproutInstagramAnalytics$followersByCityArgs<ExtArgs>
    followersByCountry?: boolean | SproutInstagramAnalytics$followersByCountryArgs<ExtArgs>
    _count?: boolean | SproutInstagramAnalyticsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutInstagramAnalytics"]>

  export type SproutInstagramAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    commentsCount?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    likes?: boolean
    saves?: boolean
    videoViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailContacts?: boolean
    getDirectionsClicks?: boolean
    phoneCallClicks?: boolean
    postsSendByContentType?: boolean
    postsSentByPostType?: boolean
    postsSentCount?: boolean
    profileFollowerAdds?: boolean
    profileFollowers?: boolean
    profileImpressionsUnique?: boolean
    profileReachUnique?: boolean
    profileViews?: boolean
    profileViewsUnique?: boolean
    websiteClicks?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutInstagramAnalytics"]>

  export type SproutInstagramAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    commentsCount?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    likes?: boolean
    saves?: boolean
    videoViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailContacts?: boolean
    getDirectionsClicks?: boolean
    phoneCallClicks?: boolean
    postsSendByContentType?: boolean
    postsSentByPostType?: boolean
    postsSentCount?: boolean
    profileFollowerAdds?: boolean
    profileFollowers?: boolean
    profileImpressionsUnique?: boolean
    profileReachUnique?: boolean
    profileViews?: boolean
    profileViewsUnique?: boolean
    websiteClicks?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutInstagramAnalytics"]>

  export type SproutInstagramAnalyticsSelectScalar = {
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    commentsCount?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    likes?: boolean
    saves?: boolean
    videoViews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailContacts?: boolean
    getDirectionsClicks?: boolean
    phoneCallClicks?: boolean
    postsSendByContentType?: boolean
    postsSentByPostType?: boolean
    postsSentCount?: boolean
    profileFollowerAdds?: boolean
    profileFollowers?: boolean
    profileImpressionsUnique?: boolean
    profileReachUnique?: boolean
    profileViews?: boolean
    profileViewsUnique?: boolean
    websiteClicks?: boolean
  }

  export type SproutInstagramAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sproutSocialAccountId" | "customerProfileId" | "reportingDate" | "commentsCount" | "engagements" | "impressions" | "impressionsUnique" | "followersCount" | "likes" | "saves" | "videoViews" | "createdAt" | "updatedAt" | "emailContacts" | "getDirectionsClicks" | "phoneCallClicks" | "postsSendByContentType" | "postsSentByPostType" | "postsSentCount" | "profileFollowerAdds" | "profileFollowers" | "profileImpressionsUnique" | "profileReachUnique" | "profileViews" | "profileViewsUnique" | "websiteClicks", ExtArgs["result"]["sproutInstagramAnalytics"]>
  export type SproutInstagramAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
    followersByCity?: boolean | SproutInstagramAnalytics$followersByCityArgs<ExtArgs>
    followersByCountry?: boolean | SproutInstagramAnalytics$followersByCountryArgs<ExtArgs>
    _count?: boolean | SproutInstagramAnalyticsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SproutInstagramAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }
  export type SproutInstagramAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }

  export type $SproutInstagramAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SproutInstagramAnalytics"
    objects: {
      sproutSocialAccount: Prisma.$SproutSocialAccountPayload<ExtArgs>
      followersByCity: Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>[]
      followersByCountry: Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sproutSocialAccountId: string
      customerProfileId: number
      reportingDate: Date
      commentsCount: number | null
      engagements: number | null
      impressions: number | null
      impressionsUnique: number | null
      followersCount: number | null
      likes: number | null
      saves: number | null
      videoViews: number | null
      createdAt: Date
      updatedAt: Date
      emailContacts: number | null
      getDirectionsClicks: number | null
      phoneCallClicks: number | null
      postsSendByContentType: Prisma.JsonValue | null
      postsSentByPostType: Prisma.JsonValue | null
      postsSentCount: number | null
      profileFollowerAdds: number | null
      profileFollowers: number | null
      profileImpressionsUnique: number | null
      profileReachUnique: number | null
      profileViews: number | null
      profileViewsUnique: number | null
      websiteClicks: number | null
    }, ExtArgs["result"]["sproutInstagramAnalytics"]>
    composites: {}
  }

  type SproutInstagramAnalyticsGetPayload<S extends boolean | null | undefined | SproutInstagramAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload, S>

  type SproutInstagramAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SproutInstagramAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SproutInstagramAnalyticsCountAggregateInputType | true
    }

  export interface SproutInstagramAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SproutInstagramAnalytics'], meta: { name: 'SproutInstagramAnalytics' } }
    /**
     * Find zero or one SproutInstagramAnalytics that matches the filter.
     * @param {SproutInstagramAnalyticsFindUniqueArgs} args - Arguments to find a SproutInstagramAnalytics
     * @example
     * // Get one SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SproutInstagramAnalyticsFindUniqueArgs>(args: SelectSubset<T, SproutInstagramAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__SproutInstagramAnalyticsClient<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SproutInstagramAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SproutInstagramAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a SproutInstagramAnalytics
     * @example
     * // Get one SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SproutInstagramAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, SproutInstagramAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SproutInstagramAnalyticsClient<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutInstagramAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramAnalyticsFindFirstArgs} args - Arguments to find a SproutInstagramAnalytics
     * @example
     * // Get one SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SproutInstagramAnalyticsFindFirstArgs>(args?: SelectSubset<T, SproutInstagramAnalyticsFindFirstArgs<ExtArgs>>): Prisma__SproutInstagramAnalyticsClient<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutInstagramAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramAnalyticsFindFirstOrThrowArgs} args - Arguments to find a SproutInstagramAnalytics
     * @example
     * // Get one SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SproutInstagramAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, SproutInstagramAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SproutInstagramAnalyticsClient<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SproutInstagramAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.findMany()
     * 
     * // Get first 10 SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sproutInstagramAnalyticsWithIdOnly = await prisma.sproutInstagramAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SproutInstagramAnalyticsFindManyArgs>(args?: SelectSubset<T, SproutInstagramAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SproutInstagramAnalytics.
     * @param {SproutInstagramAnalyticsCreateArgs} args - Arguments to create a SproutInstagramAnalytics.
     * @example
     * // Create one SproutInstagramAnalytics
     * const SproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.create({
     *   data: {
     *     // ... data to create a SproutInstagramAnalytics
     *   }
     * })
     * 
     */
    create<T extends SproutInstagramAnalyticsCreateArgs>(args: SelectSubset<T, SproutInstagramAnalyticsCreateArgs<ExtArgs>>): Prisma__SproutInstagramAnalyticsClient<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SproutInstagramAnalytics.
     * @param {SproutInstagramAnalyticsCreateManyArgs} args - Arguments to create many SproutInstagramAnalytics.
     * @example
     * // Create many SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SproutInstagramAnalyticsCreateManyArgs>(args?: SelectSubset<T, SproutInstagramAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SproutInstagramAnalytics and returns the data saved in the database.
     * @param {SproutInstagramAnalyticsCreateManyAndReturnArgs} args - Arguments to create many SproutInstagramAnalytics.
     * @example
     * // Create many SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SproutInstagramAnalytics and only return the `id`
     * const sproutInstagramAnalyticsWithIdOnly = await prisma.sproutInstagramAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SproutInstagramAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, SproutInstagramAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SproutInstagramAnalytics.
     * @param {SproutInstagramAnalyticsDeleteArgs} args - Arguments to delete one SproutInstagramAnalytics.
     * @example
     * // Delete one SproutInstagramAnalytics
     * const SproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.delete({
     *   where: {
     *     // ... filter to delete one SproutInstagramAnalytics
     *   }
     * })
     * 
     */
    delete<T extends SproutInstagramAnalyticsDeleteArgs>(args: SelectSubset<T, SproutInstagramAnalyticsDeleteArgs<ExtArgs>>): Prisma__SproutInstagramAnalyticsClient<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SproutInstagramAnalytics.
     * @param {SproutInstagramAnalyticsUpdateArgs} args - Arguments to update one SproutInstagramAnalytics.
     * @example
     * // Update one SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SproutInstagramAnalyticsUpdateArgs>(args: SelectSubset<T, SproutInstagramAnalyticsUpdateArgs<ExtArgs>>): Prisma__SproutInstagramAnalyticsClient<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SproutInstagramAnalytics.
     * @param {SproutInstagramAnalyticsDeleteManyArgs} args - Arguments to filter SproutInstagramAnalytics to delete.
     * @example
     * // Delete a few SproutInstagramAnalytics
     * const { count } = await prisma.sproutInstagramAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SproutInstagramAnalyticsDeleteManyArgs>(args?: SelectSubset<T, SproutInstagramAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutInstagramAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SproutInstagramAnalyticsUpdateManyArgs>(args: SelectSubset<T, SproutInstagramAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutInstagramAnalytics and returns the data updated in the database.
     * @param {SproutInstagramAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many SproutInstagramAnalytics.
     * @example
     * // Update many SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SproutInstagramAnalytics and only return the `id`
     * const sproutInstagramAnalyticsWithIdOnly = await prisma.sproutInstagramAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SproutInstagramAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, SproutInstagramAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SproutInstagramAnalytics.
     * @param {SproutInstagramAnalyticsUpsertArgs} args - Arguments to update or create a SproutInstagramAnalytics.
     * @example
     * // Update or create a SproutInstagramAnalytics
     * const sproutInstagramAnalytics = await prisma.sproutInstagramAnalytics.upsert({
     *   create: {
     *     // ... data to create a SproutInstagramAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SproutInstagramAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends SproutInstagramAnalyticsUpsertArgs>(args: SelectSubset<T, SproutInstagramAnalyticsUpsertArgs<ExtArgs>>): Prisma__SproutInstagramAnalyticsClient<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SproutInstagramAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramAnalyticsCountArgs} args - Arguments to filter SproutInstagramAnalytics to count.
     * @example
     * // Count the number of SproutInstagramAnalytics
     * const count = await prisma.sproutInstagramAnalytics.count({
     *   where: {
     *     // ... the filter for the SproutInstagramAnalytics we want to count
     *   }
     * })
    **/
    count<T extends SproutInstagramAnalyticsCountArgs>(
      args?: Subset<T, SproutInstagramAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SproutInstagramAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SproutInstagramAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SproutInstagramAnalyticsAggregateArgs>(args: Subset<T, SproutInstagramAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetSproutInstagramAnalyticsAggregateType<T>>

    /**
     * Group by SproutInstagramAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SproutInstagramAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SproutInstagramAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: SproutInstagramAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SproutInstagramAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSproutInstagramAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SproutInstagramAnalytics model
   */
  readonly fields: SproutInstagramAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SproutInstagramAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SproutInstagramAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sproutSocialAccount<T extends SproutSocialAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccountDefaultArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    followersByCity<T extends SproutInstagramAnalytics$followersByCityArgs<ExtArgs> = {}>(args?: Subset<T, SproutInstagramAnalytics$followersByCityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followersByCountry<T extends SproutInstagramAnalytics$followersByCountryArgs<ExtArgs> = {}>(args?: Subset<T, SproutInstagramAnalytics$followersByCountryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SproutInstagramAnalytics model
   */
  interface SproutInstagramAnalyticsFieldRefs {
    readonly id: FieldRef<"SproutInstagramAnalytics", 'String'>
    readonly sproutSocialAccountId: FieldRef<"SproutInstagramAnalytics", 'String'>
    readonly customerProfileId: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly reportingDate: FieldRef<"SproutInstagramAnalytics", 'DateTime'>
    readonly commentsCount: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly engagements: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly impressions: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly impressionsUnique: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly followersCount: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly likes: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly saves: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly videoViews: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly createdAt: FieldRef<"SproutInstagramAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"SproutInstagramAnalytics", 'DateTime'>
    readonly emailContacts: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly getDirectionsClicks: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly phoneCallClicks: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly postsSendByContentType: FieldRef<"SproutInstagramAnalytics", 'Json'>
    readonly postsSentByPostType: FieldRef<"SproutInstagramAnalytics", 'Json'>
    readonly postsSentCount: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly profileFollowerAdds: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly profileFollowers: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly profileImpressionsUnique: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly profileReachUnique: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly profileViews: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly profileViewsUnique: FieldRef<"SproutInstagramAnalytics", 'Int'>
    readonly websiteClicks: FieldRef<"SproutInstagramAnalytics", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SproutInstagramAnalytics findUnique
   */
  export type SproutInstagramAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramAnalytics to fetch.
     */
    where: SproutInstagramAnalyticsWhereUniqueInput
  }

  /**
   * SproutInstagramAnalytics findUniqueOrThrow
   */
  export type SproutInstagramAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramAnalytics to fetch.
     */
    where: SproutInstagramAnalyticsWhereUniqueInput
  }

  /**
   * SproutInstagramAnalytics findFirst
   */
  export type SproutInstagramAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramAnalytics to fetch.
     */
    where?: SproutInstagramAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramAnalytics to fetch.
     */
    orderBy?: SproutInstagramAnalyticsOrderByWithRelationInput | SproutInstagramAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutInstagramAnalytics.
     */
    cursor?: SproutInstagramAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutInstagramAnalytics.
     */
    distinct?: SproutInstagramAnalyticsScalarFieldEnum | SproutInstagramAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutInstagramAnalytics findFirstOrThrow
   */
  export type SproutInstagramAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramAnalytics to fetch.
     */
    where?: SproutInstagramAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramAnalytics to fetch.
     */
    orderBy?: SproutInstagramAnalyticsOrderByWithRelationInput | SproutInstagramAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutInstagramAnalytics.
     */
    cursor?: SproutInstagramAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutInstagramAnalytics.
     */
    distinct?: SproutInstagramAnalyticsScalarFieldEnum | SproutInstagramAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutInstagramAnalytics findMany
   */
  export type SproutInstagramAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramAnalytics to fetch.
     */
    where?: SproutInstagramAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramAnalytics to fetch.
     */
    orderBy?: SproutInstagramAnalyticsOrderByWithRelationInput | SproutInstagramAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SproutInstagramAnalytics.
     */
    cursor?: SproutInstagramAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramAnalytics.
     */
    skip?: number
    distinct?: SproutInstagramAnalyticsScalarFieldEnum | SproutInstagramAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutInstagramAnalytics create
   */
  export type SproutInstagramAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a SproutInstagramAnalytics.
     */
    data: XOR<SproutInstagramAnalyticsCreateInput, SproutInstagramAnalyticsUncheckedCreateInput>
  }

  /**
   * SproutInstagramAnalytics createMany
   */
  export type SproutInstagramAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SproutInstagramAnalytics.
     */
    data: SproutInstagramAnalyticsCreateManyInput | SproutInstagramAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SproutInstagramAnalytics createManyAndReturn
   */
  export type SproutInstagramAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many SproutInstagramAnalytics.
     */
    data: SproutInstagramAnalyticsCreateManyInput | SproutInstagramAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutInstagramAnalytics update
   */
  export type SproutInstagramAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a SproutInstagramAnalytics.
     */
    data: XOR<SproutInstagramAnalyticsUpdateInput, SproutInstagramAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which SproutInstagramAnalytics to update.
     */
    where: SproutInstagramAnalyticsWhereUniqueInput
  }

  /**
   * SproutInstagramAnalytics updateMany
   */
  export type SproutInstagramAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SproutInstagramAnalytics.
     */
    data: XOR<SproutInstagramAnalyticsUpdateManyMutationInput, SproutInstagramAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SproutInstagramAnalytics to update
     */
    where?: SproutInstagramAnalyticsWhereInput
    /**
     * Limit how many SproutInstagramAnalytics to update.
     */
    limit?: number
  }

  /**
   * SproutInstagramAnalytics updateManyAndReturn
   */
  export type SproutInstagramAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update SproutInstagramAnalytics.
     */
    data: XOR<SproutInstagramAnalyticsUpdateManyMutationInput, SproutInstagramAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SproutInstagramAnalytics to update
     */
    where?: SproutInstagramAnalyticsWhereInput
    /**
     * Limit how many SproutInstagramAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutInstagramAnalytics upsert
   */
  export type SproutInstagramAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the SproutInstagramAnalytics to update in case it exists.
     */
    where: SproutInstagramAnalyticsWhereUniqueInput
    /**
     * In case the SproutInstagramAnalytics found by the `where` argument doesn't exist, create a new SproutInstagramAnalytics with this data.
     */
    create: XOR<SproutInstagramAnalyticsCreateInput, SproutInstagramAnalyticsUncheckedCreateInput>
    /**
     * In case the SproutInstagramAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SproutInstagramAnalyticsUpdateInput, SproutInstagramAnalyticsUncheckedUpdateInput>
  }

  /**
   * SproutInstagramAnalytics delete
   */
  export type SproutInstagramAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which SproutInstagramAnalytics to delete.
     */
    where: SproutInstagramAnalyticsWhereUniqueInput
  }

  /**
   * SproutInstagramAnalytics deleteMany
   */
  export type SproutInstagramAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutInstagramAnalytics to delete
     */
    where?: SproutInstagramAnalyticsWhereInput
    /**
     * Limit how many SproutInstagramAnalytics to delete.
     */
    limit?: number
  }

  /**
   * SproutInstagramAnalytics.followersByCity
   */
  export type SproutInstagramAnalytics$followersByCityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityInclude<ExtArgs> | null
    where?: SproutInstagramFollowersByCityWhereInput
    orderBy?: SproutInstagramFollowersByCityOrderByWithRelationInput | SproutInstagramFollowersByCityOrderByWithRelationInput[]
    cursor?: SproutInstagramFollowersByCityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SproutInstagramFollowersByCityScalarFieldEnum | SproutInstagramFollowersByCityScalarFieldEnum[]
  }

  /**
   * SproutInstagramAnalytics.followersByCountry
   */
  export type SproutInstagramAnalytics$followersByCountryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryInclude<ExtArgs> | null
    where?: SproutInstagramFollowersByCountryWhereInput
    orderBy?: SproutInstagramFollowersByCountryOrderByWithRelationInput | SproutInstagramFollowersByCountryOrderByWithRelationInput[]
    cursor?: SproutInstagramFollowersByCountryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SproutInstagramFollowersByCountryScalarFieldEnum | SproutInstagramFollowersByCountryScalarFieldEnum[]
  }

  /**
   * SproutInstagramAnalytics without action
   */
  export type SproutInstagramAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model SproutInstagramFollowersByCity
   */

  export type AggregateSproutInstagramFollowersByCity = {
    _count: SproutInstagramFollowersByCityCountAggregateOutputType | null
    _avg: SproutInstagramFollowersByCityAvgAggregateOutputType | null
    _sum: SproutInstagramFollowersByCitySumAggregateOutputType | null
    _min: SproutInstagramFollowersByCityMinAggregateOutputType | null
    _max: SproutInstagramFollowersByCityMaxAggregateOutputType | null
  }

  export type SproutInstagramFollowersByCityAvgAggregateOutputType = {
    count: number | null
  }

  export type SproutInstagramFollowersByCitySumAggregateOutputType = {
    count: number | null
  }

  export type SproutInstagramFollowersByCityMinAggregateOutputType = {
    id: string | null
    sproutInstagramAnalyticsId: string | null
    city: string | null
    count: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutInstagramFollowersByCityMaxAggregateOutputType = {
    id: string | null
    sproutInstagramAnalyticsId: string | null
    city: string | null
    count: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutInstagramFollowersByCityCountAggregateOutputType = {
    id: number
    sproutInstagramAnalyticsId: number
    city: number
    count: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SproutInstagramFollowersByCityAvgAggregateInputType = {
    count?: true
  }

  export type SproutInstagramFollowersByCitySumAggregateInputType = {
    count?: true
  }

  export type SproutInstagramFollowersByCityMinAggregateInputType = {
    id?: true
    sproutInstagramAnalyticsId?: true
    city?: true
    count?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutInstagramFollowersByCityMaxAggregateInputType = {
    id?: true
    sproutInstagramAnalyticsId?: true
    city?: true
    count?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutInstagramFollowersByCityCountAggregateInputType = {
    id?: true
    sproutInstagramAnalyticsId?: true
    city?: true
    count?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SproutInstagramFollowersByCityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutInstagramFollowersByCity to aggregate.
     */
    where?: SproutInstagramFollowersByCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramFollowersByCities to fetch.
     */
    orderBy?: SproutInstagramFollowersByCityOrderByWithRelationInput | SproutInstagramFollowersByCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SproutInstagramFollowersByCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramFollowersByCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramFollowersByCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SproutInstagramFollowersByCities
    **/
    _count?: true | SproutInstagramFollowersByCityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SproutInstagramFollowersByCityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SproutInstagramFollowersByCitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SproutInstagramFollowersByCityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SproutInstagramFollowersByCityMaxAggregateInputType
  }

  export type GetSproutInstagramFollowersByCityAggregateType<T extends SproutInstagramFollowersByCityAggregateArgs> = {
        [P in keyof T & keyof AggregateSproutInstagramFollowersByCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSproutInstagramFollowersByCity[P]>
      : GetScalarType<T[P], AggregateSproutInstagramFollowersByCity[P]>
  }




  export type SproutInstagramFollowersByCityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutInstagramFollowersByCityWhereInput
    orderBy?: SproutInstagramFollowersByCityOrderByWithAggregationInput | SproutInstagramFollowersByCityOrderByWithAggregationInput[]
    by: SproutInstagramFollowersByCityScalarFieldEnum[] | SproutInstagramFollowersByCityScalarFieldEnum
    having?: SproutInstagramFollowersByCityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SproutInstagramFollowersByCityCountAggregateInputType | true
    _avg?: SproutInstagramFollowersByCityAvgAggregateInputType
    _sum?: SproutInstagramFollowersByCitySumAggregateInputType
    _min?: SproutInstagramFollowersByCityMinAggregateInputType
    _max?: SproutInstagramFollowersByCityMaxAggregateInputType
  }

  export type SproutInstagramFollowersByCityGroupByOutputType = {
    id: string
    sproutInstagramAnalyticsId: string
    city: string
    count: number
    createdAt: Date
    updatedAt: Date
    _count: SproutInstagramFollowersByCityCountAggregateOutputType | null
    _avg: SproutInstagramFollowersByCityAvgAggregateOutputType | null
    _sum: SproutInstagramFollowersByCitySumAggregateOutputType | null
    _min: SproutInstagramFollowersByCityMinAggregateOutputType | null
    _max: SproutInstagramFollowersByCityMaxAggregateOutputType | null
  }

  type GetSproutInstagramFollowersByCityGroupByPayload<T extends SproutInstagramFollowersByCityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SproutInstagramFollowersByCityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SproutInstagramFollowersByCityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SproutInstagramFollowersByCityGroupByOutputType[P]>
            : GetScalarType<T[P], SproutInstagramFollowersByCityGroupByOutputType[P]>
        }
      >
    >


  export type SproutInstagramFollowersByCitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutInstagramAnalyticsId?: boolean
    city?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutInstagramFollowersByCity"]>

  export type SproutInstagramFollowersByCitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutInstagramAnalyticsId?: boolean
    city?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutInstagramFollowersByCity"]>

  export type SproutInstagramFollowersByCitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutInstagramAnalyticsId?: boolean
    city?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutInstagramFollowersByCity"]>

  export type SproutInstagramFollowersByCitySelectScalar = {
    id?: boolean
    sproutInstagramAnalyticsId?: boolean
    city?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SproutInstagramFollowersByCityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sproutInstagramAnalyticsId" | "city" | "count" | "createdAt" | "updatedAt", ExtArgs["result"]["sproutInstagramFollowersByCity"]>
  export type SproutInstagramFollowersByCityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }
  export type SproutInstagramFollowersByCityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }
  export type SproutInstagramFollowersByCityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }

  export type $SproutInstagramFollowersByCityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SproutInstagramFollowersByCity"
    objects: {
      sproutInstagramAnalytics: Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sproutInstagramAnalyticsId: string
      city: string
      count: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sproutInstagramFollowersByCity"]>
    composites: {}
  }

  type SproutInstagramFollowersByCityGetPayload<S extends boolean | null | undefined | SproutInstagramFollowersByCityDefaultArgs> = $Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload, S>

  type SproutInstagramFollowersByCityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SproutInstagramFollowersByCityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SproutInstagramFollowersByCityCountAggregateInputType | true
    }

  export interface SproutInstagramFollowersByCityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SproutInstagramFollowersByCity'], meta: { name: 'SproutInstagramFollowersByCity' } }
    /**
     * Find zero or one SproutInstagramFollowersByCity that matches the filter.
     * @param {SproutInstagramFollowersByCityFindUniqueArgs} args - Arguments to find a SproutInstagramFollowersByCity
     * @example
     * // Get one SproutInstagramFollowersByCity
     * const sproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SproutInstagramFollowersByCityFindUniqueArgs>(args: SelectSubset<T, SproutInstagramFollowersByCityFindUniqueArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCityClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SproutInstagramFollowersByCity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SproutInstagramFollowersByCityFindUniqueOrThrowArgs} args - Arguments to find a SproutInstagramFollowersByCity
     * @example
     * // Get one SproutInstagramFollowersByCity
     * const sproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SproutInstagramFollowersByCityFindUniqueOrThrowArgs>(args: SelectSubset<T, SproutInstagramFollowersByCityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCityClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutInstagramFollowersByCity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCityFindFirstArgs} args - Arguments to find a SproutInstagramFollowersByCity
     * @example
     * // Get one SproutInstagramFollowersByCity
     * const sproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SproutInstagramFollowersByCityFindFirstArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCityFindFirstArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCityClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutInstagramFollowersByCity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCityFindFirstOrThrowArgs} args - Arguments to find a SproutInstagramFollowersByCity
     * @example
     * // Get one SproutInstagramFollowersByCity
     * const sproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SproutInstagramFollowersByCityFindFirstOrThrowArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCityFindFirstOrThrowArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCityClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SproutInstagramFollowersByCities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SproutInstagramFollowersByCities
     * const sproutInstagramFollowersByCities = await prisma.sproutInstagramFollowersByCity.findMany()
     * 
     * // Get first 10 SproutInstagramFollowersByCities
     * const sproutInstagramFollowersByCities = await prisma.sproutInstagramFollowersByCity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sproutInstagramFollowersByCityWithIdOnly = await prisma.sproutInstagramFollowersByCity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SproutInstagramFollowersByCityFindManyArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SproutInstagramFollowersByCity.
     * @param {SproutInstagramFollowersByCityCreateArgs} args - Arguments to create a SproutInstagramFollowersByCity.
     * @example
     * // Create one SproutInstagramFollowersByCity
     * const SproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.create({
     *   data: {
     *     // ... data to create a SproutInstagramFollowersByCity
     *   }
     * })
     * 
     */
    create<T extends SproutInstagramFollowersByCityCreateArgs>(args: SelectSubset<T, SproutInstagramFollowersByCityCreateArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCityClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SproutInstagramFollowersByCities.
     * @param {SproutInstagramFollowersByCityCreateManyArgs} args - Arguments to create many SproutInstagramFollowersByCities.
     * @example
     * // Create many SproutInstagramFollowersByCities
     * const sproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SproutInstagramFollowersByCityCreateManyArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SproutInstagramFollowersByCities and returns the data saved in the database.
     * @param {SproutInstagramFollowersByCityCreateManyAndReturnArgs} args - Arguments to create many SproutInstagramFollowersByCities.
     * @example
     * // Create many SproutInstagramFollowersByCities
     * const sproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SproutInstagramFollowersByCities and only return the `id`
     * const sproutInstagramFollowersByCityWithIdOnly = await prisma.sproutInstagramFollowersByCity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SproutInstagramFollowersByCityCreateManyAndReturnArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SproutInstagramFollowersByCity.
     * @param {SproutInstagramFollowersByCityDeleteArgs} args - Arguments to delete one SproutInstagramFollowersByCity.
     * @example
     * // Delete one SproutInstagramFollowersByCity
     * const SproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.delete({
     *   where: {
     *     // ... filter to delete one SproutInstagramFollowersByCity
     *   }
     * })
     * 
     */
    delete<T extends SproutInstagramFollowersByCityDeleteArgs>(args: SelectSubset<T, SproutInstagramFollowersByCityDeleteArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCityClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SproutInstagramFollowersByCity.
     * @param {SproutInstagramFollowersByCityUpdateArgs} args - Arguments to update one SproutInstagramFollowersByCity.
     * @example
     * // Update one SproutInstagramFollowersByCity
     * const sproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SproutInstagramFollowersByCityUpdateArgs>(args: SelectSubset<T, SproutInstagramFollowersByCityUpdateArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCityClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SproutInstagramFollowersByCities.
     * @param {SproutInstagramFollowersByCityDeleteManyArgs} args - Arguments to filter SproutInstagramFollowersByCities to delete.
     * @example
     * // Delete a few SproutInstagramFollowersByCities
     * const { count } = await prisma.sproutInstagramFollowersByCity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SproutInstagramFollowersByCityDeleteManyArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutInstagramFollowersByCities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SproutInstagramFollowersByCities
     * const sproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SproutInstagramFollowersByCityUpdateManyArgs>(args: SelectSubset<T, SproutInstagramFollowersByCityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutInstagramFollowersByCities and returns the data updated in the database.
     * @param {SproutInstagramFollowersByCityUpdateManyAndReturnArgs} args - Arguments to update many SproutInstagramFollowersByCities.
     * @example
     * // Update many SproutInstagramFollowersByCities
     * const sproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SproutInstagramFollowersByCities and only return the `id`
     * const sproutInstagramFollowersByCityWithIdOnly = await prisma.sproutInstagramFollowersByCity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SproutInstagramFollowersByCityUpdateManyAndReturnArgs>(args: SelectSubset<T, SproutInstagramFollowersByCityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SproutInstagramFollowersByCity.
     * @param {SproutInstagramFollowersByCityUpsertArgs} args - Arguments to update or create a SproutInstagramFollowersByCity.
     * @example
     * // Update or create a SproutInstagramFollowersByCity
     * const sproutInstagramFollowersByCity = await prisma.sproutInstagramFollowersByCity.upsert({
     *   create: {
     *     // ... data to create a SproutInstagramFollowersByCity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SproutInstagramFollowersByCity we want to update
     *   }
     * })
     */
    upsert<T extends SproutInstagramFollowersByCityUpsertArgs>(args: SelectSubset<T, SproutInstagramFollowersByCityUpsertArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCityClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SproutInstagramFollowersByCities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCityCountArgs} args - Arguments to filter SproutInstagramFollowersByCities to count.
     * @example
     * // Count the number of SproutInstagramFollowersByCities
     * const count = await prisma.sproutInstagramFollowersByCity.count({
     *   where: {
     *     // ... the filter for the SproutInstagramFollowersByCities we want to count
     *   }
     * })
    **/
    count<T extends SproutInstagramFollowersByCityCountArgs>(
      args?: Subset<T, SproutInstagramFollowersByCityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SproutInstagramFollowersByCityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SproutInstagramFollowersByCity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SproutInstagramFollowersByCityAggregateArgs>(args: Subset<T, SproutInstagramFollowersByCityAggregateArgs>): Prisma.PrismaPromise<GetSproutInstagramFollowersByCityAggregateType<T>>

    /**
     * Group by SproutInstagramFollowersByCity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SproutInstagramFollowersByCityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SproutInstagramFollowersByCityGroupByArgs['orderBy'] }
        : { orderBy?: SproutInstagramFollowersByCityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SproutInstagramFollowersByCityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSproutInstagramFollowersByCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SproutInstagramFollowersByCity model
   */
  readonly fields: SproutInstagramFollowersByCityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SproutInstagramFollowersByCity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SproutInstagramFollowersByCityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sproutInstagramAnalytics<T extends SproutInstagramAnalyticsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SproutInstagramAnalyticsDefaultArgs<ExtArgs>>): Prisma__SproutInstagramAnalyticsClient<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SproutInstagramFollowersByCity model
   */
  interface SproutInstagramFollowersByCityFieldRefs {
    readonly id: FieldRef<"SproutInstagramFollowersByCity", 'String'>
    readonly sproutInstagramAnalyticsId: FieldRef<"SproutInstagramFollowersByCity", 'String'>
    readonly city: FieldRef<"SproutInstagramFollowersByCity", 'String'>
    readonly count: FieldRef<"SproutInstagramFollowersByCity", 'Int'>
    readonly createdAt: FieldRef<"SproutInstagramFollowersByCity", 'DateTime'>
    readonly updatedAt: FieldRef<"SproutInstagramFollowersByCity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SproutInstagramFollowersByCity findUnique
   */
  export type SproutInstagramFollowersByCityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramFollowersByCity to fetch.
     */
    where: SproutInstagramFollowersByCityWhereUniqueInput
  }

  /**
   * SproutInstagramFollowersByCity findUniqueOrThrow
   */
  export type SproutInstagramFollowersByCityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramFollowersByCity to fetch.
     */
    where: SproutInstagramFollowersByCityWhereUniqueInput
  }

  /**
   * SproutInstagramFollowersByCity findFirst
   */
  export type SproutInstagramFollowersByCityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramFollowersByCity to fetch.
     */
    where?: SproutInstagramFollowersByCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramFollowersByCities to fetch.
     */
    orderBy?: SproutInstagramFollowersByCityOrderByWithRelationInput | SproutInstagramFollowersByCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutInstagramFollowersByCities.
     */
    cursor?: SproutInstagramFollowersByCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramFollowersByCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramFollowersByCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutInstagramFollowersByCities.
     */
    distinct?: SproutInstagramFollowersByCityScalarFieldEnum | SproutInstagramFollowersByCityScalarFieldEnum[]
  }

  /**
   * SproutInstagramFollowersByCity findFirstOrThrow
   */
  export type SproutInstagramFollowersByCityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramFollowersByCity to fetch.
     */
    where?: SproutInstagramFollowersByCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramFollowersByCities to fetch.
     */
    orderBy?: SproutInstagramFollowersByCityOrderByWithRelationInput | SproutInstagramFollowersByCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutInstagramFollowersByCities.
     */
    cursor?: SproutInstagramFollowersByCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramFollowersByCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramFollowersByCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutInstagramFollowersByCities.
     */
    distinct?: SproutInstagramFollowersByCityScalarFieldEnum | SproutInstagramFollowersByCityScalarFieldEnum[]
  }

  /**
   * SproutInstagramFollowersByCity findMany
   */
  export type SproutInstagramFollowersByCityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramFollowersByCities to fetch.
     */
    where?: SproutInstagramFollowersByCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramFollowersByCities to fetch.
     */
    orderBy?: SproutInstagramFollowersByCityOrderByWithRelationInput | SproutInstagramFollowersByCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SproutInstagramFollowersByCities.
     */
    cursor?: SproutInstagramFollowersByCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramFollowersByCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramFollowersByCities.
     */
    skip?: number
    distinct?: SproutInstagramFollowersByCityScalarFieldEnum | SproutInstagramFollowersByCityScalarFieldEnum[]
  }

  /**
   * SproutInstagramFollowersByCity create
   */
  export type SproutInstagramFollowersByCityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityInclude<ExtArgs> | null
    /**
     * The data needed to create a SproutInstagramFollowersByCity.
     */
    data: XOR<SproutInstagramFollowersByCityCreateInput, SproutInstagramFollowersByCityUncheckedCreateInput>
  }

  /**
   * SproutInstagramFollowersByCity createMany
   */
  export type SproutInstagramFollowersByCityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SproutInstagramFollowersByCities.
     */
    data: SproutInstagramFollowersByCityCreateManyInput | SproutInstagramFollowersByCityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SproutInstagramFollowersByCity createManyAndReturn
   */
  export type SproutInstagramFollowersByCityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * The data used to create many SproutInstagramFollowersByCities.
     */
    data: SproutInstagramFollowersByCityCreateManyInput | SproutInstagramFollowersByCityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutInstagramFollowersByCity update
   */
  export type SproutInstagramFollowersByCityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityInclude<ExtArgs> | null
    /**
     * The data needed to update a SproutInstagramFollowersByCity.
     */
    data: XOR<SproutInstagramFollowersByCityUpdateInput, SproutInstagramFollowersByCityUncheckedUpdateInput>
    /**
     * Choose, which SproutInstagramFollowersByCity to update.
     */
    where: SproutInstagramFollowersByCityWhereUniqueInput
  }

  /**
   * SproutInstagramFollowersByCity updateMany
   */
  export type SproutInstagramFollowersByCityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SproutInstagramFollowersByCities.
     */
    data: XOR<SproutInstagramFollowersByCityUpdateManyMutationInput, SproutInstagramFollowersByCityUncheckedUpdateManyInput>
    /**
     * Filter which SproutInstagramFollowersByCities to update
     */
    where?: SproutInstagramFollowersByCityWhereInput
    /**
     * Limit how many SproutInstagramFollowersByCities to update.
     */
    limit?: number
  }

  /**
   * SproutInstagramFollowersByCity updateManyAndReturn
   */
  export type SproutInstagramFollowersByCityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * The data used to update SproutInstagramFollowersByCities.
     */
    data: XOR<SproutInstagramFollowersByCityUpdateManyMutationInput, SproutInstagramFollowersByCityUncheckedUpdateManyInput>
    /**
     * Filter which SproutInstagramFollowersByCities to update
     */
    where?: SproutInstagramFollowersByCityWhereInput
    /**
     * Limit how many SproutInstagramFollowersByCities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutInstagramFollowersByCity upsert
   */
  export type SproutInstagramFollowersByCityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityInclude<ExtArgs> | null
    /**
     * The filter to search for the SproutInstagramFollowersByCity to update in case it exists.
     */
    where: SproutInstagramFollowersByCityWhereUniqueInput
    /**
     * In case the SproutInstagramFollowersByCity found by the `where` argument doesn't exist, create a new SproutInstagramFollowersByCity with this data.
     */
    create: XOR<SproutInstagramFollowersByCityCreateInput, SproutInstagramFollowersByCityUncheckedCreateInput>
    /**
     * In case the SproutInstagramFollowersByCity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SproutInstagramFollowersByCityUpdateInput, SproutInstagramFollowersByCityUncheckedUpdateInput>
  }

  /**
   * SproutInstagramFollowersByCity delete
   */
  export type SproutInstagramFollowersByCityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityInclude<ExtArgs> | null
    /**
     * Filter which SproutInstagramFollowersByCity to delete.
     */
    where: SproutInstagramFollowersByCityWhereUniqueInput
  }

  /**
   * SproutInstagramFollowersByCity deleteMany
   */
  export type SproutInstagramFollowersByCityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutInstagramFollowersByCities to delete
     */
    where?: SproutInstagramFollowersByCityWhereInput
    /**
     * Limit how many SproutInstagramFollowersByCities to delete.
     */
    limit?: number
  }

  /**
   * SproutInstagramFollowersByCity without action
   */
  export type SproutInstagramFollowersByCityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCity
     */
    select?: SproutInstagramFollowersByCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCity
     */
    omit?: SproutInstagramFollowersByCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCityInclude<ExtArgs> | null
  }


  /**
   * Model SproutInstagramFollowersByCountry
   */

  export type AggregateSproutInstagramFollowersByCountry = {
    _count: SproutInstagramFollowersByCountryCountAggregateOutputType | null
    _avg: SproutInstagramFollowersByCountryAvgAggregateOutputType | null
    _sum: SproutInstagramFollowersByCountrySumAggregateOutputType | null
    _min: SproutInstagramFollowersByCountryMinAggregateOutputType | null
    _max: SproutInstagramFollowersByCountryMaxAggregateOutputType | null
  }

  export type SproutInstagramFollowersByCountryAvgAggregateOutputType = {
    count: number | null
  }

  export type SproutInstagramFollowersByCountrySumAggregateOutputType = {
    count: number | null
  }

  export type SproutInstagramFollowersByCountryMinAggregateOutputType = {
    id: string | null
    sproutInstagramAnalyticsId: string | null
    country: string | null
    count: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutInstagramFollowersByCountryMaxAggregateOutputType = {
    id: string | null
    sproutInstagramAnalyticsId: string | null
    country: string | null
    count: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutInstagramFollowersByCountryCountAggregateOutputType = {
    id: number
    sproutInstagramAnalyticsId: number
    country: number
    count: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SproutInstagramFollowersByCountryAvgAggregateInputType = {
    count?: true
  }

  export type SproutInstagramFollowersByCountrySumAggregateInputType = {
    count?: true
  }

  export type SproutInstagramFollowersByCountryMinAggregateInputType = {
    id?: true
    sproutInstagramAnalyticsId?: true
    country?: true
    count?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutInstagramFollowersByCountryMaxAggregateInputType = {
    id?: true
    sproutInstagramAnalyticsId?: true
    country?: true
    count?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutInstagramFollowersByCountryCountAggregateInputType = {
    id?: true
    sproutInstagramAnalyticsId?: true
    country?: true
    count?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SproutInstagramFollowersByCountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutInstagramFollowersByCountry to aggregate.
     */
    where?: SproutInstagramFollowersByCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramFollowersByCountries to fetch.
     */
    orderBy?: SproutInstagramFollowersByCountryOrderByWithRelationInput | SproutInstagramFollowersByCountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SproutInstagramFollowersByCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramFollowersByCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramFollowersByCountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SproutInstagramFollowersByCountries
    **/
    _count?: true | SproutInstagramFollowersByCountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SproutInstagramFollowersByCountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SproutInstagramFollowersByCountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SproutInstagramFollowersByCountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SproutInstagramFollowersByCountryMaxAggregateInputType
  }

  export type GetSproutInstagramFollowersByCountryAggregateType<T extends SproutInstagramFollowersByCountryAggregateArgs> = {
        [P in keyof T & keyof AggregateSproutInstagramFollowersByCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSproutInstagramFollowersByCountry[P]>
      : GetScalarType<T[P], AggregateSproutInstagramFollowersByCountry[P]>
  }




  export type SproutInstagramFollowersByCountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutInstagramFollowersByCountryWhereInput
    orderBy?: SproutInstagramFollowersByCountryOrderByWithAggregationInput | SproutInstagramFollowersByCountryOrderByWithAggregationInput[]
    by: SproutInstagramFollowersByCountryScalarFieldEnum[] | SproutInstagramFollowersByCountryScalarFieldEnum
    having?: SproutInstagramFollowersByCountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SproutInstagramFollowersByCountryCountAggregateInputType | true
    _avg?: SproutInstagramFollowersByCountryAvgAggregateInputType
    _sum?: SproutInstagramFollowersByCountrySumAggregateInputType
    _min?: SproutInstagramFollowersByCountryMinAggregateInputType
    _max?: SproutInstagramFollowersByCountryMaxAggregateInputType
  }

  export type SproutInstagramFollowersByCountryGroupByOutputType = {
    id: string
    sproutInstagramAnalyticsId: string
    country: string
    count: number
    createdAt: Date
    updatedAt: Date
    _count: SproutInstagramFollowersByCountryCountAggregateOutputType | null
    _avg: SproutInstagramFollowersByCountryAvgAggregateOutputType | null
    _sum: SproutInstagramFollowersByCountrySumAggregateOutputType | null
    _min: SproutInstagramFollowersByCountryMinAggregateOutputType | null
    _max: SproutInstagramFollowersByCountryMaxAggregateOutputType | null
  }

  type GetSproutInstagramFollowersByCountryGroupByPayload<T extends SproutInstagramFollowersByCountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SproutInstagramFollowersByCountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SproutInstagramFollowersByCountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SproutInstagramFollowersByCountryGroupByOutputType[P]>
            : GetScalarType<T[P], SproutInstagramFollowersByCountryGroupByOutputType[P]>
        }
      >
    >


  export type SproutInstagramFollowersByCountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutInstagramAnalyticsId?: boolean
    country?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutInstagramFollowersByCountry"]>

  export type SproutInstagramFollowersByCountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutInstagramAnalyticsId?: boolean
    country?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutInstagramFollowersByCountry"]>

  export type SproutInstagramFollowersByCountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutInstagramAnalyticsId?: boolean
    country?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutInstagramFollowersByCountry"]>

  export type SproutInstagramFollowersByCountrySelectScalar = {
    id?: boolean
    sproutInstagramAnalyticsId?: boolean
    country?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SproutInstagramFollowersByCountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sproutInstagramAnalyticsId" | "country" | "count" | "createdAt" | "updatedAt", ExtArgs["result"]["sproutInstagramFollowersByCountry"]>
  export type SproutInstagramFollowersByCountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }
  export type SproutInstagramFollowersByCountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }
  export type SproutInstagramFollowersByCountryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutInstagramAnalytics?: boolean | SproutInstagramAnalyticsDefaultArgs<ExtArgs>
  }

  export type $SproutInstagramFollowersByCountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SproutInstagramFollowersByCountry"
    objects: {
      sproutInstagramAnalytics: Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sproutInstagramAnalyticsId: string
      country: string
      count: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sproutInstagramFollowersByCountry"]>
    composites: {}
  }

  type SproutInstagramFollowersByCountryGetPayload<S extends boolean | null | undefined | SproutInstagramFollowersByCountryDefaultArgs> = $Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload, S>

  type SproutInstagramFollowersByCountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SproutInstagramFollowersByCountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SproutInstagramFollowersByCountryCountAggregateInputType | true
    }

  export interface SproutInstagramFollowersByCountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SproutInstagramFollowersByCountry'], meta: { name: 'SproutInstagramFollowersByCountry' } }
    /**
     * Find zero or one SproutInstagramFollowersByCountry that matches the filter.
     * @param {SproutInstagramFollowersByCountryFindUniqueArgs} args - Arguments to find a SproutInstagramFollowersByCountry
     * @example
     * // Get one SproutInstagramFollowersByCountry
     * const sproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SproutInstagramFollowersByCountryFindUniqueArgs>(args: SelectSubset<T, SproutInstagramFollowersByCountryFindUniqueArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCountryClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SproutInstagramFollowersByCountry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SproutInstagramFollowersByCountryFindUniqueOrThrowArgs} args - Arguments to find a SproutInstagramFollowersByCountry
     * @example
     * // Get one SproutInstagramFollowersByCountry
     * const sproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SproutInstagramFollowersByCountryFindUniqueOrThrowArgs>(args: SelectSubset<T, SproutInstagramFollowersByCountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCountryClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutInstagramFollowersByCountry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCountryFindFirstArgs} args - Arguments to find a SproutInstagramFollowersByCountry
     * @example
     * // Get one SproutInstagramFollowersByCountry
     * const sproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SproutInstagramFollowersByCountryFindFirstArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCountryFindFirstArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCountryClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutInstagramFollowersByCountry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCountryFindFirstOrThrowArgs} args - Arguments to find a SproutInstagramFollowersByCountry
     * @example
     * // Get one SproutInstagramFollowersByCountry
     * const sproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SproutInstagramFollowersByCountryFindFirstOrThrowArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCountryClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SproutInstagramFollowersByCountries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SproutInstagramFollowersByCountries
     * const sproutInstagramFollowersByCountries = await prisma.sproutInstagramFollowersByCountry.findMany()
     * 
     * // Get first 10 SproutInstagramFollowersByCountries
     * const sproutInstagramFollowersByCountries = await prisma.sproutInstagramFollowersByCountry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sproutInstagramFollowersByCountryWithIdOnly = await prisma.sproutInstagramFollowersByCountry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SproutInstagramFollowersByCountryFindManyArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SproutInstagramFollowersByCountry.
     * @param {SproutInstagramFollowersByCountryCreateArgs} args - Arguments to create a SproutInstagramFollowersByCountry.
     * @example
     * // Create one SproutInstagramFollowersByCountry
     * const SproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.create({
     *   data: {
     *     // ... data to create a SproutInstagramFollowersByCountry
     *   }
     * })
     * 
     */
    create<T extends SproutInstagramFollowersByCountryCreateArgs>(args: SelectSubset<T, SproutInstagramFollowersByCountryCreateArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCountryClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SproutInstagramFollowersByCountries.
     * @param {SproutInstagramFollowersByCountryCreateManyArgs} args - Arguments to create many SproutInstagramFollowersByCountries.
     * @example
     * // Create many SproutInstagramFollowersByCountries
     * const sproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SproutInstagramFollowersByCountryCreateManyArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SproutInstagramFollowersByCountries and returns the data saved in the database.
     * @param {SproutInstagramFollowersByCountryCreateManyAndReturnArgs} args - Arguments to create many SproutInstagramFollowersByCountries.
     * @example
     * // Create many SproutInstagramFollowersByCountries
     * const sproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SproutInstagramFollowersByCountries and only return the `id`
     * const sproutInstagramFollowersByCountryWithIdOnly = await prisma.sproutInstagramFollowersByCountry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SproutInstagramFollowersByCountryCreateManyAndReturnArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SproutInstagramFollowersByCountry.
     * @param {SproutInstagramFollowersByCountryDeleteArgs} args - Arguments to delete one SproutInstagramFollowersByCountry.
     * @example
     * // Delete one SproutInstagramFollowersByCountry
     * const SproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.delete({
     *   where: {
     *     // ... filter to delete one SproutInstagramFollowersByCountry
     *   }
     * })
     * 
     */
    delete<T extends SproutInstagramFollowersByCountryDeleteArgs>(args: SelectSubset<T, SproutInstagramFollowersByCountryDeleteArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCountryClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SproutInstagramFollowersByCountry.
     * @param {SproutInstagramFollowersByCountryUpdateArgs} args - Arguments to update one SproutInstagramFollowersByCountry.
     * @example
     * // Update one SproutInstagramFollowersByCountry
     * const sproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SproutInstagramFollowersByCountryUpdateArgs>(args: SelectSubset<T, SproutInstagramFollowersByCountryUpdateArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCountryClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SproutInstagramFollowersByCountries.
     * @param {SproutInstagramFollowersByCountryDeleteManyArgs} args - Arguments to filter SproutInstagramFollowersByCountries to delete.
     * @example
     * // Delete a few SproutInstagramFollowersByCountries
     * const { count } = await prisma.sproutInstagramFollowersByCountry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SproutInstagramFollowersByCountryDeleteManyArgs>(args?: SelectSubset<T, SproutInstagramFollowersByCountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutInstagramFollowersByCountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SproutInstagramFollowersByCountries
     * const sproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SproutInstagramFollowersByCountryUpdateManyArgs>(args: SelectSubset<T, SproutInstagramFollowersByCountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutInstagramFollowersByCountries and returns the data updated in the database.
     * @param {SproutInstagramFollowersByCountryUpdateManyAndReturnArgs} args - Arguments to update many SproutInstagramFollowersByCountries.
     * @example
     * // Update many SproutInstagramFollowersByCountries
     * const sproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SproutInstagramFollowersByCountries and only return the `id`
     * const sproutInstagramFollowersByCountryWithIdOnly = await prisma.sproutInstagramFollowersByCountry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SproutInstagramFollowersByCountryUpdateManyAndReturnArgs>(args: SelectSubset<T, SproutInstagramFollowersByCountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SproutInstagramFollowersByCountry.
     * @param {SproutInstagramFollowersByCountryUpsertArgs} args - Arguments to update or create a SproutInstagramFollowersByCountry.
     * @example
     * // Update or create a SproutInstagramFollowersByCountry
     * const sproutInstagramFollowersByCountry = await prisma.sproutInstagramFollowersByCountry.upsert({
     *   create: {
     *     // ... data to create a SproutInstagramFollowersByCountry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SproutInstagramFollowersByCountry we want to update
     *   }
     * })
     */
    upsert<T extends SproutInstagramFollowersByCountryUpsertArgs>(args: SelectSubset<T, SproutInstagramFollowersByCountryUpsertArgs<ExtArgs>>): Prisma__SproutInstagramFollowersByCountryClient<$Result.GetResult<Prisma.$SproutInstagramFollowersByCountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SproutInstagramFollowersByCountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCountryCountArgs} args - Arguments to filter SproutInstagramFollowersByCountries to count.
     * @example
     * // Count the number of SproutInstagramFollowersByCountries
     * const count = await prisma.sproutInstagramFollowersByCountry.count({
     *   where: {
     *     // ... the filter for the SproutInstagramFollowersByCountries we want to count
     *   }
     * })
    **/
    count<T extends SproutInstagramFollowersByCountryCountArgs>(
      args?: Subset<T, SproutInstagramFollowersByCountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SproutInstagramFollowersByCountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SproutInstagramFollowersByCountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SproutInstagramFollowersByCountryAggregateArgs>(args: Subset<T, SproutInstagramFollowersByCountryAggregateArgs>): Prisma.PrismaPromise<GetSproutInstagramFollowersByCountryAggregateType<T>>

    /**
     * Group by SproutInstagramFollowersByCountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutInstagramFollowersByCountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SproutInstagramFollowersByCountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SproutInstagramFollowersByCountryGroupByArgs['orderBy'] }
        : { orderBy?: SproutInstagramFollowersByCountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SproutInstagramFollowersByCountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSproutInstagramFollowersByCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SproutInstagramFollowersByCountry model
   */
  readonly fields: SproutInstagramFollowersByCountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SproutInstagramFollowersByCountry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SproutInstagramFollowersByCountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sproutInstagramAnalytics<T extends SproutInstagramAnalyticsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SproutInstagramAnalyticsDefaultArgs<ExtArgs>>): Prisma__SproutInstagramAnalyticsClient<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SproutInstagramFollowersByCountry model
   */
  interface SproutInstagramFollowersByCountryFieldRefs {
    readonly id: FieldRef<"SproutInstagramFollowersByCountry", 'String'>
    readonly sproutInstagramAnalyticsId: FieldRef<"SproutInstagramFollowersByCountry", 'String'>
    readonly country: FieldRef<"SproutInstagramFollowersByCountry", 'String'>
    readonly count: FieldRef<"SproutInstagramFollowersByCountry", 'Int'>
    readonly createdAt: FieldRef<"SproutInstagramFollowersByCountry", 'DateTime'>
    readonly updatedAt: FieldRef<"SproutInstagramFollowersByCountry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SproutInstagramFollowersByCountry findUnique
   */
  export type SproutInstagramFollowersByCountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramFollowersByCountry to fetch.
     */
    where: SproutInstagramFollowersByCountryWhereUniqueInput
  }

  /**
   * SproutInstagramFollowersByCountry findUniqueOrThrow
   */
  export type SproutInstagramFollowersByCountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramFollowersByCountry to fetch.
     */
    where: SproutInstagramFollowersByCountryWhereUniqueInput
  }

  /**
   * SproutInstagramFollowersByCountry findFirst
   */
  export type SproutInstagramFollowersByCountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramFollowersByCountry to fetch.
     */
    where?: SproutInstagramFollowersByCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramFollowersByCountries to fetch.
     */
    orderBy?: SproutInstagramFollowersByCountryOrderByWithRelationInput | SproutInstagramFollowersByCountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutInstagramFollowersByCountries.
     */
    cursor?: SproutInstagramFollowersByCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramFollowersByCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramFollowersByCountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutInstagramFollowersByCountries.
     */
    distinct?: SproutInstagramFollowersByCountryScalarFieldEnum | SproutInstagramFollowersByCountryScalarFieldEnum[]
  }

  /**
   * SproutInstagramFollowersByCountry findFirstOrThrow
   */
  export type SproutInstagramFollowersByCountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramFollowersByCountry to fetch.
     */
    where?: SproutInstagramFollowersByCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramFollowersByCountries to fetch.
     */
    orderBy?: SproutInstagramFollowersByCountryOrderByWithRelationInput | SproutInstagramFollowersByCountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutInstagramFollowersByCountries.
     */
    cursor?: SproutInstagramFollowersByCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramFollowersByCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramFollowersByCountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutInstagramFollowersByCountries.
     */
    distinct?: SproutInstagramFollowersByCountryScalarFieldEnum | SproutInstagramFollowersByCountryScalarFieldEnum[]
  }

  /**
   * SproutInstagramFollowersByCountry findMany
   */
  export type SproutInstagramFollowersByCountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryInclude<ExtArgs> | null
    /**
     * Filter, which SproutInstagramFollowersByCountries to fetch.
     */
    where?: SproutInstagramFollowersByCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutInstagramFollowersByCountries to fetch.
     */
    orderBy?: SproutInstagramFollowersByCountryOrderByWithRelationInput | SproutInstagramFollowersByCountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SproutInstagramFollowersByCountries.
     */
    cursor?: SproutInstagramFollowersByCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutInstagramFollowersByCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutInstagramFollowersByCountries.
     */
    skip?: number
    distinct?: SproutInstagramFollowersByCountryScalarFieldEnum | SproutInstagramFollowersByCountryScalarFieldEnum[]
  }

  /**
   * SproutInstagramFollowersByCountry create
   */
  export type SproutInstagramFollowersByCountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryInclude<ExtArgs> | null
    /**
     * The data needed to create a SproutInstagramFollowersByCountry.
     */
    data: XOR<SproutInstagramFollowersByCountryCreateInput, SproutInstagramFollowersByCountryUncheckedCreateInput>
  }

  /**
   * SproutInstagramFollowersByCountry createMany
   */
  export type SproutInstagramFollowersByCountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SproutInstagramFollowersByCountries.
     */
    data: SproutInstagramFollowersByCountryCreateManyInput | SproutInstagramFollowersByCountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SproutInstagramFollowersByCountry createManyAndReturn
   */
  export type SproutInstagramFollowersByCountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * The data used to create many SproutInstagramFollowersByCountries.
     */
    data: SproutInstagramFollowersByCountryCreateManyInput | SproutInstagramFollowersByCountryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutInstagramFollowersByCountry update
   */
  export type SproutInstagramFollowersByCountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryInclude<ExtArgs> | null
    /**
     * The data needed to update a SproutInstagramFollowersByCountry.
     */
    data: XOR<SproutInstagramFollowersByCountryUpdateInput, SproutInstagramFollowersByCountryUncheckedUpdateInput>
    /**
     * Choose, which SproutInstagramFollowersByCountry to update.
     */
    where: SproutInstagramFollowersByCountryWhereUniqueInput
  }

  /**
   * SproutInstagramFollowersByCountry updateMany
   */
  export type SproutInstagramFollowersByCountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SproutInstagramFollowersByCountries.
     */
    data: XOR<SproutInstagramFollowersByCountryUpdateManyMutationInput, SproutInstagramFollowersByCountryUncheckedUpdateManyInput>
    /**
     * Filter which SproutInstagramFollowersByCountries to update
     */
    where?: SproutInstagramFollowersByCountryWhereInput
    /**
     * Limit how many SproutInstagramFollowersByCountries to update.
     */
    limit?: number
  }

  /**
   * SproutInstagramFollowersByCountry updateManyAndReturn
   */
  export type SproutInstagramFollowersByCountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * The data used to update SproutInstagramFollowersByCountries.
     */
    data: XOR<SproutInstagramFollowersByCountryUpdateManyMutationInput, SproutInstagramFollowersByCountryUncheckedUpdateManyInput>
    /**
     * Filter which SproutInstagramFollowersByCountries to update
     */
    where?: SproutInstagramFollowersByCountryWhereInput
    /**
     * Limit how many SproutInstagramFollowersByCountries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutInstagramFollowersByCountry upsert
   */
  export type SproutInstagramFollowersByCountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryInclude<ExtArgs> | null
    /**
     * The filter to search for the SproutInstagramFollowersByCountry to update in case it exists.
     */
    where: SproutInstagramFollowersByCountryWhereUniqueInput
    /**
     * In case the SproutInstagramFollowersByCountry found by the `where` argument doesn't exist, create a new SproutInstagramFollowersByCountry with this data.
     */
    create: XOR<SproutInstagramFollowersByCountryCreateInput, SproutInstagramFollowersByCountryUncheckedCreateInput>
    /**
     * In case the SproutInstagramFollowersByCountry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SproutInstagramFollowersByCountryUpdateInput, SproutInstagramFollowersByCountryUncheckedUpdateInput>
  }

  /**
   * SproutInstagramFollowersByCountry delete
   */
  export type SproutInstagramFollowersByCountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryInclude<ExtArgs> | null
    /**
     * Filter which SproutInstagramFollowersByCountry to delete.
     */
    where: SproutInstagramFollowersByCountryWhereUniqueInput
  }

  /**
   * SproutInstagramFollowersByCountry deleteMany
   */
  export type SproutInstagramFollowersByCountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutInstagramFollowersByCountries to delete
     */
    where?: SproutInstagramFollowersByCountryWhereInput
    /**
     * Limit how many SproutInstagramFollowersByCountries to delete.
     */
    limit?: number
  }

  /**
   * SproutInstagramFollowersByCountry without action
   */
  export type SproutInstagramFollowersByCountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramFollowersByCountry
     */
    select?: SproutInstagramFollowersByCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramFollowersByCountry
     */
    omit?: SproutInstagramFollowersByCountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramFollowersByCountryInclude<ExtArgs> | null
  }


  /**
   * Model SproutLinkedInAnalytics
   */

  export type AggregateSproutLinkedInAnalytics = {
    _count: SproutLinkedInAnalyticsCountAggregateOutputType | null
    _avg: SproutLinkedInAnalyticsAvgAggregateOutputType | null
    _sum: SproutLinkedInAnalyticsSumAggregateOutputType | null
    _min: SproutLinkedInAnalyticsMinAggregateOutputType | null
    _max: SproutLinkedInAnalyticsMaxAggregateOutputType | null
  }

  export type SproutLinkedInAnalyticsAvgAggregateOutputType = {
    customerProfileId: number | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    reactions: number | null
  }

  export type SproutLinkedInAnalyticsSumAggregateOutputType = {
    customerProfileId: number | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    reactions: number | null
  }

  export type SproutLinkedInAnalyticsMinAggregateOutputType = {
    id: string | null
    sproutSocialAccountId: string | null
    customerProfileId: number | null
    reportingDate: Date | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    reactions: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutLinkedInAnalyticsMaxAggregateOutputType = {
    id: string | null
    sproutSocialAccountId: string | null
    customerProfileId: number | null
    reportingDate: Date | null
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    reactions: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutLinkedInAnalyticsCountAggregateOutputType = {
    id: number
    sproutSocialAccountId: number
    customerProfileId: number
    reportingDate: number
    engagements: number
    impressions: number
    impressionsUnique: number
    followersCount: number
    reactions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SproutLinkedInAnalyticsAvgAggregateInputType = {
    customerProfileId?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    reactions?: true
  }

  export type SproutLinkedInAnalyticsSumAggregateInputType = {
    customerProfileId?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    reactions?: true
  }

  export type SproutLinkedInAnalyticsMinAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    reactions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutLinkedInAnalyticsMaxAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    reactions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutLinkedInAnalyticsCountAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    engagements?: true
    impressions?: true
    impressionsUnique?: true
    followersCount?: true
    reactions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SproutLinkedInAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutLinkedInAnalytics to aggregate.
     */
    where?: SproutLinkedInAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutLinkedInAnalytics to fetch.
     */
    orderBy?: SproutLinkedInAnalyticsOrderByWithRelationInput | SproutLinkedInAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SproutLinkedInAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutLinkedInAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutLinkedInAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SproutLinkedInAnalytics
    **/
    _count?: true | SproutLinkedInAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SproutLinkedInAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SproutLinkedInAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SproutLinkedInAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SproutLinkedInAnalyticsMaxAggregateInputType
  }

  export type GetSproutLinkedInAnalyticsAggregateType<T extends SproutLinkedInAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateSproutLinkedInAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSproutLinkedInAnalytics[P]>
      : GetScalarType<T[P], AggregateSproutLinkedInAnalytics[P]>
  }




  export type SproutLinkedInAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutLinkedInAnalyticsWhereInput
    orderBy?: SproutLinkedInAnalyticsOrderByWithAggregationInput | SproutLinkedInAnalyticsOrderByWithAggregationInput[]
    by: SproutLinkedInAnalyticsScalarFieldEnum[] | SproutLinkedInAnalyticsScalarFieldEnum
    having?: SproutLinkedInAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SproutLinkedInAnalyticsCountAggregateInputType | true
    _avg?: SproutLinkedInAnalyticsAvgAggregateInputType
    _sum?: SproutLinkedInAnalyticsSumAggregateInputType
    _min?: SproutLinkedInAnalyticsMinAggregateInputType
    _max?: SproutLinkedInAnalyticsMaxAggregateInputType
  }

  export type SproutLinkedInAnalyticsGroupByOutputType = {
    id: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date
    engagements: number | null
    impressions: number | null
    impressionsUnique: number | null
    followersCount: number | null
    reactions: number | null
    createdAt: Date
    updatedAt: Date
    _count: SproutLinkedInAnalyticsCountAggregateOutputType | null
    _avg: SproutLinkedInAnalyticsAvgAggregateOutputType | null
    _sum: SproutLinkedInAnalyticsSumAggregateOutputType | null
    _min: SproutLinkedInAnalyticsMinAggregateOutputType | null
    _max: SproutLinkedInAnalyticsMaxAggregateOutputType | null
  }

  type GetSproutLinkedInAnalyticsGroupByPayload<T extends SproutLinkedInAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SproutLinkedInAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SproutLinkedInAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SproutLinkedInAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], SproutLinkedInAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type SproutLinkedInAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    reactions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutLinkedInAnalytics"]>

  export type SproutLinkedInAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    reactions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutLinkedInAnalytics"]>

  export type SproutLinkedInAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    reactions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutLinkedInAnalytics"]>

  export type SproutLinkedInAnalyticsSelectScalar = {
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    engagements?: boolean
    impressions?: boolean
    impressionsUnique?: boolean
    followersCount?: boolean
    reactions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SproutLinkedInAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sproutSocialAccountId" | "customerProfileId" | "reportingDate" | "engagements" | "impressions" | "impressionsUnique" | "followersCount" | "reactions" | "createdAt" | "updatedAt", ExtArgs["result"]["sproutLinkedInAnalytics"]>
  export type SproutLinkedInAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }
  export type SproutLinkedInAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }
  export type SproutLinkedInAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }

  export type $SproutLinkedInAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SproutLinkedInAnalytics"
    objects: {
      sproutSocialAccount: Prisma.$SproutSocialAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sproutSocialAccountId: string
      customerProfileId: number
      reportingDate: Date
      engagements: number | null
      impressions: number | null
      impressionsUnique: number | null
      followersCount: number | null
      reactions: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sproutLinkedInAnalytics"]>
    composites: {}
  }

  type SproutLinkedInAnalyticsGetPayload<S extends boolean | null | undefined | SproutLinkedInAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload, S>

  type SproutLinkedInAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SproutLinkedInAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SproutLinkedInAnalyticsCountAggregateInputType | true
    }

  export interface SproutLinkedInAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SproutLinkedInAnalytics'], meta: { name: 'SproutLinkedInAnalytics' } }
    /**
     * Find zero or one SproutLinkedInAnalytics that matches the filter.
     * @param {SproutLinkedInAnalyticsFindUniqueArgs} args - Arguments to find a SproutLinkedInAnalytics
     * @example
     * // Get one SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SproutLinkedInAnalyticsFindUniqueArgs>(args: SelectSubset<T, SproutLinkedInAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__SproutLinkedInAnalyticsClient<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SproutLinkedInAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SproutLinkedInAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a SproutLinkedInAnalytics
     * @example
     * // Get one SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SproutLinkedInAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, SproutLinkedInAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SproutLinkedInAnalyticsClient<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutLinkedInAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutLinkedInAnalyticsFindFirstArgs} args - Arguments to find a SproutLinkedInAnalytics
     * @example
     * // Get one SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SproutLinkedInAnalyticsFindFirstArgs>(args?: SelectSubset<T, SproutLinkedInAnalyticsFindFirstArgs<ExtArgs>>): Prisma__SproutLinkedInAnalyticsClient<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutLinkedInAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutLinkedInAnalyticsFindFirstOrThrowArgs} args - Arguments to find a SproutLinkedInAnalytics
     * @example
     * // Get one SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SproutLinkedInAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, SproutLinkedInAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SproutLinkedInAnalyticsClient<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SproutLinkedInAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutLinkedInAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.findMany()
     * 
     * // Get first 10 SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sproutLinkedInAnalyticsWithIdOnly = await prisma.sproutLinkedInAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SproutLinkedInAnalyticsFindManyArgs>(args?: SelectSubset<T, SproutLinkedInAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SproutLinkedInAnalytics.
     * @param {SproutLinkedInAnalyticsCreateArgs} args - Arguments to create a SproutLinkedInAnalytics.
     * @example
     * // Create one SproutLinkedInAnalytics
     * const SproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.create({
     *   data: {
     *     // ... data to create a SproutLinkedInAnalytics
     *   }
     * })
     * 
     */
    create<T extends SproutLinkedInAnalyticsCreateArgs>(args: SelectSubset<T, SproutLinkedInAnalyticsCreateArgs<ExtArgs>>): Prisma__SproutLinkedInAnalyticsClient<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SproutLinkedInAnalytics.
     * @param {SproutLinkedInAnalyticsCreateManyArgs} args - Arguments to create many SproutLinkedInAnalytics.
     * @example
     * // Create many SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SproutLinkedInAnalyticsCreateManyArgs>(args?: SelectSubset<T, SproutLinkedInAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SproutLinkedInAnalytics and returns the data saved in the database.
     * @param {SproutLinkedInAnalyticsCreateManyAndReturnArgs} args - Arguments to create many SproutLinkedInAnalytics.
     * @example
     * // Create many SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SproutLinkedInAnalytics and only return the `id`
     * const sproutLinkedInAnalyticsWithIdOnly = await prisma.sproutLinkedInAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SproutLinkedInAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, SproutLinkedInAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SproutLinkedInAnalytics.
     * @param {SproutLinkedInAnalyticsDeleteArgs} args - Arguments to delete one SproutLinkedInAnalytics.
     * @example
     * // Delete one SproutLinkedInAnalytics
     * const SproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.delete({
     *   where: {
     *     // ... filter to delete one SproutLinkedInAnalytics
     *   }
     * })
     * 
     */
    delete<T extends SproutLinkedInAnalyticsDeleteArgs>(args: SelectSubset<T, SproutLinkedInAnalyticsDeleteArgs<ExtArgs>>): Prisma__SproutLinkedInAnalyticsClient<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SproutLinkedInAnalytics.
     * @param {SproutLinkedInAnalyticsUpdateArgs} args - Arguments to update one SproutLinkedInAnalytics.
     * @example
     * // Update one SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SproutLinkedInAnalyticsUpdateArgs>(args: SelectSubset<T, SproutLinkedInAnalyticsUpdateArgs<ExtArgs>>): Prisma__SproutLinkedInAnalyticsClient<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SproutLinkedInAnalytics.
     * @param {SproutLinkedInAnalyticsDeleteManyArgs} args - Arguments to filter SproutLinkedInAnalytics to delete.
     * @example
     * // Delete a few SproutLinkedInAnalytics
     * const { count } = await prisma.sproutLinkedInAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SproutLinkedInAnalyticsDeleteManyArgs>(args?: SelectSubset<T, SproutLinkedInAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutLinkedInAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutLinkedInAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SproutLinkedInAnalyticsUpdateManyArgs>(args: SelectSubset<T, SproutLinkedInAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutLinkedInAnalytics and returns the data updated in the database.
     * @param {SproutLinkedInAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many SproutLinkedInAnalytics.
     * @example
     * // Update many SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SproutLinkedInAnalytics and only return the `id`
     * const sproutLinkedInAnalyticsWithIdOnly = await prisma.sproutLinkedInAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SproutLinkedInAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, SproutLinkedInAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SproutLinkedInAnalytics.
     * @param {SproutLinkedInAnalyticsUpsertArgs} args - Arguments to update or create a SproutLinkedInAnalytics.
     * @example
     * // Update or create a SproutLinkedInAnalytics
     * const sproutLinkedInAnalytics = await prisma.sproutLinkedInAnalytics.upsert({
     *   create: {
     *     // ... data to create a SproutLinkedInAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SproutLinkedInAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends SproutLinkedInAnalyticsUpsertArgs>(args: SelectSubset<T, SproutLinkedInAnalyticsUpsertArgs<ExtArgs>>): Prisma__SproutLinkedInAnalyticsClient<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SproutLinkedInAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutLinkedInAnalyticsCountArgs} args - Arguments to filter SproutLinkedInAnalytics to count.
     * @example
     * // Count the number of SproutLinkedInAnalytics
     * const count = await prisma.sproutLinkedInAnalytics.count({
     *   where: {
     *     // ... the filter for the SproutLinkedInAnalytics we want to count
     *   }
     * })
    **/
    count<T extends SproutLinkedInAnalyticsCountArgs>(
      args?: Subset<T, SproutLinkedInAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SproutLinkedInAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SproutLinkedInAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutLinkedInAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SproutLinkedInAnalyticsAggregateArgs>(args: Subset<T, SproutLinkedInAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetSproutLinkedInAnalyticsAggregateType<T>>

    /**
     * Group by SproutLinkedInAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutLinkedInAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SproutLinkedInAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SproutLinkedInAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: SproutLinkedInAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SproutLinkedInAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSproutLinkedInAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SproutLinkedInAnalytics model
   */
  readonly fields: SproutLinkedInAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SproutLinkedInAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SproutLinkedInAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sproutSocialAccount<T extends SproutSocialAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccountDefaultArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SproutLinkedInAnalytics model
   */
  interface SproutLinkedInAnalyticsFieldRefs {
    readonly id: FieldRef<"SproutLinkedInAnalytics", 'String'>
    readonly sproutSocialAccountId: FieldRef<"SproutLinkedInAnalytics", 'String'>
    readonly customerProfileId: FieldRef<"SproutLinkedInAnalytics", 'Int'>
    readonly reportingDate: FieldRef<"SproutLinkedInAnalytics", 'DateTime'>
    readonly engagements: FieldRef<"SproutLinkedInAnalytics", 'Int'>
    readonly impressions: FieldRef<"SproutLinkedInAnalytics", 'Int'>
    readonly impressionsUnique: FieldRef<"SproutLinkedInAnalytics", 'Int'>
    readonly followersCount: FieldRef<"SproutLinkedInAnalytics", 'Int'>
    readonly reactions: FieldRef<"SproutLinkedInAnalytics", 'Int'>
    readonly createdAt: FieldRef<"SproutLinkedInAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"SproutLinkedInAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SproutLinkedInAnalytics findUnique
   */
  export type SproutLinkedInAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutLinkedInAnalytics to fetch.
     */
    where: SproutLinkedInAnalyticsWhereUniqueInput
  }

  /**
   * SproutLinkedInAnalytics findUniqueOrThrow
   */
  export type SproutLinkedInAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutLinkedInAnalytics to fetch.
     */
    where: SproutLinkedInAnalyticsWhereUniqueInput
  }

  /**
   * SproutLinkedInAnalytics findFirst
   */
  export type SproutLinkedInAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutLinkedInAnalytics to fetch.
     */
    where?: SproutLinkedInAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutLinkedInAnalytics to fetch.
     */
    orderBy?: SproutLinkedInAnalyticsOrderByWithRelationInput | SproutLinkedInAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutLinkedInAnalytics.
     */
    cursor?: SproutLinkedInAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutLinkedInAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutLinkedInAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutLinkedInAnalytics.
     */
    distinct?: SproutLinkedInAnalyticsScalarFieldEnum | SproutLinkedInAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutLinkedInAnalytics findFirstOrThrow
   */
  export type SproutLinkedInAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutLinkedInAnalytics to fetch.
     */
    where?: SproutLinkedInAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutLinkedInAnalytics to fetch.
     */
    orderBy?: SproutLinkedInAnalyticsOrderByWithRelationInput | SproutLinkedInAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutLinkedInAnalytics.
     */
    cursor?: SproutLinkedInAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutLinkedInAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutLinkedInAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutLinkedInAnalytics.
     */
    distinct?: SproutLinkedInAnalyticsScalarFieldEnum | SproutLinkedInAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutLinkedInAnalytics findMany
   */
  export type SproutLinkedInAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutLinkedInAnalytics to fetch.
     */
    where?: SproutLinkedInAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutLinkedInAnalytics to fetch.
     */
    orderBy?: SproutLinkedInAnalyticsOrderByWithRelationInput | SproutLinkedInAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SproutLinkedInAnalytics.
     */
    cursor?: SproutLinkedInAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutLinkedInAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutLinkedInAnalytics.
     */
    skip?: number
    distinct?: SproutLinkedInAnalyticsScalarFieldEnum | SproutLinkedInAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutLinkedInAnalytics create
   */
  export type SproutLinkedInAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a SproutLinkedInAnalytics.
     */
    data: XOR<SproutLinkedInAnalyticsCreateInput, SproutLinkedInAnalyticsUncheckedCreateInput>
  }

  /**
   * SproutLinkedInAnalytics createMany
   */
  export type SproutLinkedInAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SproutLinkedInAnalytics.
     */
    data: SproutLinkedInAnalyticsCreateManyInput | SproutLinkedInAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SproutLinkedInAnalytics createManyAndReturn
   */
  export type SproutLinkedInAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many SproutLinkedInAnalytics.
     */
    data: SproutLinkedInAnalyticsCreateManyInput | SproutLinkedInAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutLinkedInAnalytics update
   */
  export type SproutLinkedInAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a SproutLinkedInAnalytics.
     */
    data: XOR<SproutLinkedInAnalyticsUpdateInput, SproutLinkedInAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which SproutLinkedInAnalytics to update.
     */
    where: SproutLinkedInAnalyticsWhereUniqueInput
  }

  /**
   * SproutLinkedInAnalytics updateMany
   */
  export type SproutLinkedInAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SproutLinkedInAnalytics.
     */
    data: XOR<SproutLinkedInAnalyticsUpdateManyMutationInput, SproutLinkedInAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SproutLinkedInAnalytics to update
     */
    where?: SproutLinkedInAnalyticsWhereInput
    /**
     * Limit how many SproutLinkedInAnalytics to update.
     */
    limit?: number
  }

  /**
   * SproutLinkedInAnalytics updateManyAndReturn
   */
  export type SproutLinkedInAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update SproutLinkedInAnalytics.
     */
    data: XOR<SproutLinkedInAnalyticsUpdateManyMutationInput, SproutLinkedInAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SproutLinkedInAnalytics to update
     */
    where?: SproutLinkedInAnalyticsWhereInput
    /**
     * Limit how many SproutLinkedInAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutLinkedInAnalytics upsert
   */
  export type SproutLinkedInAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the SproutLinkedInAnalytics to update in case it exists.
     */
    where: SproutLinkedInAnalyticsWhereUniqueInput
    /**
     * In case the SproutLinkedInAnalytics found by the `where` argument doesn't exist, create a new SproutLinkedInAnalytics with this data.
     */
    create: XOR<SproutLinkedInAnalyticsCreateInput, SproutLinkedInAnalyticsUncheckedCreateInput>
    /**
     * In case the SproutLinkedInAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SproutLinkedInAnalyticsUpdateInput, SproutLinkedInAnalyticsUncheckedUpdateInput>
  }

  /**
   * SproutLinkedInAnalytics delete
   */
  export type SproutLinkedInAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which SproutLinkedInAnalytics to delete.
     */
    where: SproutLinkedInAnalyticsWhereUniqueInput
  }

  /**
   * SproutLinkedInAnalytics deleteMany
   */
  export type SproutLinkedInAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutLinkedInAnalytics to delete
     */
    where?: SproutLinkedInAnalyticsWhereInput
    /**
     * Limit how many SproutLinkedInAnalytics to delete.
     */
    limit?: number
  }

  /**
   * SproutLinkedInAnalytics without action
   */
  export type SproutLinkedInAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model SproutPinterestAnalytics
   */

  export type AggregateSproutPinterestAnalytics = {
    _count: SproutPinterestAnalyticsCountAggregateOutputType | null
    _avg: SproutPinterestAnalyticsAvgAggregateOutputType | null
    _sum: SproutPinterestAnalyticsSumAggregateOutputType | null
    _min: SproutPinterestAnalyticsMinAggregateOutputType | null
    _max: SproutPinterestAnalyticsMaxAggregateOutputType | null
  }

  export type SproutPinterestAnalyticsAvgAggregateOutputType = {
    customerProfileId: number | null
    followersCount: number | null
    followingCount: number | null
  }

  export type SproutPinterestAnalyticsSumAggregateOutputType = {
    customerProfileId: number | null
    followersCount: number | null
    followingCount: number | null
  }

  export type SproutPinterestAnalyticsMinAggregateOutputType = {
    id: string | null
    sproutSocialAccountId: string | null
    customerProfileId: number | null
    reportingDate: Date | null
    followersCount: number | null
    followingCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutPinterestAnalyticsMaxAggregateOutputType = {
    id: string | null
    sproutSocialAccountId: string | null
    customerProfileId: number | null
    reportingDate: Date | null
    followersCount: number | null
    followingCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutPinterestAnalyticsCountAggregateOutputType = {
    id: number
    sproutSocialAccountId: number
    customerProfileId: number
    reportingDate: number
    followersCount: number
    followingCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SproutPinterestAnalyticsAvgAggregateInputType = {
    customerProfileId?: true
    followersCount?: true
    followingCount?: true
  }

  export type SproutPinterestAnalyticsSumAggregateInputType = {
    customerProfileId?: true
    followersCount?: true
    followingCount?: true
  }

  export type SproutPinterestAnalyticsMinAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    followersCount?: true
    followingCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutPinterestAnalyticsMaxAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    followersCount?: true
    followingCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutPinterestAnalyticsCountAggregateInputType = {
    id?: true
    sproutSocialAccountId?: true
    customerProfileId?: true
    reportingDate?: true
    followersCount?: true
    followingCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SproutPinterestAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutPinterestAnalytics to aggregate.
     */
    where?: SproutPinterestAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutPinterestAnalytics to fetch.
     */
    orderBy?: SproutPinterestAnalyticsOrderByWithRelationInput | SproutPinterestAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SproutPinterestAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutPinterestAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutPinterestAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SproutPinterestAnalytics
    **/
    _count?: true | SproutPinterestAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SproutPinterestAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SproutPinterestAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SproutPinterestAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SproutPinterestAnalyticsMaxAggregateInputType
  }

  export type GetSproutPinterestAnalyticsAggregateType<T extends SproutPinterestAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateSproutPinterestAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSproutPinterestAnalytics[P]>
      : GetScalarType<T[P], AggregateSproutPinterestAnalytics[P]>
  }




  export type SproutPinterestAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutPinterestAnalyticsWhereInput
    orderBy?: SproutPinterestAnalyticsOrderByWithAggregationInput | SproutPinterestAnalyticsOrderByWithAggregationInput[]
    by: SproutPinterestAnalyticsScalarFieldEnum[] | SproutPinterestAnalyticsScalarFieldEnum
    having?: SproutPinterestAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SproutPinterestAnalyticsCountAggregateInputType | true
    _avg?: SproutPinterestAnalyticsAvgAggregateInputType
    _sum?: SproutPinterestAnalyticsSumAggregateInputType
    _min?: SproutPinterestAnalyticsMinAggregateInputType
    _max?: SproutPinterestAnalyticsMaxAggregateInputType
  }

  export type SproutPinterestAnalyticsGroupByOutputType = {
    id: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date
    followersCount: number | null
    followingCount: number | null
    createdAt: Date
    updatedAt: Date
    _count: SproutPinterestAnalyticsCountAggregateOutputType | null
    _avg: SproutPinterestAnalyticsAvgAggregateOutputType | null
    _sum: SproutPinterestAnalyticsSumAggregateOutputType | null
    _min: SproutPinterestAnalyticsMinAggregateOutputType | null
    _max: SproutPinterestAnalyticsMaxAggregateOutputType | null
  }

  type GetSproutPinterestAnalyticsGroupByPayload<T extends SproutPinterestAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SproutPinterestAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SproutPinterestAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SproutPinterestAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], SproutPinterestAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type SproutPinterestAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    followersCount?: boolean
    followingCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutPinterestAnalytics"]>

  export type SproutPinterestAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    followersCount?: boolean
    followingCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutPinterestAnalytics"]>

  export type SproutPinterestAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    followersCount?: boolean
    followingCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutPinterestAnalytics"]>

  export type SproutPinterestAnalyticsSelectScalar = {
    id?: boolean
    sproutSocialAccountId?: boolean
    customerProfileId?: boolean
    reportingDate?: boolean
    followersCount?: boolean
    followingCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SproutPinterestAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sproutSocialAccountId" | "customerProfileId" | "reportingDate" | "followersCount" | "followingCount" | "createdAt" | "updatedAt", ExtArgs["result"]["sproutPinterestAnalytics"]>
  export type SproutPinterestAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }
  export type SproutPinterestAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }
  export type SproutPinterestAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
  }

  export type $SproutPinterestAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SproutPinterestAnalytics"
    objects: {
      sproutSocialAccount: Prisma.$SproutSocialAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sproutSocialAccountId: string
      customerProfileId: number
      reportingDate: Date
      followersCount: number | null
      followingCount: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sproutPinterestAnalytics"]>
    composites: {}
  }

  type SproutPinterestAnalyticsGetPayload<S extends boolean | null | undefined | SproutPinterestAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload, S>

  type SproutPinterestAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SproutPinterestAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SproutPinterestAnalyticsCountAggregateInputType | true
    }

  export interface SproutPinterestAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SproutPinterestAnalytics'], meta: { name: 'SproutPinterestAnalytics' } }
    /**
     * Find zero or one SproutPinterestAnalytics that matches the filter.
     * @param {SproutPinterestAnalyticsFindUniqueArgs} args - Arguments to find a SproutPinterestAnalytics
     * @example
     * // Get one SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SproutPinterestAnalyticsFindUniqueArgs>(args: SelectSubset<T, SproutPinterestAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__SproutPinterestAnalyticsClient<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SproutPinterestAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SproutPinterestAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a SproutPinterestAnalytics
     * @example
     * // Get one SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SproutPinterestAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, SproutPinterestAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SproutPinterestAnalyticsClient<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutPinterestAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutPinterestAnalyticsFindFirstArgs} args - Arguments to find a SproutPinterestAnalytics
     * @example
     * // Get one SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SproutPinterestAnalyticsFindFirstArgs>(args?: SelectSubset<T, SproutPinterestAnalyticsFindFirstArgs<ExtArgs>>): Prisma__SproutPinterestAnalyticsClient<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutPinterestAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutPinterestAnalyticsFindFirstOrThrowArgs} args - Arguments to find a SproutPinterestAnalytics
     * @example
     * // Get one SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SproutPinterestAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, SproutPinterestAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SproutPinterestAnalyticsClient<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SproutPinterestAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutPinterestAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.findMany()
     * 
     * // Get first 10 SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sproutPinterestAnalyticsWithIdOnly = await prisma.sproutPinterestAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SproutPinterestAnalyticsFindManyArgs>(args?: SelectSubset<T, SproutPinterestAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SproutPinterestAnalytics.
     * @param {SproutPinterestAnalyticsCreateArgs} args - Arguments to create a SproutPinterestAnalytics.
     * @example
     * // Create one SproutPinterestAnalytics
     * const SproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.create({
     *   data: {
     *     // ... data to create a SproutPinterestAnalytics
     *   }
     * })
     * 
     */
    create<T extends SproutPinterestAnalyticsCreateArgs>(args: SelectSubset<T, SproutPinterestAnalyticsCreateArgs<ExtArgs>>): Prisma__SproutPinterestAnalyticsClient<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SproutPinterestAnalytics.
     * @param {SproutPinterestAnalyticsCreateManyArgs} args - Arguments to create many SproutPinterestAnalytics.
     * @example
     * // Create many SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SproutPinterestAnalyticsCreateManyArgs>(args?: SelectSubset<T, SproutPinterestAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SproutPinterestAnalytics and returns the data saved in the database.
     * @param {SproutPinterestAnalyticsCreateManyAndReturnArgs} args - Arguments to create many SproutPinterestAnalytics.
     * @example
     * // Create many SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SproutPinterestAnalytics and only return the `id`
     * const sproutPinterestAnalyticsWithIdOnly = await prisma.sproutPinterestAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SproutPinterestAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, SproutPinterestAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SproutPinterestAnalytics.
     * @param {SproutPinterestAnalyticsDeleteArgs} args - Arguments to delete one SproutPinterestAnalytics.
     * @example
     * // Delete one SproutPinterestAnalytics
     * const SproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.delete({
     *   where: {
     *     // ... filter to delete one SproutPinterestAnalytics
     *   }
     * })
     * 
     */
    delete<T extends SproutPinterestAnalyticsDeleteArgs>(args: SelectSubset<T, SproutPinterestAnalyticsDeleteArgs<ExtArgs>>): Prisma__SproutPinterestAnalyticsClient<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SproutPinterestAnalytics.
     * @param {SproutPinterestAnalyticsUpdateArgs} args - Arguments to update one SproutPinterestAnalytics.
     * @example
     * // Update one SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SproutPinterestAnalyticsUpdateArgs>(args: SelectSubset<T, SproutPinterestAnalyticsUpdateArgs<ExtArgs>>): Prisma__SproutPinterestAnalyticsClient<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SproutPinterestAnalytics.
     * @param {SproutPinterestAnalyticsDeleteManyArgs} args - Arguments to filter SproutPinterestAnalytics to delete.
     * @example
     * // Delete a few SproutPinterestAnalytics
     * const { count } = await prisma.sproutPinterestAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SproutPinterestAnalyticsDeleteManyArgs>(args?: SelectSubset<T, SproutPinterestAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutPinterestAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutPinterestAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SproutPinterestAnalyticsUpdateManyArgs>(args: SelectSubset<T, SproutPinterestAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutPinterestAnalytics and returns the data updated in the database.
     * @param {SproutPinterestAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many SproutPinterestAnalytics.
     * @example
     * // Update many SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SproutPinterestAnalytics and only return the `id`
     * const sproutPinterestAnalyticsWithIdOnly = await prisma.sproutPinterestAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SproutPinterestAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, SproutPinterestAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SproutPinterestAnalytics.
     * @param {SproutPinterestAnalyticsUpsertArgs} args - Arguments to update or create a SproutPinterestAnalytics.
     * @example
     * // Update or create a SproutPinterestAnalytics
     * const sproutPinterestAnalytics = await prisma.sproutPinterestAnalytics.upsert({
     *   create: {
     *     // ... data to create a SproutPinterestAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SproutPinterestAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends SproutPinterestAnalyticsUpsertArgs>(args: SelectSubset<T, SproutPinterestAnalyticsUpsertArgs<ExtArgs>>): Prisma__SproutPinterestAnalyticsClient<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SproutPinterestAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutPinterestAnalyticsCountArgs} args - Arguments to filter SproutPinterestAnalytics to count.
     * @example
     * // Count the number of SproutPinterestAnalytics
     * const count = await prisma.sproutPinterestAnalytics.count({
     *   where: {
     *     // ... the filter for the SproutPinterestAnalytics we want to count
     *   }
     * })
    **/
    count<T extends SproutPinterestAnalyticsCountArgs>(
      args?: Subset<T, SproutPinterestAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SproutPinterestAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SproutPinterestAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutPinterestAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SproutPinterestAnalyticsAggregateArgs>(args: Subset<T, SproutPinterestAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetSproutPinterestAnalyticsAggregateType<T>>

    /**
     * Group by SproutPinterestAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutPinterestAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SproutPinterestAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SproutPinterestAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: SproutPinterestAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SproutPinterestAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSproutPinterestAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SproutPinterestAnalytics model
   */
  readonly fields: SproutPinterestAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SproutPinterestAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SproutPinterestAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sproutSocialAccount<T extends SproutSocialAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccountDefaultArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SproutPinterestAnalytics model
   */
  interface SproutPinterestAnalyticsFieldRefs {
    readonly id: FieldRef<"SproutPinterestAnalytics", 'String'>
    readonly sproutSocialAccountId: FieldRef<"SproutPinterestAnalytics", 'String'>
    readonly customerProfileId: FieldRef<"SproutPinterestAnalytics", 'Int'>
    readonly reportingDate: FieldRef<"SproutPinterestAnalytics", 'DateTime'>
    readonly followersCount: FieldRef<"SproutPinterestAnalytics", 'Int'>
    readonly followingCount: FieldRef<"SproutPinterestAnalytics", 'Int'>
    readonly createdAt: FieldRef<"SproutPinterestAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"SproutPinterestAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SproutPinterestAnalytics findUnique
   */
  export type SproutPinterestAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutPinterestAnalytics to fetch.
     */
    where: SproutPinterestAnalyticsWhereUniqueInput
  }

  /**
   * SproutPinterestAnalytics findUniqueOrThrow
   */
  export type SproutPinterestAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutPinterestAnalytics to fetch.
     */
    where: SproutPinterestAnalyticsWhereUniqueInput
  }

  /**
   * SproutPinterestAnalytics findFirst
   */
  export type SproutPinterestAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutPinterestAnalytics to fetch.
     */
    where?: SproutPinterestAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutPinterestAnalytics to fetch.
     */
    orderBy?: SproutPinterestAnalyticsOrderByWithRelationInput | SproutPinterestAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutPinterestAnalytics.
     */
    cursor?: SproutPinterestAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutPinterestAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutPinterestAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutPinterestAnalytics.
     */
    distinct?: SproutPinterestAnalyticsScalarFieldEnum | SproutPinterestAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutPinterestAnalytics findFirstOrThrow
   */
  export type SproutPinterestAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutPinterestAnalytics to fetch.
     */
    where?: SproutPinterestAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutPinterestAnalytics to fetch.
     */
    orderBy?: SproutPinterestAnalyticsOrderByWithRelationInput | SproutPinterestAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutPinterestAnalytics.
     */
    cursor?: SproutPinterestAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutPinterestAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutPinterestAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutPinterestAnalytics.
     */
    distinct?: SproutPinterestAnalyticsScalarFieldEnum | SproutPinterestAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutPinterestAnalytics findMany
   */
  export type SproutPinterestAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which SproutPinterestAnalytics to fetch.
     */
    where?: SproutPinterestAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutPinterestAnalytics to fetch.
     */
    orderBy?: SproutPinterestAnalyticsOrderByWithRelationInput | SproutPinterestAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SproutPinterestAnalytics.
     */
    cursor?: SproutPinterestAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutPinterestAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutPinterestAnalytics.
     */
    skip?: number
    distinct?: SproutPinterestAnalyticsScalarFieldEnum | SproutPinterestAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutPinterestAnalytics create
   */
  export type SproutPinterestAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a SproutPinterestAnalytics.
     */
    data: XOR<SproutPinterestAnalyticsCreateInput, SproutPinterestAnalyticsUncheckedCreateInput>
  }

  /**
   * SproutPinterestAnalytics createMany
   */
  export type SproutPinterestAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SproutPinterestAnalytics.
     */
    data: SproutPinterestAnalyticsCreateManyInput | SproutPinterestAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SproutPinterestAnalytics createManyAndReturn
   */
  export type SproutPinterestAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many SproutPinterestAnalytics.
     */
    data: SproutPinterestAnalyticsCreateManyInput | SproutPinterestAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutPinterestAnalytics update
   */
  export type SproutPinterestAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a SproutPinterestAnalytics.
     */
    data: XOR<SproutPinterestAnalyticsUpdateInput, SproutPinterestAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which SproutPinterestAnalytics to update.
     */
    where: SproutPinterestAnalyticsWhereUniqueInput
  }

  /**
   * SproutPinterestAnalytics updateMany
   */
  export type SproutPinterestAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SproutPinterestAnalytics.
     */
    data: XOR<SproutPinterestAnalyticsUpdateManyMutationInput, SproutPinterestAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SproutPinterestAnalytics to update
     */
    where?: SproutPinterestAnalyticsWhereInput
    /**
     * Limit how many SproutPinterestAnalytics to update.
     */
    limit?: number
  }

  /**
   * SproutPinterestAnalytics updateManyAndReturn
   */
  export type SproutPinterestAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update SproutPinterestAnalytics.
     */
    data: XOR<SproutPinterestAnalyticsUpdateManyMutationInput, SproutPinterestAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which SproutPinterestAnalytics to update
     */
    where?: SproutPinterestAnalyticsWhereInput
    /**
     * Limit how many SproutPinterestAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SproutPinterestAnalytics upsert
   */
  export type SproutPinterestAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the SproutPinterestAnalytics to update in case it exists.
     */
    where: SproutPinterestAnalyticsWhereUniqueInput
    /**
     * In case the SproutPinterestAnalytics found by the `where` argument doesn't exist, create a new SproutPinterestAnalytics with this data.
     */
    create: XOR<SproutPinterestAnalyticsCreateInput, SproutPinterestAnalyticsUncheckedCreateInput>
    /**
     * In case the SproutPinterestAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SproutPinterestAnalyticsUpdateInput, SproutPinterestAnalyticsUncheckedUpdateInput>
  }

  /**
   * SproutPinterestAnalytics delete
   */
  export type SproutPinterestAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which SproutPinterestAnalytics to delete.
     */
    where: SproutPinterestAnalyticsWhereUniqueInput
  }

  /**
   * SproutPinterestAnalytics deleteMany
   */
  export type SproutPinterestAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutPinterestAnalytics to delete
     */
    where?: SproutPinterestAnalyticsWhereInput
    /**
     * Limit how many SproutPinterestAnalytics to delete.
     */
    limit?: number
  }

  /**
   * SproutPinterestAnalytics without action
   */
  export type SproutPinterestAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model SproutSocialAccount
   */

  export type AggregateSproutSocialAccount = {
    _count: SproutSocialAccountCountAggregateOutputType | null
    _avg: SproutSocialAccountAvgAggregateOutputType | null
    _sum: SproutSocialAccountSumAggregateOutputType | null
    _min: SproutSocialAccountMinAggregateOutputType | null
    _max: SproutSocialAccountMaxAggregateOutputType | null
  }

  export type SproutSocialAccountAvgAggregateOutputType = {
    customerProfileId: number | null
    groups: number | null
  }

  export type SproutSocialAccountSumAggregateOutputType = {
    customerProfileId: number | null
    groups: number[]
  }

  export type SproutSocialAccountMinAggregateOutputType = {
    id: string | null
    customerProfileId: number | null
    networkType: string | null
    name: string | null
    nativeName: string | null
    link: string | null
    nativeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutSocialAccountMaxAggregateOutputType = {
    id: string | null
    customerProfileId: number | null
    networkType: string | null
    name: string | null
    nativeName: string | null
    link: string | null
    nativeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SproutSocialAccountCountAggregateOutputType = {
    id: number
    customerProfileId: number
    networkType: number
    name: number
    nativeName: number
    link: number
    nativeId: number
    groups: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SproutSocialAccountAvgAggregateInputType = {
    customerProfileId?: true
    groups?: true
  }

  export type SproutSocialAccountSumAggregateInputType = {
    customerProfileId?: true
    groups?: true
  }

  export type SproutSocialAccountMinAggregateInputType = {
    id?: true
    customerProfileId?: true
    networkType?: true
    name?: true
    nativeName?: true
    link?: true
    nativeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutSocialAccountMaxAggregateInputType = {
    id?: true
    customerProfileId?: true
    networkType?: true
    name?: true
    nativeName?: true
    link?: true
    nativeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SproutSocialAccountCountAggregateInputType = {
    id?: true
    customerProfileId?: true
    networkType?: true
    name?: true
    nativeName?: true
    link?: true
    nativeId?: true
    groups?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SproutSocialAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutSocialAccount to aggregate.
     */
    where?: SproutSocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutSocialAccounts to fetch.
     */
    orderBy?: SproutSocialAccountOrderByWithRelationInput | SproutSocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SproutSocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutSocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutSocialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SproutSocialAccounts
    **/
    _count?: true | SproutSocialAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SproutSocialAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SproutSocialAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SproutSocialAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SproutSocialAccountMaxAggregateInputType
  }

  export type GetSproutSocialAccountAggregateType<T extends SproutSocialAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSproutSocialAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSproutSocialAccount[P]>
      : GetScalarType<T[P], AggregateSproutSocialAccount[P]>
  }




  export type SproutSocialAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SproutSocialAccountWhereInput
    orderBy?: SproutSocialAccountOrderByWithAggregationInput | SproutSocialAccountOrderByWithAggregationInput[]
    by: SproutSocialAccountScalarFieldEnum[] | SproutSocialAccountScalarFieldEnum
    having?: SproutSocialAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SproutSocialAccountCountAggregateInputType | true
    _avg?: SproutSocialAccountAvgAggregateInputType
    _sum?: SproutSocialAccountSumAggregateInputType
    _min?: SproutSocialAccountMinAggregateInputType
    _max?: SproutSocialAccountMaxAggregateInputType
  }

  export type SproutSocialAccountGroupByOutputType = {
    id: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups: number[]
    createdAt: Date
    updatedAt: Date
    _count: SproutSocialAccountCountAggregateOutputType | null
    _avg: SproutSocialAccountAvgAggregateOutputType | null
    _sum: SproutSocialAccountSumAggregateOutputType | null
    _min: SproutSocialAccountMinAggregateOutputType | null
    _max: SproutSocialAccountMaxAggregateOutputType | null
  }

  type GetSproutSocialAccountGroupByPayload<T extends SproutSocialAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SproutSocialAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SproutSocialAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SproutSocialAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SproutSocialAccountGroupByOutputType[P]>
        }
      >
    >


  export type SproutSocialAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerProfileId?: boolean
    networkType?: boolean
    name?: boolean
    nativeName?: boolean
    link?: boolean
    nativeId?: boolean
    groups?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facebookAnalytics?: boolean | SproutSocialAccount$facebookAnalyticsArgs<ExtArgs>
    facebookPosts?: boolean | SproutSocialAccount$facebookPostsArgs<ExtArgs>
    facebookPostAnalytics?: boolean | SproutSocialAccount$facebookPostAnalyticsArgs<ExtArgs>
    instagramAnalytics?: boolean | SproutSocialAccount$instagramAnalyticsArgs<ExtArgs>
    linkedInAnalytics?: boolean | SproutSocialAccount$linkedInAnalyticsArgs<ExtArgs>
    pinterestAnalytics?: boolean | SproutSocialAccount$pinterestAnalyticsArgs<ExtArgs>
    users?: boolean | SproutSocialAccount$usersArgs<ExtArgs>
    _count?: boolean | SproutSocialAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sproutSocialAccount"]>

  export type SproutSocialAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerProfileId?: boolean
    networkType?: boolean
    name?: boolean
    nativeName?: boolean
    link?: boolean
    nativeId?: boolean
    groups?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sproutSocialAccount"]>

  export type SproutSocialAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerProfileId?: boolean
    networkType?: boolean
    name?: boolean
    nativeName?: boolean
    link?: boolean
    nativeId?: boolean
    groups?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sproutSocialAccount"]>

  export type SproutSocialAccountSelectScalar = {
    id?: boolean
    customerProfileId?: boolean
    networkType?: boolean
    name?: boolean
    nativeName?: boolean
    link?: boolean
    nativeId?: boolean
    groups?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SproutSocialAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerProfileId" | "networkType" | "name" | "nativeName" | "link" | "nativeId" | "groups" | "createdAt" | "updatedAt", ExtArgs["result"]["sproutSocialAccount"]>
  export type SproutSocialAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facebookAnalytics?: boolean | SproutSocialAccount$facebookAnalyticsArgs<ExtArgs>
    facebookPosts?: boolean | SproutSocialAccount$facebookPostsArgs<ExtArgs>
    facebookPostAnalytics?: boolean | SproutSocialAccount$facebookPostAnalyticsArgs<ExtArgs>
    instagramAnalytics?: boolean | SproutSocialAccount$instagramAnalyticsArgs<ExtArgs>
    linkedInAnalytics?: boolean | SproutSocialAccount$linkedInAnalyticsArgs<ExtArgs>
    pinterestAnalytics?: boolean | SproutSocialAccount$pinterestAnalyticsArgs<ExtArgs>
    users?: boolean | SproutSocialAccount$usersArgs<ExtArgs>
    _count?: boolean | SproutSocialAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SproutSocialAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SproutSocialAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SproutSocialAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SproutSocialAccount"
    objects: {
      facebookAnalytics: Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>[]
      facebookPosts: Prisma.$SproutFacebookPostPayload<ExtArgs>[]
      facebookPostAnalytics: Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>[]
      instagramAnalytics: Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>[]
      linkedInAnalytics: Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>[]
      pinterestAnalytics: Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>[]
      users: Prisma.$UserToSproutSocialAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerProfileId: number
      networkType: string
      name: string
      nativeName: string
      link: string
      nativeId: string
      groups: number[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sproutSocialAccount"]>
    composites: {}
  }

  type SproutSocialAccountGetPayload<S extends boolean | null | undefined | SproutSocialAccountDefaultArgs> = $Result.GetResult<Prisma.$SproutSocialAccountPayload, S>

  type SproutSocialAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SproutSocialAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SproutSocialAccountCountAggregateInputType | true
    }

  export interface SproutSocialAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SproutSocialAccount'], meta: { name: 'SproutSocialAccount' } }
    /**
     * Find zero or one SproutSocialAccount that matches the filter.
     * @param {SproutSocialAccountFindUniqueArgs} args - Arguments to find a SproutSocialAccount
     * @example
     * // Get one SproutSocialAccount
     * const sproutSocialAccount = await prisma.sproutSocialAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SproutSocialAccountFindUniqueArgs>(args: SelectSubset<T, SproutSocialAccountFindUniqueArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SproutSocialAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SproutSocialAccountFindUniqueOrThrowArgs} args - Arguments to find a SproutSocialAccount
     * @example
     * // Get one SproutSocialAccount
     * const sproutSocialAccount = await prisma.sproutSocialAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SproutSocialAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SproutSocialAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutSocialAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutSocialAccountFindFirstArgs} args - Arguments to find a SproutSocialAccount
     * @example
     * // Get one SproutSocialAccount
     * const sproutSocialAccount = await prisma.sproutSocialAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SproutSocialAccountFindFirstArgs>(args?: SelectSubset<T, SproutSocialAccountFindFirstArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SproutSocialAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutSocialAccountFindFirstOrThrowArgs} args - Arguments to find a SproutSocialAccount
     * @example
     * // Get one SproutSocialAccount
     * const sproutSocialAccount = await prisma.sproutSocialAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SproutSocialAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SproutSocialAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SproutSocialAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutSocialAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SproutSocialAccounts
     * const sproutSocialAccounts = await prisma.sproutSocialAccount.findMany()
     * 
     * // Get first 10 SproutSocialAccounts
     * const sproutSocialAccounts = await prisma.sproutSocialAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sproutSocialAccountWithIdOnly = await prisma.sproutSocialAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SproutSocialAccountFindManyArgs>(args?: SelectSubset<T, SproutSocialAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SproutSocialAccount.
     * @param {SproutSocialAccountCreateArgs} args - Arguments to create a SproutSocialAccount.
     * @example
     * // Create one SproutSocialAccount
     * const SproutSocialAccount = await prisma.sproutSocialAccount.create({
     *   data: {
     *     // ... data to create a SproutSocialAccount
     *   }
     * })
     * 
     */
    create<T extends SproutSocialAccountCreateArgs>(args: SelectSubset<T, SproutSocialAccountCreateArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SproutSocialAccounts.
     * @param {SproutSocialAccountCreateManyArgs} args - Arguments to create many SproutSocialAccounts.
     * @example
     * // Create many SproutSocialAccounts
     * const sproutSocialAccount = await prisma.sproutSocialAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SproutSocialAccountCreateManyArgs>(args?: SelectSubset<T, SproutSocialAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SproutSocialAccounts and returns the data saved in the database.
     * @param {SproutSocialAccountCreateManyAndReturnArgs} args - Arguments to create many SproutSocialAccounts.
     * @example
     * // Create many SproutSocialAccounts
     * const sproutSocialAccount = await prisma.sproutSocialAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SproutSocialAccounts and only return the `id`
     * const sproutSocialAccountWithIdOnly = await prisma.sproutSocialAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SproutSocialAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, SproutSocialAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SproutSocialAccount.
     * @param {SproutSocialAccountDeleteArgs} args - Arguments to delete one SproutSocialAccount.
     * @example
     * // Delete one SproutSocialAccount
     * const SproutSocialAccount = await prisma.sproutSocialAccount.delete({
     *   where: {
     *     // ... filter to delete one SproutSocialAccount
     *   }
     * })
     * 
     */
    delete<T extends SproutSocialAccountDeleteArgs>(args: SelectSubset<T, SproutSocialAccountDeleteArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SproutSocialAccount.
     * @param {SproutSocialAccountUpdateArgs} args - Arguments to update one SproutSocialAccount.
     * @example
     * // Update one SproutSocialAccount
     * const sproutSocialAccount = await prisma.sproutSocialAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SproutSocialAccountUpdateArgs>(args: SelectSubset<T, SproutSocialAccountUpdateArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SproutSocialAccounts.
     * @param {SproutSocialAccountDeleteManyArgs} args - Arguments to filter SproutSocialAccounts to delete.
     * @example
     * // Delete a few SproutSocialAccounts
     * const { count } = await prisma.sproutSocialAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SproutSocialAccountDeleteManyArgs>(args?: SelectSubset<T, SproutSocialAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutSocialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutSocialAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SproutSocialAccounts
     * const sproutSocialAccount = await prisma.sproutSocialAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SproutSocialAccountUpdateManyArgs>(args: SelectSubset<T, SproutSocialAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SproutSocialAccounts and returns the data updated in the database.
     * @param {SproutSocialAccountUpdateManyAndReturnArgs} args - Arguments to update many SproutSocialAccounts.
     * @example
     * // Update many SproutSocialAccounts
     * const sproutSocialAccount = await prisma.sproutSocialAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SproutSocialAccounts and only return the `id`
     * const sproutSocialAccountWithIdOnly = await prisma.sproutSocialAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SproutSocialAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, SproutSocialAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SproutSocialAccount.
     * @param {SproutSocialAccountUpsertArgs} args - Arguments to update or create a SproutSocialAccount.
     * @example
     * // Update or create a SproutSocialAccount
     * const sproutSocialAccount = await prisma.sproutSocialAccount.upsert({
     *   create: {
     *     // ... data to create a SproutSocialAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SproutSocialAccount we want to update
     *   }
     * })
     */
    upsert<T extends SproutSocialAccountUpsertArgs>(args: SelectSubset<T, SproutSocialAccountUpsertArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SproutSocialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutSocialAccountCountArgs} args - Arguments to filter SproutSocialAccounts to count.
     * @example
     * // Count the number of SproutSocialAccounts
     * const count = await prisma.sproutSocialAccount.count({
     *   where: {
     *     // ... the filter for the SproutSocialAccounts we want to count
     *   }
     * })
    **/
    count<T extends SproutSocialAccountCountArgs>(
      args?: Subset<T, SproutSocialAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SproutSocialAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SproutSocialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutSocialAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SproutSocialAccountAggregateArgs>(args: Subset<T, SproutSocialAccountAggregateArgs>): Prisma.PrismaPromise<GetSproutSocialAccountAggregateType<T>>

    /**
     * Group by SproutSocialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SproutSocialAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SproutSocialAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SproutSocialAccountGroupByArgs['orderBy'] }
        : { orderBy?: SproutSocialAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SproutSocialAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSproutSocialAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SproutSocialAccount model
   */
  readonly fields: SproutSocialAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SproutSocialAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SproutSocialAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facebookAnalytics<T extends SproutSocialAccount$facebookAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccount$facebookAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    facebookPosts<T extends SproutSocialAccount$facebookPostsArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccount$facebookPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    facebookPostAnalytics<T extends SproutSocialAccount$facebookPostAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccount$facebookPostAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutFacebookPostAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instagramAnalytics<T extends SproutSocialAccount$instagramAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccount$instagramAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutInstagramAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    linkedInAnalytics<T extends SproutSocialAccount$linkedInAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccount$linkedInAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutLinkedInAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pinterestAnalytics<T extends SproutSocialAccount$pinterestAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccount$pinterestAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SproutPinterestAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends SproutSocialAccount$usersArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccount$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SproutSocialAccount model
   */
  interface SproutSocialAccountFieldRefs {
    readonly id: FieldRef<"SproutSocialAccount", 'String'>
    readonly customerProfileId: FieldRef<"SproutSocialAccount", 'Int'>
    readonly networkType: FieldRef<"SproutSocialAccount", 'String'>
    readonly name: FieldRef<"SproutSocialAccount", 'String'>
    readonly nativeName: FieldRef<"SproutSocialAccount", 'String'>
    readonly link: FieldRef<"SproutSocialAccount", 'String'>
    readonly nativeId: FieldRef<"SproutSocialAccount", 'String'>
    readonly groups: FieldRef<"SproutSocialAccount", 'Int[]'>
    readonly createdAt: FieldRef<"SproutSocialAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"SproutSocialAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SproutSocialAccount findUnique
   */
  export type SproutSocialAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which SproutSocialAccount to fetch.
     */
    where: SproutSocialAccountWhereUniqueInput
  }

  /**
   * SproutSocialAccount findUniqueOrThrow
   */
  export type SproutSocialAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which SproutSocialAccount to fetch.
     */
    where: SproutSocialAccountWhereUniqueInput
  }

  /**
   * SproutSocialAccount findFirst
   */
  export type SproutSocialAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which SproutSocialAccount to fetch.
     */
    where?: SproutSocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutSocialAccounts to fetch.
     */
    orderBy?: SproutSocialAccountOrderByWithRelationInput | SproutSocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutSocialAccounts.
     */
    cursor?: SproutSocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutSocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutSocialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutSocialAccounts.
     */
    distinct?: SproutSocialAccountScalarFieldEnum | SproutSocialAccountScalarFieldEnum[]
  }

  /**
   * SproutSocialAccount findFirstOrThrow
   */
  export type SproutSocialAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which SproutSocialAccount to fetch.
     */
    where?: SproutSocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutSocialAccounts to fetch.
     */
    orderBy?: SproutSocialAccountOrderByWithRelationInput | SproutSocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SproutSocialAccounts.
     */
    cursor?: SproutSocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutSocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutSocialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SproutSocialAccounts.
     */
    distinct?: SproutSocialAccountScalarFieldEnum | SproutSocialAccountScalarFieldEnum[]
  }

  /**
   * SproutSocialAccount findMany
   */
  export type SproutSocialAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which SproutSocialAccounts to fetch.
     */
    where?: SproutSocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SproutSocialAccounts to fetch.
     */
    orderBy?: SproutSocialAccountOrderByWithRelationInput | SproutSocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SproutSocialAccounts.
     */
    cursor?: SproutSocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SproutSocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SproutSocialAccounts.
     */
    skip?: number
    distinct?: SproutSocialAccountScalarFieldEnum | SproutSocialAccountScalarFieldEnum[]
  }

  /**
   * SproutSocialAccount create
   */
  export type SproutSocialAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutSocialAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a SproutSocialAccount.
     */
    data: XOR<SproutSocialAccountCreateInput, SproutSocialAccountUncheckedCreateInput>
  }

  /**
   * SproutSocialAccount createMany
   */
  export type SproutSocialAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SproutSocialAccounts.
     */
    data: SproutSocialAccountCreateManyInput | SproutSocialAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SproutSocialAccount createManyAndReturn
   */
  export type SproutSocialAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * The data used to create many SproutSocialAccounts.
     */
    data: SproutSocialAccountCreateManyInput | SproutSocialAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SproutSocialAccount update
   */
  export type SproutSocialAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutSocialAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a SproutSocialAccount.
     */
    data: XOR<SproutSocialAccountUpdateInput, SproutSocialAccountUncheckedUpdateInput>
    /**
     * Choose, which SproutSocialAccount to update.
     */
    where: SproutSocialAccountWhereUniqueInput
  }

  /**
   * SproutSocialAccount updateMany
   */
  export type SproutSocialAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SproutSocialAccounts.
     */
    data: XOR<SproutSocialAccountUpdateManyMutationInput, SproutSocialAccountUncheckedUpdateManyInput>
    /**
     * Filter which SproutSocialAccounts to update
     */
    where?: SproutSocialAccountWhereInput
    /**
     * Limit how many SproutSocialAccounts to update.
     */
    limit?: number
  }

  /**
   * SproutSocialAccount updateManyAndReturn
   */
  export type SproutSocialAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * The data used to update SproutSocialAccounts.
     */
    data: XOR<SproutSocialAccountUpdateManyMutationInput, SproutSocialAccountUncheckedUpdateManyInput>
    /**
     * Filter which SproutSocialAccounts to update
     */
    where?: SproutSocialAccountWhereInput
    /**
     * Limit how many SproutSocialAccounts to update.
     */
    limit?: number
  }

  /**
   * SproutSocialAccount upsert
   */
  export type SproutSocialAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutSocialAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the SproutSocialAccount to update in case it exists.
     */
    where: SproutSocialAccountWhereUniqueInput
    /**
     * In case the SproutSocialAccount found by the `where` argument doesn't exist, create a new SproutSocialAccount with this data.
     */
    create: XOR<SproutSocialAccountCreateInput, SproutSocialAccountUncheckedCreateInput>
    /**
     * In case the SproutSocialAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SproutSocialAccountUpdateInput, SproutSocialAccountUncheckedUpdateInput>
  }

  /**
   * SproutSocialAccount delete
   */
  export type SproutSocialAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter which SproutSocialAccount to delete.
     */
    where: SproutSocialAccountWhereUniqueInput
  }

  /**
   * SproutSocialAccount deleteMany
   */
  export type SproutSocialAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SproutSocialAccounts to delete
     */
    where?: SproutSocialAccountWhereInput
    /**
     * Limit how many SproutSocialAccounts to delete.
     */
    limit?: number
  }

  /**
   * SproutSocialAccount.facebookAnalytics
   */
  export type SproutSocialAccount$facebookAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookAnalytics
     */
    select?: SproutFacebookAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookAnalytics
     */
    omit?: SproutFacebookAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookAnalyticsInclude<ExtArgs> | null
    where?: SproutFacebookAnalyticsWhereInput
    orderBy?: SproutFacebookAnalyticsOrderByWithRelationInput | SproutFacebookAnalyticsOrderByWithRelationInput[]
    cursor?: SproutFacebookAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SproutFacebookAnalyticsScalarFieldEnum | SproutFacebookAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutSocialAccount.facebookPosts
   */
  export type SproutSocialAccount$facebookPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPost
     */
    select?: SproutFacebookPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPost
     */
    omit?: SproutFacebookPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostInclude<ExtArgs> | null
    where?: SproutFacebookPostWhereInput
    orderBy?: SproutFacebookPostOrderByWithRelationInput | SproutFacebookPostOrderByWithRelationInput[]
    cursor?: SproutFacebookPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SproutFacebookPostScalarFieldEnum | SproutFacebookPostScalarFieldEnum[]
  }

  /**
   * SproutSocialAccount.facebookPostAnalytics
   */
  export type SproutSocialAccount$facebookPostAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutFacebookPostAnalytics
     */
    select?: SproutFacebookPostAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutFacebookPostAnalytics
     */
    omit?: SproutFacebookPostAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutFacebookPostAnalyticsInclude<ExtArgs> | null
    where?: SproutFacebookPostAnalyticsWhereInput
    orderBy?: SproutFacebookPostAnalyticsOrderByWithRelationInput | SproutFacebookPostAnalyticsOrderByWithRelationInput[]
    cursor?: SproutFacebookPostAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SproutFacebookPostAnalyticsScalarFieldEnum | SproutFacebookPostAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutSocialAccount.instagramAnalytics
   */
  export type SproutSocialAccount$instagramAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutInstagramAnalytics
     */
    select?: SproutInstagramAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutInstagramAnalytics
     */
    omit?: SproutInstagramAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutInstagramAnalyticsInclude<ExtArgs> | null
    where?: SproutInstagramAnalyticsWhereInput
    orderBy?: SproutInstagramAnalyticsOrderByWithRelationInput | SproutInstagramAnalyticsOrderByWithRelationInput[]
    cursor?: SproutInstagramAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SproutInstagramAnalyticsScalarFieldEnum | SproutInstagramAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutSocialAccount.linkedInAnalytics
   */
  export type SproutSocialAccount$linkedInAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutLinkedInAnalytics
     */
    select?: SproutLinkedInAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutLinkedInAnalytics
     */
    omit?: SproutLinkedInAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutLinkedInAnalyticsInclude<ExtArgs> | null
    where?: SproutLinkedInAnalyticsWhereInput
    orderBy?: SproutLinkedInAnalyticsOrderByWithRelationInput | SproutLinkedInAnalyticsOrderByWithRelationInput[]
    cursor?: SproutLinkedInAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SproutLinkedInAnalyticsScalarFieldEnum | SproutLinkedInAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutSocialAccount.pinterestAnalytics
   */
  export type SproutSocialAccount$pinterestAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutPinterestAnalytics
     */
    select?: SproutPinterestAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutPinterestAnalytics
     */
    omit?: SproutPinterestAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutPinterestAnalyticsInclude<ExtArgs> | null
    where?: SproutPinterestAnalyticsWhereInput
    orderBy?: SproutPinterestAnalyticsOrderByWithRelationInput | SproutPinterestAnalyticsOrderByWithRelationInput[]
    cursor?: SproutPinterestAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SproutPinterestAnalyticsScalarFieldEnum | SproutPinterestAnalyticsScalarFieldEnum[]
  }

  /**
   * SproutSocialAccount.users
   */
  export type SproutSocialAccount$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
    where?: UserToSproutSocialAccountWhereInput
    orderBy?: UserToSproutSocialAccountOrderByWithRelationInput | UserToSproutSocialAccountOrderByWithRelationInput[]
    cursor?: UserToSproutSocialAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserToSproutSocialAccountScalarFieldEnum | UserToSproutSocialAccountScalarFieldEnum[]
  }

  /**
   * SproutSocialAccount without action
   */
  export type SproutSocialAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SproutSocialAccount
     */
    select?: SproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SproutSocialAccount
     */
    omit?: SproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SproutSocialAccountInclude<ExtArgs> | null
  }


  /**
   * Model UserToSproutSocialAccount
   */

  export type AggregateUserToSproutSocialAccount = {
    _count: UserToSproutSocialAccountCountAggregateOutputType | null
    _min: UserToSproutSocialAccountMinAggregateOutputType | null
    _max: UserToSproutSocialAccountMaxAggregateOutputType | null
  }

  export type UserToSproutSocialAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sproutSocialAccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToSproutSocialAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sproutSocialAccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToSproutSocialAccountCountAggregateOutputType = {
    id: number
    userId: number
    sproutSocialAccountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserToSproutSocialAccountMinAggregateInputType = {
    id?: true
    userId?: true
    sproutSocialAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToSproutSocialAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    sproutSocialAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToSproutSocialAccountCountAggregateInputType = {
    id?: true
    userId?: true
    sproutSocialAccountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserToSproutSocialAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToSproutSocialAccount to aggregate.
     */
    where?: UserToSproutSocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToSproutSocialAccounts to fetch.
     */
    orderBy?: UserToSproutSocialAccountOrderByWithRelationInput | UserToSproutSocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToSproutSocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToSproutSocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToSproutSocialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToSproutSocialAccounts
    **/
    _count?: true | UserToSproutSocialAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToSproutSocialAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToSproutSocialAccountMaxAggregateInputType
  }

  export type GetUserToSproutSocialAccountAggregateType<T extends UserToSproutSocialAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToSproutSocialAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToSproutSocialAccount[P]>
      : GetScalarType<T[P], AggregateUserToSproutSocialAccount[P]>
  }




  export type UserToSproutSocialAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToSproutSocialAccountWhereInput
    orderBy?: UserToSproutSocialAccountOrderByWithAggregationInput | UserToSproutSocialAccountOrderByWithAggregationInput[]
    by: UserToSproutSocialAccountScalarFieldEnum[] | UserToSproutSocialAccountScalarFieldEnum
    having?: UserToSproutSocialAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToSproutSocialAccountCountAggregateInputType | true
    _min?: UserToSproutSocialAccountMinAggregateInputType
    _max?: UserToSproutSocialAccountMaxAggregateInputType
  }

  export type UserToSproutSocialAccountGroupByOutputType = {
    id: string
    userId: string
    sproutSocialAccountId: string
    createdAt: Date
    updatedAt: Date
    _count: UserToSproutSocialAccountCountAggregateOutputType | null
    _min: UserToSproutSocialAccountMinAggregateOutputType | null
    _max: UserToSproutSocialAccountMaxAggregateOutputType | null
  }

  type GetUserToSproutSocialAccountGroupByPayload<T extends UserToSproutSocialAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserToSproutSocialAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToSproutSocialAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToSproutSocialAccountGroupByOutputType[P]>
            : GetScalarType<T[P], UserToSproutSocialAccountGroupByOutputType[P]>
        }
      >
    >


  export type UserToSproutSocialAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sproutSocialAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToSproutSocialAccount"]>

  export type UserToSproutSocialAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sproutSocialAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToSproutSocialAccount"]>

  export type UserToSproutSocialAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sproutSocialAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToSproutSocialAccount"]>

  export type UserToSproutSocialAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    sproutSocialAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserToSproutSocialAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sproutSocialAccountId" | "createdAt" | "updatedAt", ExtArgs["result"]["userToSproutSocialAccount"]>
  export type UserToSproutSocialAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserToSproutSocialAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserToSproutSocialAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sproutSocialAccount?: boolean | SproutSocialAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserToSproutSocialAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserToSproutSocialAccount"
    objects: {
      sproutSocialAccount: Prisma.$SproutSocialAccountPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sproutSocialAccountId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userToSproutSocialAccount"]>
    composites: {}
  }

  type UserToSproutSocialAccountGetPayload<S extends boolean | null | undefined | UserToSproutSocialAccountDefaultArgs> = $Result.GetResult<Prisma.$UserToSproutSocialAccountPayload, S>

  type UserToSproutSocialAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserToSproutSocialAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserToSproutSocialAccountCountAggregateInputType | true
    }

  export interface UserToSproutSocialAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserToSproutSocialAccount'], meta: { name: 'UserToSproutSocialAccount' } }
    /**
     * Find zero or one UserToSproutSocialAccount that matches the filter.
     * @param {UserToSproutSocialAccountFindUniqueArgs} args - Arguments to find a UserToSproutSocialAccount
     * @example
     * // Get one UserToSproutSocialAccount
     * const userToSproutSocialAccount = await prisma.userToSproutSocialAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserToSproutSocialAccountFindUniqueArgs>(args: SelectSubset<T, UserToSproutSocialAccountFindUniqueArgs<ExtArgs>>): Prisma__UserToSproutSocialAccountClient<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserToSproutSocialAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserToSproutSocialAccountFindUniqueOrThrowArgs} args - Arguments to find a UserToSproutSocialAccount
     * @example
     * // Get one UserToSproutSocialAccount
     * const userToSproutSocialAccount = await prisma.userToSproutSocialAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserToSproutSocialAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, UserToSproutSocialAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserToSproutSocialAccountClient<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserToSproutSocialAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToSproutSocialAccountFindFirstArgs} args - Arguments to find a UserToSproutSocialAccount
     * @example
     * // Get one UserToSproutSocialAccount
     * const userToSproutSocialAccount = await prisma.userToSproutSocialAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserToSproutSocialAccountFindFirstArgs>(args?: SelectSubset<T, UserToSproutSocialAccountFindFirstArgs<ExtArgs>>): Prisma__UserToSproutSocialAccountClient<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserToSproutSocialAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToSproutSocialAccountFindFirstOrThrowArgs} args - Arguments to find a UserToSproutSocialAccount
     * @example
     * // Get one UserToSproutSocialAccount
     * const userToSproutSocialAccount = await prisma.userToSproutSocialAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserToSproutSocialAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, UserToSproutSocialAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserToSproutSocialAccountClient<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserToSproutSocialAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToSproutSocialAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToSproutSocialAccounts
     * const userToSproutSocialAccounts = await prisma.userToSproutSocialAccount.findMany()
     * 
     * // Get first 10 UserToSproutSocialAccounts
     * const userToSproutSocialAccounts = await prisma.userToSproutSocialAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToSproutSocialAccountWithIdOnly = await prisma.userToSproutSocialAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserToSproutSocialAccountFindManyArgs>(args?: SelectSubset<T, UserToSproutSocialAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserToSproutSocialAccount.
     * @param {UserToSproutSocialAccountCreateArgs} args - Arguments to create a UserToSproutSocialAccount.
     * @example
     * // Create one UserToSproutSocialAccount
     * const UserToSproutSocialAccount = await prisma.userToSproutSocialAccount.create({
     *   data: {
     *     // ... data to create a UserToSproutSocialAccount
     *   }
     * })
     * 
     */
    create<T extends UserToSproutSocialAccountCreateArgs>(args: SelectSubset<T, UserToSproutSocialAccountCreateArgs<ExtArgs>>): Prisma__UserToSproutSocialAccountClient<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserToSproutSocialAccounts.
     * @param {UserToSproutSocialAccountCreateManyArgs} args - Arguments to create many UserToSproutSocialAccounts.
     * @example
     * // Create many UserToSproutSocialAccounts
     * const userToSproutSocialAccount = await prisma.userToSproutSocialAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserToSproutSocialAccountCreateManyArgs>(args?: SelectSubset<T, UserToSproutSocialAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserToSproutSocialAccounts and returns the data saved in the database.
     * @param {UserToSproutSocialAccountCreateManyAndReturnArgs} args - Arguments to create many UserToSproutSocialAccounts.
     * @example
     * // Create many UserToSproutSocialAccounts
     * const userToSproutSocialAccount = await prisma.userToSproutSocialAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserToSproutSocialAccounts and only return the `id`
     * const userToSproutSocialAccountWithIdOnly = await prisma.userToSproutSocialAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserToSproutSocialAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, UserToSproutSocialAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserToSproutSocialAccount.
     * @param {UserToSproutSocialAccountDeleteArgs} args - Arguments to delete one UserToSproutSocialAccount.
     * @example
     * // Delete one UserToSproutSocialAccount
     * const UserToSproutSocialAccount = await prisma.userToSproutSocialAccount.delete({
     *   where: {
     *     // ... filter to delete one UserToSproutSocialAccount
     *   }
     * })
     * 
     */
    delete<T extends UserToSproutSocialAccountDeleteArgs>(args: SelectSubset<T, UserToSproutSocialAccountDeleteArgs<ExtArgs>>): Prisma__UserToSproutSocialAccountClient<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserToSproutSocialAccount.
     * @param {UserToSproutSocialAccountUpdateArgs} args - Arguments to update one UserToSproutSocialAccount.
     * @example
     * // Update one UserToSproutSocialAccount
     * const userToSproutSocialAccount = await prisma.userToSproutSocialAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserToSproutSocialAccountUpdateArgs>(args: SelectSubset<T, UserToSproutSocialAccountUpdateArgs<ExtArgs>>): Prisma__UserToSproutSocialAccountClient<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserToSproutSocialAccounts.
     * @param {UserToSproutSocialAccountDeleteManyArgs} args - Arguments to filter UserToSproutSocialAccounts to delete.
     * @example
     * // Delete a few UserToSproutSocialAccounts
     * const { count } = await prisma.userToSproutSocialAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserToSproutSocialAccountDeleteManyArgs>(args?: SelectSubset<T, UserToSproutSocialAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToSproutSocialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToSproutSocialAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToSproutSocialAccounts
     * const userToSproutSocialAccount = await prisma.userToSproutSocialAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserToSproutSocialAccountUpdateManyArgs>(args: SelectSubset<T, UserToSproutSocialAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToSproutSocialAccounts and returns the data updated in the database.
     * @param {UserToSproutSocialAccountUpdateManyAndReturnArgs} args - Arguments to update many UserToSproutSocialAccounts.
     * @example
     * // Update many UserToSproutSocialAccounts
     * const userToSproutSocialAccount = await prisma.userToSproutSocialAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserToSproutSocialAccounts and only return the `id`
     * const userToSproutSocialAccountWithIdOnly = await prisma.userToSproutSocialAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserToSproutSocialAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, UserToSproutSocialAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserToSproutSocialAccount.
     * @param {UserToSproutSocialAccountUpsertArgs} args - Arguments to update or create a UserToSproutSocialAccount.
     * @example
     * // Update or create a UserToSproutSocialAccount
     * const userToSproutSocialAccount = await prisma.userToSproutSocialAccount.upsert({
     *   create: {
     *     // ... data to create a UserToSproutSocialAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToSproutSocialAccount we want to update
     *   }
     * })
     */
    upsert<T extends UserToSproutSocialAccountUpsertArgs>(args: SelectSubset<T, UserToSproutSocialAccountUpsertArgs<ExtArgs>>): Prisma__UserToSproutSocialAccountClient<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserToSproutSocialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToSproutSocialAccountCountArgs} args - Arguments to filter UserToSproutSocialAccounts to count.
     * @example
     * // Count the number of UserToSproutSocialAccounts
     * const count = await prisma.userToSproutSocialAccount.count({
     *   where: {
     *     // ... the filter for the UserToSproutSocialAccounts we want to count
     *   }
     * })
    **/
    count<T extends UserToSproutSocialAccountCountArgs>(
      args?: Subset<T, UserToSproutSocialAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToSproutSocialAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToSproutSocialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToSproutSocialAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToSproutSocialAccountAggregateArgs>(args: Subset<T, UserToSproutSocialAccountAggregateArgs>): Prisma.PrismaPromise<GetUserToSproutSocialAccountAggregateType<T>>

    /**
     * Group by UserToSproutSocialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToSproutSocialAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToSproutSocialAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToSproutSocialAccountGroupByArgs['orderBy'] }
        : { orderBy?: UserToSproutSocialAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToSproutSocialAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToSproutSocialAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserToSproutSocialAccount model
   */
  readonly fields: UserToSproutSocialAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToSproutSocialAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserToSproutSocialAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sproutSocialAccount<T extends SproutSocialAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SproutSocialAccountDefaultArgs<ExtArgs>>): Prisma__SproutSocialAccountClient<$Result.GetResult<Prisma.$SproutSocialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserToSproutSocialAccount model
   */
  interface UserToSproutSocialAccountFieldRefs {
    readonly id: FieldRef<"UserToSproutSocialAccount", 'String'>
    readonly userId: FieldRef<"UserToSproutSocialAccount", 'String'>
    readonly sproutSocialAccountId: FieldRef<"UserToSproutSocialAccount", 'String'>
    readonly createdAt: FieldRef<"UserToSproutSocialAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"UserToSproutSocialAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserToSproutSocialAccount findUnique
   */
  export type UserToSproutSocialAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserToSproutSocialAccount to fetch.
     */
    where: UserToSproutSocialAccountWhereUniqueInput
  }

  /**
   * UserToSproutSocialAccount findUniqueOrThrow
   */
  export type UserToSproutSocialAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserToSproutSocialAccount to fetch.
     */
    where: UserToSproutSocialAccountWhereUniqueInput
  }

  /**
   * UserToSproutSocialAccount findFirst
   */
  export type UserToSproutSocialAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserToSproutSocialAccount to fetch.
     */
    where?: UserToSproutSocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToSproutSocialAccounts to fetch.
     */
    orderBy?: UserToSproutSocialAccountOrderByWithRelationInput | UserToSproutSocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToSproutSocialAccounts.
     */
    cursor?: UserToSproutSocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToSproutSocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToSproutSocialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToSproutSocialAccounts.
     */
    distinct?: UserToSproutSocialAccountScalarFieldEnum | UserToSproutSocialAccountScalarFieldEnum[]
  }

  /**
   * UserToSproutSocialAccount findFirstOrThrow
   */
  export type UserToSproutSocialAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserToSproutSocialAccount to fetch.
     */
    where?: UserToSproutSocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToSproutSocialAccounts to fetch.
     */
    orderBy?: UserToSproutSocialAccountOrderByWithRelationInput | UserToSproutSocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToSproutSocialAccounts.
     */
    cursor?: UserToSproutSocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToSproutSocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToSproutSocialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToSproutSocialAccounts.
     */
    distinct?: UserToSproutSocialAccountScalarFieldEnum | UserToSproutSocialAccountScalarFieldEnum[]
  }

  /**
   * UserToSproutSocialAccount findMany
   */
  export type UserToSproutSocialAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserToSproutSocialAccounts to fetch.
     */
    where?: UserToSproutSocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToSproutSocialAccounts to fetch.
     */
    orderBy?: UserToSproutSocialAccountOrderByWithRelationInput | UserToSproutSocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToSproutSocialAccounts.
     */
    cursor?: UserToSproutSocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToSproutSocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToSproutSocialAccounts.
     */
    skip?: number
    distinct?: UserToSproutSocialAccountScalarFieldEnum | UserToSproutSocialAccountScalarFieldEnum[]
  }

  /**
   * UserToSproutSocialAccount create
   */
  export type UserToSproutSocialAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a UserToSproutSocialAccount.
     */
    data: XOR<UserToSproutSocialAccountCreateInput, UserToSproutSocialAccountUncheckedCreateInput>
  }

  /**
   * UserToSproutSocialAccount createMany
   */
  export type UserToSproutSocialAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserToSproutSocialAccounts.
     */
    data: UserToSproutSocialAccountCreateManyInput | UserToSproutSocialAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserToSproutSocialAccount createManyAndReturn
   */
  export type UserToSproutSocialAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * The data used to create many UserToSproutSocialAccounts.
     */
    data: UserToSproutSocialAccountCreateManyInput | UserToSproutSocialAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserToSproutSocialAccount update
   */
  export type UserToSproutSocialAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a UserToSproutSocialAccount.
     */
    data: XOR<UserToSproutSocialAccountUpdateInput, UserToSproutSocialAccountUncheckedUpdateInput>
    /**
     * Choose, which UserToSproutSocialAccount to update.
     */
    where: UserToSproutSocialAccountWhereUniqueInput
  }

  /**
   * UserToSproutSocialAccount updateMany
   */
  export type UserToSproutSocialAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserToSproutSocialAccounts.
     */
    data: XOR<UserToSproutSocialAccountUpdateManyMutationInput, UserToSproutSocialAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserToSproutSocialAccounts to update
     */
    where?: UserToSproutSocialAccountWhereInput
    /**
     * Limit how many UserToSproutSocialAccounts to update.
     */
    limit?: number
  }

  /**
   * UserToSproutSocialAccount updateManyAndReturn
   */
  export type UserToSproutSocialAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * The data used to update UserToSproutSocialAccounts.
     */
    data: XOR<UserToSproutSocialAccountUpdateManyMutationInput, UserToSproutSocialAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserToSproutSocialAccounts to update
     */
    where?: UserToSproutSocialAccountWhereInput
    /**
     * Limit how many UserToSproutSocialAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserToSproutSocialAccount upsert
   */
  export type UserToSproutSocialAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the UserToSproutSocialAccount to update in case it exists.
     */
    where: UserToSproutSocialAccountWhereUniqueInput
    /**
     * In case the UserToSproutSocialAccount found by the `where` argument doesn't exist, create a new UserToSproutSocialAccount with this data.
     */
    create: XOR<UserToSproutSocialAccountCreateInput, UserToSproutSocialAccountUncheckedCreateInput>
    /**
     * In case the UserToSproutSocialAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToSproutSocialAccountUpdateInput, UserToSproutSocialAccountUncheckedUpdateInput>
  }

  /**
   * UserToSproutSocialAccount delete
   */
  export type UserToSproutSocialAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
    /**
     * Filter which UserToSproutSocialAccount to delete.
     */
    where: UserToSproutSocialAccountWhereUniqueInput
  }

  /**
   * UserToSproutSocialAccount deleteMany
   */
  export type UserToSproutSocialAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToSproutSocialAccounts to delete
     */
    where?: UserToSproutSocialAccountWhereInput
    /**
     * Limit how many UserToSproutSocialAccounts to delete.
     */
    limit?: number
  }

  /**
   * UserToSproutSocialAccount without action
   */
  export type UserToSproutSocialAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
  }


  /**
   * Model UserToGaAccount
   */

  export type AggregateUserToGaAccount = {
    _count: UserToGaAccountCountAggregateOutputType | null
    _min: UserToGaAccountMinAggregateOutputType | null
    _max: UserToGaAccountMaxAggregateOutputType | null
  }

  export type UserToGaAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gaAccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToGaAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gaAccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToGaAccountCountAggregateOutputType = {
    id: number
    userId: number
    gaAccountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserToGaAccountMinAggregateInputType = {
    id?: true
    userId?: true
    gaAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToGaAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    gaAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToGaAccountCountAggregateInputType = {
    id?: true
    userId?: true
    gaAccountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserToGaAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToGaAccount to aggregate.
     */
    where?: UserToGaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToGaAccounts to fetch.
     */
    orderBy?: UserToGaAccountOrderByWithRelationInput | UserToGaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToGaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToGaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToGaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToGaAccounts
    **/
    _count?: true | UserToGaAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToGaAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToGaAccountMaxAggregateInputType
  }

  export type GetUserToGaAccountAggregateType<T extends UserToGaAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToGaAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToGaAccount[P]>
      : GetScalarType<T[P], AggregateUserToGaAccount[P]>
  }




  export type UserToGaAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToGaAccountWhereInput
    orderBy?: UserToGaAccountOrderByWithAggregationInput | UserToGaAccountOrderByWithAggregationInput[]
    by: UserToGaAccountScalarFieldEnum[] | UserToGaAccountScalarFieldEnum
    having?: UserToGaAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToGaAccountCountAggregateInputType | true
    _min?: UserToGaAccountMinAggregateInputType
    _max?: UserToGaAccountMaxAggregateInputType
  }

  export type UserToGaAccountGroupByOutputType = {
    id: string
    userId: string
    gaAccountId: string
    createdAt: Date
    updatedAt: Date
    _count: UserToGaAccountCountAggregateOutputType | null
    _min: UserToGaAccountMinAggregateOutputType | null
    _max: UserToGaAccountMaxAggregateOutputType | null
  }

  type GetUserToGaAccountGroupByPayload<T extends UserToGaAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserToGaAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToGaAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToGaAccountGroupByOutputType[P]>
            : GetScalarType<T[P], UserToGaAccountGroupByOutputType[P]>
        }
      >
    >


  export type UserToGaAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gaAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToGaAccount"]>

  export type UserToGaAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gaAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToGaAccount"]>

  export type UserToGaAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gaAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToGaAccount"]>

  export type UserToGaAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    gaAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserToGaAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "gaAccountId" | "createdAt" | "updatedAt", ExtArgs["result"]["userToGaAccount"]>
  export type UserToGaAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserToGaAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserToGaAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gaAccount?: boolean | GaAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserToGaAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserToGaAccount"
    objects: {
      gaAccount: Prisma.$GaAccountPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      gaAccountId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userToGaAccount"]>
    composites: {}
  }

  type UserToGaAccountGetPayload<S extends boolean | null | undefined | UserToGaAccountDefaultArgs> = $Result.GetResult<Prisma.$UserToGaAccountPayload, S>

  type UserToGaAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserToGaAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserToGaAccountCountAggregateInputType | true
    }

  export interface UserToGaAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserToGaAccount'], meta: { name: 'UserToGaAccount' } }
    /**
     * Find zero or one UserToGaAccount that matches the filter.
     * @param {UserToGaAccountFindUniqueArgs} args - Arguments to find a UserToGaAccount
     * @example
     * // Get one UserToGaAccount
     * const userToGaAccount = await prisma.userToGaAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserToGaAccountFindUniqueArgs>(args: SelectSubset<T, UserToGaAccountFindUniqueArgs<ExtArgs>>): Prisma__UserToGaAccountClient<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserToGaAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserToGaAccountFindUniqueOrThrowArgs} args - Arguments to find a UserToGaAccount
     * @example
     * // Get one UserToGaAccount
     * const userToGaAccount = await prisma.userToGaAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserToGaAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, UserToGaAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserToGaAccountClient<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserToGaAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToGaAccountFindFirstArgs} args - Arguments to find a UserToGaAccount
     * @example
     * // Get one UserToGaAccount
     * const userToGaAccount = await prisma.userToGaAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserToGaAccountFindFirstArgs>(args?: SelectSubset<T, UserToGaAccountFindFirstArgs<ExtArgs>>): Prisma__UserToGaAccountClient<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserToGaAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToGaAccountFindFirstOrThrowArgs} args - Arguments to find a UserToGaAccount
     * @example
     * // Get one UserToGaAccount
     * const userToGaAccount = await prisma.userToGaAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserToGaAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, UserToGaAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserToGaAccountClient<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserToGaAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToGaAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToGaAccounts
     * const userToGaAccounts = await prisma.userToGaAccount.findMany()
     * 
     * // Get first 10 UserToGaAccounts
     * const userToGaAccounts = await prisma.userToGaAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToGaAccountWithIdOnly = await prisma.userToGaAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserToGaAccountFindManyArgs>(args?: SelectSubset<T, UserToGaAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserToGaAccount.
     * @param {UserToGaAccountCreateArgs} args - Arguments to create a UserToGaAccount.
     * @example
     * // Create one UserToGaAccount
     * const UserToGaAccount = await prisma.userToGaAccount.create({
     *   data: {
     *     // ... data to create a UserToGaAccount
     *   }
     * })
     * 
     */
    create<T extends UserToGaAccountCreateArgs>(args: SelectSubset<T, UserToGaAccountCreateArgs<ExtArgs>>): Prisma__UserToGaAccountClient<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserToGaAccounts.
     * @param {UserToGaAccountCreateManyArgs} args - Arguments to create many UserToGaAccounts.
     * @example
     * // Create many UserToGaAccounts
     * const userToGaAccount = await prisma.userToGaAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserToGaAccountCreateManyArgs>(args?: SelectSubset<T, UserToGaAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserToGaAccounts and returns the data saved in the database.
     * @param {UserToGaAccountCreateManyAndReturnArgs} args - Arguments to create many UserToGaAccounts.
     * @example
     * // Create many UserToGaAccounts
     * const userToGaAccount = await prisma.userToGaAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserToGaAccounts and only return the `id`
     * const userToGaAccountWithIdOnly = await prisma.userToGaAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserToGaAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, UserToGaAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserToGaAccount.
     * @param {UserToGaAccountDeleteArgs} args - Arguments to delete one UserToGaAccount.
     * @example
     * // Delete one UserToGaAccount
     * const UserToGaAccount = await prisma.userToGaAccount.delete({
     *   where: {
     *     // ... filter to delete one UserToGaAccount
     *   }
     * })
     * 
     */
    delete<T extends UserToGaAccountDeleteArgs>(args: SelectSubset<T, UserToGaAccountDeleteArgs<ExtArgs>>): Prisma__UserToGaAccountClient<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserToGaAccount.
     * @param {UserToGaAccountUpdateArgs} args - Arguments to update one UserToGaAccount.
     * @example
     * // Update one UserToGaAccount
     * const userToGaAccount = await prisma.userToGaAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserToGaAccountUpdateArgs>(args: SelectSubset<T, UserToGaAccountUpdateArgs<ExtArgs>>): Prisma__UserToGaAccountClient<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserToGaAccounts.
     * @param {UserToGaAccountDeleteManyArgs} args - Arguments to filter UserToGaAccounts to delete.
     * @example
     * // Delete a few UserToGaAccounts
     * const { count } = await prisma.userToGaAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserToGaAccountDeleteManyArgs>(args?: SelectSubset<T, UserToGaAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToGaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToGaAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToGaAccounts
     * const userToGaAccount = await prisma.userToGaAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserToGaAccountUpdateManyArgs>(args: SelectSubset<T, UserToGaAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToGaAccounts and returns the data updated in the database.
     * @param {UserToGaAccountUpdateManyAndReturnArgs} args - Arguments to update many UserToGaAccounts.
     * @example
     * // Update many UserToGaAccounts
     * const userToGaAccount = await prisma.userToGaAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserToGaAccounts and only return the `id`
     * const userToGaAccountWithIdOnly = await prisma.userToGaAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserToGaAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, UserToGaAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserToGaAccount.
     * @param {UserToGaAccountUpsertArgs} args - Arguments to update or create a UserToGaAccount.
     * @example
     * // Update or create a UserToGaAccount
     * const userToGaAccount = await prisma.userToGaAccount.upsert({
     *   create: {
     *     // ... data to create a UserToGaAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToGaAccount we want to update
     *   }
     * })
     */
    upsert<T extends UserToGaAccountUpsertArgs>(args: SelectSubset<T, UserToGaAccountUpsertArgs<ExtArgs>>): Prisma__UserToGaAccountClient<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserToGaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToGaAccountCountArgs} args - Arguments to filter UserToGaAccounts to count.
     * @example
     * // Count the number of UserToGaAccounts
     * const count = await prisma.userToGaAccount.count({
     *   where: {
     *     // ... the filter for the UserToGaAccounts we want to count
     *   }
     * })
    **/
    count<T extends UserToGaAccountCountArgs>(
      args?: Subset<T, UserToGaAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToGaAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToGaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToGaAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToGaAccountAggregateArgs>(args: Subset<T, UserToGaAccountAggregateArgs>): Prisma.PrismaPromise<GetUserToGaAccountAggregateType<T>>

    /**
     * Group by UserToGaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToGaAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToGaAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToGaAccountGroupByArgs['orderBy'] }
        : { orderBy?: UserToGaAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToGaAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToGaAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserToGaAccount model
   */
  readonly fields: UserToGaAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToGaAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserToGaAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gaAccount<T extends GaAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GaAccountDefaultArgs<ExtArgs>>): Prisma__GaAccountClient<$Result.GetResult<Prisma.$GaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserToGaAccount model
   */
  interface UserToGaAccountFieldRefs {
    readonly id: FieldRef<"UserToGaAccount", 'String'>
    readonly userId: FieldRef<"UserToGaAccount", 'String'>
    readonly gaAccountId: FieldRef<"UserToGaAccount", 'String'>
    readonly createdAt: FieldRef<"UserToGaAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"UserToGaAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserToGaAccount findUnique
   */
  export type UserToGaAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserToGaAccount to fetch.
     */
    where: UserToGaAccountWhereUniqueInput
  }

  /**
   * UserToGaAccount findUniqueOrThrow
   */
  export type UserToGaAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserToGaAccount to fetch.
     */
    where: UserToGaAccountWhereUniqueInput
  }

  /**
   * UserToGaAccount findFirst
   */
  export type UserToGaAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserToGaAccount to fetch.
     */
    where?: UserToGaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToGaAccounts to fetch.
     */
    orderBy?: UserToGaAccountOrderByWithRelationInput | UserToGaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToGaAccounts.
     */
    cursor?: UserToGaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToGaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToGaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToGaAccounts.
     */
    distinct?: UserToGaAccountScalarFieldEnum | UserToGaAccountScalarFieldEnum[]
  }

  /**
   * UserToGaAccount findFirstOrThrow
   */
  export type UserToGaAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserToGaAccount to fetch.
     */
    where?: UserToGaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToGaAccounts to fetch.
     */
    orderBy?: UserToGaAccountOrderByWithRelationInput | UserToGaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToGaAccounts.
     */
    cursor?: UserToGaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToGaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToGaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToGaAccounts.
     */
    distinct?: UserToGaAccountScalarFieldEnum | UserToGaAccountScalarFieldEnum[]
  }

  /**
   * UserToGaAccount findMany
   */
  export type UserToGaAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserToGaAccounts to fetch.
     */
    where?: UserToGaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToGaAccounts to fetch.
     */
    orderBy?: UserToGaAccountOrderByWithRelationInput | UserToGaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToGaAccounts.
     */
    cursor?: UserToGaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToGaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToGaAccounts.
     */
    skip?: number
    distinct?: UserToGaAccountScalarFieldEnum | UserToGaAccountScalarFieldEnum[]
  }

  /**
   * UserToGaAccount create
   */
  export type UserToGaAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a UserToGaAccount.
     */
    data: XOR<UserToGaAccountCreateInput, UserToGaAccountUncheckedCreateInput>
  }

  /**
   * UserToGaAccount createMany
   */
  export type UserToGaAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserToGaAccounts.
     */
    data: UserToGaAccountCreateManyInput | UserToGaAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserToGaAccount createManyAndReturn
   */
  export type UserToGaAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * The data used to create many UserToGaAccounts.
     */
    data: UserToGaAccountCreateManyInput | UserToGaAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserToGaAccount update
   */
  export type UserToGaAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a UserToGaAccount.
     */
    data: XOR<UserToGaAccountUpdateInput, UserToGaAccountUncheckedUpdateInput>
    /**
     * Choose, which UserToGaAccount to update.
     */
    where: UserToGaAccountWhereUniqueInput
  }

  /**
   * UserToGaAccount updateMany
   */
  export type UserToGaAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserToGaAccounts.
     */
    data: XOR<UserToGaAccountUpdateManyMutationInput, UserToGaAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserToGaAccounts to update
     */
    where?: UserToGaAccountWhereInput
    /**
     * Limit how many UserToGaAccounts to update.
     */
    limit?: number
  }

  /**
   * UserToGaAccount updateManyAndReturn
   */
  export type UserToGaAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * The data used to update UserToGaAccounts.
     */
    data: XOR<UserToGaAccountUpdateManyMutationInput, UserToGaAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserToGaAccounts to update
     */
    where?: UserToGaAccountWhereInput
    /**
     * Limit how many UserToGaAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserToGaAccount upsert
   */
  export type UserToGaAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the UserToGaAccount to update in case it exists.
     */
    where: UserToGaAccountWhereUniqueInput
    /**
     * In case the UserToGaAccount found by the `where` argument doesn't exist, create a new UserToGaAccount with this data.
     */
    create: XOR<UserToGaAccountCreateInput, UserToGaAccountUncheckedCreateInput>
    /**
     * In case the UserToGaAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToGaAccountUpdateInput, UserToGaAccountUncheckedUpdateInput>
  }

  /**
   * UserToGaAccount delete
   */
  export type UserToGaAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
    /**
     * Filter which UserToGaAccount to delete.
     */
    where: UserToGaAccountWhereUniqueInput
  }

  /**
   * UserToGaAccount deleteMany
   */
  export type UserToGaAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToGaAccounts to delete
     */
    where?: UserToGaAccountWhereInput
    /**
     * Limit how many UserToGaAccounts to delete.
     */
    limit?: number
  }

  /**
   * UserToGaAccount without action
   */
  export type UserToGaAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    roleId: string | null
    emailVerified: Date | null
    image: string | null
    name: string | null
    accountRepId: string | null
    isActive: boolean | null
    password: string | null
    deleted: boolean | null
    companyId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    roleId: string | null
    emailVerified: Date | null
    image: string | null
    name: string | null
    accountRepId: string | null
    isActive: boolean | null
    password: string | null
    deleted: boolean | null
    companyId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    createdAt: number
    updatedAt: number
    roleId: number
    emailVerified: number
    image: number
    name: number
    accountRepId: number
    isActive: number
    password: number
    deleted: number
    companyId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
    emailVerified?: true
    image?: true
    name?: true
    accountRepId?: true
    isActive?: true
    password?: true
    deleted?: true
    companyId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
    emailVerified?: true
    image?: true
    name?: true
    accountRepId?: true
    isActive?: true
    password?: true
    deleted?: true
    companyId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
    emailVerified?: true
    image?: true
    name?: true
    accountRepId?: true
    isActive?: true
    password?: true
    deleted?: true
    companyId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    createdAt: Date
    updatedAt: Date
    roleId: string
    emailVerified: Date | null
    image: string | null
    name: string | null
    accountRepId: string | null
    isActive: boolean
    password: string | null
    deleted: boolean
    companyId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    emailVerified?: boolean
    image?: boolean
    name?: boolean
    accountRepId?: boolean
    isActive?: boolean
    password?: boolean
    deleted?: boolean
    companyId?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    receivedRatings?: boolean | User$receivedRatingsArgs<ExtArgs>
    givenRatings?: boolean | User$givenRatingsArgs<ExtArgs>
    clientConversations?: boolean | User$clientConversationsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    gaImportRuns?: boolean | User$gaImportRunsArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    queries?: boolean | User$queriesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    clientTickets?: boolean | User$clientTicketsArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
    clients?: boolean | User$clientsArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    emailClients?: boolean | User$emailClientsArgs<ExtArgs>
    userToGaAccounts?: boolean | User$userToGaAccountsArgs<ExtArgs>
    sproutSocialAccounts?: boolean | User$sproutSocialAccountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    emailVerified?: boolean
    image?: boolean
    name?: boolean
    accountRepId?: boolean
    isActive?: boolean
    password?: boolean
    deleted?: boolean
    companyId?: boolean
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    emailVerified?: boolean
    image?: boolean
    name?: boolean
    accountRepId?: boolean
    isActive?: boolean
    password?: boolean
    deleted?: boolean
    companyId?: boolean
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    emailVerified?: boolean
    image?: boolean
    name?: boolean
    accountRepId?: boolean
    isActive?: boolean
    password?: boolean
    deleted?: boolean
    companyId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "createdAt" | "updatedAt" | "roleId" | "emailVerified" | "image" | "name" | "accountRepId" | "isActive" | "password" | "deleted" | "companyId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    receivedRatings?: boolean | User$receivedRatingsArgs<ExtArgs>
    givenRatings?: boolean | User$givenRatingsArgs<ExtArgs>
    clientConversations?: boolean | User$clientConversationsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    gaImportRuns?: boolean | User$gaImportRunsArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    queries?: boolean | User$queriesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    clientTickets?: boolean | User$clientTicketsArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
    clients?: boolean | User$clientsArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    emailClients?: boolean | User$emailClientsArgs<ExtArgs>
    userToGaAccounts?: boolean | User$userToGaAccountsArgs<ExtArgs>
    sproutSocialAccounts?: boolean | User$sproutSocialAccountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountRep?: boolean | User$accountRepArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      activities: Prisma.$ClientActivityPayload<ExtArgs>[]
      receivedRatings: Prisma.$ClientSatisfactionPayload<ExtArgs>[]
      givenRatings: Prisma.$ClientSatisfactionPayload<ExtArgs>[]
      clientConversations: Prisma.$ConversationPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      gaImportRuns: Prisma.$GaImportRunPayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      queries: Prisma.$QueryPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      assignedTickets: Prisma.$TicketPayload<ExtArgs>[]
      clientTickets: Prisma.$TicketPayload<ExtArgs>[]
      ticketComments: Prisma.$TicketCommentPayload<ExtArgs>[]
      accountRep: Prisma.$UserPayload<ExtArgs> | null
      clients: Prisma.$UserPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs> | null
      role: Prisma.$RolePayload<ExtArgs>
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      emailClients: Prisma.$UserToEmailClientPayload<ExtArgs>[]
      userToGaAccounts: Prisma.$UserToGaAccountPayload<ExtArgs>[]
      sproutSocialAccounts: Prisma.$UserToSproutSocialAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      createdAt: Date
      updatedAt: Date
      roleId: string
      emailVerified: Date | null
      image: string | null
      name: string | null
      accountRepId: string | null
      isActive: boolean
      password: string | null
      deleted: boolean
      companyId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedRatings<T extends User$receivedRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    givenRatings<T extends User$givenRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$givenRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSatisfactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientConversations<T extends User$clientConversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientConversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gaImportRuns<T extends User$gaImportRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$gaImportRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaImportRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    queries<T extends User$queriesArgs<ExtArgs> = {}>(args?: Subset<T, User$queriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTickets<T extends User$assignedTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientTickets<T extends User$clientTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketComments<T extends User$ticketCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accountRep<T extends User$accountRepArgs<ExtArgs> = {}>(args?: Subset<T, User$accountRepArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clients<T extends User$clientsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends User$companyArgs<ExtArgs> = {}>(args?: Subset<T, User$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emailClients<T extends User$emailClientsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userToGaAccounts<T extends User$userToGaAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$userToGaAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToGaAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sproutSocialAccounts<T extends User$sproutSocialAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$sproutSocialAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToSproutSocialAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly accountRepId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly password: FieldRef<"User", 'String'>
    readonly deleted: FieldRef<"User", 'Boolean'>
    readonly companyId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    where?: ClientActivityWhereInput
    orderBy?: ClientActivityOrderByWithRelationInput | ClientActivityOrderByWithRelationInput[]
    cursor?: ClientActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientActivityScalarFieldEnum | ClientActivityScalarFieldEnum[]
  }

  /**
   * User.receivedRatings
   */
  export type User$receivedRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    where?: ClientSatisfactionWhereInput
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    cursor?: ClientSatisfactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientSatisfactionScalarFieldEnum | ClientSatisfactionScalarFieldEnum[]
  }

  /**
   * User.givenRatings
   */
  export type User$givenRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSatisfaction
     */
    select?: ClientSatisfactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSatisfaction
     */
    omit?: ClientSatisfactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSatisfactionInclude<ExtArgs> | null
    where?: ClientSatisfactionWhereInput
    orderBy?: ClientSatisfactionOrderByWithRelationInput | ClientSatisfactionOrderByWithRelationInput[]
    cursor?: ClientSatisfactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientSatisfactionScalarFieldEnum | ClientSatisfactionScalarFieldEnum[]
  }

  /**
   * User.clientConversations
   */
  export type User$clientConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.gaImportRuns
   */
  export type User$gaImportRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GaImportRun
     */
    select?: GaImportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GaImportRun
     */
    omit?: GaImportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GaImportRunInclude<ExtArgs> | null
    where?: GaImportRunWhereInput
    orderBy?: GaImportRunOrderByWithRelationInput | GaImportRunOrderByWithRelationInput[]
    cursor?: GaImportRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GaImportRunScalarFieldEnum | GaImportRunScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.queries
   */
  export type User$queriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    cursor?: QueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.assignedTickets
   */
  export type User$assignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.clientTickets
   */
  export type User$clientTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.ticketComments
   */
  export type User$ticketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * User.accountRep
   */
  export type User$accountRepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.clients
   */
  export type User$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.company
   */
  export type User$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.emailClients
   */
  export type User$emailClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
    where?: UserToEmailClientWhereInput
    orderBy?: UserToEmailClientOrderByWithRelationInput | UserToEmailClientOrderByWithRelationInput[]
    cursor?: UserToEmailClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserToEmailClientScalarFieldEnum | UserToEmailClientScalarFieldEnum[]
  }

  /**
   * User.userToGaAccounts
   */
  export type User$userToGaAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToGaAccount
     */
    select?: UserToGaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToGaAccount
     */
    omit?: UserToGaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToGaAccountInclude<ExtArgs> | null
    where?: UserToGaAccountWhereInput
    orderBy?: UserToGaAccountOrderByWithRelationInput | UserToGaAccountOrderByWithRelationInput[]
    cursor?: UserToGaAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserToGaAccountScalarFieldEnum | UserToGaAccountScalarFieldEnum[]
  }

  /**
   * User.sproutSocialAccounts
   */
  export type User$sproutSocialAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToSproutSocialAccount
     */
    select?: UserToSproutSocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToSproutSocialAccount
     */
    omit?: UserToSproutSocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToSproutSocialAccountInclude<ExtArgs> | null
    where?: UserToSproutSocialAccountWhereInput
    orderBy?: UserToSproutSocialAccountOrderByWithRelationInput | UserToSproutSocialAccountOrderByWithRelationInput[]
    cursor?: UserToSproutSocialAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserToSproutSocialAccountScalarFieldEnum | UserToSproutSocialAccountScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsAvgAggregateOutputType = {
    apiCredits: number | null
    apiCreditsLimit: number | null
  }

  export type UserSettingsSumAggregateOutputType = {
    apiCredits: number | null
    apiCreditsLimit: number | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    emailNotifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    theme: string | null
    apiCredits: number | null
    apiCreditsLimit: number | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    emailNotifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    theme: string | null
    apiCredits: number | null
    apiCreditsLimit: number | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    emailNotifications: number
    createdAt: number
    updatedAt: number
    theme: number
    apiCredits: number
    apiCreditsLimit: number
    _all: number
  }


  export type UserSettingsAvgAggregateInputType = {
    apiCredits?: true
    apiCreditsLimit?: true
  }

  export type UserSettingsSumAggregateInputType = {
    apiCredits?: true
    apiCreditsLimit?: true
  }

  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    createdAt?: true
    updatedAt?: true
    theme?: true
    apiCredits?: true
    apiCreditsLimit?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    createdAt?: true
    updatedAt?: true
    theme?: true
    apiCredits?: true
    apiCreditsLimit?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    createdAt?: true
    updatedAt?: true
    theme?: true
    apiCredits?: true
    apiCreditsLimit?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _avg?: UserSettingsAvgAggregateInputType
    _sum?: UserSettingsSumAggregateInputType
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    emailNotifications: boolean
    createdAt: Date
    updatedAt: Date
    theme: string | null
    apiCredits: number
    apiCreditsLimit: number
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    theme?: boolean
    apiCredits?: boolean
    apiCreditsLimit?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    theme?: boolean
    apiCredits?: boolean
    apiCreditsLimit?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    theme?: boolean
    apiCredits?: boolean
    apiCreditsLimit?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    theme?: boolean
    apiCredits?: boolean
    apiCreditsLimit?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "emailNotifications" | "createdAt" | "updatedAt" | "theme" | "apiCredits" | "apiCreditsLimit", ExtArgs["result"]["userSettings"]>
  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      emailNotifications: boolean
      createdAt: Date
      updatedAt: Date
      theme: string | null
      apiCredits: number
      apiCreditsLimit: number
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly emailNotifications: FieldRef<"UserSettings", 'Boolean'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
    readonly theme: FieldRef<"UserSettings", 'String'>
    readonly apiCredits: FieldRef<"UserSettings", 'Int'>
    readonly apiCreditsLimit: FieldRef<"UserSettings", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings updateManyAndReturn
   */
  export type UserSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedToId: string | null
    clientId: string | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedToId: string | null
    clientId: string | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    assignedToId: number
    clientId: number
    _all: number
  }


  export type TicketMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    clientId?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    clientId?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    clientId?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    title: string
    description: string
    status: $Enums.TicketStatus
    priority: $Enums.TicketPriority
    createdAt: Date
    updatedAt: Date
    assignedToId: string | null
    clientId: string
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    clientId?: boolean
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Ticket$attachmentsArgs<ExtArgs>
    comments?: boolean | Ticket$commentsArgs<ExtArgs>
    tags?: boolean | Ticket$tagsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    clientId?: boolean
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    clientId?: boolean
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    clientId?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "priority" | "createdAt" | "updatedAt" | "assignedToId" | "clientId", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Ticket$attachmentsArgs<ExtArgs>
    comments?: boolean | Ticket$commentsArgs<ExtArgs>
    tags?: boolean | Ticket$tagsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      client: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$TicketAttachmentPayload<ExtArgs>[]
      comments: Prisma.$TicketCommentPayload<ExtArgs>[]
      tags: Prisma.$TicketTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: $Enums.TicketStatus
      priority: $Enums.TicketPriority
      createdAt: Date
      updatedAt: Date
      assignedToId: string | null
      clientId: string
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends Ticket$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Ticket$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Ticket$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Ticket$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly title: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly priority: FieldRef<"Ticket", 'TicketPriority'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
    readonly assignedToId: FieldRef<"Ticket", 'String'>
    readonly clientId: FieldRef<"Ticket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket.assignedTo
   */
  export type Ticket$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.attachments
   */
  export type Ticket$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    cursor?: TicketAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * Ticket.comments
   */
  export type Ticket$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * Ticket.tags
   */
  export type Ticket$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    where?: TicketTagWhereInput
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    cursor?: TicketTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketAttachment
   */

  export type AggregateTicketAttachment = {
    _count: TicketAttachmentCountAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  export type TicketAttachmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    createdAt: Date | null
    ticketId: string | null
  }

  export type TicketAttachmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    createdAt: Date | null
    ticketId: string | null
  }

  export type TicketAttachmentCountAggregateOutputType = {
    id: number
    name: number
    url: number
    createdAt: number
    ticketId: number
    _all: number
  }


  export type TicketAttachmentMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    createdAt?: true
    ticketId?: true
  }

  export type TicketAttachmentMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    createdAt?: true
    ticketId?: true
  }

  export type TicketAttachmentCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    createdAt?: true
    ticketId?: true
    _all?: true
  }

  export type TicketAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachment to aggregate.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketAttachments
    **/
    _count?: true | TicketAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type GetTicketAttachmentAggregateType<T extends TicketAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketAttachment[P]>
      : GetScalarType<T[P], AggregateTicketAttachment[P]>
  }




  export type TicketAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithAggregationInput | TicketAttachmentOrderByWithAggregationInput[]
    by: TicketAttachmentScalarFieldEnum[] | TicketAttachmentScalarFieldEnum
    having?: TicketAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketAttachmentCountAggregateInputType | true
    _min?: TicketAttachmentMinAggregateInputType
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type TicketAttachmentGroupByOutputType = {
    id: string
    name: string
    url: string
    createdAt: Date
    ticketId: string
    _count: TicketAttachmentCountAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  type GetTicketAttachmentGroupByPayload<T extends TicketAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type TicketAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    createdAt?: boolean
    ticketId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    createdAt?: boolean
    ticketId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    createdAt?: boolean
    ticketId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    createdAt?: boolean
    ticketId?: boolean
  }

  export type TicketAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "createdAt" | "ticketId", ExtArgs["result"]["ticketAttachment"]>
  export type TicketAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketAttachment"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      createdAt: Date
      ticketId: string
    }, ExtArgs["result"]["ticketAttachment"]>
    composites: {}
  }

  type TicketAttachmentGetPayload<S extends boolean | null | undefined | TicketAttachmentDefaultArgs> = $Result.GetResult<Prisma.$TicketAttachmentPayload, S>

  type TicketAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketAttachmentCountAggregateInputType | true
    }

  export interface TicketAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketAttachment'], meta: { name: 'TicketAttachment' } }
    /**
     * Find zero or one TicketAttachment that matches the filter.
     * @param {TicketAttachmentFindUniqueArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketAttachmentFindUniqueArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketAttachmentFindUniqueOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketAttachmentFindFirstArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany()
     * 
     * // Get first 10 TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketAttachmentFindManyArgs>(args?: SelectSubset<T, TicketAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketAttachment.
     * @param {TicketAttachmentCreateArgs} args - Arguments to create a TicketAttachment.
     * @example
     * // Create one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.create({
     *   data: {
     *     // ... data to create a TicketAttachment
     *   }
     * })
     * 
     */
    create<T extends TicketAttachmentCreateArgs>(args: SelectSubset<T, TicketAttachmentCreateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketAttachments.
     * @param {TicketAttachmentCreateManyArgs} args - Arguments to create many TicketAttachments.
     * @example
     * // Create many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketAttachmentCreateManyArgs>(args?: SelectSubset<T, TicketAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketAttachments and returns the data saved in the database.
     * @param {TicketAttachmentCreateManyAndReturnArgs} args - Arguments to create many TicketAttachments.
     * @example
     * // Create many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketAttachments and only return the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketAttachment.
     * @param {TicketAttachmentDeleteArgs} args - Arguments to delete one TicketAttachment.
     * @example
     * // Delete one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.delete({
     *   where: {
     *     // ... filter to delete one TicketAttachment
     *   }
     * })
     * 
     */
    delete<T extends TicketAttachmentDeleteArgs>(args: SelectSubset<T, TicketAttachmentDeleteArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketAttachment.
     * @param {TicketAttachmentUpdateArgs} args - Arguments to update one TicketAttachment.
     * @example
     * // Update one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketAttachmentUpdateArgs>(args: SelectSubset<T, TicketAttachmentUpdateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketAttachments.
     * @param {TicketAttachmentDeleteManyArgs} args - Arguments to filter TicketAttachments to delete.
     * @example
     * // Delete a few TicketAttachments
     * const { count } = await prisma.ticketAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketAttachmentDeleteManyArgs>(args?: SelectSubset<T, TicketAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketAttachmentUpdateManyArgs>(args: SelectSubset<T, TicketAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAttachments and returns the data updated in the database.
     * @param {TicketAttachmentUpdateManyAndReturnArgs} args - Arguments to update many TicketAttachments.
     * @example
     * // Update many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketAttachments and only return the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketAttachment.
     * @param {TicketAttachmentUpsertArgs} args - Arguments to update or create a TicketAttachment.
     * @example
     * // Update or create a TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.upsert({
     *   create: {
     *     // ... data to create a TicketAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketAttachment we want to update
     *   }
     * })
     */
    upsert<T extends TicketAttachmentUpsertArgs>(args: SelectSubset<T, TicketAttachmentUpsertArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentCountArgs} args - Arguments to filter TicketAttachments to count.
     * @example
     * // Count the number of TicketAttachments
     * const count = await prisma.ticketAttachment.count({
     *   where: {
     *     // ... the filter for the TicketAttachments we want to count
     *   }
     * })
    **/
    count<T extends TicketAttachmentCountArgs>(
      args?: Subset<T, TicketAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAttachmentAggregateArgs>(args: Subset<T, TicketAttachmentAggregateArgs>): Prisma.PrismaPromise<GetTicketAttachmentAggregateType<T>>

    /**
     * Group by TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: TicketAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketAttachment model
   */
  readonly fields: TicketAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketAttachment model
   */
  interface TicketAttachmentFieldRefs {
    readonly id: FieldRef<"TicketAttachment", 'String'>
    readonly name: FieldRef<"TicketAttachment", 'String'>
    readonly url: FieldRef<"TicketAttachment", 'String'>
    readonly createdAt: FieldRef<"TicketAttachment", 'DateTime'>
    readonly ticketId: FieldRef<"TicketAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TicketAttachment findUnique
   */
  export type TicketAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findUniqueOrThrow
   */
  export type TicketAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findFirst
   */
  export type TicketAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findFirstOrThrow
   */
  export type TicketAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findMany
   */
  export type TicketAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachments to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment create
   */
  export type TicketAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketAttachment.
     */
    data: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
  }

  /**
   * TicketAttachment createMany
   */
  export type TicketAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketAttachments.
     */
    data: TicketAttachmentCreateManyInput | TicketAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketAttachment createManyAndReturn
   */
  export type TicketAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many TicketAttachments.
     */
    data: TicketAttachmentCreateManyInput | TicketAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketAttachment update
   */
  export type TicketAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketAttachment.
     */
    data: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
    /**
     * Choose, which TicketAttachment to update.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment updateMany
   */
  export type TicketAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketAttachments.
     */
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAttachments to update
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to update.
     */
    limit?: number
  }

  /**
   * TicketAttachment updateManyAndReturn
   */
  export type TicketAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update TicketAttachments.
     */
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAttachments to update
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketAttachment upsert
   */
  export type TicketAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketAttachment to update in case it exists.
     */
    where: TicketAttachmentWhereUniqueInput
    /**
     * In case the TicketAttachment found by the `where` argument doesn't exist, create a new TicketAttachment with this data.
     */
    create: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
    /**
     * In case the TicketAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
  }

  /**
   * TicketAttachment delete
   */
  export type TicketAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter which TicketAttachment to delete.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment deleteMany
   */
  export type TicketAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachments to delete
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to delete.
     */
    limit?: number
  }

  /**
   * TicketAttachment without action
   */
  export type TicketAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model TicketComment
   */

  export type AggregateTicketComment = {
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  export type TicketCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ticketId: string | null
    authorId: string | null
  }

  export type TicketCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ticketId: string | null
    authorId: string | null
  }

  export type TicketCommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    ticketId: number
    authorId: number
    _all: number
  }


  export type TicketCommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    ticketId?: true
    authorId?: true
  }

  export type TicketCommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    ticketId?: true
    authorId?: true
  }

  export type TicketCommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    ticketId?: true
    authorId?: true
    _all?: true
  }

  export type TicketCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComment to aggregate.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketComments
    **/
    _count?: true | TicketCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketCommentMaxAggregateInputType
  }

  export type GetTicketCommentAggregateType<T extends TicketCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketComment[P]>
      : GetScalarType<T[P], AggregateTicketComment[P]>
  }




  export type TicketCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithAggregationInput | TicketCommentOrderByWithAggregationInput[]
    by: TicketCommentScalarFieldEnum[] | TicketCommentScalarFieldEnum
    having?: TicketCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCommentCountAggregateInputType | true
    _min?: TicketCommentMinAggregateInputType
    _max?: TicketCommentMaxAggregateInputType
  }

  export type TicketCommentGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    ticketId: string
    authorId: string
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  type GetTicketCommentGroupByPayload<T extends TicketCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
        }
      >
    >


  export type TicketCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticketId?: boolean
    authorId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticketId?: boolean
    authorId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticketId?: boolean
    authorId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticketId?: boolean
    authorId?: boolean
  }

  export type TicketCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt" | "ticketId" | "authorId", ExtArgs["result"]["ticketComment"]>
  export type TicketCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketComment"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
      ticketId: string
      authorId: string
    }, ExtArgs["result"]["ticketComment"]>
    composites: {}
  }

  type TicketCommentGetPayload<S extends boolean | null | undefined | TicketCommentDefaultArgs> = $Result.GetResult<Prisma.$TicketCommentPayload, S>

  type TicketCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCommentCountAggregateInputType | true
    }

  export interface TicketCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketComment'], meta: { name: 'TicketComment' } }
    /**
     * Find zero or one TicketComment that matches the filter.
     * @param {TicketCommentFindUniqueArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketCommentFindUniqueArgs>(args: SelectSubset<T, TicketCommentFindUniqueArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketCommentFindUniqueOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketCommentFindFirstArgs>(args?: SelectSubset<T, TicketCommentFindFirstArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketComments
     * const ticketComments = await prisma.ticketComment.findMany()
     * 
     * // Get first 10 TicketComments
     * const ticketComments = await prisma.ticketComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketCommentFindManyArgs>(args?: SelectSubset<T, TicketCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketComment.
     * @param {TicketCommentCreateArgs} args - Arguments to create a TicketComment.
     * @example
     * // Create one TicketComment
     * const TicketComment = await prisma.ticketComment.create({
     *   data: {
     *     // ... data to create a TicketComment
     *   }
     * })
     * 
     */
    create<T extends TicketCommentCreateArgs>(args: SelectSubset<T, TicketCommentCreateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketComments.
     * @param {TicketCommentCreateManyArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCommentCreateManyArgs>(args?: SelectSubset<T, TicketCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketComments and returns the data saved in the database.
     * @param {TicketCommentCreateManyAndReturnArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketComments and only return the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketComment.
     * @param {TicketCommentDeleteArgs} args - Arguments to delete one TicketComment.
     * @example
     * // Delete one TicketComment
     * const TicketComment = await prisma.ticketComment.delete({
     *   where: {
     *     // ... filter to delete one TicketComment
     *   }
     * })
     * 
     */
    delete<T extends TicketCommentDeleteArgs>(args: SelectSubset<T, TicketCommentDeleteArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketComment.
     * @param {TicketCommentUpdateArgs} args - Arguments to update one TicketComment.
     * @example
     * // Update one TicketComment
     * const ticketComment = await prisma.ticketComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketCommentUpdateArgs>(args: SelectSubset<T, TicketCommentUpdateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketComments.
     * @param {TicketCommentDeleteManyArgs} args - Arguments to filter TicketComments to delete.
     * @example
     * // Delete a few TicketComments
     * const { count } = await prisma.ticketComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketCommentDeleteManyArgs>(args?: SelectSubset<T, TicketCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketCommentUpdateManyArgs>(args: SelectSubset<T, TicketCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments and returns the data updated in the database.
     * @param {TicketCommentUpdateManyAndReturnArgs} args - Arguments to update many TicketComments.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketComments and only return the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketComment.
     * @param {TicketCommentUpsertArgs} args - Arguments to update or create a TicketComment.
     * @example
     * // Update or create a TicketComment
     * const ticketComment = await prisma.ticketComment.upsert({
     *   create: {
     *     // ... data to create a TicketComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketComment we want to update
     *   }
     * })
     */
    upsert<T extends TicketCommentUpsertArgs>(args: SelectSubset<T, TicketCommentUpsertArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentCountArgs} args - Arguments to filter TicketComments to count.
     * @example
     * // Count the number of TicketComments
     * const count = await prisma.ticketComment.count({
     *   where: {
     *     // ... the filter for the TicketComments we want to count
     *   }
     * })
    **/
    count<T extends TicketCommentCountArgs>(
      args?: Subset<T, TicketCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketCommentAggregateArgs>(args: Subset<T, TicketCommentAggregateArgs>): Prisma.PrismaPromise<GetTicketCommentAggregateType<T>>

    /**
     * Group by TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketCommentGroupByArgs['orderBy'] }
        : { orderBy?: TicketCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketComment model
   */
  readonly fields: TicketCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketComment model
   */
  interface TicketCommentFieldRefs {
    readonly id: FieldRef<"TicketComment", 'String'>
    readonly content: FieldRef<"TicketComment", 'String'>
    readonly createdAt: FieldRef<"TicketComment", 'DateTime'>
    readonly updatedAt: FieldRef<"TicketComment", 'DateTime'>
    readonly ticketId: FieldRef<"TicketComment", 'String'>
    readonly authorId: FieldRef<"TicketComment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TicketComment findUnique
   */
  export type TicketCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findUniqueOrThrow
   */
  export type TicketCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findFirst
   */
  export type TicketCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findFirstOrThrow
   */
  export type TicketCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findMany
   */
  export type TicketCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComments to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment create
   */
  export type TicketCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketComment.
     */
    data: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
  }

  /**
   * TicketComment createMany
   */
  export type TicketCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketComment createManyAndReturn
   */
  export type TicketCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketComment update
   */
  export type TicketCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketComment.
     */
    data: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
    /**
     * Choose, which TicketComment to update.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment updateMany
   */
  export type TicketCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to update.
     */
    limit?: number
  }

  /**
   * TicketComment updateManyAndReturn
   */
  export type TicketCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketComment upsert
   */
  export type TicketCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketComment to update in case it exists.
     */
    where: TicketCommentWhereUniqueInput
    /**
     * In case the TicketComment found by the `where` argument doesn't exist, create a new TicketComment with this data.
     */
    create: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
    /**
     * In case the TicketComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
  }

  /**
   * TicketComment delete
   */
  export type TicketCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter which TicketComment to delete.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment deleteMany
   */
  export type TicketCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComments to delete
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to delete.
     */
    limit?: number
  }

  /**
   * TicketComment without action
   */
  export type TicketCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
  }


  /**
   * Model TicketTag
   */

  export type AggregateTicketTag = {
    _count: TicketTagCountAggregateOutputType | null
    _min: TicketTagMinAggregateOutputType | null
    _max: TicketTagMaxAggregateOutputType | null
  }

  export type TicketTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type TicketTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type TicketTagCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type TicketTagMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type TicketTagMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type TicketTagCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type TicketTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketTag to aggregate.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketTags
    **/
    _count?: true | TicketTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketTagMaxAggregateInputType
  }

  export type GetTicketTagAggregateType<T extends TicketTagAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketTag[P]>
      : GetScalarType<T[P], AggregateTicketTag[P]>
  }




  export type TicketTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTagWhereInput
    orderBy?: TicketTagOrderByWithAggregationInput | TicketTagOrderByWithAggregationInput[]
    by: TicketTagScalarFieldEnum[] | TicketTagScalarFieldEnum
    having?: TicketTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketTagCountAggregateInputType | true
    _min?: TicketTagMinAggregateInputType
    _max?: TicketTagMaxAggregateInputType
  }

  export type TicketTagGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    _count: TicketTagCountAggregateOutputType | null
    _min: TicketTagMinAggregateOutputType | null
    _max: TicketTagMaxAggregateOutputType | null
  }

  type GetTicketTagGroupByPayload<T extends TicketTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketTagGroupByOutputType[P]>
            : GetScalarType<T[P], TicketTagGroupByOutputType[P]>
        }
      >
    >


  export type TicketTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    tickets?: boolean | TicketTag$ticketsArgs<ExtArgs>
    _count?: boolean | TicketTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketTag"]>

  export type TicketTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ticketTag"]>

  export type TicketTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ticketTag"]>

  export type TicketTagSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type TicketTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt", ExtArgs["result"]["ticketTag"]>
  export type TicketTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | TicketTag$ticketsArgs<ExtArgs>
    _count?: boolean | TicketTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TicketTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TicketTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketTag"
    objects: {
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
    }, ExtArgs["result"]["ticketTag"]>
    composites: {}
  }

  type TicketTagGetPayload<S extends boolean | null | undefined | TicketTagDefaultArgs> = $Result.GetResult<Prisma.$TicketTagPayload, S>

  type TicketTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketTagCountAggregateInputType | true
    }

  export interface TicketTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketTag'], meta: { name: 'TicketTag' } }
    /**
     * Find zero or one TicketTag that matches the filter.
     * @param {TicketTagFindUniqueArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketTagFindUniqueArgs>(args: SelectSubset<T, TicketTagFindUniqueArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketTagFindUniqueOrThrowArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketTagFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagFindFirstArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketTagFindFirstArgs>(args?: SelectSubset<T, TicketTagFindFirstArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagFindFirstOrThrowArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketTagFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketTags
     * const ticketTags = await prisma.ticketTag.findMany()
     * 
     * // Get first 10 TicketTags
     * const ticketTags = await prisma.ticketTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketTagWithIdOnly = await prisma.ticketTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketTagFindManyArgs>(args?: SelectSubset<T, TicketTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketTag.
     * @param {TicketTagCreateArgs} args - Arguments to create a TicketTag.
     * @example
     * // Create one TicketTag
     * const TicketTag = await prisma.ticketTag.create({
     *   data: {
     *     // ... data to create a TicketTag
     *   }
     * })
     * 
     */
    create<T extends TicketTagCreateArgs>(args: SelectSubset<T, TicketTagCreateArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketTags.
     * @param {TicketTagCreateManyArgs} args - Arguments to create many TicketTags.
     * @example
     * // Create many TicketTags
     * const ticketTag = await prisma.ticketTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketTagCreateManyArgs>(args?: SelectSubset<T, TicketTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketTags and returns the data saved in the database.
     * @param {TicketTagCreateManyAndReturnArgs} args - Arguments to create many TicketTags.
     * @example
     * // Create many TicketTags
     * const ticketTag = await prisma.ticketTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketTags and only return the `id`
     * const ticketTagWithIdOnly = await prisma.ticketTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketTagCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketTag.
     * @param {TicketTagDeleteArgs} args - Arguments to delete one TicketTag.
     * @example
     * // Delete one TicketTag
     * const TicketTag = await prisma.ticketTag.delete({
     *   where: {
     *     // ... filter to delete one TicketTag
     *   }
     * })
     * 
     */
    delete<T extends TicketTagDeleteArgs>(args: SelectSubset<T, TicketTagDeleteArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketTag.
     * @param {TicketTagUpdateArgs} args - Arguments to update one TicketTag.
     * @example
     * // Update one TicketTag
     * const ticketTag = await prisma.ticketTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketTagUpdateArgs>(args: SelectSubset<T, TicketTagUpdateArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketTags.
     * @param {TicketTagDeleteManyArgs} args - Arguments to filter TicketTags to delete.
     * @example
     * // Delete a few TicketTags
     * const { count } = await prisma.ticketTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketTagDeleteManyArgs>(args?: SelectSubset<T, TicketTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketTags
     * const ticketTag = await prisma.ticketTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketTagUpdateManyArgs>(args: SelectSubset<T, TicketTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketTags and returns the data updated in the database.
     * @param {TicketTagUpdateManyAndReturnArgs} args - Arguments to update many TicketTags.
     * @example
     * // Update many TicketTags
     * const ticketTag = await prisma.ticketTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketTags and only return the `id`
     * const ticketTagWithIdOnly = await prisma.ticketTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketTagUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketTag.
     * @param {TicketTagUpsertArgs} args - Arguments to update or create a TicketTag.
     * @example
     * // Update or create a TicketTag
     * const ticketTag = await prisma.ticketTag.upsert({
     *   create: {
     *     // ... data to create a TicketTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketTag we want to update
     *   }
     * })
     */
    upsert<T extends TicketTagUpsertArgs>(args: SelectSubset<T, TicketTagUpsertArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagCountArgs} args - Arguments to filter TicketTags to count.
     * @example
     * // Count the number of TicketTags
     * const count = await prisma.ticketTag.count({
     *   where: {
     *     // ... the filter for the TicketTags we want to count
     *   }
     * })
    **/
    count<T extends TicketTagCountArgs>(
      args?: Subset<T, TicketTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketTagAggregateArgs>(args: Subset<T, TicketTagAggregateArgs>): Prisma.PrismaPromise<GetTicketTagAggregateType<T>>

    /**
     * Group by TicketTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketTagGroupByArgs['orderBy'] }
        : { orderBy?: TicketTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketTag model
   */
  readonly fields: TicketTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tickets<T extends TicketTag$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, TicketTag$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketTag model
   */
  interface TicketTagFieldRefs {
    readonly id: FieldRef<"TicketTag", 'String'>
    readonly name: FieldRef<"TicketTag", 'String'>
    readonly createdAt: FieldRef<"TicketTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketTag findUnique
   */
  export type TicketTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where: TicketTagWhereUniqueInput
  }

  /**
   * TicketTag findUniqueOrThrow
   */
  export type TicketTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where: TicketTagWhereUniqueInput
  }

  /**
   * TicketTag findFirst
   */
  export type TicketTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTags.
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTags.
     */
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
  }

  /**
   * TicketTag findFirstOrThrow
   */
  export type TicketTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTags.
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTags.
     */
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
  }

  /**
   * TicketTag findMany
   */
  export type TicketTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTags to fetch.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketTags.
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
  }

  /**
   * TicketTag create
   */
  export type TicketTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketTag.
     */
    data: XOR<TicketTagCreateInput, TicketTagUncheckedCreateInput>
  }

  /**
   * TicketTag createMany
   */
  export type TicketTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketTags.
     */
    data: TicketTagCreateManyInput | TicketTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketTag createManyAndReturn
   */
  export type TicketTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * The data used to create many TicketTags.
     */
    data: TicketTagCreateManyInput | TicketTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketTag update
   */
  export type TicketTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketTag.
     */
    data: XOR<TicketTagUpdateInput, TicketTagUncheckedUpdateInput>
    /**
     * Choose, which TicketTag to update.
     */
    where: TicketTagWhereUniqueInput
  }

  /**
   * TicketTag updateMany
   */
  export type TicketTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketTags.
     */
    data: XOR<TicketTagUpdateManyMutationInput, TicketTagUncheckedUpdateManyInput>
    /**
     * Filter which TicketTags to update
     */
    where?: TicketTagWhereInput
    /**
     * Limit how many TicketTags to update.
     */
    limit?: number
  }

  /**
   * TicketTag updateManyAndReturn
   */
  export type TicketTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * The data used to update TicketTags.
     */
    data: XOR<TicketTagUpdateManyMutationInput, TicketTagUncheckedUpdateManyInput>
    /**
     * Filter which TicketTags to update
     */
    where?: TicketTagWhereInput
    /**
     * Limit how many TicketTags to update.
     */
    limit?: number
  }

  /**
   * TicketTag upsert
   */
  export type TicketTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketTag to update in case it exists.
     */
    where: TicketTagWhereUniqueInput
    /**
     * In case the TicketTag found by the `where` argument doesn't exist, create a new TicketTag with this data.
     */
    create: XOR<TicketTagCreateInput, TicketTagUncheckedCreateInput>
    /**
     * In case the TicketTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketTagUpdateInput, TicketTagUncheckedUpdateInput>
  }

  /**
   * TicketTag delete
   */
  export type TicketTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter which TicketTag to delete.
     */
    where: TicketTagWhereUniqueInput
  }

  /**
   * TicketTag deleteMany
   */
  export type TicketTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketTags to delete
     */
    where?: TicketTagWhereInput
    /**
     * Limit how many TicketTags to delete.
     */
    limit?: number
  }

  /**
   * TicketTag.tickets
   */
  export type TicketTag$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * TicketTag without action
   */
  export type TicketTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTag
     */
    omit?: TicketTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
  }


  /**
   * Model MessageAttachment
   */

  export type AggregateMessageAttachment = {
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  export type MessageAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type MessageAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type MessageAttachmentMinAggregateOutputType = {
    id: string | null
    filename: string | null
    fileSize: number | null
    mimeType: string | null
    url: string | null
    createdAt: Date | null
    messageId: string | null
  }

  export type MessageAttachmentMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    fileSize: number | null
    mimeType: string | null
    url: string | null
    createdAt: Date | null
    messageId: string | null
  }

  export type MessageAttachmentCountAggregateOutputType = {
    id: number
    filename: number
    fileSize: number
    mimeType: number
    url: number
    createdAt: number
    messageId: number
    _all: number
  }


  export type MessageAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type MessageAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type MessageAttachmentMinAggregateInputType = {
    id?: true
    filename?: true
    fileSize?: true
    mimeType?: true
    url?: true
    createdAt?: true
    messageId?: true
  }

  export type MessageAttachmentMaxAggregateInputType = {
    id?: true
    filename?: true
    fileSize?: true
    mimeType?: true
    url?: true
    createdAt?: true
    messageId?: true
  }

  export type MessageAttachmentCountAggregateInputType = {
    id?: true
    filename?: true
    fileSize?: true
    mimeType?: true
    url?: true
    createdAt?: true
    messageId?: true
    _all?: true
  }

  export type MessageAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachment to aggregate.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageAttachments
    **/
    _count?: true | MessageAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type GetMessageAttachmentAggregateType<T extends MessageAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageAttachment[P]>
      : GetScalarType<T[P], AggregateMessageAttachment[P]>
  }




  export type MessageAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithAggregationInput | MessageAttachmentOrderByWithAggregationInput[]
    by: MessageAttachmentScalarFieldEnum[] | MessageAttachmentScalarFieldEnum
    having?: MessageAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageAttachmentCountAggregateInputType | true
    _avg?: MessageAttachmentAvgAggregateInputType
    _sum?: MessageAttachmentSumAggregateInputType
    _min?: MessageAttachmentMinAggregateInputType
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type MessageAttachmentGroupByOutputType = {
    id: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt: Date
    messageId: string
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  type GetMessageAttachmentGroupByPayload<T extends MessageAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type MessageAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
    messageId?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
    messageId?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
    messageId?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectScalar = {
    id?: boolean
    filename?: boolean
    fileSize?: boolean
    mimeType?: boolean
    url?: boolean
    createdAt?: boolean
    messageId?: boolean
  }

  export type MessageAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "fileSize" | "mimeType" | "url" | "createdAt" | "messageId", ExtArgs["result"]["messageAttachment"]>
  export type MessageAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $MessageAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageAttachment"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      fileSize: number
      mimeType: string
      url: string
      createdAt: Date
      messageId: string
    }, ExtArgs["result"]["messageAttachment"]>
    composites: {}
  }

  type MessageAttachmentGetPayload<S extends boolean | null | undefined | MessageAttachmentDefaultArgs> = $Result.GetResult<Prisma.$MessageAttachmentPayload, S>

  type MessageAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageAttachmentCountAggregateInputType | true
    }

  export interface MessageAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageAttachment'], meta: { name: 'MessageAttachment' } }
    /**
     * Find zero or one MessageAttachment that matches the filter.
     * @param {MessageAttachmentFindUniqueArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageAttachmentFindUniqueArgs>(args: SelectSubset<T, MessageAttachmentFindUniqueArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageAttachmentFindUniqueOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageAttachmentFindFirstArgs>(args?: SelectSubset<T, MessageAttachmentFindFirstArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany()
     * 
     * // Get first 10 MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageAttachmentFindManyArgs>(args?: SelectSubset<T, MessageAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageAttachment.
     * @param {MessageAttachmentCreateArgs} args - Arguments to create a MessageAttachment.
     * @example
     * // Create one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.create({
     *   data: {
     *     // ... data to create a MessageAttachment
     *   }
     * })
     * 
     */
    create<T extends MessageAttachmentCreateArgs>(args: SelectSubset<T, MessageAttachmentCreateArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageAttachments.
     * @param {MessageAttachmentCreateManyArgs} args - Arguments to create many MessageAttachments.
     * @example
     * // Create many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageAttachmentCreateManyArgs>(args?: SelectSubset<T, MessageAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageAttachments and returns the data saved in the database.
     * @param {MessageAttachmentCreateManyAndReturnArgs} args - Arguments to create many MessageAttachments.
     * @example
     * // Create many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageAttachments and only return the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageAttachment.
     * @param {MessageAttachmentDeleteArgs} args - Arguments to delete one MessageAttachment.
     * @example
     * // Delete one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.delete({
     *   where: {
     *     // ... filter to delete one MessageAttachment
     *   }
     * })
     * 
     */
    delete<T extends MessageAttachmentDeleteArgs>(args: SelectSubset<T, MessageAttachmentDeleteArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageAttachment.
     * @param {MessageAttachmentUpdateArgs} args - Arguments to update one MessageAttachment.
     * @example
     * // Update one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageAttachmentUpdateArgs>(args: SelectSubset<T, MessageAttachmentUpdateArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageAttachments.
     * @param {MessageAttachmentDeleteManyArgs} args - Arguments to filter MessageAttachments to delete.
     * @example
     * // Delete a few MessageAttachments
     * const { count } = await prisma.messageAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageAttachmentDeleteManyArgs>(args?: SelectSubset<T, MessageAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageAttachmentUpdateManyArgs>(args: SelectSubset<T, MessageAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAttachments and returns the data updated in the database.
     * @param {MessageAttachmentUpdateManyAndReturnArgs} args - Arguments to update many MessageAttachments.
     * @example
     * // Update many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageAttachments and only return the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageAttachment.
     * @param {MessageAttachmentUpsertArgs} args - Arguments to update or create a MessageAttachment.
     * @example
     * // Update or create a MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.upsert({
     *   create: {
     *     // ... data to create a MessageAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageAttachment we want to update
     *   }
     * })
     */
    upsert<T extends MessageAttachmentUpsertArgs>(args: SelectSubset<T, MessageAttachmentUpsertArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentCountArgs} args - Arguments to filter MessageAttachments to count.
     * @example
     * // Count the number of MessageAttachments
     * const count = await prisma.messageAttachment.count({
     *   where: {
     *     // ... the filter for the MessageAttachments we want to count
     *   }
     * })
    **/
    count<T extends MessageAttachmentCountArgs>(
      args?: Subset<T, MessageAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAttachmentAggregateArgs>(args: Subset<T, MessageAttachmentAggregateArgs>): Prisma.PrismaPromise<GetMessageAttachmentAggregateType<T>>

    /**
     * Group by MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: MessageAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageAttachment model
   */
  readonly fields: MessageAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageAttachment model
   */
  interface MessageAttachmentFieldRefs {
    readonly id: FieldRef<"MessageAttachment", 'String'>
    readonly filename: FieldRef<"MessageAttachment", 'String'>
    readonly fileSize: FieldRef<"MessageAttachment", 'Int'>
    readonly mimeType: FieldRef<"MessageAttachment", 'String'>
    readonly url: FieldRef<"MessageAttachment", 'String'>
    readonly createdAt: FieldRef<"MessageAttachment", 'DateTime'>
    readonly messageId: FieldRef<"MessageAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MessageAttachment findUnique
   */
  export type MessageAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment findUniqueOrThrow
   */
  export type MessageAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment findFirst
   */
  export type MessageAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment findFirstOrThrow
   */
  export type MessageAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment findMany
   */
  export type MessageAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachments to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment create
   */
  export type MessageAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageAttachment.
     */
    data: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
  }

  /**
   * MessageAttachment createMany
   */
  export type MessageAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageAttachments.
     */
    data: MessageAttachmentCreateManyInput | MessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageAttachment createManyAndReturn
   */
  export type MessageAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many MessageAttachments.
     */
    data: MessageAttachmentCreateManyInput | MessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAttachment update
   */
  export type MessageAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageAttachment.
     */
    data: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
    /**
     * Choose, which MessageAttachment to update.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment updateMany
   */
  export type MessageAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageAttachments.
     */
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAttachments to update
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to update.
     */
    limit?: number
  }

  /**
   * MessageAttachment updateManyAndReturn
   */
  export type MessageAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update MessageAttachments.
     */
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAttachments to update
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAttachment upsert
   */
  export type MessageAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageAttachment to update in case it exists.
     */
    where: MessageAttachmentWhereUniqueInput
    /**
     * In case the MessageAttachment found by the `where` argument doesn't exist, create a new MessageAttachment with this data.
     */
    create: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
    /**
     * In case the MessageAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
  }

  /**
   * MessageAttachment delete
   */
  export type MessageAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter which MessageAttachment to delete.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment deleteMany
   */
  export type MessageAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachments to delete
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to delete.
     */
    limit?: number
  }

  /**
   * MessageAttachment without action
   */
  export type MessageAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model ClientActivity
   */

  export type AggregateClientActivity = {
    _count: ClientActivityCountAggregateOutputType | null
    _min: ClientActivityMinAggregateOutputType | null
    _max: ClientActivityMaxAggregateOutputType | null
  }

  export type ClientActivityMinAggregateOutputType = {
    id: string | null
    type: string | null
    description: string | null
    status: $Enums.ActivityStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ClientActivityMaxAggregateOutputType = {
    id: string | null
    type: string | null
    description: string | null
    status: $Enums.ActivityStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ClientActivityCountAggregateOutputType = {
    id: number
    type: number
    description: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type ClientActivityMinAggregateInputType = {
    id?: true
    type?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ClientActivityMaxAggregateInputType = {
    id?: true
    type?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ClientActivityCountAggregateInputType = {
    id?: true
    type?: true
    description?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type ClientActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientActivity to aggregate.
     */
    where?: ClientActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientActivities to fetch.
     */
    orderBy?: ClientActivityOrderByWithRelationInput | ClientActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientActivities
    **/
    _count?: true | ClientActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientActivityMaxAggregateInputType
  }

  export type GetClientActivityAggregateType<T extends ClientActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateClientActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientActivity[P]>
      : GetScalarType<T[P], AggregateClientActivity[P]>
  }




  export type ClientActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientActivityWhereInput
    orderBy?: ClientActivityOrderByWithAggregationInput | ClientActivityOrderByWithAggregationInput[]
    by: ClientActivityScalarFieldEnum[] | ClientActivityScalarFieldEnum
    having?: ClientActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientActivityCountAggregateInputType | true
    _min?: ClientActivityMinAggregateInputType
    _max?: ClientActivityMaxAggregateInputType
  }

  export type ClientActivityGroupByOutputType = {
    id: string
    type: string
    description: string
    status: $Enums.ActivityStatus
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: ClientActivityCountAggregateOutputType | null
    _min: ClientActivityMinAggregateOutputType | null
    _max: ClientActivityMaxAggregateOutputType | null
  }

  type GetClientActivityGroupByPayload<T extends ClientActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ClientActivityGroupByOutputType[P]>
        }
      >
    >


  export type ClientActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientActivity"]>

  export type ClientActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientActivity"]>

  export type ClientActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientActivity"]>

  export type ClientActivitySelectScalar = {
    id?: boolean
    type?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type ClientActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "description" | "status" | "metadata" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["clientActivity"]>
  export type ClientActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientActivity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      description: string
      status: $Enums.ActivityStatus
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["clientActivity"]>
    composites: {}
  }

  type ClientActivityGetPayload<S extends boolean | null | undefined | ClientActivityDefaultArgs> = $Result.GetResult<Prisma.$ClientActivityPayload, S>

  type ClientActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientActivityCountAggregateInputType | true
    }

  export interface ClientActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientActivity'], meta: { name: 'ClientActivity' } }
    /**
     * Find zero or one ClientActivity that matches the filter.
     * @param {ClientActivityFindUniqueArgs} args - Arguments to find a ClientActivity
     * @example
     * // Get one ClientActivity
     * const clientActivity = await prisma.clientActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientActivityFindUniqueArgs>(args: SelectSubset<T, ClientActivityFindUniqueArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientActivityFindUniqueOrThrowArgs} args - Arguments to find a ClientActivity
     * @example
     * // Get one ClientActivity
     * const clientActivity = await prisma.clientActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityFindFirstArgs} args - Arguments to find a ClientActivity
     * @example
     * // Get one ClientActivity
     * const clientActivity = await prisma.clientActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientActivityFindFirstArgs>(args?: SelectSubset<T, ClientActivityFindFirstArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityFindFirstOrThrowArgs} args - Arguments to find a ClientActivity
     * @example
     * // Get one ClientActivity
     * const clientActivity = await prisma.clientActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientActivities
     * const clientActivities = await prisma.clientActivity.findMany()
     * 
     * // Get first 10 ClientActivities
     * const clientActivities = await prisma.clientActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientActivityWithIdOnly = await prisma.clientActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientActivityFindManyArgs>(args?: SelectSubset<T, ClientActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientActivity.
     * @param {ClientActivityCreateArgs} args - Arguments to create a ClientActivity.
     * @example
     * // Create one ClientActivity
     * const ClientActivity = await prisma.clientActivity.create({
     *   data: {
     *     // ... data to create a ClientActivity
     *   }
     * })
     * 
     */
    create<T extends ClientActivityCreateArgs>(args: SelectSubset<T, ClientActivityCreateArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientActivities.
     * @param {ClientActivityCreateManyArgs} args - Arguments to create many ClientActivities.
     * @example
     * // Create many ClientActivities
     * const clientActivity = await prisma.clientActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientActivityCreateManyArgs>(args?: SelectSubset<T, ClientActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientActivities and returns the data saved in the database.
     * @param {ClientActivityCreateManyAndReturnArgs} args - Arguments to create many ClientActivities.
     * @example
     * // Create many ClientActivities
     * const clientActivity = await prisma.clientActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientActivities and only return the `id`
     * const clientActivityWithIdOnly = await prisma.clientActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientActivity.
     * @param {ClientActivityDeleteArgs} args - Arguments to delete one ClientActivity.
     * @example
     * // Delete one ClientActivity
     * const ClientActivity = await prisma.clientActivity.delete({
     *   where: {
     *     // ... filter to delete one ClientActivity
     *   }
     * })
     * 
     */
    delete<T extends ClientActivityDeleteArgs>(args: SelectSubset<T, ClientActivityDeleteArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientActivity.
     * @param {ClientActivityUpdateArgs} args - Arguments to update one ClientActivity.
     * @example
     * // Update one ClientActivity
     * const clientActivity = await prisma.clientActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientActivityUpdateArgs>(args: SelectSubset<T, ClientActivityUpdateArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientActivities.
     * @param {ClientActivityDeleteManyArgs} args - Arguments to filter ClientActivities to delete.
     * @example
     * // Delete a few ClientActivities
     * const { count } = await prisma.clientActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientActivityDeleteManyArgs>(args?: SelectSubset<T, ClientActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientActivities
     * const clientActivity = await prisma.clientActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientActivityUpdateManyArgs>(args: SelectSubset<T, ClientActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientActivities and returns the data updated in the database.
     * @param {ClientActivityUpdateManyAndReturnArgs} args - Arguments to update many ClientActivities.
     * @example
     * // Update many ClientActivities
     * const clientActivity = await prisma.clientActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientActivities and only return the `id`
     * const clientActivityWithIdOnly = await prisma.clientActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientActivity.
     * @param {ClientActivityUpsertArgs} args - Arguments to update or create a ClientActivity.
     * @example
     * // Update or create a ClientActivity
     * const clientActivity = await prisma.clientActivity.upsert({
     *   create: {
     *     // ... data to create a ClientActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientActivity we want to update
     *   }
     * })
     */
    upsert<T extends ClientActivityUpsertArgs>(args: SelectSubset<T, ClientActivityUpsertArgs<ExtArgs>>): Prisma__ClientActivityClient<$Result.GetResult<Prisma.$ClientActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityCountArgs} args - Arguments to filter ClientActivities to count.
     * @example
     * // Count the number of ClientActivities
     * const count = await prisma.clientActivity.count({
     *   where: {
     *     // ... the filter for the ClientActivities we want to count
     *   }
     * })
    **/
    count<T extends ClientActivityCountArgs>(
      args?: Subset<T, ClientActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientActivityAggregateArgs>(args: Subset<T, ClientActivityAggregateArgs>): Prisma.PrismaPromise<GetClientActivityAggregateType<T>>

    /**
     * Group by ClientActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientActivityGroupByArgs['orderBy'] }
        : { orderBy?: ClientActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientActivity model
   */
  readonly fields: ClientActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientActivity model
   */
  interface ClientActivityFieldRefs {
    readonly id: FieldRef<"ClientActivity", 'String'>
    readonly type: FieldRef<"ClientActivity", 'String'>
    readonly description: FieldRef<"ClientActivity", 'String'>
    readonly status: FieldRef<"ClientActivity", 'ActivityStatus'>
    readonly metadata: FieldRef<"ClientActivity", 'Json'>
    readonly createdAt: FieldRef<"ClientActivity", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientActivity", 'DateTime'>
    readonly userId: FieldRef<"ClientActivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientActivity findUnique
   */
  export type ClientActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter, which ClientActivity to fetch.
     */
    where: ClientActivityWhereUniqueInput
  }

  /**
   * ClientActivity findUniqueOrThrow
   */
  export type ClientActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter, which ClientActivity to fetch.
     */
    where: ClientActivityWhereUniqueInput
  }

  /**
   * ClientActivity findFirst
   */
  export type ClientActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter, which ClientActivity to fetch.
     */
    where?: ClientActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientActivities to fetch.
     */
    orderBy?: ClientActivityOrderByWithRelationInput | ClientActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientActivities.
     */
    cursor?: ClientActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientActivities.
     */
    distinct?: ClientActivityScalarFieldEnum | ClientActivityScalarFieldEnum[]
  }

  /**
   * ClientActivity findFirstOrThrow
   */
  export type ClientActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter, which ClientActivity to fetch.
     */
    where?: ClientActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientActivities to fetch.
     */
    orderBy?: ClientActivityOrderByWithRelationInput | ClientActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientActivities.
     */
    cursor?: ClientActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientActivities.
     */
    distinct?: ClientActivityScalarFieldEnum | ClientActivityScalarFieldEnum[]
  }

  /**
   * ClientActivity findMany
   */
  export type ClientActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter, which ClientActivities to fetch.
     */
    where?: ClientActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientActivities to fetch.
     */
    orderBy?: ClientActivityOrderByWithRelationInput | ClientActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientActivities.
     */
    cursor?: ClientActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientActivities.
     */
    skip?: number
    distinct?: ClientActivityScalarFieldEnum | ClientActivityScalarFieldEnum[]
  }

  /**
   * ClientActivity create
   */
  export type ClientActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientActivity.
     */
    data: XOR<ClientActivityCreateInput, ClientActivityUncheckedCreateInput>
  }

  /**
   * ClientActivity createMany
   */
  export type ClientActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientActivities.
     */
    data: ClientActivityCreateManyInput | ClientActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientActivity createManyAndReturn
   */
  export type ClientActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * The data used to create many ClientActivities.
     */
    data: ClientActivityCreateManyInput | ClientActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientActivity update
   */
  export type ClientActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientActivity.
     */
    data: XOR<ClientActivityUpdateInput, ClientActivityUncheckedUpdateInput>
    /**
     * Choose, which ClientActivity to update.
     */
    where: ClientActivityWhereUniqueInput
  }

  /**
   * ClientActivity updateMany
   */
  export type ClientActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientActivities.
     */
    data: XOR<ClientActivityUpdateManyMutationInput, ClientActivityUncheckedUpdateManyInput>
    /**
     * Filter which ClientActivities to update
     */
    where?: ClientActivityWhereInput
    /**
     * Limit how many ClientActivities to update.
     */
    limit?: number
  }

  /**
   * ClientActivity updateManyAndReturn
   */
  export type ClientActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * The data used to update ClientActivities.
     */
    data: XOR<ClientActivityUpdateManyMutationInput, ClientActivityUncheckedUpdateManyInput>
    /**
     * Filter which ClientActivities to update
     */
    where?: ClientActivityWhereInput
    /**
     * Limit how many ClientActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientActivity upsert
   */
  export type ClientActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientActivity to update in case it exists.
     */
    where: ClientActivityWhereUniqueInput
    /**
     * In case the ClientActivity found by the `where` argument doesn't exist, create a new ClientActivity with this data.
     */
    create: XOR<ClientActivityCreateInput, ClientActivityUncheckedCreateInput>
    /**
     * In case the ClientActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientActivityUpdateInput, ClientActivityUncheckedUpdateInput>
  }

  /**
   * ClientActivity delete
   */
  export type ClientActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
    /**
     * Filter which ClientActivity to delete.
     */
    where: ClientActivityWhereUniqueInput
  }

  /**
   * ClientActivity deleteMany
   */
  export type ClientActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientActivities to delete
     */
    where?: ClientActivityWhereInput
    /**
     * Limit how many ClientActivities to delete.
     */
    limit?: number
  }

  /**
   * ClientActivity without action
   */
  export type ClientActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientActivity
     */
    select?: ClientActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientActivity
     */
    omit?: ClientActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientActivityInclude<ExtArgs> | null
  }


  /**
   * Model UserToEmailClient
   */

  export type AggregateUserToEmailClient = {
    _count: UserToEmailClientCountAggregateOutputType | null
    _min: UserToEmailClientMinAggregateOutputType | null
    _max: UserToEmailClientMaxAggregateOutputType | null
  }

  export type UserToEmailClientMinAggregateOutputType = {
    id: string | null
    userId: string | null
    emailClientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToEmailClientMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    emailClientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToEmailClientCountAggregateOutputType = {
    id: number
    userId: number
    emailClientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserToEmailClientMinAggregateInputType = {
    id?: true
    userId?: true
    emailClientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToEmailClientMaxAggregateInputType = {
    id?: true
    userId?: true
    emailClientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToEmailClientCountAggregateInputType = {
    id?: true
    userId?: true
    emailClientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserToEmailClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToEmailClient to aggregate.
     */
    where?: UserToEmailClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToEmailClients to fetch.
     */
    orderBy?: UserToEmailClientOrderByWithRelationInput | UserToEmailClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToEmailClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToEmailClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToEmailClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToEmailClients
    **/
    _count?: true | UserToEmailClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToEmailClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToEmailClientMaxAggregateInputType
  }

  export type GetUserToEmailClientAggregateType<T extends UserToEmailClientAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToEmailClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToEmailClient[P]>
      : GetScalarType<T[P], AggregateUserToEmailClient[P]>
  }




  export type UserToEmailClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToEmailClientWhereInput
    orderBy?: UserToEmailClientOrderByWithAggregationInput | UserToEmailClientOrderByWithAggregationInput[]
    by: UserToEmailClientScalarFieldEnum[] | UserToEmailClientScalarFieldEnum
    having?: UserToEmailClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToEmailClientCountAggregateInputType | true
    _min?: UserToEmailClientMinAggregateInputType
    _max?: UserToEmailClientMaxAggregateInputType
  }

  export type UserToEmailClientGroupByOutputType = {
    id: string
    userId: string
    emailClientId: string
    createdAt: Date
    updatedAt: Date
    _count: UserToEmailClientCountAggregateOutputType | null
    _min: UserToEmailClientMinAggregateOutputType | null
    _max: UserToEmailClientMaxAggregateOutputType | null
  }

  type GetUserToEmailClientGroupByPayload<T extends UserToEmailClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserToEmailClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToEmailClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToEmailClientGroupByOutputType[P]>
            : GetScalarType<T[P], UserToEmailClientGroupByOutputType[P]>
        }
      >
    >


  export type UserToEmailClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailClientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToEmailClient"]>

  export type UserToEmailClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailClientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToEmailClient"]>

  export type UserToEmailClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailClientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToEmailClient"]>

  export type UserToEmailClientSelectScalar = {
    id?: boolean
    userId?: boolean
    emailClientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserToEmailClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "emailClientId" | "createdAt" | "updatedAt", ExtArgs["result"]["userToEmailClient"]>
  export type UserToEmailClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserToEmailClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserToEmailClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailClient?: boolean | EmailClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserToEmailClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserToEmailClient"
    objects: {
      emailClient: Prisma.$EmailClientPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      emailClientId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userToEmailClient"]>
    composites: {}
  }

  type UserToEmailClientGetPayload<S extends boolean | null | undefined | UserToEmailClientDefaultArgs> = $Result.GetResult<Prisma.$UserToEmailClientPayload, S>

  type UserToEmailClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserToEmailClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserToEmailClientCountAggregateInputType | true
    }

  export interface UserToEmailClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserToEmailClient'], meta: { name: 'UserToEmailClient' } }
    /**
     * Find zero or one UserToEmailClient that matches the filter.
     * @param {UserToEmailClientFindUniqueArgs} args - Arguments to find a UserToEmailClient
     * @example
     * // Get one UserToEmailClient
     * const userToEmailClient = await prisma.userToEmailClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserToEmailClientFindUniqueArgs>(args: SelectSubset<T, UserToEmailClientFindUniqueArgs<ExtArgs>>): Prisma__UserToEmailClientClient<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserToEmailClient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserToEmailClientFindUniqueOrThrowArgs} args - Arguments to find a UserToEmailClient
     * @example
     * // Get one UserToEmailClient
     * const userToEmailClient = await prisma.userToEmailClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserToEmailClientFindUniqueOrThrowArgs>(args: SelectSubset<T, UserToEmailClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserToEmailClientClient<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserToEmailClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToEmailClientFindFirstArgs} args - Arguments to find a UserToEmailClient
     * @example
     * // Get one UserToEmailClient
     * const userToEmailClient = await prisma.userToEmailClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserToEmailClientFindFirstArgs>(args?: SelectSubset<T, UserToEmailClientFindFirstArgs<ExtArgs>>): Prisma__UserToEmailClientClient<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserToEmailClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToEmailClientFindFirstOrThrowArgs} args - Arguments to find a UserToEmailClient
     * @example
     * // Get one UserToEmailClient
     * const userToEmailClient = await prisma.userToEmailClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserToEmailClientFindFirstOrThrowArgs>(args?: SelectSubset<T, UserToEmailClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserToEmailClientClient<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserToEmailClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToEmailClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToEmailClients
     * const userToEmailClients = await prisma.userToEmailClient.findMany()
     * 
     * // Get first 10 UserToEmailClients
     * const userToEmailClients = await prisma.userToEmailClient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToEmailClientWithIdOnly = await prisma.userToEmailClient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserToEmailClientFindManyArgs>(args?: SelectSubset<T, UserToEmailClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserToEmailClient.
     * @param {UserToEmailClientCreateArgs} args - Arguments to create a UserToEmailClient.
     * @example
     * // Create one UserToEmailClient
     * const UserToEmailClient = await prisma.userToEmailClient.create({
     *   data: {
     *     // ... data to create a UserToEmailClient
     *   }
     * })
     * 
     */
    create<T extends UserToEmailClientCreateArgs>(args: SelectSubset<T, UserToEmailClientCreateArgs<ExtArgs>>): Prisma__UserToEmailClientClient<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserToEmailClients.
     * @param {UserToEmailClientCreateManyArgs} args - Arguments to create many UserToEmailClients.
     * @example
     * // Create many UserToEmailClients
     * const userToEmailClient = await prisma.userToEmailClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserToEmailClientCreateManyArgs>(args?: SelectSubset<T, UserToEmailClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserToEmailClients and returns the data saved in the database.
     * @param {UserToEmailClientCreateManyAndReturnArgs} args - Arguments to create many UserToEmailClients.
     * @example
     * // Create many UserToEmailClients
     * const userToEmailClient = await prisma.userToEmailClient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserToEmailClients and only return the `id`
     * const userToEmailClientWithIdOnly = await prisma.userToEmailClient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserToEmailClientCreateManyAndReturnArgs>(args?: SelectSubset<T, UserToEmailClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserToEmailClient.
     * @param {UserToEmailClientDeleteArgs} args - Arguments to delete one UserToEmailClient.
     * @example
     * // Delete one UserToEmailClient
     * const UserToEmailClient = await prisma.userToEmailClient.delete({
     *   where: {
     *     // ... filter to delete one UserToEmailClient
     *   }
     * })
     * 
     */
    delete<T extends UserToEmailClientDeleteArgs>(args: SelectSubset<T, UserToEmailClientDeleteArgs<ExtArgs>>): Prisma__UserToEmailClientClient<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserToEmailClient.
     * @param {UserToEmailClientUpdateArgs} args - Arguments to update one UserToEmailClient.
     * @example
     * // Update one UserToEmailClient
     * const userToEmailClient = await prisma.userToEmailClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserToEmailClientUpdateArgs>(args: SelectSubset<T, UserToEmailClientUpdateArgs<ExtArgs>>): Prisma__UserToEmailClientClient<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserToEmailClients.
     * @param {UserToEmailClientDeleteManyArgs} args - Arguments to filter UserToEmailClients to delete.
     * @example
     * // Delete a few UserToEmailClients
     * const { count } = await prisma.userToEmailClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserToEmailClientDeleteManyArgs>(args?: SelectSubset<T, UserToEmailClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToEmailClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToEmailClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToEmailClients
     * const userToEmailClient = await prisma.userToEmailClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserToEmailClientUpdateManyArgs>(args: SelectSubset<T, UserToEmailClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToEmailClients and returns the data updated in the database.
     * @param {UserToEmailClientUpdateManyAndReturnArgs} args - Arguments to update many UserToEmailClients.
     * @example
     * // Update many UserToEmailClients
     * const userToEmailClient = await prisma.userToEmailClient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserToEmailClients and only return the `id`
     * const userToEmailClientWithIdOnly = await prisma.userToEmailClient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserToEmailClientUpdateManyAndReturnArgs>(args: SelectSubset<T, UserToEmailClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserToEmailClient.
     * @param {UserToEmailClientUpsertArgs} args - Arguments to update or create a UserToEmailClient.
     * @example
     * // Update or create a UserToEmailClient
     * const userToEmailClient = await prisma.userToEmailClient.upsert({
     *   create: {
     *     // ... data to create a UserToEmailClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToEmailClient we want to update
     *   }
     * })
     */
    upsert<T extends UserToEmailClientUpsertArgs>(args: SelectSubset<T, UserToEmailClientUpsertArgs<ExtArgs>>): Prisma__UserToEmailClientClient<$Result.GetResult<Prisma.$UserToEmailClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserToEmailClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToEmailClientCountArgs} args - Arguments to filter UserToEmailClients to count.
     * @example
     * // Count the number of UserToEmailClients
     * const count = await prisma.userToEmailClient.count({
     *   where: {
     *     // ... the filter for the UserToEmailClients we want to count
     *   }
     * })
    **/
    count<T extends UserToEmailClientCountArgs>(
      args?: Subset<T, UserToEmailClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToEmailClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToEmailClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToEmailClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToEmailClientAggregateArgs>(args: Subset<T, UserToEmailClientAggregateArgs>): Prisma.PrismaPromise<GetUserToEmailClientAggregateType<T>>

    /**
     * Group by UserToEmailClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToEmailClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToEmailClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToEmailClientGroupByArgs['orderBy'] }
        : { orderBy?: UserToEmailClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToEmailClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToEmailClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserToEmailClient model
   */
  readonly fields: UserToEmailClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToEmailClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserToEmailClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emailClient<T extends EmailClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailClientDefaultArgs<ExtArgs>>): Prisma__EmailClientClient<$Result.GetResult<Prisma.$EmailClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserToEmailClient model
   */
  interface UserToEmailClientFieldRefs {
    readonly id: FieldRef<"UserToEmailClient", 'String'>
    readonly userId: FieldRef<"UserToEmailClient", 'String'>
    readonly emailClientId: FieldRef<"UserToEmailClient", 'String'>
    readonly createdAt: FieldRef<"UserToEmailClient", 'DateTime'>
    readonly updatedAt: FieldRef<"UserToEmailClient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserToEmailClient findUnique
   */
  export type UserToEmailClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
    /**
     * Filter, which UserToEmailClient to fetch.
     */
    where: UserToEmailClientWhereUniqueInput
  }

  /**
   * UserToEmailClient findUniqueOrThrow
   */
  export type UserToEmailClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
    /**
     * Filter, which UserToEmailClient to fetch.
     */
    where: UserToEmailClientWhereUniqueInput
  }

  /**
   * UserToEmailClient findFirst
   */
  export type UserToEmailClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
    /**
     * Filter, which UserToEmailClient to fetch.
     */
    where?: UserToEmailClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToEmailClients to fetch.
     */
    orderBy?: UserToEmailClientOrderByWithRelationInput | UserToEmailClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToEmailClients.
     */
    cursor?: UserToEmailClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToEmailClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToEmailClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToEmailClients.
     */
    distinct?: UserToEmailClientScalarFieldEnum | UserToEmailClientScalarFieldEnum[]
  }

  /**
   * UserToEmailClient findFirstOrThrow
   */
  export type UserToEmailClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
    /**
     * Filter, which UserToEmailClient to fetch.
     */
    where?: UserToEmailClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToEmailClients to fetch.
     */
    orderBy?: UserToEmailClientOrderByWithRelationInput | UserToEmailClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToEmailClients.
     */
    cursor?: UserToEmailClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToEmailClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToEmailClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToEmailClients.
     */
    distinct?: UserToEmailClientScalarFieldEnum | UserToEmailClientScalarFieldEnum[]
  }

  /**
   * UserToEmailClient findMany
   */
  export type UserToEmailClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
    /**
     * Filter, which UserToEmailClients to fetch.
     */
    where?: UserToEmailClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToEmailClients to fetch.
     */
    orderBy?: UserToEmailClientOrderByWithRelationInput | UserToEmailClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToEmailClients.
     */
    cursor?: UserToEmailClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToEmailClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToEmailClients.
     */
    skip?: number
    distinct?: UserToEmailClientScalarFieldEnum | UserToEmailClientScalarFieldEnum[]
  }

  /**
   * UserToEmailClient create
   */
  export type UserToEmailClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
    /**
     * The data needed to create a UserToEmailClient.
     */
    data: XOR<UserToEmailClientCreateInput, UserToEmailClientUncheckedCreateInput>
  }

  /**
   * UserToEmailClient createMany
   */
  export type UserToEmailClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserToEmailClients.
     */
    data: UserToEmailClientCreateManyInput | UserToEmailClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserToEmailClient createManyAndReturn
   */
  export type UserToEmailClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * The data used to create many UserToEmailClients.
     */
    data: UserToEmailClientCreateManyInput | UserToEmailClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserToEmailClient update
   */
  export type UserToEmailClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
    /**
     * The data needed to update a UserToEmailClient.
     */
    data: XOR<UserToEmailClientUpdateInput, UserToEmailClientUncheckedUpdateInput>
    /**
     * Choose, which UserToEmailClient to update.
     */
    where: UserToEmailClientWhereUniqueInput
  }

  /**
   * UserToEmailClient updateMany
   */
  export type UserToEmailClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserToEmailClients.
     */
    data: XOR<UserToEmailClientUpdateManyMutationInput, UserToEmailClientUncheckedUpdateManyInput>
    /**
     * Filter which UserToEmailClients to update
     */
    where?: UserToEmailClientWhereInput
    /**
     * Limit how many UserToEmailClients to update.
     */
    limit?: number
  }

  /**
   * UserToEmailClient updateManyAndReturn
   */
  export type UserToEmailClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * The data used to update UserToEmailClients.
     */
    data: XOR<UserToEmailClientUpdateManyMutationInput, UserToEmailClientUncheckedUpdateManyInput>
    /**
     * Filter which UserToEmailClients to update
     */
    where?: UserToEmailClientWhereInput
    /**
     * Limit how many UserToEmailClients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserToEmailClient upsert
   */
  export type UserToEmailClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
    /**
     * The filter to search for the UserToEmailClient to update in case it exists.
     */
    where: UserToEmailClientWhereUniqueInput
    /**
     * In case the UserToEmailClient found by the `where` argument doesn't exist, create a new UserToEmailClient with this data.
     */
    create: XOR<UserToEmailClientCreateInput, UserToEmailClientUncheckedCreateInput>
    /**
     * In case the UserToEmailClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToEmailClientUpdateInput, UserToEmailClientUncheckedUpdateInput>
  }

  /**
   * UserToEmailClient delete
   */
  export type UserToEmailClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
    /**
     * Filter which UserToEmailClient to delete.
     */
    where: UserToEmailClientWhereUniqueInput
  }

  /**
   * UserToEmailClient deleteMany
   */
  export type UserToEmailClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToEmailClients to delete
     */
    where?: UserToEmailClientWhereInput
    /**
     * Limit how many UserToEmailClients to delete.
     */
    limit?: number
  }

  /**
   * UserToEmailClient without action
   */
  export type UserToEmailClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToEmailClient
     */
    select?: UserToEmailClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToEmailClient
     */
    omit?: UserToEmailClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToEmailClientInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const ClientSatisfactionScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    feedback: 'feedback',
    userId: 'userId',
    accountRepId: 'accountRepId',
    createdAt: 'createdAt'
  };

  export type ClientSatisfactionScalarFieldEnum = (typeof ClientSatisfactionScalarFieldEnum)[keyof typeof ClientSatisfactionScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    isStarred: 'isStarred',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    description: 'description',
    gaAccountId: 'gaAccountId',
    gaPropertyId: 'gaPropertyId',
    clientId: 'clientId'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const EmailCampaignScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    campaignId: 'campaignId',
    campaignName: 'campaignName',
    emailClientId: 'emailClientId'
  };

  export type EmailCampaignScalarFieldEnum = (typeof EmailCampaignScalarFieldEnum)[keyof typeof EmailCampaignScalarFieldEnum]


  export const EmailCampaignContentScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    type: 'type',
    recipients: 'recipients',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    contentType: 'contentType',
    createTime: 'createTime',
    emailCampaignId: 'emailCampaignId',
    htmlContent: 'htmlContent',
    plainContent: 'plainContent',
    sendTime: 'sendTime',
    webId: 'webId'
  };

  export type EmailCampaignContentScalarFieldEnum = (typeof EmailCampaignContentScalarFieldEnum)[keyof typeof EmailCampaignContentScalarFieldEnum]


  export const EmailCampaignDailyStatsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    opens: 'opens',
    clicks: 'clicks',
    bounces: 'bounces',
    unsubscribes: 'unsubscribes',
    variation: 'variation',
    phase: 'phase',
    requests: 'requests',
    delivered: 'delivered',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    bounceDrops: 'bounceDrops',
    cumulativeBounceRate: 'cumulativeBounceRate',
    cumulativeSpamReportsRate: 'cumulativeSpamReportsRate',
    cumulativeTotalClickRate: 'cumulativeTotalClickRate',
    cumulativeTotalOpenRate: 'cumulativeTotalOpenRate',
    cumulativeUniqueClickRate: 'cumulativeUniqueClickRate',
    cumulativeUniqueOpenRate: 'cumulativeUniqueOpenRate',
    cumulativeUnsubscribeRate: 'cumulativeUnsubscribeRate',
    dailyBounceRate: 'dailyBounceRate',
    dailySpamReportsRate: 'dailySpamReportsRate',
    dailyTotalClickRate: 'dailyTotalClickRate',
    dailyTotalClickToOpenRate: 'dailyTotalClickToOpenRate',
    dailyTotalOpenRate: 'dailyTotalOpenRate',
    dailyUniqueClickRate: 'dailyUniqueClickRate',
    dailyUniqueClickToOpenRate: 'dailyUniqueClickToOpenRate',
    dailyUniqueOpenRate: 'dailyUniqueOpenRate',
    dailyUnsubscribeRate: 'dailyUnsubscribeRate',
    emailCampaignId: 'emailCampaignId',
    emailClientId: 'emailClientId',
    singleSendName: 'singleSendName',
    spamReportDrops: 'spamReportDrops',
    spamReports: 'spamReports',
    totalClicks: 'totalClicks',
    totalOpens: 'totalOpens',
    uniqueClicks: 'uniqueClicks',
    uniqueOpens: 'uniqueOpens'
  };

  export type EmailCampaignDailyStatsScalarFieldEnum = (typeof EmailCampaignDailyStatsScalarFieldEnum)[keyof typeof EmailCampaignDailyStatsScalarFieldEnum]


  export const EmailClientScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientName: 'clientName'
  };

  export type EmailClientScalarFieldEnum = (typeof EmailClientScalarFieldEnum)[keyof typeof EmailClientScalarFieldEnum]


  export const EmailClientCredentialsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    apiKey: 'apiKey',
    emailClientId: 'emailClientId',
    platformName: 'platformName'
  };

  export type EmailClientCredentialsScalarFieldEnum = (typeof EmailClientCredentialsScalarFieldEnum)[keyof typeof EmailClientCredentialsScalarFieldEnum]


  export const EmailGlobalDailyStatsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    bounces: 'bounces',
    clicks: 'clicks',
    emailClientId: 'emailClientId',
    opens: 'opens',
    unsubs: 'unsubs'
  };

  export type EmailGlobalDailyStatsScalarFieldEnum = (typeof EmailGlobalDailyStatsScalarFieldEnum)[keyof typeof EmailGlobalDailyStatsScalarFieldEnum]


  export const GaAccountScalarFieldEnum: {
    id: 'id',
    gaAccountId: 'gaAccountId',
    gaAccountName: 'gaAccountName',
    deleted: 'deleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GaAccountScalarFieldEnum = (typeof GaAccountScalarFieldEnum)[keyof typeof GaAccountScalarFieldEnum]


  export const GaPropertyScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    gaPropertyName: 'gaPropertyName',
    gaAccountId: 'gaAccountId',
    deleted: 'deleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GaPropertyScalarFieldEnum = (typeof GaPropertyScalarFieldEnum)[keyof typeof GaPropertyScalarFieldEnum]


  export const GaImportRunScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    dateStart: 'dateStart',
    dateEnd: 'dateEnd',
    status: 'status',
    errorMessage: 'errorMessage',
    requestedByUserId: 'requestedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GaImportRunScalarFieldEnum = (typeof GaImportRunScalarFieldEnum)[keyof typeof GaImportRunScalarFieldEnum]


  export const GaKpiDailyScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    date: 'date',
    sessions: 'sessions',
    screenPageViewsPerSession: 'screenPageViewsPerSession',
    engagementRate: 'engagementRate',
    avgSessionDurationSec: 'avgSessionDurationSec',
    goalCompletions: 'goalCompletions',
    goalCompletionRate: 'goalCompletionRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GaKpiDailyScalarFieldEnum = (typeof GaKpiDailyScalarFieldEnum)[keyof typeof GaKpiDailyScalarFieldEnum]


  export const GaKpiMonthlyScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    month: 'month',
    sessions: 'sessions',
    screenPageViewsPerSession: 'screenPageViewsPerSession',
    engagementRate: 'engagementRate',
    avgSessionDurationSec: 'avgSessionDurationSec',
    goalCompletions: 'goalCompletions',
    goalCompletionRate: 'goalCompletionRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GaKpiMonthlyScalarFieldEnum = (typeof GaKpiMonthlyScalarFieldEnum)[keyof typeof GaKpiMonthlyScalarFieldEnum]


  export const GaChannelDailyScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    date: 'date',
    channelGroup: 'channelGroup',
    sessions: 'sessions',
    screenPageViewsPerSession: 'screenPageViewsPerSession',
    engagementRate: 'engagementRate',
    avgSessionDurationSec: 'avgSessionDurationSec',
    goalCompletions: 'goalCompletions',
    goalCompletionRate: 'goalCompletionRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GaChannelDailyScalarFieldEnum = (typeof GaChannelDailyScalarFieldEnum)[keyof typeof GaChannelDailyScalarFieldEnum]


  export const GaSourceDailyScalarFieldEnum: {
    id: 'id',
    gaPropertyId: 'gaPropertyId',
    date: 'date',
    trafficSource: 'trafficSource',
    sessions: 'sessions',
    screenPageViewsPerSession: 'screenPageViewsPerSession',
    engagementRate: 'engagementRate',
    avgSessionDurationSec: 'avgSessionDurationSec',
    goalCompletions: 'goalCompletions',
    goalCompletionRate: 'goalCompletionRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GaSourceDailyScalarFieldEnum = (typeof GaSourceDailyScalarFieldEnum)[keyof typeof GaSourceDailyScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expires: 'expires',
    sessionToken: 'sessionToken'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    senderId: 'senderId',
    recipientId: 'recipientId',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    archived: 'archived',
    isThreadStart: 'isThreadStart',
    parentId: 'parentId',
    threadId: 'threadId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ParsedPieGraphDataScalarFieldEnum: {
    id: 'id',
    queryId: 'queryId',
    channel: 'channel',
    source: 'source',
    sessions: 'sessions',
    conversionRate: 'conversionRate',
    conversions: 'conversions',
    bounces: 'bounces',
    prevSessionsDiff: 'prevSessionsDiff',
    prevConversionRateDiff: 'prevConversionRateDiff',
    prevConversionsDiff: 'prevConversionsDiff',
    prevBouncesDiff: 'prevBouncesDiff',
    yearSessionsDiff: 'yearSessionsDiff',
    yearConversionRateDiff: 'yearConversionRateDiff',
    yearConversionsDiff: 'yearConversionsDiff',
    yearBouncesDiff: 'yearBouncesDiff',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParsedPieGraphDataScalarFieldEnum = (typeof ParsedPieGraphDataScalarFieldEnum)[keyof typeof ParsedPieGraphDataScalarFieldEnum]


  export const ParsedQueryDataScalarFieldEnum: {
    id: 'id',
    queryId: 'queryId',
    date: 'date',
    channel: 'channel',
    source: 'source',
    sessions: 'sessions',
    conversionRate: 'conversionRate',
    conversions: 'conversions',
    bounces: 'bounces',
    createdAt: 'createdAt',
    bounceRate: 'bounceRate',
    engagedSessions: 'engagedSessions',
    newUsers: 'newUsers'
  };

  export type ParsedQueryDataScalarFieldEnum = (typeof ParsedQueryDataScalarFieldEnum)[keyof typeof ParsedQueryDataScalarFieldEnum]


  export const ParsedQuerySummaryScalarFieldEnum: {
    id: 'id',
    queryId: 'queryId',
    date: 'date',
    totalEngagedSessions: 'totalEngagedSessions',
    averageBounceRate: 'averageBounceRate',
    totalNewUsers: 'totalNewUsers',
    totalConversions: 'totalConversions',
    createdAt: 'createdAt'
  };

  export type ParsedQuerySummaryScalarFieldEnum = (typeof ParsedQuerySummaryScalarFieldEnum)[keyof typeof ParsedQuerySummaryScalarFieldEnum]


  export const QueryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    response: 'response',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    content: 'content',
    status: 'status',
    conversationId: 'conversationId',
    rating: 'rating',
    metadata: 'metadata',
    lineGraphData: 'lineGraphData',
    pieGraphData: 'pieGraphData'
  };

  export type QueryScalarFieldEnum = (typeof QueryScalarFieldEnum)[keyof typeof QueryScalarFieldEnum]


  export const SproutFacebookAnalyticsScalarFieldEnum: {
    id: 'id',
    sproutSocialAccountId: 'sproutSocialAccountId',
    customerProfileId: 'customerProfileId',
    reportingDate: 'reportingDate',
    engagements: 'engagements',
    impressions: 'impressions',
    impressionsUnique: 'impressionsUnique',
    followersCount: 'followersCount',
    postContentClicks: 'postContentClicks',
    postContentClicksOther: 'postContentClicksOther',
    postLinkClicks: 'postLinkClicks',
    postPhotoViewClicks: 'postPhotoViewClicks',
    tabViews: 'tabViews',
    videoViews: 'videoViews',
    videoViews10s: 'videoViews10s',
    videoViewsOrganic: 'videoViewsOrganic',
    videoViewsPaid: 'videoViewsPaid',
    videoViewsUnique: 'videoViewsUnique',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    netFollowerGrowth: 'netFollowerGrowth'
  };

  export type SproutFacebookAnalyticsScalarFieldEnum = (typeof SproutFacebookAnalyticsScalarFieldEnum)[keyof typeof SproutFacebookAnalyticsScalarFieldEnum]


  export const SproutFacebookPostScalarFieldEnum: {
    id: 'id',
    sproutSocialAccountId: 'sproutSocialAccountId',
    postType: 'postType',
    postStatus: 'postStatus',
    postLink: 'postLink',
    postText: 'postText',
    postNativeId: 'postNativeId',
    postCreatedTime: 'postCreatedTime',
    postSentTime: 'postSentTime',
    postLastUpdated: 'postLastUpdated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SproutFacebookPostScalarFieldEnum = (typeof SproutFacebookPostScalarFieldEnum)[keyof typeof SproutFacebookPostScalarFieldEnum]


  export const SproutFacebookPostAnalyticsScalarFieldEnum: {
    id: 'id',
    angryReactions: 'angryReactions',
    clientNativeId: 'clientNativeId',
    commentsCount: 'commentsCount',
    hahaReactions: 'hahaReactions',
    impressions: 'impressions',
    impressionsFollower: 'impressionsFollower',
    impressionsNonFollower: 'impressionsNonFollower',
    impressionsNonViral: 'impressionsNonViral',
    impressionsOrganic: 'impressionsOrganic',
    impressionsPaid: 'impressionsPaid',
    impressionsViral: 'impressionsViral',
    likes: 'likes',
    loveReactions: 'loveReactions',
    postContentClicks: 'postContentClicks',
    postContentClicksOther: 'postContentClicksOther',
    postLinkClicks: 'postLinkClicks',
    postNativeId: 'postNativeId',
    postPhotoViewClicks: 'postPhotoViewClicks',
    postVideoPlayClicks: 'postVideoPlayClicks',
    questionAnswers: 'questionAnswers',
    reach: 'reach',
    reachFollower: 'reachFollower',
    reachNonViral: 'reachNonViral',
    reachOrganic: 'reachOrganic',
    reachPaid: 'reachPaid',
    reachViral: 'reachViral',
    reactions: 'reactions',
    reportingDate: 'reportingDate',
    sadReactions: 'sadReactions',
    sharesCount: 'sharesCount',
    sproutSocialAccountId: 'sproutSocialAccountId',
    videoLength: 'videoLength',
    videoViews: 'videoViews',
    videoViewsAutoplay: 'videoViewsAutoplay',
    videoViewsOrganic: 'videoViewsOrganic',
    videoViewsPaid: 'videoViewsPaid',
    wowReactions: 'wowReactions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SproutFacebookPostAnalyticsScalarFieldEnum = (typeof SproutFacebookPostAnalyticsScalarFieldEnum)[keyof typeof SproutFacebookPostAnalyticsScalarFieldEnum]


  export const SproutInstagramAnalyticsScalarFieldEnum: {
    id: 'id',
    sproutSocialAccountId: 'sproutSocialAccountId',
    customerProfileId: 'customerProfileId',
    reportingDate: 'reportingDate',
    commentsCount: 'commentsCount',
    engagements: 'engagements',
    impressions: 'impressions',
    impressionsUnique: 'impressionsUnique',
    followersCount: 'followersCount',
    likes: 'likes',
    saves: 'saves',
    videoViews: 'videoViews',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    emailContacts: 'emailContacts',
    getDirectionsClicks: 'getDirectionsClicks',
    phoneCallClicks: 'phoneCallClicks',
    postsSendByContentType: 'postsSendByContentType',
    postsSentByPostType: 'postsSentByPostType',
    postsSentCount: 'postsSentCount',
    profileFollowerAdds: 'profileFollowerAdds',
    profileFollowers: 'profileFollowers',
    profileImpressionsUnique: 'profileImpressionsUnique',
    profileReachUnique: 'profileReachUnique',
    profileViews: 'profileViews',
    profileViewsUnique: 'profileViewsUnique',
    websiteClicks: 'websiteClicks'
  };

  export type SproutInstagramAnalyticsScalarFieldEnum = (typeof SproutInstagramAnalyticsScalarFieldEnum)[keyof typeof SproutInstagramAnalyticsScalarFieldEnum]


  export const SproutInstagramFollowersByCityScalarFieldEnum: {
    id: 'id',
    sproutInstagramAnalyticsId: 'sproutInstagramAnalyticsId',
    city: 'city',
    count: 'count',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SproutInstagramFollowersByCityScalarFieldEnum = (typeof SproutInstagramFollowersByCityScalarFieldEnum)[keyof typeof SproutInstagramFollowersByCityScalarFieldEnum]


  export const SproutInstagramFollowersByCountryScalarFieldEnum: {
    id: 'id',
    sproutInstagramAnalyticsId: 'sproutInstagramAnalyticsId',
    country: 'country',
    count: 'count',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SproutInstagramFollowersByCountryScalarFieldEnum = (typeof SproutInstagramFollowersByCountryScalarFieldEnum)[keyof typeof SproutInstagramFollowersByCountryScalarFieldEnum]


  export const SproutLinkedInAnalyticsScalarFieldEnum: {
    id: 'id',
    sproutSocialAccountId: 'sproutSocialAccountId',
    customerProfileId: 'customerProfileId',
    reportingDate: 'reportingDate',
    engagements: 'engagements',
    impressions: 'impressions',
    impressionsUnique: 'impressionsUnique',
    followersCount: 'followersCount',
    reactions: 'reactions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SproutLinkedInAnalyticsScalarFieldEnum = (typeof SproutLinkedInAnalyticsScalarFieldEnum)[keyof typeof SproutLinkedInAnalyticsScalarFieldEnum]


  export const SproutPinterestAnalyticsScalarFieldEnum: {
    id: 'id',
    sproutSocialAccountId: 'sproutSocialAccountId',
    customerProfileId: 'customerProfileId',
    reportingDate: 'reportingDate',
    followersCount: 'followersCount',
    followingCount: 'followingCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SproutPinterestAnalyticsScalarFieldEnum = (typeof SproutPinterestAnalyticsScalarFieldEnum)[keyof typeof SproutPinterestAnalyticsScalarFieldEnum]


  export const SproutSocialAccountScalarFieldEnum: {
    id: 'id',
    customerProfileId: 'customerProfileId',
    networkType: 'networkType',
    name: 'name',
    nativeName: 'nativeName',
    link: 'link',
    nativeId: 'nativeId',
    groups: 'groups',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SproutSocialAccountScalarFieldEnum = (typeof SproutSocialAccountScalarFieldEnum)[keyof typeof SproutSocialAccountScalarFieldEnum]


  export const UserToSproutSocialAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sproutSocialAccountId: 'sproutSocialAccountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserToSproutSocialAccountScalarFieldEnum = (typeof UserToSproutSocialAccountScalarFieldEnum)[keyof typeof UserToSproutSocialAccountScalarFieldEnum]


  export const UserToGaAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gaAccountId: 'gaAccountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserToGaAccountScalarFieldEnum = (typeof UserToGaAccountScalarFieldEnum)[keyof typeof UserToGaAccountScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    roleId: 'roleId',
    emailVerified: 'emailVerified',
    image: 'image',
    name: 'name',
    accountRepId: 'accountRepId',
    isActive: 'isActive',
    password: 'password',
    deleted: 'deleted',
    companyId: 'companyId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailNotifications: 'emailNotifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    theme: 'theme',
    apiCredits: 'apiCredits',
    apiCreditsLimit: 'apiCreditsLimit'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedToId: 'assignedToId',
    clientId: 'clientId'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketAttachmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    createdAt: 'createdAt',
    ticketId: 'ticketId'
  };

  export type TicketAttachmentScalarFieldEnum = (typeof TicketAttachmentScalarFieldEnum)[keyof typeof TicketAttachmentScalarFieldEnum]


  export const TicketCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ticketId: 'ticketId',
    authorId: 'authorId'
  };

  export type TicketCommentScalarFieldEnum = (typeof TicketCommentScalarFieldEnum)[keyof typeof TicketCommentScalarFieldEnum]


  export const TicketTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type TicketTagScalarFieldEnum = (typeof TicketTagScalarFieldEnum)[keyof typeof TicketTagScalarFieldEnum]


  export const MessageAttachmentScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    url: 'url',
    createdAt: 'createdAt',
    messageId: 'messageId'
  };

  export type MessageAttachmentScalarFieldEnum = (typeof MessageAttachmentScalarFieldEnum)[keyof typeof MessageAttachmentScalarFieldEnum]


  export const ClientActivityScalarFieldEnum: {
    id: 'id',
    type: 'type',
    description: 'description',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type ClientActivityScalarFieldEnum = (typeof ClientActivityScalarFieldEnum)[keyof typeof ClientActivityScalarFieldEnum]


  export const UserToEmailClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailClientId: 'emailClientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserToEmailClientScalarFieldEnum = (typeof UserToEmailClientScalarFieldEnum)[keyof typeof UserToEmailClientScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ImportStatus'
   */
  export type EnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus'>
    


  /**
   * Reference to a field of type 'ImportStatus[]'
   */
  export type ListEnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'QueryStatus'
   */
  export type EnumQueryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryStatus'>
    


  /**
   * Reference to a field of type 'QueryStatus[]'
   */
  export type ListEnumQueryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'TicketPriority[]'
   */
  export type ListEnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority[]'>
    


  /**
   * Reference to a field of type 'ActivityStatus'
   */
  export type EnumActivityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityStatus'>
    


  /**
   * Reference to a field of type 'ActivityStatus[]'
   */
  export type ListEnumActivityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type ClientSatisfactionWhereInput = {
    AND?: ClientSatisfactionWhereInput | ClientSatisfactionWhereInput[]
    OR?: ClientSatisfactionWhereInput[]
    NOT?: ClientSatisfactionWhereInput | ClientSatisfactionWhereInput[]
    id?: StringFilter<"ClientSatisfaction"> | string
    rating?: FloatFilter<"ClientSatisfaction"> | number
    feedback?: StringNullableFilter<"ClientSatisfaction"> | string | null
    userId?: StringFilter<"ClientSatisfaction"> | string
    accountRepId?: StringFilter<"ClientSatisfaction"> | string
    createdAt?: DateTimeFilter<"ClientSatisfaction"> | Date | string
    accountRep?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClientSatisfactionOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    userId?: SortOrder
    accountRepId?: SortOrder
    createdAt?: SortOrder
    accountRep?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ClientSatisfactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientSatisfactionWhereInput | ClientSatisfactionWhereInput[]
    OR?: ClientSatisfactionWhereInput[]
    NOT?: ClientSatisfactionWhereInput | ClientSatisfactionWhereInput[]
    rating?: FloatFilter<"ClientSatisfaction"> | number
    feedback?: StringNullableFilter<"ClientSatisfaction"> | string | null
    userId?: StringFilter<"ClientSatisfaction"> | string
    accountRepId?: StringFilter<"ClientSatisfaction"> | string
    createdAt?: DateTimeFilter<"ClientSatisfaction"> | Date | string
    accountRep?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ClientSatisfactionOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    userId?: SortOrder
    accountRepId?: SortOrder
    createdAt?: SortOrder
    _count?: ClientSatisfactionCountOrderByAggregateInput
    _avg?: ClientSatisfactionAvgOrderByAggregateInput
    _max?: ClientSatisfactionMaxOrderByAggregateInput
    _min?: ClientSatisfactionMinOrderByAggregateInput
    _sum?: ClientSatisfactionSumOrderByAggregateInput
  }

  export type ClientSatisfactionScalarWhereWithAggregatesInput = {
    AND?: ClientSatisfactionScalarWhereWithAggregatesInput | ClientSatisfactionScalarWhereWithAggregatesInput[]
    OR?: ClientSatisfactionScalarWhereWithAggregatesInput[]
    NOT?: ClientSatisfactionScalarWhereWithAggregatesInput | ClientSatisfactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientSatisfaction"> | string
    rating?: FloatWithAggregatesFilter<"ClientSatisfaction"> | number
    feedback?: StringNullableWithAggregatesFilter<"ClientSatisfaction"> | string | null
    userId?: StringWithAggregatesFilter<"ClientSatisfaction"> | string
    accountRepId?: StringWithAggregatesFilter<"ClientSatisfaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClientSatisfaction"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    isStarred?: BoolFilter<"Conversation"> | boolean
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    userId?: StringFilter<"Conversation"> | string
    description?: StringNullableFilter<"Conversation"> | string | null
    gaAccountId?: StringNullableFilter<"Conversation"> | string | null
    gaPropertyId?: StringNullableFilter<"Conversation"> | string | null
    clientId?: StringNullableFilter<"Conversation"> | string | null
    client?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    gaAccount?: XOR<GaAccountNullableScalarRelationFilter, GaAccountWhereInput> | null
    gaProperty?: XOR<GaPropertyNullableScalarRelationFilter, GaPropertyWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    queries?: QueryListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    isStarred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    description?: SortOrderInput | SortOrder
    gaAccountId?: SortOrderInput | SortOrder
    gaPropertyId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    client?: UserOrderByWithRelationInput
    gaAccount?: GaAccountOrderByWithRelationInput
    gaProperty?: GaPropertyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    queries?: QueryOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    title?: StringFilter<"Conversation"> | string
    isStarred?: BoolFilter<"Conversation"> | boolean
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    userId?: StringFilter<"Conversation"> | string
    description?: StringNullableFilter<"Conversation"> | string | null
    gaAccountId?: StringNullableFilter<"Conversation"> | string | null
    gaPropertyId?: StringNullableFilter<"Conversation"> | string | null
    clientId?: StringNullableFilter<"Conversation"> | string | null
    client?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    gaAccount?: XOR<GaAccountNullableScalarRelationFilter, GaAccountWhereInput> | null
    gaProperty?: XOR<GaPropertyNullableScalarRelationFilter, GaPropertyWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    queries?: QueryListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    isStarred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    description?: SortOrderInput | SortOrder
    gaAccountId?: SortOrderInput | SortOrder
    gaPropertyId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    title?: StringWithAggregatesFilter<"Conversation"> | string
    isStarred?: BoolWithAggregatesFilter<"Conversation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    userId?: StringWithAggregatesFilter<"Conversation"> | string
    description?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    gaAccountId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    gaPropertyId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
  }

  export type EmailCampaignWhereInput = {
    AND?: EmailCampaignWhereInput | EmailCampaignWhereInput[]
    OR?: EmailCampaignWhereInput[]
    NOT?: EmailCampaignWhereInput | EmailCampaignWhereInput[]
    id?: StringFilter<"EmailCampaign"> | string
    createdAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    campaignId?: StringFilter<"EmailCampaign"> | string
    campaignName?: StringFilter<"EmailCampaign"> | string
    emailClientId?: StringFilter<"EmailCampaign"> | string
    emailClient?: XOR<EmailClientScalarRelationFilter, EmailClientWhereInput>
    emailCampaignContents?: XOR<EmailCampaignContentNullableScalarRelationFilter, EmailCampaignContentWhereInput> | null
    emailCampaignDailyStats?: EmailCampaignDailyStatsListRelationFilter
  }

  export type EmailCampaignOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    campaignName?: SortOrder
    emailClientId?: SortOrder
    emailClient?: EmailClientOrderByWithRelationInput
    emailCampaignContents?: EmailCampaignContentOrderByWithRelationInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsOrderByRelationAggregateInput
  }

  export type EmailCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId?: string
    AND?: EmailCampaignWhereInput | EmailCampaignWhereInput[]
    OR?: EmailCampaignWhereInput[]
    NOT?: EmailCampaignWhereInput | EmailCampaignWhereInput[]
    createdAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    campaignName?: StringFilter<"EmailCampaign"> | string
    emailClientId?: StringFilter<"EmailCampaign"> | string
    emailClient?: XOR<EmailClientScalarRelationFilter, EmailClientWhereInput>
    emailCampaignContents?: XOR<EmailCampaignContentNullableScalarRelationFilter, EmailCampaignContentWhereInput> | null
    emailCampaignDailyStats?: EmailCampaignDailyStatsListRelationFilter
  }, "id" | "campaignId">

  export type EmailCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    campaignName?: SortOrder
    emailClientId?: SortOrder
    _count?: EmailCampaignCountOrderByAggregateInput
    _max?: EmailCampaignMaxOrderByAggregateInput
    _min?: EmailCampaignMinOrderByAggregateInput
  }

  export type EmailCampaignScalarWhereWithAggregatesInput = {
    AND?: EmailCampaignScalarWhereWithAggregatesInput | EmailCampaignScalarWhereWithAggregatesInput[]
    OR?: EmailCampaignScalarWhereWithAggregatesInput[]
    NOT?: EmailCampaignScalarWhereWithAggregatesInput | EmailCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailCampaign"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailCampaign"> | Date | string
    campaignId?: StringWithAggregatesFilter<"EmailCampaign"> | string
    campaignName?: StringWithAggregatesFilter<"EmailCampaign"> | string
    emailClientId?: StringWithAggregatesFilter<"EmailCampaign"> | string
  }

  export type EmailCampaignContentWhereInput = {
    AND?: EmailCampaignContentWhereInput | EmailCampaignContentWhereInput[]
    OR?: EmailCampaignContentWhereInput[]
    NOT?: EmailCampaignContentWhereInput | EmailCampaignContentWhereInput[]
    id?: StringFilter<"EmailCampaignContent"> | string
    subject?: StringFilter<"EmailCampaignContent"> | string
    type?: StringFilter<"EmailCampaignContent"> | string
    recipients?: IntFilter<"EmailCampaignContent"> | number
    createdAt?: DateTimeFilter<"EmailCampaignContent"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCampaignContent"> | Date | string
    contentType?: StringFilter<"EmailCampaignContent"> | string
    createTime?: DateTimeFilter<"EmailCampaignContent"> | Date | string
    emailCampaignId?: StringFilter<"EmailCampaignContent"> | string
    htmlContent?: StringFilter<"EmailCampaignContent"> | string
    plainContent?: StringFilter<"EmailCampaignContent"> | string
    sendTime?: DateTimeFilter<"EmailCampaignContent"> | Date | string
    webId?: StringFilter<"EmailCampaignContent"> | string
    emailCampaign?: XOR<EmailCampaignScalarRelationFilter, EmailCampaignWhereInput>
  }

  export type EmailCampaignContentOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrder
    type?: SortOrder
    recipients?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contentType?: SortOrder
    createTime?: SortOrder
    emailCampaignId?: SortOrder
    htmlContent?: SortOrder
    plainContent?: SortOrder
    sendTime?: SortOrder
    webId?: SortOrder
    emailCampaign?: EmailCampaignOrderByWithRelationInput
  }

  export type EmailCampaignContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    emailCampaignId?: string
    AND?: EmailCampaignContentWhereInput | EmailCampaignContentWhereInput[]
    OR?: EmailCampaignContentWhereInput[]
    NOT?: EmailCampaignContentWhereInput | EmailCampaignContentWhereInput[]
    subject?: StringFilter<"EmailCampaignContent"> | string
    type?: StringFilter<"EmailCampaignContent"> | string
    recipients?: IntFilter<"EmailCampaignContent"> | number
    createdAt?: DateTimeFilter<"EmailCampaignContent"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCampaignContent"> | Date | string
    contentType?: StringFilter<"EmailCampaignContent"> | string
    createTime?: DateTimeFilter<"EmailCampaignContent"> | Date | string
    htmlContent?: StringFilter<"EmailCampaignContent"> | string
    plainContent?: StringFilter<"EmailCampaignContent"> | string
    sendTime?: DateTimeFilter<"EmailCampaignContent"> | Date | string
    webId?: StringFilter<"EmailCampaignContent"> | string
    emailCampaign?: XOR<EmailCampaignScalarRelationFilter, EmailCampaignWhereInput>
  }, "id" | "emailCampaignId">

  export type EmailCampaignContentOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrder
    type?: SortOrder
    recipients?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contentType?: SortOrder
    createTime?: SortOrder
    emailCampaignId?: SortOrder
    htmlContent?: SortOrder
    plainContent?: SortOrder
    sendTime?: SortOrder
    webId?: SortOrder
    _count?: EmailCampaignContentCountOrderByAggregateInput
    _avg?: EmailCampaignContentAvgOrderByAggregateInput
    _max?: EmailCampaignContentMaxOrderByAggregateInput
    _min?: EmailCampaignContentMinOrderByAggregateInput
    _sum?: EmailCampaignContentSumOrderByAggregateInput
  }

  export type EmailCampaignContentScalarWhereWithAggregatesInput = {
    AND?: EmailCampaignContentScalarWhereWithAggregatesInput | EmailCampaignContentScalarWhereWithAggregatesInput[]
    OR?: EmailCampaignContentScalarWhereWithAggregatesInput[]
    NOT?: EmailCampaignContentScalarWhereWithAggregatesInput | EmailCampaignContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailCampaignContent"> | string
    subject?: StringWithAggregatesFilter<"EmailCampaignContent"> | string
    type?: StringWithAggregatesFilter<"EmailCampaignContent"> | string
    recipients?: IntWithAggregatesFilter<"EmailCampaignContent"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EmailCampaignContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailCampaignContent"> | Date | string
    contentType?: StringWithAggregatesFilter<"EmailCampaignContent"> | string
    createTime?: DateTimeWithAggregatesFilter<"EmailCampaignContent"> | Date | string
    emailCampaignId?: StringWithAggregatesFilter<"EmailCampaignContent"> | string
    htmlContent?: StringWithAggregatesFilter<"EmailCampaignContent"> | string
    plainContent?: StringWithAggregatesFilter<"EmailCampaignContent"> | string
    sendTime?: DateTimeWithAggregatesFilter<"EmailCampaignContent"> | Date | string
    webId?: StringWithAggregatesFilter<"EmailCampaignContent"> | string
  }

  export type EmailCampaignDailyStatsWhereInput = {
    AND?: EmailCampaignDailyStatsWhereInput | EmailCampaignDailyStatsWhereInput[]
    OR?: EmailCampaignDailyStatsWhereInput[]
    NOT?: EmailCampaignDailyStatsWhereInput | EmailCampaignDailyStatsWhereInput[]
    id?: StringFilter<"EmailCampaignDailyStats"> | string
    date?: DateTimeFilter<"EmailCampaignDailyStats"> | Date | string
    opens?: IntFilter<"EmailCampaignDailyStats"> | number
    clicks?: IntFilter<"EmailCampaignDailyStats"> | number
    bounces?: IntFilter<"EmailCampaignDailyStats"> | number
    unsubscribes?: IntFilter<"EmailCampaignDailyStats"> | number
    variation?: StringFilter<"EmailCampaignDailyStats"> | string
    phase?: StringFilter<"EmailCampaignDailyStats"> | string
    requests?: IntFilter<"EmailCampaignDailyStats"> | number
    delivered?: IntFilter<"EmailCampaignDailyStats"> | number
    createdAt?: DateTimeFilter<"EmailCampaignDailyStats"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCampaignDailyStats"> | Date | string
    bounceDrops?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeBounceRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeSpamReportsRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeTotalClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeTotalOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeUniqueClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeUniqueOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeUnsubscribeRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyBounceRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailySpamReportsRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyTotalClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyTotalClickToOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyTotalOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueClickToOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUnsubscribeRate?: IntFilter<"EmailCampaignDailyStats"> | number
    emailCampaignId?: StringFilter<"EmailCampaignDailyStats"> | string
    emailClientId?: StringFilter<"EmailCampaignDailyStats"> | string
    singleSendName?: StringFilter<"EmailCampaignDailyStats"> | string
    spamReportDrops?: IntFilter<"EmailCampaignDailyStats"> | number
    spamReports?: IntFilter<"EmailCampaignDailyStats"> | number
    totalClicks?: IntFilter<"EmailCampaignDailyStats"> | number
    totalOpens?: IntFilter<"EmailCampaignDailyStats"> | number
    uniqueClicks?: IntFilter<"EmailCampaignDailyStats"> | number
    uniqueOpens?: IntFilter<"EmailCampaignDailyStats"> | number
    emailCampaign?: XOR<EmailCampaignScalarRelationFilter, EmailCampaignWhereInput>
    emailClient?: XOR<EmailClientScalarRelationFilter, EmailClientWhereInput>
  }

  export type EmailCampaignDailyStatsOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    opens?: SortOrder
    clicks?: SortOrder
    bounces?: SortOrder
    unsubscribes?: SortOrder
    variation?: SortOrder
    phase?: SortOrder
    requests?: SortOrder
    delivered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bounceDrops?: SortOrder
    cumulativeBounceRate?: SortOrder
    cumulativeSpamReportsRate?: SortOrder
    cumulativeTotalClickRate?: SortOrder
    cumulativeTotalOpenRate?: SortOrder
    cumulativeUniqueClickRate?: SortOrder
    cumulativeUniqueOpenRate?: SortOrder
    cumulativeUnsubscribeRate?: SortOrder
    dailyBounceRate?: SortOrder
    dailySpamReportsRate?: SortOrder
    dailyTotalClickRate?: SortOrder
    dailyTotalClickToOpenRate?: SortOrder
    dailyTotalOpenRate?: SortOrder
    dailyUniqueClickRate?: SortOrder
    dailyUniqueClickToOpenRate?: SortOrder
    dailyUniqueOpenRate?: SortOrder
    dailyUnsubscribeRate?: SortOrder
    emailCampaignId?: SortOrder
    emailClientId?: SortOrder
    singleSendName?: SortOrder
    spamReportDrops?: SortOrder
    spamReports?: SortOrder
    totalClicks?: SortOrder
    totalOpens?: SortOrder
    uniqueClicks?: SortOrder
    uniqueOpens?: SortOrder
    emailCampaign?: EmailCampaignOrderByWithRelationInput
    emailClient?: EmailClientOrderByWithRelationInput
  }

  export type EmailCampaignDailyStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    emailCampaignId_date?: EmailCampaignDailyStatsEmailCampaignIdDateCompoundUniqueInput
    AND?: EmailCampaignDailyStatsWhereInput | EmailCampaignDailyStatsWhereInput[]
    OR?: EmailCampaignDailyStatsWhereInput[]
    NOT?: EmailCampaignDailyStatsWhereInput | EmailCampaignDailyStatsWhereInput[]
    date?: DateTimeFilter<"EmailCampaignDailyStats"> | Date | string
    opens?: IntFilter<"EmailCampaignDailyStats"> | number
    clicks?: IntFilter<"EmailCampaignDailyStats"> | number
    bounces?: IntFilter<"EmailCampaignDailyStats"> | number
    unsubscribes?: IntFilter<"EmailCampaignDailyStats"> | number
    variation?: StringFilter<"EmailCampaignDailyStats"> | string
    phase?: StringFilter<"EmailCampaignDailyStats"> | string
    requests?: IntFilter<"EmailCampaignDailyStats"> | number
    delivered?: IntFilter<"EmailCampaignDailyStats"> | number
    createdAt?: DateTimeFilter<"EmailCampaignDailyStats"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCampaignDailyStats"> | Date | string
    bounceDrops?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeBounceRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeSpamReportsRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeTotalClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeTotalOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeUniqueClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeUniqueOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeUnsubscribeRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyBounceRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailySpamReportsRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyTotalClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyTotalClickToOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyTotalOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueClickToOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUnsubscribeRate?: IntFilter<"EmailCampaignDailyStats"> | number
    emailCampaignId?: StringFilter<"EmailCampaignDailyStats"> | string
    emailClientId?: StringFilter<"EmailCampaignDailyStats"> | string
    singleSendName?: StringFilter<"EmailCampaignDailyStats"> | string
    spamReportDrops?: IntFilter<"EmailCampaignDailyStats"> | number
    spamReports?: IntFilter<"EmailCampaignDailyStats"> | number
    totalClicks?: IntFilter<"EmailCampaignDailyStats"> | number
    totalOpens?: IntFilter<"EmailCampaignDailyStats"> | number
    uniqueClicks?: IntFilter<"EmailCampaignDailyStats"> | number
    uniqueOpens?: IntFilter<"EmailCampaignDailyStats"> | number
    emailCampaign?: XOR<EmailCampaignScalarRelationFilter, EmailCampaignWhereInput>
    emailClient?: XOR<EmailClientScalarRelationFilter, EmailClientWhereInput>
  }, "id" | "emailCampaignId_date">

  export type EmailCampaignDailyStatsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    opens?: SortOrder
    clicks?: SortOrder
    bounces?: SortOrder
    unsubscribes?: SortOrder
    variation?: SortOrder
    phase?: SortOrder
    requests?: SortOrder
    delivered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bounceDrops?: SortOrder
    cumulativeBounceRate?: SortOrder
    cumulativeSpamReportsRate?: SortOrder
    cumulativeTotalClickRate?: SortOrder
    cumulativeTotalOpenRate?: SortOrder
    cumulativeUniqueClickRate?: SortOrder
    cumulativeUniqueOpenRate?: SortOrder
    cumulativeUnsubscribeRate?: SortOrder
    dailyBounceRate?: SortOrder
    dailySpamReportsRate?: SortOrder
    dailyTotalClickRate?: SortOrder
    dailyTotalClickToOpenRate?: SortOrder
    dailyTotalOpenRate?: SortOrder
    dailyUniqueClickRate?: SortOrder
    dailyUniqueClickToOpenRate?: SortOrder
    dailyUniqueOpenRate?: SortOrder
    dailyUnsubscribeRate?: SortOrder
    emailCampaignId?: SortOrder
    emailClientId?: SortOrder
    singleSendName?: SortOrder
    spamReportDrops?: SortOrder
    spamReports?: SortOrder
    totalClicks?: SortOrder
    totalOpens?: SortOrder
    uniqueClicks?: SortOrder
    uniqueOpens?: SortOrder
    _count?: EmailCampaignDailyStatsCountOrderByAggregateInput
    _avg?: EmailCampaignDailyStatsAvgOrderByAggregateInput
    _max?: EmailCampaignDailyStatsMaxOrderByAggregateInput
    _min?: EmailCampaignDailyStatsMinOrderByAggregateInput
    _sum?: EmailCampaignDailyStatsSumOrderByAggregateInput
  }

  export type EmailCampaignDailyStatsScalarWhereWithAggregatesInput = {
    AND?: EmailCampaignDailyStatsScalarWhereWithAggregatesInput | EmailCampaignDailyStatsScalarWhereWithAggregatesInput[]
    OR?: EmailCampaignDailyStatsScalarWhereWithAggregatesInput[]
    NOT?: EmailCampaignDailyStatsScalarWhereWithAggregatesInput | EmailCampaignDailyStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailCampaignDailyStats"> | string
    date?: DateTimeWithAggregatesFilter<"EmailCampaignDailyStats"> | Date | string
    opens?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    clicks?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    bounces?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    unsubscribes?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    variation?: StringWithAggregatesFilter<"EmailCampaignDailyStats"> | string
    phase?: StringWithAggregatesFilter<"EmailCampaignDailyStats"> | string
    requests?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    delivered?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EmailCampaignDailyStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailCampaignDailyStats"> | Date | string
    bounceDrops?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    cumulativeBounceRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    cumulativeSpamReportsRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    cumulativeTotalClickRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    cumulativeTotalOpenRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    cumulativeUniqueClickRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    cumulativeUniqueOpenRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    cumulativeUnsubscribeRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    dailyBounceRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    dailySpamReportsRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    dailyTotalClickRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    dailyTotalClickToOpenRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    dailyTotalOpenRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueClickRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueClickToOpenRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueOpenRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    dailyUnsubscribeRate?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    emailCampaignId?: StringWithAggregatesFilter<"EmailCampaignDailyStats"> | string
    emailClientId?: StringWithAggregatesFilter<"EmailCampaignDailyStats"> | string
    singleSendName?: StringWithAggregatesFilter<"EmailCampaignDailyStats"> | string
    spamReportDrops?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    spamReports?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    totalClicks?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    totalOpens?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    uniqueClicks?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
    uniqueOpens?: IntWithAggregatesFilter<"EmailCampaignDailyStats"> | number
  }

  export type EmailClientWhereInput = {
    AND?: EmailClientWhereInput | EmailClientWhereInput[]
    OR?: EmailClientWhereInput[]
    NOT?: EmailClientWhereInput | EmailClientWhereInput[]
    id?: StringFilter<"EmailClient"> | string
    createdAt?: DateTimeFilter<"EmailClient"> | Date | string
    updatedAt?: DateTimeFilter<"EmailClient"> | Date | string
    clientName?: StringFilter<"EmailClient"> | string
    emailCampaigns?: EmailCampaignListRelationFilter
    emailCampaignDailyStats?: EmailCampaignDailyStatsListRelationFilter
    emailClientCredentials?: EmailClientCredentialsListRelationFilter
    emailGlobalDailyStats?: EmailGlobalDailyStatsListRelationFilter
    users?: UserToEmailClientListRelationFilter
  }

  export type EmailClientOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientName?: SortOrder
    emailCampaigns?: EmailCampaignOrderByRelationAggregateInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsOrderByRelationAggregateInput
    emailClientCredentials?: EmailClientCredentialsOrderByRelationAggregateInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsOrderByRelationAggregateInput
    users?: UserToEmailClientOrderByRelationAggregateInput
  }

  export type EmailClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailClientWhereInput | EmailClientWhereInput[]
    OR?: EmailClientWhereInput[]
    NOT?: EmailClientWhereInput | EmailClientWhereInput[]
    createdAt?: DateTimeFilter<"EmailClient"> | Date | string
    updatedAt?: DateTimeFilter<"EmailClient"> | Date | string
    clientName?: StringFilter<"EmailClient"> | string
    emailCampaigns?: EmailCampaignListRelationFilter
    emailCampaignDailyStats?: EmailCampaignDailyStatsListRelationFilter
    emailClientCredentials?: EmailClientCredentialsListRelationFilter
    emailGlobalDailyStats?: EmailGlobalDailyStatsListRelationFilter
    users?: UserToEmailClientListRelationFilter
  }, "id">

  export type EmailClientOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientName?: SortOrder
    _count?: EmailClientCountOrderByAggregateInput
    _max?: EmailClientMaxOrderByAggregateInput
    _min?: EmailClientMinOrderByAggregateInput
  }

  export type EmailClientScalarWhereWithAggregatesInput = {
    AND?: EmailClientScalarWhereWithAggregatesInput | EmailClientScalarWhereWithAggregatesInput[]
    OR?: EmailClientScalarWhereWithAggregatesInput[]
    NOT?: EmailClientScalarWhereWithAggregatesInput | EmailClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailClient"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailClient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailClient"> | Date | string
    clientName?: StringWithAggregatesFilter<"EmailClient"> | string
  }

  export type EmailClientCredentialsWhereInput = {
    AND?: EmailClientCredentialsWhereInput | EmailClientCredentialsWhereInput[]
    OR?: EmailClientCredentialsWhereInput[]
    NOT?: EmailClientCredentialsWhereInput | EmailClientCredentialsWhereInput[]
    id?: StringFilter<"EmailClientCredentials"> | string
    createdAt?: DateTimeFilter<"EmailClientCredentials"> | Date | string
    updatedAt?: DateTimeFilter<"EmailClientCredentials"> | Date | string
    apiKey?: StringFilter<"EmailClientCredentials"> | string
    emailClientId?: StringFilter<"EmailClientCredentials"> | string
    platformName?: StringFilter<"EmailClientCredentials"> | string
    emailClient?: XOR<EmailClientScalarRelationFilter, EmailClientWhereInput>
  }

  export type EmailClientCredentialsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiKey?: SortOrder
    emailClientId?: SortOrder
    platformName?: SortOrder
    emailClient?: EmailClientOrderByWithRelationInput
  }

  export type EmailClientCredentialsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    emailClientId_platformName?: EmailClientCredentialsEmailClientIdPlatformNameCompoundUniqueInput
    AND?: EmailClientCredentialsWhereInput | EmailClientCredentialsWhereInput[]
    OR?: EmailClientCredentialsWhereInput[]
    NOT?: EmailClientCredentialsWhereInput | EmailClientCredentialsWhereInput[]
    createdAt?: DateTimeFilter<"EmailClientCredentials"> | Date | string
    updatedAt?: DateTimeFilter<"EmailClientCredentials"> | Date | string
    apiKey?: StringFilter<"EmailClientCredentials"> | string
    emailClientId?: StringFilter<"EmailClientCredentials"> | string
    platformName?: StringFilter<"EmailClientCredentials"> | string
    emailClient?: XOR<EmailClientScalarRelationFilter, EmailClientWhereInput>
  }, "id" | "emailClientId_platformName">

  export type EmailClientCredentialsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiKey?: SortOrder
    emailClientId?: SortOrder
    platformName?: SortOrder
    _count?: EmailClientCredentialsCountOrderByAggregateInput
    _max?: EmailClientCredentialsMaxOrderByAggregateInput
    _min?: EmailClientCredentialsMinOrderByAggregateInput
  }

  export type EmailClientCredentialsScalarWhereWithAggregatesInput = {
    AND?: EmailClientCredentialsScalarWhereWithAggregatesInput | EmailClientCredentialsScalarWhereWithAggregatesInput[]
    OR?: EmailClientCredentialsScalarWhereWithAggregatesInput[]
    NOT?: EmailClientCredentialsScalarWhereWithAggregatesInput | EmailClientCredentialsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailClientCredentials"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailClientCredentials"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailClientCredentials"> | Date | string
    apiKey?: StringWithAggregatesFilter<"EmailClientCredentials"> | string
    emailClientId?: StringWithAggregatesFilter<"EmailClientCredentials"> | string
    platformName?: StringWithAggregatesFilter<"EmailClientCredentials"> | string
  }

  export type EmailGlobalDailyStatsWhereInput = {
    AND?: EmailGlobalDailyStatsWhereInput | EmailGlobalDailyStatsWhereInput[]
    OR?: EmailGlobalDailyStatsWhereInput[]
    NOT?: EmailGlobalDailyStatsWhereInput | EmailGlobalDailyStatsWhereInput[]
    id?: StringFilter<"EmailGlobalDailyStats"> | string
    date?: DateTimeFilter<"EmailGlobalDailyStats"> | Date | string
    createdAt?: DateTimeFilter<"EmailGlobalDailyStats"> | Date | string
    updatedAt?: DateTimeFilter<"EmailGlobalDailyStats"> | Date | string
    bounces?: IntFilter<"EmailGlobalDailyStats"> | number
    clicks?: IntFilter<"EmailGlobalDailyStats"> | number
    emailClientId?: StringFilter<"EmailGlobalDailyStats"> | string
    opens?: IntFilter<"EmailGlobalDailyStats"> | number
    unsubs?: IntFilter<"EmailGlobalDailyStats"> | number
    emailClient?: XOR<EmailClientScalarRelationFilter, EmailClientWhereInput>
  }

  export type EmailGlobalDailyStatsOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bounces?: SortOrder
    clicks?: SortOrder
    emailClientId?: SortOrder
    opens?: SortOrder
    unsubs?: SortOrder
    emailClient?: EmailClientOrderByWithRelationInput
  }

  export type EmailGlobalDailyStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    emailClientId_date?: EmailGlobalDailyStatsEmailClientIdDateCompoundUniqueInput
    AND?: EmailGlobalDailyStatsWhereInput | EmailGlobalDailyStatsWhereInput[]
    OR?: EmailGlobalDailyStatsWhereInput[]
    NOT?: EmailGlobalDailyStatsWhereInput | EmailGlobalDailyStatsWhereInput[]
    date?: DateTimeFilter<"EmailGlobalDailyStats"> | Date | string
    createdAt?: DateTimeFilter<"EmailGlobalDailyStats"> | Date | string
    updatedAt?: DateTimeFilter<"EmailGlobalDailyStats"> | Date | string
    bounces?: IntFilter<"EmailGlobalDailyStats"> | number
    clicks?: IntFilter<"EmailGlobalDailyStats"> | number
    emailClientId?: StringFilter<"EmailGlobalDailyStats"> | string
    opens?: IntFilter<"EmailGlobalDailyStats"> | number
    unsubs?: IntFilter<"EmailGlobalDailyStats"> | number
    emailClient?: XOR<EmailClientScalarRelationFilter, EmailClientWhereInput>
  }, "id" | "emailClientId_date">

  export type EmailGlobalDailyStatsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bounces?: SortOrder
    clicks?: SortOrder
    emailClientId?: SortOrder
    opens?: SortOrder
    unsubs?: SortOrder
    _count?: EmailGlobalDailyStatsCountOrderByAggregateInput
    _avg?: EmailGlobalDailyStatsAvgOrderByAggregateInput
    _max?: EmailGlobalDailyStatsMaxOrderByAggregateInput
    _min?: EmailGlobalDailyStatsMinOrderByAggregateInput
    _sum?: EmailGlobalDailyStatsSumOrderByAggregateInput
  }

  export type EmailGlobalDailyStatsScalarWhereWithAggregatesInput = {
    AND?: EmailGlobalDailyStatsScalarWhereWithAggregatesInput | EmailGlobalDailyStatsScalarWhereWithAggregatesInput[]
    OR?: EmailGlobalDailyStatsScalarWhereWithAggregatesInput[]
    NOT?: EmailGlobalDailyStatsScalarWhereWithAggregatesInput | EmailGlobalDailyStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailGlobalDailyStats"> | string
    date?: DateTimeWithAggregatesFilter<"EmailGlobalDailyStats"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailGlobalDailyStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailGlobalDailyStats"> | Date | string
    bounces?: IntWithAggregatesFilter<"EmailGlobalDailyStats"> | number
    clicks?: IntWithAggregatesFilter<"EmailGlobalDailyStats"> | number
    emailClientId?: StringWithAggregatesFilter<"EmailGlobalDailyStats"> | string
    opens?: IntWithAggregatesFilter<"EmailGlobalDailyStats"> | number
    unsubs?: IntWithAggregatesFilter<"EmailGlobalDailyStats"> | number
  }

  export type GaAccountWhereInput = {
    AND?: GaAccountWhereInput | GaAccountWhereInput[]
    OR?: GaAccountWhereInput[]
    NOT?: GaAccountWhereInput | GaAccountWhereInput[]
    id?: StringFilter<"GaAccount"> | string
    gaAccountId?: StringFilter<"GaAccount"> | string
    gaAccountName?: StringFilter<"GaAccount"> | string
    deleted?: BoolFilter<"GaAccount"> | boolean
    createdAt?: DateTimeFilter<"GaAccount"> | Date | string
    updatedAt?: DateTimeFilter<"GaAccount"> | Date | string
    conversations?: ConversationListRelationFilter
    gaProperties?: GaPropertyListRelationFilter
    userToGaAccounts?: UserToGaAccountListRelationFilter
  }

  export type GaAccountOrderByWithRelationInput = {
    id?: SortOrder
    gaAccountId?: SortOrder
    gaAccountName?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversations?: ConversationOrderByRelationAggregateInput
    gaProperties?: GaPropertyOrderByRelationAggregateInput
    userToGaAccounts?: UserToGaAccountOrderByRelationAggregateInput
  }

  export type GaAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gaAccountId?: string
    AND?: GaAccountWhereInput | GaAccountWhereInput[]
    OR?: GaAccountWhereInput[]
    NOT?: GaAccountWhereInput | GaAccountWhereInput[]
    gaAccountName?: StringFilter<"GaAccount"> | string
    deleted?: BoolFilter<"GaAccount"> | boolean
    createdAt?: DateTimeFilter<"GaAccount"> | Date | string
    updatedAt?: DateTimeFilter<"GaAccount"> | Date | string
    conversations?: ConversationListRelationFilter
    gaProperties?: GaPropertyListRelationFilter
    userToGaAccounts?: UserToGaAccountListRelationFilter
  }, "id" | "gaAccountId">

  export type GaAccountOrderByWithAggregationInput = {
    id?: SortOrder
    gaAccountId?: SortOrder
    gaAccountName?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GaAccountCountOrderByAggregateInput
    _max?: GaAccountMaxOrderByAggregateInput
    _min?: GaAccountMinOrderByAggregateInput
  }

  export type GaAccountScalarWhereWithAggregatesInput = {
    AND?: GaAccountScalarWhereWithAggregatesInput | GaAccountScalarWhereWithAggregatesInput[]
    OR?: GaAccountScalarWhereWithAggregatesInput[]
    NOT?: GaAccountScalarWhereWithAggregatesInput | GaAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaAccount"> | string
    gaAccountId?: StringWithAggregatesFilter<"GaAccount"> | string
    gaAccountName?: StringWithAggregatesFilter<"GaAccount"> | string
    deleted?: BoolWithAggregatesFilter<"GaAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GaAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GaAccount"> | Date | string
  }

  export type GaPropertyWhereInput = {
    AND?: GaPropertyWhereInput | GaPropertyWhereInput[]
    OR?: GaPropertyWhereInput[]
    NOT?: GaPropertyWhereInput | GaPropertyWhereInput[]
    id?: StringFilter<"GaProperty"> | string
    gaPropertyId?: StringFilter<"GaProperty"> | string
    gaPropertyName?: StringFilter<"GaProperty"> | string
    gaAccountId?: StringFilter<"GaProperty"> | string
    deleted?: BoolFilter<"GaProperty"> | boolean
    createdAt?: DateTimeFilter<"GaProperty"> | Date | string
    updatedAt?: DateTimeFilter<"GaProperty"> | Date | string
    conversations?: ConversationListRelationFilter
    channelDaily?: GaChannelDailyListRelationFilter
    imports?: GaImportRunListRelationFilter
    kpiDaily?: GaKpiDailyListRelationFilter
    kpiMonthly?: GaKpiMonthlyListRelationFilter
    gaAccount?: XOR<GaAccountScalarRelationFilter, GaAccountWhereInput>
    sourceDaily?: GaSourceDailyListRelationFilter
  }

  export type GaPropertyOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    gaPropertyName?: SortOrder
    gaAccountId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversations?: ConversationOrderByRelationAggregateInput
    channelDaily?: GaChannelDailyOrderByRelationAggregateInput
    imports?: GaImportRunOrderByRelationAggregateInput
    kpiDaily?: GaKpiDailyOrderByRelationAggregateInput
    kpiMonthly?: GaKpiMonthlyOrderByRelationAggregateInput
    gaAccount?: GaAccountOrderByWithRelationInput
    sourceDaily?: GaSourceDailyOrderByRelationAggregateInput
  }

  export type GaPropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gaPropertyId?: string
    AND?: GaPropertyWhereInput | GaPropertyWhereInput[]
    OR?: GaPropertyWhereInput[]
    NOT?: GaPropertyWhereInput | GaPropertyWhereInput[]
    gaPropertyName?: StringFilter<"GaProperty"> | string
    gaAccountId?: StringFilter<"GaProperty"> | string
    deleted?: BoolFilter<"GaProperty"> | boolean
    createdAt?: DateTimeFilter<"GaProperty"> | Date | string
    updatedAt?: DateTimeFilter<"GaProperty"> | Date | string
    conversations?: ConversationListRelationFilter
    channelDaily?: GaChannelDailyListRelationFilter
    imports?: GaImportRunListRelationFilter
    kpiDaily?: GaKpiDailyListRelationFilter
    kpiMonthly?: GaKpiMonthlyListRelationFilter
    gaAccount?: XOR<GaAccountScalarRelationFilter, GaAccountWhereInput>
    sourceDaily?: GaSourceDailyListRelationFilter
  }, "id" | "gaPropertyId">

  export type GaPropertyOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    gaPropertyName?: SortOrder
    gaAccountId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GaPropertyCountOrderByAggregateInput
    _max?: GaPropertyMaxOrderByAggregateInput
    _min?: GaPropertyMinOrderByAggregateInput
  }

  export type GaPropertyScalarWhereWithAggregatesInput = {
    AND?: GaPropertyScalarWhereWithAggregatesInput | GaPropertyScalarWhereWithAggregatesInput[]
    OR?: GaPropertyScalarWhereWithAggregatesInput[]
    NOT?: GaPropertyScalarWhereWithAggregatesInput | GaPropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaProperty"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaProperty"> | string
    gaPropertyName?: StringWithAggregatesFilter<"GaProperty"> | string
    gaAccountId?: StringWithAggregatesFilter<"GaProperty"> | string
    deleted?: BoolWithAggregatesFilter<"GaProperty"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GaProperty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GaProperty"> | Date | string
  }

  export type GaImportRunWhereInput = {
    AND?: GaImportRunWhereInput | GaImportRunWhereInput[]
    OR?: GaImportRunWhereInput[]
    NOT?: GaImportRunWhereInput | GaImportRunWhereInput[]
    id?: StringFilter<"GaImportRun"> | string
    gaPropertyId?: StringFilter<"GaImportRun"> | string
    dateStart?: DateTimeFilter<"GaImportRun"> | Date | string
    dateEnd?: DateTimeFilter<"GaImportRun"> | Date | string
    status?: EnumImportStatusFilter<"GaImportRun"> | $Enums.ImportStatus
    errorMessage?: StringNullableFilter<"GaImportRun"> | string | null
    requestedByUserId?: StringFilter<"GaImportRun"> | string
    createdAt?: DateTimeFilter<"GaImportRun"> | Date | string
    updatedAt?: DateTimeFilter<"GaImportRun"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
    requestedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GaImportRunOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    requestedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaProperty?: GaPropertyOrderByWithRelationInput
    requestedBy?: UserOrderByWithRelationInput
  }

  export type GaImportRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GaImportRunWhereInput | GaImportRunWhereInput[]
    OR?: GaImportRunWhereInput[]
    NOT?: GaImportRunWhereInput | GaImportRunWhereInput[]
    gaPropertyId?: StringFilter<"GaImportRun"> | string
    dateStart?: DateTimeFilter<"GaImportRun"> | Date | string
    dateEnd?: DateTimeFilter<"GaImportRun"> | Date | string
    status?: EnumImportStatusFilter<"GaImportRun"> | $Enums.ImportStatus
    errorMessage?: StringNullableFilter<"GaImportRun"> | string | null
    requestedByUserId?: StringFilter<"GaImportRun"> | string
    createdAt?: DateTimeFilter<"GaImportRun"> | Date | string
    updatedAt?: DateTimeFilter<"GaImportRun"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
    requestedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GaImportRunOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    requestedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GaImportRunCountOrderByAggregateInput
    _max?: GaImportRunMaxOrderByAggregateInput
    _min?: GaImportRunMinOrderByAggregateInput
  }

  export type GaImportRunScalarWhereWithAggregatesInput = {
    AND?: GaImportRunScalarWhereWithAggregatesInput | GaImportRunScalarWhereWithAggregatesInput[]
    OR?: GaImportRunScalarWhereWithAggregatesInput[]
    NOT?: GaImportRunScalarWhereWithAggregatesInput | GaImportRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaImportRun"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaImportRun"> | string
    dateStart?: DateTimeWithAggregatesFilter<"GaImportRun"> | Date | string
    dateEnd?: DateTimeWithAggregatesFilter<"GaImportRun"> | Date | string
    status?: EnumImportStatusWithAggregatesFilter<"GaImportRun"> | $Enums.ImportStatus
    errorMessage?: StringNullableWithAggregatesFilter<"GaImportRun"> | string | null
    requestedByUserId?: StringWithAggregatesFilter<"GaImportRun"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GaImportRun"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GaImportRun"> | Date | string
  }

  export type GaKpiDailyWhereInput = {
    AND?: GaKpiDailyWhereInput | GaKpiDailyWhereInput[]
    OR?: GaKpiDailyWhereInput[]
    NOT?: GaKpiDailyWhereInput | GaKpiDailyWhereInput[]
    id?: StringFilter<"GaKpiDaily"> | string
    gaPropertyId?: StringFilter<"GaKpiDaily"> | string
    date?: DateTimeFilter<"GaKpiDaily"> | Date | string
    sessions?: IntFilter<"GaKpiDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiDaily"> | number
    engagementRate?: FloatFilter<"GaKpiDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiDaily"> | number
    goalCompletions?: IntFilter<"GaKpiDaily"> | number
    goalCompletionRate?: FloatFilter<"GaKpiDaily"> | number
    createdAt?: DateTimeFilter<"GaKpiDaily"> | Date | string
    updatedAt?: DateTimeFilter<"GaKpiDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }

  export type GaKpiDailyOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaProperty?: GaPropertyOrderByWithRelationInput
  }

  export type GaKpiDailyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gaPropertyId_date?: GaKpiDailyGaPropertyIdDateCompoundUniqueInput
    AND?: GaKpiDailyWhereInput | GaKpiDailyWhereInput[]
    OR?: GaKpiDailyWhereInput[]
    NOT?: GaKpiDailyWhereInput | GaKpiDailyWhereInput[]
    gaPropertyId?: StringFilter<"GaKpiDaily"> | string
    date?: DateTimeFilter<"GaKpiDaily"> | Date | string
    sessions?: IntFilter<"GaKpiDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiDaily"> | number
    engagementRate?: FloatFilter<"GaKpiDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiDaily"> | number
    goalCompletions?: IntFilter<"GaKpiDaily"> | number
    goalCompletionRate?: FloatFilter<"GaKpiDaily"> | number
    createdAt?: DateTimeFilter<"GaKpiDaily"> | Date | string
    updatedAt?: DateTimeFilter<"GaKpiDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }, "id" | "gaPropertyId_date">

  export type GaKpiDailyOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GaKpiDailyCountOrderByAggregateInput
    _avg?: GaKpiDailyAvgOrderByAggregateInput
    _max?: GaKpiDailyMaxOrderByAggregateInput
    _min?: GaKpiDailyMinOrderByAggregateInput
    _sum?: GaKpiDailySumOrderByAggregateInput
  }

  export type GaKpiDailyScalarWhereWithAggregatesInput = {
    AND?: GaKpiDailyScalarWhereWithAggregatesInput | GaKpiDailyScalarWhereWithAggregatesInput[]
    OR?: GaKpiDailyScalarWhereWithAggregatesInput[]
    NOT?: GaKpiDailyScalarWhereWithAggregatesInput | GaKpiDailyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaKpiDaily"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaKpiDaily"> | string
    date?: DateTimeWithAggregatesFilter<"GaKpiDaily"> | Date | string
    sessions?: IntWithAggregatesFilter<"GaKpiDaily"> | number
    screenPageViewsPerSession?: FloatWithAggregatesFilter<"GaKpiDaily"> | number
    engagementRate?: FloatWithAggregatesFilter<"GaKpiDaily"> | number
    avgSessionDurationSec?: IntWithAggregatesFilter<"GaKpiDaily"> | number
    goalCompletions?: IntWithAggregatesFilter<"GaKpiDaily"> | number
    goalCompletionRate?: FloatWithAggregatesFilter<"GaKpiDaily"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GaKpiDaily"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GaKpiDaily"> | Date | string
  }

  export type GaKpiMonthlyWhereInput = {
    AND?: GaKpiMonthlyWhereInput | GaKpiMonthlyWhereInput[]
    OR?: GaKpiMonthlyWhereInput[]
    NOT?: GaKpiMonthlyWhereInput | GaKpiMonthlyWhereInput[]
    id?: StringFilter<"GaKpiMonthly"> | string
    gaPropertyId?: StringFilter<"GaKpiMonthly"> | string
    month?: IntFilter<"GaKpiMonthly"> | number
    sessions?: IntFilter<"GaKpiMonthly"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiMonthly"> | number
    engagementRate?: FloatFilter<"GaKpiMonthly"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiMonthly"> | number
    goalCompletions?: IntFilter<"GaKpiMonthly"> | number
    goalCompletionRate?: FloatFilter<"GaKpiMonthly"> | number
    createdAt?: DateTimeFilter<"GaKpiMonthly"> | Date | string
    updatedAt?: DateTimeFilter<"GaKpiMonthly"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }

  export type GaKpiMonthlyOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaProperty?: GaPropertyOrderByWithRelationInput
  }

  export type GaKpiMonthlyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gaPropertyId_month?: GaKpiMonthlyGaPropertyIdMonthCompoundUniqueInput
    AND?: GaKpiMonthlyWhereInput | GaKpiMonthlyWhereInput[]
    OR?: GaKpiMonthlyWhereInput[]
    NOT?: GaKpiMonthlyWhereInput | GaKpiMonthlyWhereInput[]
    gaPropertyId?: StringFilter<"GaKpiMonthly"> | string
    month?: IntFilter<"GaKpiMonthly"> | number
    sessions?: IntFilter<"GaKpiMonthly"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiMonthly"> | number
    engagementRate?: FloatFilter<"GaKpiMonthly"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiMonthly"> | number
    goalCompletions?: IntFilter<"GaKpiMonthly"> | number
    goalCompletionRate?: FloatFilter<"GaKpiMonthly"> | number
    createdAt?: DateTimeFilter<"GaKpiMonthly"> | Date | string
    updatedAt?: DateTimeFilter<"GaKpiMonthly"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }, "id" | "gaPropertyId_month">

  export type GaKpiMonthlyOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GaKpiMonthlyCountOrderByAggregateInput
    _avg?: GaKpiMonthlyAvgOrderByAggregateInput
    _max?: GaKpiMonthlyMaxOrderByAggregateInput
    _min?: GaKpiMonthlyMinOrderByAggregateInput
    _sum?: GaKpiMonthlySumOrderByAggregateInput
  }

  export type GaKpiMonthlyScalarWhereWithAggregatesInput = {
    AND?: GaKpiMonthlyScalarWhereWithAggregatesInput | GaKpiMonthlyScalarWhereWithAggregatesInput[]
    OR?: GaKpiMonthlyScalarWhereWithAggregatesInput[]
    NOT?: GaKpiMonthlyScalarWhereWithAggregatesInput | GaKpiMonthlyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaKpiMonthly"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaKpiMonthly"> | string
    month?: IntWithAggregatesFilter<"GaKpiMonthly"> | number
    sessions?: IntWithAggregatesFilter<"GaKpiMonthly"> | number
    screenPageViewsPerSession?: FloatWithAggregatesFilter<"GaKpiMonthly"> | number
    engagementRate?: FloatWithAggregatesFilter<"GaKpiMonthly"> | number
    avgSessionDurationSec?: IntWithAggregatesFilter<"GaKpiMonthly"> | number
    goalCompletions?: IntWithAggregatesFilter<"GaKpiMonthly"> | number
    goalCompletionRate?: FloatWithAggregatesFilter<"GaKpiMonthly"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GaKpiMonthly"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GaKpiMonthly"> | Date | string
  }

  export type GaChannelDailyWhereInput = {
    AND?: GaChannelDailyWhereInput | GaChannelDailyWhereInput[]
    OR?: GaChannelDailyWhereInput[]
    NOT?: GaChannelDailyWhereInput | GaChannelDailyWhereInput[]
    id?: StringFilter<"GaChannelDaily"> | string
    gaPropertyId?: StringFilter<"GaChannelDaily"> | string
    date?: DateTimeFilter<"GaChannelDaily"> | Date | string
    channelGroup?: StringFilter<"GaChannelDaily"> | string
    sessions?: IntFilter<"GaChannelDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaChannelDaily"> | number
    engagementRate?: FloatFilter<"GaChannelDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaChannelDaily"> | number
    goalCompletions?: IntFilter<"GaChannelDaily"> | number
    goalCompletionRate?: FloatFilter<"GaChannelDaily"> | number
    createdAt?: DateTimeFilter<"GaChannelDaily"> | Date | string
    updatedAt?: DateTimeFilter<"GaChannelDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }

  export type GaChannelDailyOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    channelGroup?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaProperty?: GaPropertyOrderByWithRelationInput
  }

  export type GaChannelDailyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gaPropertyId_date_channelGroup?: GaChannelDailyGaPropertyIdDateChannelGroupCompoundUniqueInput
    AND?: GaChannelDailyWhereInput | GaChannelDailyWhereInput[]
    OR?: GaChannelDailyWhereInput[]
    NOT?: GaChannelDailyWhereInput | GaChannelDailyWhereInput[]
    gaPropertyId?: StringFilter<"GaChannelDaily"> | string
    date?: DateTimeFilter<"GaChannelDaily"> | Date | string
    channelGroup?: StringFilter<"GaChannelDaily"> | string
    sessions?: IntFilter<"GaChannelDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaChannelDaily"> | number
    engagementRate?: FloatFilter<"GaChannelDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaChannelDaily"> | number
    goalCompletions?: IntFilter<"GaChannelDaily"> | number
    goalCompletionRate?: FloatFilter<"GaChannelDaily"> | number
    createdAt?: DateTimeFilter<"GaChannelDaily"> | Date | string
    updatedAt?: DateTimeFilter<"GaChannelDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }, "id" | "gaPropertyId_date_channelGroup">

  export type GaChannelDailyOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    channelGroup?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GaChannelDailyCountOrderByAggregateInput
    _avg?: GaChannelDailyAvgOrderByAggregateInput
    _max?: GaChannelDailyMaxOrderByAggregateInput
    _min?: GaChannelDailyMinOrderByAggregateInput
    _sum?: GaChannelDailySumOrderByAggregateInput
  }

  export type GaChannelDailyScalarWhereWithAggregatesInput = {
    AND?: GaChannelDailyScalarWhereWithAggregatesInput | GaChannelDailyScalarWhereWithAggregatesInput[]
    OR?: GaChannelDailyScalarWhereWithAggregatesInput[]
    NOT?: GaChannelDailyScalarWhereWithAggregatesInput | GaChannelDailyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaChannelDaily"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaChannelDaily"> | string
    date?: DateTimeWithAggregatesFilter<"GaChannelDaily"> | Date | string
    channelGroup?: StringWithAggregatesFilter<"GaChannelDaily"> | string
    sessions?: IntWithAggregatesFilter<"GaChannelDaily"> | number
    screenPageViewsPerSession?: FloatWithAggregatesFilter<"GaChannelDaily"> | number
    engagementRate?: FloatWithAggregatesFilter<"GaChannelDaily"> | number
    avgSessionDurationSec?: IntWithAggregatesFilter<"GaChannelDaily"> | number
    goalCompletions?: IntWithAggregatesFilter<"GaChannelDaily"> | number
    goalCompletionRate?: FloatWithAggregatesFilter<"GaChannelDaily"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GaChannelDaily"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GaChannelDaily"> | Date | string
  }

  export type GaSourceDailyWhereInput = {
    AND?: GaSourceDailyWhereInput | GaSourceDailyWhereInput[]
    OR?: GaSourceDailyWhereInput[]
    NOT?: GaSourceDailyWhereInput | GaSourceDailyWhereInput[]
    id?: StringFilter<"GaSourceDaily"> | string
    gaPropertyId?: StringFilter<"GaSourceDaily"> | string
    date?: DateTimeFilter<"GaSourceDaily"> | Date | string
    trafficSource?: StringFilter<"GaSourceDaily"> | string
    sessions?: IntFilter<"GaSourceDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaSourceDaily"> | number
    engagementRate?: FloatFilter<"GaSourceDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaSourceDaily"> | number
    goalCompletions?: IntFilter<"GaSourceDaily"> | number
    goalCompletionRate?: FloatFilter<"GaSourceDaily"> | number
    createdAt?: DateTimeFilter<"GaSourceDaily"> | Date | string
    updatedAt?: DateTimeFilter<"GaSourceDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }

  export type GaSourceDailyOrderByWithRelationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    trafficSource?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaProperty?: GaPropertyOrderByWithRelationInput
  }

  export type GaSourceDailyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gaPropertyId_date_trafficSource?: GaSourceDailyGaPropertyIdDateTrafficSourceCompoundUniqueInput
    AND?: GaSourceDailyWhereInput | GaSourceDailyWhereInput[]
    OR?: GaSourceDailyWhereInput[]
    NOT?: GaSourceDailyWhereInput | GaSourceDailyWhereInput[]
    gaPropertyId?: StringFilter<"GaSourceDaily"> | string
    date?: DateTimeFilter<"GaSourceDaily"> | Date | string
    trafficSource?: StringFilter<"GaSourceDaily"> | string
    sessions?: IntFilter<"GaSourceDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaSourceDaily"> | number
    engagementRate?: FloatFilter<"GaSourceDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaSourceDaily"> | number
    goalCompletions?: IntFilter<"GaSourceDaily"> | number
    goalCompletionRate?: FloatFilter<"GaSourceDaily"> | number
    createdAt?: DateTimeFilter<"GaSourceDaily"> | Date | string
    updatedAt?: DateTimeFilter<"GaSourceDaily"> | Date | string
    gaProperty?: XOR<GaPropertyScalarRelationFilter, GaPropertyWhereInput>
  }, "id" | "gaPropertyId_date_trafficSource">

  export type GaSourceDailyOrderByWithAggregationInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    trafficSource?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GaSourceDailyCountOrderByAggregateInput
    _avg?: GaSourceDailyAvgOrderByAggregateInput
    _max?: GaSourceDailyMaxOrderByAggregateInput
    _min?: GaSourceDailyMinOrderByAggregateInput
    _sum?: GaSourceDailySumOrderByAggregateInput
  }

  export type GaSourceDailyScalarWhereWithAggregatesInput = {
    AND?: GaSourceDailyScalarWhereWithAggregatesInput | GaSourceDailyScalarWhereWithAggregatesInput[]
    OR?: GaSourceDailyScalarWhereWithAggregatesInput[]
    NOT?: GaSourceDailyScalarWhereWithAggregatesInput | GaSourceDailyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GaSourceDaily"> | string
    gaPropertyId?: StringWithAggregatesFilter<"GaSourceDaily"> | string
    date?: DateTimeWithAggregatesFilter<"GaSourceDaily"> | Date | string
    trafficSource?: StringWithAggregatesFilter<"GaSourceDaily"> | string
    sessions?: IntWithAggregatesFilter<"GaSourceDaily"> | number
    screenPageViewsPerSession?: FloatWithAggregatesFilter<"GaSourceDaily"> | number
    engagementRate?: FloatWithAggregatesFilter<"GaSourceDaily"> | number
    avgSessionDurationSec?: IntWithAggregatesFilter<"GaSourceDaily"> | number
    goalCompletions?: IntWithAggregatesFilter<"GaSourceDaily"> | number
    goalCompletionRate?: FloatWithAggregatesFilter<"GaSourceDaily"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GaSourceDaily"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GaSourceDaily"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    sessionToken?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    archived?: BoolFilter<"Message"> | boolean
    isThreadStart?: BoolFilter<"Message"> | boolean
    parentId?: StringNullableFilter<"Message"> | string | null
    threadId?: StringNullableFilter<"Message"> | string | null
    parent?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    replies?: MessageListRelationFilter
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: MessageAttachmentListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    isThreadStart?: SortOrder
    parentId?: SortOrderInput | SortOrder
    threadId?: SortOrderInput | SortOrder
    parent?: MessageOrderByWithRelationInput
    replies?: MessageOrderByRelationAggregateInput
    recipient?: UserOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    attachments?: MessageAttachmentOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    archived?: BoolFilter<"Message"> | boolean
    isThreadStart?: BoolFilter<"Message"> | boolean
    parentId?: StringNullableFilter<"Message"> | string | null
    threadId?: StringNullableFilter<"Message"> | string | null
    parent?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    replies?: MessageListRelationFilter
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: MessageAttachmentListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    isThreadStart?: SortOrder
    parentId?: SortOrderInput | SortOrder
    threadId?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    recipientId?: StringWithAggregatesFilter<"Message"> | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    archived?: BoolWithAggregatesFilter<"Message"> | boolean
    isThreadStart?: BoolWithAggregatesFilter<"Message"> | boolean
    parentId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    threadId?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ParsedPieGraphDataWhereInput = {
    AND?: ParsedPieGraphDataWhereInput | ParsedPieGraphDataWhereInput[]
    OR?: ParsedPieGraphDataWhereInput[]
    NOT?: ParsedPieGraphDataWhereInput | ParsedPieGraphDataWhereInput[]
    id?: StringFilter<"ParsedPieGraphData"> | string
    queryId?: StringFilter<"ParsedPieGraphData"> | string
    channel?: StringFilter<"ParsedPieGraphData"> | string
    source?: StringFilter<"ParsedPieGraphData"> | string
    sessions?: IntFilter<"ParsedPieGraphData"> | number
    conversionRate?: FloatFilter<"ParsedPieGraphData"> | number
    conversions?: IntFilter<"ParsedPieGraphData"> | number
    bounces?: IntFilter<"ParsedPieGraphData"> | number
    prevSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    createdAt?: DateTimeFilter<"ParsedPieGraphData"> | Date | string
    updatedAt?: DateTimeFilter<"ParsedPieGraphData"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }

  export type ParsedPieGraphDataOrderByWithRelationInput = {
    id?: SortOrder
    queryId?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    query?: QueryOrderByWithRelationInput
  }

  export type ParsedPieGraphDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParsedPieGraphDataWhereInput | ParsedPieGraphDataWhereInput[]
    OR?: ParsedPieGraphDataWhereInput[]
    NOT?: ParsedPieGraphDataWhereInput | ParsedPieGraphDataWhereInput[]
    queryId?: StringFilter<"ParsedPieGraphData"> | string
    channel?: StringFilter<"ParsedPieGraphData"> | string
    source?: StringFilter<"ParsedPieGraphData"> | string
    sessions?: IntFilter<"ParsedPieGraphData"> | number
    conversionRate?: FloatFilter<"ParsedPieGraphData"> | number
    conversions?: IntFilter<"ParsedPieGraphData"> | number
    bounces?: IntFilter<"ParsedPieGraphData"> | number
    prevSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    createdAt?: DateTimeFilter<"ParsedPieGraphData"> | Date | string
    updatedAt?: DateTimeFilter<"ParsedPieGraphData"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }, "id">

  export type ParsedPieGraphDataOrderByWithAggregationInput = {
    id?: SortOrder
    queryId?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParsedPieGraphDataCountOrderByAggregateInput
    _avg?: ParsedPieGraphDataAvgOrderByAggregateInput
    _max?: ParsedPieGraphDataMaxOrderByAggregateInput
    _min?: ParsedPieGraphDataMinOrderByAggregateInput
    _sum?: ParsedPieGraphDataSumOrderByAggregateInput
  }

  export type ParsedPieGraphDataScalarWhereWithAggregatesInput = {
    AND?: ParsedPieGraphDataScalarWhereWithAggregatesInput | ParsedPieGraphDataScalarWhereWithAggregatesInput[]
    OR?: ParsedPieGraphDataScalarWhereWithAggregatesInput[]
    NOT?: ParsedPieGraphDataScalarWhereWithAggregatesInput | ParsedPieGraphDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParsedPieGraphData"> | string
    queryId?: StringWithAggregatesFilter<"ParsedPieGraphData"> | string
    channel?: StringWithAggregatesFilter<"ParsedPieGraphData"> | string
    source?: StringWithAggregatesFilter<"ParsedPieGraphData"> | string
    sessions?: IntWithAggregatesFilter<"ParsedPieGraphData"> | number
    conversionRate?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    conversions?: IntWithAggregatesFilter<"ParsedPieGraphData"> | number
    bounces?: IntWithAggregatesFilter<"ParsedPieGraphData"> | number
    prevSessionsDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    prevConversionRateDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    prevConversionsDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    prevBouncesDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    yearSessionsDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    yearConversionRateDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    yearConversionsDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    yearBouncesDiff?: FloatWithAggregatesFilter<"ParsedPieGraphData"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ParsedPieGraphData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ParsedPieGraphData"> | Date | string
  }

  export type ParsedQueryDataWhereInput = {
    AND?: ParsedQueryDataWhereInput | ParsedQueryDataWhereInput[]
    OR?: ParsedQueryDataWhereInput[]
    NOT?: ParsedQueryDataWhereInput | ParsedQueryDataWhereInput[]
    id?: StringFilter<"ParsedQueryData"> | string
    queryId?: StringFilter<"ParsedQueryData"> | string
    date?: DateTimeFilter<"ParsedQueryData"> | Date | string
    channel?: StringFilter<"ParsedQueryData"> | string
    source?: StringFilter<"ParsedQueryData"> | string
    sessions?: IntFilter<"ParsedQueryData"> | number
    conversionRate?: FloatFilter<"ParsedQueryData"> | number
    conversions?: IntFilter<"ParsedQueryData"> | number
    bounces?: IntFilter<"ParsedQueryData"> | number
    createdAt?: DateTimeFilter<"ParsedQueryData"> | Date | string
    bounceRate?: FloatNullableFilter<"ParsedQueryData"> | number | null
    engagedSessions?: IntNullableFilter<"ParsedQueryData"> | number | null
    newUsers?: IntNullableFilter<"ParsedQueryData"> | number | null
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }

  export type ParsedQueryDataOrderByWithRelationInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    createdAt?: SortOrder
    bounceRate?: SortOrderInput | SortOrder
    engagedSessions?: SortOrderInput | SortOrder
    newUsers?: SortOrderInput | SortOrder
    query?: QueryOrderByWithRelationInput
  }

  export type ParsedQueryDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParsedQueryDataWhereInput | ParsedQueryDataWhereInput[]
    OR?: ParsedQueryDataWhereInput[]
    NOT?: ParsedQueryDataWhereInput | ParsedQueryDataWhereInput[]
    queryId?: StringFilter<"ParsedQueryData"> | string
    date?: DateTimeFilter<"ParsedQueryData"> | Date | string
    channel?: StringFilter<"ParsedQueryData"> | string
    source?: StringFilter<"ParsedQueryData"> | string
    sessions?: IntFilter<"ParsedQueryData"> | number
    conversionRate?: FloatFilter<"ParsedQueryData"> | number
    conversions?: IntFilter<"ParsedQueryData"> | number
    bounces?: IntFilter<"ParsedQueryData"> | number
    createdAt?: DateTimeFilter<"ParsedQueryData"> | Date | string
    bounceRate?: FloatNullableFilter<"ParsedQueryData"> | number | null
    engagedSessions?: IntNullableFilter<"ParsedQueryData"> | number | null
    newUsers?: IntNullableFilter<"ParsedQueryData"> | number | null
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }, "id">

  export type ParsedQueryDataOrderByWithAggregationInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    createdAt?: SortOrder
    bounceRate?: SortOrderInput | SortOrder
    engagedSessions?: SortOrderInput | SortOrder
    newUsers?: SortOrderInput | SortOrder
    _count?: ParsedQueryDataCountOrderByAggregateInput
    _avg?: ParsedQueryDataAvgOrderByAggregateInput
    _max?: ParsedQueryDataMaxOrderByAggregateInput
    _min?: ParsedQueryDataMinOrderByAggregateInput
    _sum?: ParsedQueryDataSumOrderByAggregateInput
  }

  export type ParsedQueryDataScalarWhereWithAggregatesInput = {
    AND?: ParsedQueryDataScalarWhereWithAggregatesInput | ParsedQueryDataScalarWhereWithAggregatesInput[]
    OR?: ParsedQueryDataScalarWhereWithAggregatesInput[]
    NOT?: ParsedQueryDataScalarWhereWithAggregatesInput | ParsedQueryDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParsedQueryData"> | string
    queryId?: StringWithAggregatesFilter<"ParsedQueryData"> | string
    date?: DateTimeWithAggregatesFilter<"ParsedQueryData"> | Date | string
    channel?: StringWithAggregatesFilter<"ParsedQueryData"> | string
    source?: StringWithAggregatesFilter<"ParsedQueryData"> | string
    sessions?: IntWithAggregatesFilter<"ParsedQueryData"> | number
    conversionRate?: FloatWithAggregatesFilter<"ParsedQueryData"> | number
    conversions?: IntWithAggregatesFilter<"ParsedQueryData"> | number
    bounces?: IntWithAggregatesFilter<"ParsedQueryData"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ParsedQueryData"> | Date | string
    bounceRate?: FloatNullableWithAggregatesFilter<"ParsedQueryData"> | number | null
    engagedSessions?: IntNullableWithAggregatesFilter<"ParsedQueryData"> | number | null
    newUsers?: IntNullableWithAggregatesFilter<"ParsedQueryData"> | number | null
  }

  export type ParsedQuerySummaryWhereInput = {
    AND?: ParsedQuerySummaryWhereInput | ParsedQuerySummaryWhereInput[]
    OR?: ParsedQuerySummaryWhereInput[]
    NOT?: ParsedQuerySummaryWhereInput | ParsedQuerySummaryWhereInput[]
    id?: StringFilter<"ParsedQuerySummary"> | string
    queryId?: StringFilter<"ParsedQuerySummary"> | string
    date?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
    totalEngagedSessions?: IntFilter<"ParsedQuerySummary"> | number
    averageBounceRate?: FloatFilter<"ParsedQuerySummary"> | number
    totalNewUsers?: IntFilter<"ParsedQuerySummary"> | number
    totalConversions?: IntFilter<"ParsedQuerySummary"> | number
    createdAt?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }

  export type ParsedQuerySummaryOrderByWithRelationInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
    createdAt?: SortOrder
    query?: QueryOrderByWithRelationInput
  }

  export type ParsedQuerySummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParsedQuerySummaryWhereInput | ParsedQuerySummaryWhereInput[]
    OR?: ParsedQuerySummaryWhereInput[]
    NOT?: ParsedQuerySummaryWhereInput | ParsedQuerySummaryWhereInput[]
    queryId?: StringFilter<"ParsedQuerySummary"> | string
    date?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
    totalEngagedSessions?: IntFilter<"ParsedQuerySummary"> | number
    averageBounceRate?: FloatFilter<"ParsedQuerySummary"> | number
    totalNewUsers?: IntFilter<"ParsedQuerySummary"> | number
    totalConversions?: IntFilter<"ParsedQuerySummary"> | number
    createdAt?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
  }, "id">

  export type ParsedQuerySummaryOrderByWithAggregationInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
    createdAt?: SortOrder
    _count?: ParsedQuerySummaryCountOrderByAggregateInput
    _avg?: ParsedQuerySummaryAvgOrderByAggregateInput
    _max?: ParsedQuerySummaryMaxOrderByAggregateInput
    _min?: ParsedQuerySummaryMinOrderByAggregateInput
    _sum?: ParsedQuerySummarySumOrderByAggregateInput
  }

  export type ParsedQuerySummaryScalarWhereWithAggregatesInput = {
    AND?: ParsedQuerySummaryScalarWhereWithAggregatesInput | ParsedQuerySummaryScalarWhereWithAggregatesInput[]
    OR?: ParsedQuerySummaryScalarWhereWithAggregatesInput[]
    NOT?: ParsedQuerySummaryScalarWhereWithAggregatesInput | ParsedQuerySummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParsedQuerySummary"> | string
    queryId?: StringWithAggregatesFilter<"ParsedQuerySummary"> | string
    date?: DateTimeWithAggregatesFilter<"ParsedQuerySummary"> | Date | string
    totalEngagedSessions?: IntWithAggregatesFilter<"ParsedQuerySummary"> | number
    averageBounceRate?: FloatWithAggregatesFilter<"ParsedQuerySummary"> | number
    totalNewUsers?: IntWithAggregatesFilter<"ParsedQuerySummary"> | number
    totalConversions?: IntWithAggregatesFilter<"ParsedQuerySummary"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ParsedQuerySummary"> | Date | string
  }

  export type QueryWhereInput = {
    AND?: QueryWhereInput | QueryWhereInput[]
    OR?: QueryWhereInput[]
    NOT?: QueryWhereInput | QueryWhereInput[]
    id?: StringFilter<"Query"> | string
    userId?: StringFilter<"Query"> | string
    response?: StringNullableFilter<"Query"> | string | null
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
    content?: StringFilter<"Query"> | string
    status?: EnumQueryStatusFilter<"Query"> | $Enums.QueryStatus
    conversationId?: StringNullableFilter<"Query"> | string | null
    rating?: IntFilter<"Query"> | number
    metadata?: JsonNullableFilter<"Query">
    lineGraphData?: JsonNullableFilter<"Query">
    pieGraphData?: JsonNullableFilter<"Query">
    parsedPieData?: ParsedPieGraphDataListRelationFilter
    parsedData?: ParsedQueryDataListRelationFilter
    parsedSummary?: ParsedQuerySummaryListRelationFilter
    conversation?: XOR<ConversationNullableScalarRelationFilter, ConversationWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type QueryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    status?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    rating?: SortOrder
    metadata?: SortOrderInput | SortOrder
    lineGraphData?: SortOrderInput | SortOrder
    pieGraphData?: SortOrderInput | SortOrder
    parsedPieData?: ParsedPieGraphDataOrderByRelationAggregateInput
    parsedData?: ParsedQueryDataOrderByRelationAggregateInput
    parsedSummary?: ParsedQuerySummaryOrderByRelationAggregateInput
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type QueryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QueryWhereInput | QueryWhereInput[]
    OR?: QueryWhereInput[]
    NOT?: QueryWhereInput | QueryWhereInput[]
    userId?: StringFilter<"Query"> | string
    response?: StringNullableFilter<"Query"> | string | null
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
    content?: StringFilter<"Query"> | string
    status?: EnumQueryStatusFilter<"Query"> | $Enums.QueryStatus
    conversationId?: StringNullableFilter<"Query"> | string | null
    rating?: IntFilter<"Query"> | number
    metadata?: JsonNullableFilter<"Query">
    lineGraphData?: JsonNullableFilter<"Query">
    pieGraphData?: JsonNullableFilter<"Query">
    parsedPieData?: ParsedPieGraphDataListRelationFilter
    parsedData?: ParsedQueryDataListRelationFilter
    parsedSummary?: ParsedQuerySummaryListRelationFilter
    conversation?: XOR<ConversationNullableScalarRelationFilter, ConversationWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type QueryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    status?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    rating?: SortOrder
    metadata?: SortOrderInput | SortOrder
    lineGraphData?: SortOrderInput | SortOrder
    pieGraphData?: SortOrderInput | SortOrder
    _count?: QueryCountOrderByAggregateInput
    _avg?: QueryAvgOrderByAggregateInput
    _max?: QueryMaxOrderByAggregateInput
    _min?: QueryMinOrderByAggregateInput
    _sum?: QuerySumOrderByAggregateInput
  }

  export type QueryScalarWhereWithAggregatesInput = {
    AND?: QueryScalarWhereWithAggregatesInput | QueryScalarWhereWithAggregatesInput[]
    OR?: QueryScalarWhereWithAggregatesInput[]
    NOT?: QueryScalarWhereWithAggregatesInput | QueryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Query"> | string
    userId?: StringWithAggregatesFilter<"Query"> | string
    response?: StringNullableWithAggregatesFilter<"Query"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Query"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Query"> | Date | string
    content?: StringWithAggregatesFilter<"Query"> | string
    status?: EnumQueryStatusWithAggregatesFilter<"Query"> | $Enums.QueryStatus
    conversationId?: StringNullableWithAggregatesFilter<"Query"> | string | null
    rating?: IntWithAggregatesFilter<"Query"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Query">
    lineGraphData?: JsonNullableWithAggregatesFilter<"Query">
    pieGraphData?: JsonNullableWithAggregatesFilter<"Query">
  }

  export type SproutFacebookAnalyticsWhereInput = {
    AND?: SproutFacebookAnalyticsWhereInput | SproutFacebookAnalyticsWhereInput[]
    OR?: SproutFacebookAnalyticsWhereInput[]
    NOT?: SproutFacebookAnalyticsWhereInput | SproutFacebookAnalyticsWhereInput[]
    id?: StringFilter<"SproutFacebookAnalytics"> | string
    sproutSocialAccountId?: StringFilter<"SproutFacebookAnalytics"> | string
    customerProfileId?: IntFilter<"SproutFacebookAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutFacebookAnalytics"> | Date | string
    engagements?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    impressionsUnique?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    followersCount?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postContentClicks?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postContentClicksOther?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postLinkClicks?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postPhotoViewClicks?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    tabViews?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViews?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViews10s?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsOrganic?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsPaid?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsUnique?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutFacebookAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutFacebookAnalytics"> | Date | string
    netFollowerGrowth?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
  }

  export type SproutFacebookAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    engagements?: SortOrderInput | SortOrder
    impressions?: SortOrderInput | SortOrder
    impressionsUnique?: SortOrderInput | SortOrder
    followersCount?: SortOrderInput | SortOrder
    postContentClicks?: SortOrderInput | SortOrder
    postContentClicksOther?: SortOrderInput | SortOrder
    postLinkClicks?: SortOrderInput | SortOrder
    postPhotoViewClicks?: SortOrderInput | SortOrder
    tabViews?: SortOrderInput | SortOrder
    videoViews?: SortOrderInput | SortOrder
    videoViews10s?: SortOrderInput | SortOrder
    videoViewsOrganic?: SortOrderInput | SortOrder
    videoViewsPaid?: SortOrderInput | SortOrder
    videoViewsUnique?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    netFollowerGrowth?: SortOrderInput | SortOrder
    sproutSocialAccount?: SproutSocialAccountOrderByWithRelationInput
  }

  export type SproutFacebookAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerProfileId_reportingDate?: SproutFacebookAnalyticsCustomerProfileIdReportingDateCompoundUniqueInput
    AND?: SproutFacebookAnalyticsWhereInput | SproutFacebookAnalyticsWhereInput[]
    OR?: SproutFacebookAnalyticsWhereInput[]
    NOT?: SproutFacebookAnalyticsWhereInput | SproutFacebookAnalyticsWhereInput[]
    sproutSocialAccountId?: StringFilter<"SproutFacebookAnalytics"> | string
    customerProfileId?: IntFilter<"SproutFacebookAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutFacebookAnalytics"> | Date | string
    engagements?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    impressionsUnique?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    followersCount?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postContentClicks?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postContentClicksOther?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postLinkClicks?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postPhotoViewClicks?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    tabViews?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViews?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViews10s?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsOrganic?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsPaid?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsUnique?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutFacebookAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutFacebookAnalytics"> | Date | string
    netFollowerGrowth?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
  }, "id" | "customerProfileId_reportingDate">

  export type SproutFacebookAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    engagements?: SortOrderInput | SortOrder
    impressions?: SortOrderInput | SortOrder
    impressionsUnique?: SortOrderInput | SortOrder
    followersCount?: SortOrderInput | SortOrder
    postContentClicks?: SortOrderInput | SortOrder
    postContentClicksOther?: SortOrderInput | SortOrder
    postLinkClicks?: SortOrderInput | SortOrder
    postPhotoViewClicks?: SortOrderInput | SortOrder
    tabViews?: SortOrderInput | SortOrder
    videoViews?: SortOrderInput | SortOrder
    videoViews10s?: SortOrderInput | SortOrder
    videoViewsOrganic?: SortOrderInput | SortOrder
    videoViewsPaid?: SortOrderInput | SortOrder
    videoViewsUnique?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    netFollowerGrowth?: SortOrderInput | SortOrder
    _count?: SproutFacebookAnalyticsCountOrderByAggregateInput
    _avg?: SproutFacebookAnalyticsAvgOrderByAggregateInput
    _max?: SproutFacebookAnalyticsMaxOrderByAggregateInput
    _min?: SproutFacebookAnalyticsMinOrderByAggregateInput
    _sum?: SproutFacebookAnalyticsSumOrderByAggregateInput
  }

  export type SproutFacebookAnalyticsScalarWhereWithAggregatesInput = {
    AND?: SproutFacebookAnalyticsScalarWhereWithAggregatesInput | SproutFacebookAnalyticsScalarWhereWithAggregatesInput[]
    OR?: SproutFacebookAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: SproutFacebookAnalyticsScalarWhereWithAggregatesInput | SproutFacebookAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SproutFacebookAnalytics"> | string
    sproutSocialAccountId?: StringWithAggregatesFilter<"SproutFacebookAnalytics"> | string
    customerProfileId?: IntWithAggregatesFilter<"SproutFacebookAnalytics"> | number
    reportingDate?: DateTimeWithAggregatesFilter<"SproutFacebookAnalytics"> | Date | string
    engagements?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    impressions?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    impressionsUnique?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    followersCount?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    postContentClicks?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    postContentClicksOther?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    postLinkClicks?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    postPhotoViewClicks?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    tabViews?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    videoViews?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    videoViews10s?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsOrganic?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsPaid?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsUnique?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SproutFacebookAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SproutFacebookAnalytics"> | Date | string
    netFollowerGrowth?: IntNullableWithAggregatesFilter<"SproutFacebookAnalytics"> | number | null
  }

  export type SproutFacebookPostWhereInput = {
    AND?: SproutFacebookPostWhereInput | SproutFacebookPostWhereInput[]
    OR?: SproutFacebookPostWhereInput[]
    NOT?: SproutFacebookPostWhereInput | SproutFacebookPostWhereInput[]
    id?: StringFilter<"SproutFacebookPost"> | string
    sproutSocialAccountId?: StringFilter<"SproutFacebookPost"> | string
    postType?: StringFilter<"SproutFacebookPost"> | string
    postStatus?: StringFilter<"SproutFacebookPost"> | string
    postLink?: StringFilter<"SproutFacebookPost"> | string
    postText?: StringFilter<"SproutFacebookPost"> | string
    postNativeId?: StringFilter<"SproutFacebookPost"> | string
    postCreatedTime?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    postSentTime?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    postLastUpdated?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    createdAt?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    updatedAt?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
  }

  export type SproutFacebookPostOrderByWithRelationInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    postType?: SortOrder
    postStatus?: SortOrder
    postLink?: SortOrder
    postText?: SortOrder
    postNativeId?: SortOrder
    postCreatedTime?: SortOrder
    postSentTime?: SortOrder
    postLastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sproutSocialAccount?: SproutSocialAccountOrderByWithRelationInput
  }

  export type SproutFacebookPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sproutSocialAccountId_postNativeId?: SproutFacebookPostSproutSocialAccountIdPostNativeIdCompoundUniqueInput
    AND?: SproutFacebookPostWhereInput | SproutFacebookPostWhereInput[]
    OR?: SproutFacebookPostWhereInput[]
    NOT?: SproutFacebookPostWhereInput | SproutFacebookPostWhereInput[]
    sproutSocialAccountId?: StringFilter<"SproutFacebookPost"> | string
    postType?: StringFilter<"SproutFacebookPost"> | string
    postStatus?: StringFilter<"SproutFacebookPost"> | string
    postLink?: StringFilter<"SproutFacebookPost"> | string
    postText?: StringFilter<"SproutFacebookPost"> | string
    postNativeId?: StringFilter<"SproutFacebookPost"> | string
    postCreatedTime?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    postSentTime?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    postLastUpdated?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    createdAt?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    updatedAt?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
  }, "id" | "sproutSocialAccountId_postNativeId">

  export type SproutFacebookPostOrderByWithAggregationInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    postType?: SortOrder
    postStatus?: SortOrder
    postLink?: SortOrder
    postText?: SortOrder
    postNativeId?: SortOrder
    postCreatedTime?: SortOrder
    postSentTime?: SortOrder
    postLastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SproutFacebookPostCountOrderByAggregateInput
    _max?: SproutFacebookPostMaxOrderByAggregateInput
    _min?: SproutFacebookPostMinOrderByAggregateInput
  }

  export type SproutFacebookPostScalarWhereWithAggregatesInput = {
    AND?: SproutFacebookPostScalarWhereWithAggregatesInput | SproutFacebookPostScalarWhereWithAggregatesInput[]
    OR?: SproutFacebookPostScalarWhereWithAggregatesInput[]
    NOT?: SproutFacebookPostScalarWhereWithAggregatesInput | SproutFacebookPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SproutFacebookPost"> | string
    sproutSocialAccountId?: StringWithAggregatesFilter<"SproutFacebookPost"> | string
    postType?: StringWithAggregatesFilter<"SproutFacebookPost"> | string
    postStatus?: StringWithAggregatesFilter<"SproutFacebookPost"> | string
    postLink?: StringWithAggregatesFilter<"SproutFacebookPost"> | string
    postText?: StringWithAggregatesFilter<"SproutFacebookPost"> | string
    postNativeId?: StringWithAggregatesFilter<"SproutFacebookPost"> | string
    postCreatedTime?: DateTimeWithAggregatesFilter<"SproutFacebookPost"> | Date | string
    postSentTime?: DateTimeWithAggregatesFilter<"SproutFacebookPost"> | Date | string
    postLastUpdated?: DateTimeWithAggregatesFilter<"SproutFacebookPost"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SproutFacebookPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SproutFacebookPost"> | Date | string
  }

  export type SproutFacebookPostAnalyticsWhereInput = {
    AND?: SproutFacebookPostAnalyticsWhereInput | SproutFacebookPostAnalyticsWhereInput[]
    OR?: SproutFacebookPostAnalyticsWhereInput[]
    NOT?: SproutFacebookPostAnalyticsWhereInput | SproutFacebookPostAnalyticsWhereInput[]
    id?: StringFilter<"SproutFacebookPostAnalytics"> | string
    angryReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    clientNativeId?: StringFilter<"SproutFacebookPostAnalytics"> | string
    commentsCount?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    hahaReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsFollower?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsNonFollower?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsNonViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsOrganic?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsPaid?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    likes?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    loveReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postContentClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postContentClicksOther?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postLinkClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postNativeId?: StringFilter<"SproutFacebookPostAnalytics"> | string
    postPhotoViewClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postVideoPlayClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    questionAnswers?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reach?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachFollower?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachNonViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachOrganic?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachPaid?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reportingDate?: DateTimeFilter<"SproutFacebookPostAnalytics"> | Date | string
    sadReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    sharesCount?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    sproutSocialAccountId?: StringFilter<"SproutFacebookPostAnalytics"> | string
    videoLength?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViews?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsAutoplay?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsOrganic?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsPaid?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    wowReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutFacebookPostAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutFacebookPostAnalytics"> | Date | string
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
  }

  export type SproutFacebookPostAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    angryReactions?: SortOrderInput | SortOrder
    clientNativeId?: SortOrder
    commentsCount?: SortOrderInput | SortOrder
    hahaReactions?: SortOrderInput | SortOrder
    impressions?: SortOrderInput | SortOrder
    impressionsFollower?: SortOrderInput | SortOrder
    impressionsNonFollower?: SortOrderInput | SortOrder
    impressionsNonViral?: SortOrderInput | SortOrder
    impressionsOrganic?: SortOrderInput | SortOrder
    impressionsPaid?: SortOrderInput | SortOrder
    impressionsViral?: SortOrderInput | SortOrder
    likes?: SortOrderInput | SortOrder
    loveReactions?: SortOrderInput | SortOrder
    postContentClicks?: SortOrderInput | SortOrder
    postContentClicksOther?: SortOrderInput | SortOrder
    postLinkClicks?: SortOrderInput | SortOrder
    postNativeId?: SortOrder
    postPhotoViewClicks?: SortOrderInput | SortOrder
    postVideoPlayClicks?: SortOrderInput | SortOrder
    questionAnswers?: SortOrderInput | SortOrder
    reach?: SortOrderInput | SortOrder
    reachFollower?: SortOrderInput | SortOrder
    reachNonViral?: SortOrderInput | SortOrder
    reachOrganic?: SortOrderInput | SortOrder
    reachPaid?: SortOrderInput | SortOrder
    reachViral?: SortOrderInput | SortOrder
    reactions?: SortOrderInput | SortOrder
    reportingDate?: SortOrder
    sadReactions?: SortOrderInput | SortOrder
    sharesCount?: SortOrderInput | SortOrder
    sproutSocialAccountId?: SortOrder
    videoLength?: SortOrderInput | SortOrder
    videoViews?: SortOrderInput | SortOrder
    videoViewsAutoplay?: SortOrderInput | SortOrder
    videoViewsOrganic?: SortOrderInput | SortOrder
    videoViewsPaid?: SortOrderInput | SortOrder
    wowReactions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sproutSocialAccount?: SproutSocialAccountOrderByWithRelationInput
  }

  export type SproutFacebookPostAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postNativeId_reportingDate?: SproutFacebookPostAnalyticsPostNativeIdReportingDateCompoundUniqueInput
    AND?: SproutFacebookPostAnalyticsWhereInput | SproutFacebookPostAnalyticsWhereInput[]
    OR?: SproutFacebookPostAnalyticsWhereInput[]
    NOT?: SproutFacebookPostAnalyticsWhereInput | SproutFacebookPostAnalyticsWhereInput[]
    angryReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    clientNativeId?: StringFilter<"SproutFacebookPostAnalytics"> | string
    commentsCount?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    hahaReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsFollower?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsNonFollower?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsNonViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsOrganic?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsPaid?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    likes?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    loveReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postContentClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postContentClicksOther?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postLinkClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postNativeId?: StringFilter<"SproutFacebookPostAnalytics"> | string
    postPhotoViewClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postVideoPlayClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    questionAnswers?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reach?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachFollower?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachNonViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachOrganic?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachPaid?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reportingDate?: DateTimeFilter<"SproutFacebookPostAnalytics"> | Date | string
    sadReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    sharesCount?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    sproutSocialAccountId?: StringFilter<"SproutFacebookPostAnalytics"> | string
    videoLength?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViews?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsAutoplay?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsOrganic?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsPaid?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    wowReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutFacebookPostAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutFacebookPostAnalytics"> | Date | string
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
  }, "id" | "postNativeId_reportingDate">

  export type SproutFacebookPostAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    angryReactions?: SortOrderInput | SortOrder
    clientNativeId?: SortOrder
    commentsCount?: SortOrderInput | SortOrder
    hahaReactions?: SortOrderInput | SortOrder
    impressions?: SortOrderInput | SortOrder
    impressionsFollower?: SortOrderInput | SortOrder
    impressionsNonFollower?: SortOrderInput | SortOrder
    impressionsNonViral?: SortOrderInput | SortOrder
    impressionsOrganic?: SortOrderInput | SortOrder
    impressionsPaid?: SortOrderInput | SortOrder
    impressionsViral?: SortOrderInput | SortOrder
    likes?: SortOrderInput | SortOrder
    loveReactions?: SortOrderInput | SortOrder
    postContentClicks?: SortOrderInput | SortOrder
    postContentClicksOther?: SortOrderInput | SortOrder
    postLinkClicks?: SortOrderInput | SortOrder
    postNativeId?: SortOrder
    postPhotoViewClicks?: SortOrderInput | SortOrder
    postVideoPlayClicks?: SortOrderInput | SortOrder
    questionAnswers?: SortOrderInput | SortOrder
    reach?: SortOrderInput | SortOrder
    reachFollower?: SortOrderInput | SortOrder
    reachNonViral?: SortOrderInput | SortOrder
    reachOrganic?: SortOrderInput | SortOrder
    reachPaid?: SortOrderInput | SortOrder
    reachViral?: SortOrderInput | SortOrder
    reactions?: SortOrderInput | SortOrder
    reportingDate?: SortOrder
    sadReactions?: SortOrderInput | SortOrder
    sharesCount?: SortOrderInput | SortOrder
    sproutSocialAccountId?: SortOrder
    videoLength?: SortOrderInput | SortOrder
    videoViews?: SortOrderInput | SortOrder
    videoViewsAutoplay?: SortOrderInput | SortOrder
    videoViewsOrganic?: SortOrderInput | SortOrder
    videoViewsPaid?: SortOrderInput | SortOrder
    wowReactions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SproutFacebookPostAnalyticsCountOrderByAggregateInput
    _avg?: SproutFacebookPostAnalyticsAvgOrderByAggregateInput
    _max?: SproutFacebookPostAnalyticsMaxOrderByAggregateInput
    _min?: SproutFacebookPostAnalyticsMinOrderByAggregateInput
    _sum?: SproutFacebookPostAnalyticsSumOrderByAggregateInput
  }

  export type SproutFacebookPostAnalyticsScalarWhereWithAggregatesInput = {
    AND?: SproutFacebookPostAnalyticsScalarWhereWithAggregatesInput | SproutFacebookPostAnalyticsScalarWhereWithAggregatesInput[]
    OR?: SproutFacebookPostAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: SproutFacebookPostAnalyticsScalarWhereWithAggregatesInput | SproutFacebookPostAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SproutFacebookPostAnalytics"> | string
    angryReactions?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    clientNativeId?: StringWithAggregatesFilter<"SproutFacebookPostAnalytics"> | string
    commentsCount?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    hahaReactions?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    impressions?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsFollower?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsNonFollower?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsNonViral?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsOrganic?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsPaid?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsViral?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    likes?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    loveReactions?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    postContentClicks?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    postContentClicksOther?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    postLinkClicks?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    postNativeId?: StringWithAggregatesFilter<"SproutFacebookPostAnalytics"> | string
    postPhotoViewClicks?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    postVideoPlayClicks?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    questionAnswers?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    reach?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    reachFollower?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    reachNonViral?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    reachOrganic?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    reachPaid?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    reachViral?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    reactions?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    reportingDate?: DateTimeWithAggregatesFilter<"SproutFacebookPostAnalytics"> | Date | string
    sadReactions?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    sharesCount?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    sproutSocialAccountId?: StringWithAggregatesFilter<"SproutFacebookPostAnalytics"> | string
    videoLength?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViews?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsAutoplay?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsOrganic?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsPaid?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    wowReactions?: IntNullableWithAggregatesFilter<"SproutFacebookPostAnalytics"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SproutFacebookPostAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SproutFacebookPostAnalytics"> | Date | string
  }

  export type SproutInstagramAnalyticsWhereInput = {
    AND?: SproutInstagramAnalyticsWhereInput | SproutInstagramAnalyticsWhereInput[]
    OR?: SproutInstagramAnalyticsWhereInput[]
    NOT?: SproutInstagramAnalyticsWhereInput | SproutInstagramAnalyticsWhereInput[]
    id?: StringFilter<"SproutInstagramAnalytics"> | string
    sproutSocialAccountId?: StringFilter<"SproutInstagramAnalytics"> | string
    customerProfileId?: IntFilter<"SproutInstagramAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutInstagramAnalytics"> | Date | string
    commentsCount?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    engagements?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    impressionsUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    followersCount?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    likes?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    saves?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    videoViews?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutInstagramAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutInstagramAnalytics"> | Date | string
    emailContacts?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    getDirectionsClicks?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    phoneCallClicks?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    postsSendByContentType?: JsonNullableFilter<"SproutInstagramAnalytics">
    postsSentByPostType?: JsonNullableFilter<"SproutInstagramAnalytics">
    postsSentCount?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileFollowerAdds?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileFollowers?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileImpressionsUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileReachUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileViews?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileViewsUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    websiteClicks?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
    followersByCity?: SproutInstagramFollowersByCityListRelationFilter
    followersByCountry?: SproutInstagramFollowersByCountryListRelationFilter
  }

  export type SproutInstagramAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    commentsCount?: SortOrderInput | SortOrder
    engagements?: SortOrderInput | SortOrder
    impressions?: SortOrderInput | SortOrder
    impressionsUnique?: SortOrderInput | SortOrder
    followersCount?: SortOrderInput | SortOrder
    likes?: SortOrderInput | SortOrder
    saves?: SortOrderInput | SortOrder
    videoViews?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailContacts?: SortOrderInput | SortOrder
    getDirectionsClicks?: SortOrderInput | SortOrder
    phoneCallClicks?: SortOrderInput | SortOrder
    postsSendByContentType?: SortOrderInput | SortOrder
    postsSentByPostType?: SortOrderInput | SortOrder
    postsSentCount?: SortOrderInput | SortOrder
    profileFollowerAdds?: SortOrderInput | SortOrder
    profileFollowers?: SortOrderInput | SortOrder
    profileImpressionsUnique?: SortOrderInput | SortOrder
    profileReachUnique?: SortOrderInput | SortOrder
    profileViews?: SortOrderInput | SortOrder
    profileViewsUnique?: SortOrderInput | SortOrder
    websiteClicks?: SortOrderInput | SortOrder
    sproutSocialAccount?: SproutSocialAccountOrderByWithRelationInput
    followersByCity?: SproutInstagramFollowersByCityOrderByRelationAggregateInput
    followersByCountry?: SproutInstagramFollowersByCountryOrderByRelationAggregateInput
  }

  export type SproutInstagramAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerProfileId_reportingDate?: SproutInstagramAnalyticsCustomerProfileIdReportingDateCompoundUniqueInput
    AND?: SproutInstagramAnalyticsWhereInput | SproutInstagramAnalyticsWhereInput[]
    OR?: SproutInstagramAnalyticsWhereInput[]
    NOT?: SproutInstagramAnalyticsWhereInput | SproutInstagramAnalyticsWhereInput[]
    sproutSocialAccountId?: StringFilter<"SproutInstagramAnalytics"> | string
    customerProfileId?: IntFilter<"SproutInstagramAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutInstagramAnalytics"> | Date | string
    commentsCount?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    engagements?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    impressionsUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    followersCount?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    likes?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    saves?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    videoViews?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutInstagramAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutInstagramAnalytics"> | Date | string
    emailContacts?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    getDirectionsClicks?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    phoneCallClicks?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    postsSendByContentType?: JsonNullableFilter<"SproutInstagramAnalytics">
    postsSentByPostType?: JsonNullableFilter<"SproutInstagramAnalytics">
    postsSentCount?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileFollowerAdds?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileFollowers?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileImpressionsUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileReachUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileViews?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileViewsUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    websiteClicks?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
    followersByCity?: SproutInstagramFollowersByCityListRelationFilter
    followersByCountry?: SproutInstagramFollowersByCountryListRelationFilter
  }, "id" | "customerProfileId_reportingDate">

  export type SproutInstagramAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    commentsCount?: SortOrderInput | SortOrder
    engagements?: SortOrderInput | SortOrder
    impressions?: SortOrderInput | SortOrder
    impressionsUnique?: SortOrderInput | SortOrder
    followersCount?: SortOrderInput | SortOrder
    likes?: SortOrderInput | SortOrder
    saves?: SortOrderInput | SortOrder
    videoViews?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailContacts?: SortOrderInput | SortOrder
    getDirectionsClicks?: SortOrderInput | SortOrder
    phoneCallClicks?: SortOrderInput | SortOrder
    postsSendByContentType?: SortOrderInput | SortOrder
    postsSentByPostType?: SortOrderInput | SortOrder
    postsSentCount?: SortOrderInput | SortOrder
    profileFollowerAdds?: SortOrderInput | SortOrder
    profileFollowers?: SortOrderInput | SortOrder
    profileImpressionsUnique?: SortOrderInput | SortOrder
    profileReachUnique?: SortOrderInput | SortOrder
    profileViews?: SortOrderInput | SortOrder
    profileViewsUnique?: SortOrderInput | SortOrder
    websiteClicks?: SortOrderInput | SortOrder
    _count?: SproutInstagramAnalyticsCountOrderByAggregateInput
    _avg?: SproutInstagramAnalyticsAvgOrderByAggregateInput
    _max?: SproutInstagramAnalyticsMaxOrderByAggregateInput
    _min?: SproutInstagramAnalyticsMinOrderByAggregateInput
    _sum?: SproutInstagramAnalyticsSumOrderByAggregateInput
  }

  export type SproutInstagramAnalyticsScalarWhereWithAggregatesInput = {
    AND?: SproutInstagramAnalyticsScalarWhereWithAggregatesInput | SproutInstagramAnalyticsScalarWhereWithAggregatesInput[]
    OR?: SproutInstagramAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: SproutInstagramAnalyticsScalarWhereWithAggregatesInput | SproutInstagramAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SproutInstagramAnalytics"> | string
    sproutSocialAccountId?: StringWithAggregatesFilter<"SproutInstagramAnalytics"> | string
    customerProfileId?: IntWithAggregatesFilter<"SproutInstagramAnalytics"> | number
    reportingDate?: DateTimeWithAggregatesFilter<"SproutInstagramAnalytics"> | Date | string
    commentsCount?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    engagements?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    impressions?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    impressionsUnique?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    followersCount?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    likes?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    saves?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    videoViews?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SproutInstagramAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SproutInstagramAnalytics"> | Date | string
    emailContacts?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    getDirectionsClicks?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    phoneCallClicks?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    postsSendByContentType?: JsonNullableWithAggregatesFilter<"SproutInstagramAnalytics">
    postsSentByPostType?: JsonNullableWithAggregatesFilter<"SproutInstagramAnalytics">
    postsSentCount?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    profileFollowerAdds?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    profileFollowers?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    profileImpressionsUnique?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    profileReachUnique?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    profileViews?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    profileViewsUnique?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
    websiteClicks?: IntNullableWithAggregatesFilter<"SproutInstagramAnalytics"> | number | null
  }

  export type SproutInstagramFollowersByCityWhereInput = {
    AND?: SproutInstagramFollowersByCityWhereInput | SproutInstagramFollowersByCityWhereInput[]
    OR?: SproutInstagramFollowersByCityWhereInput[]
    NOT?: SproutInstagramFollowersByCityWhereInput | SproutInstagramFollowersByCityWhereInput[]
    id?: StringFilter<"SproutInstagramFollowersByCity"> | string
    sproutInstagramAnalyticsId?: StringFilter<"SproutInstagramFollowersByCity"> | string
    city?: StringFilter<"SproutInstagramFollowersByCity"> | string
    count?: IntFilter<"SproutInstagramFollowersByCity"> | number
    createdAt?: DateTimeFilter<"SproutInstagramFollowersByCity"> | Date | string
    updatedAt?: DateTimeFilter<"SproutInstagramFollowersByCity"> | Date | string
    sproutInstagramAnalytics?: XOR<SproutInstagramAnalyticsScalarRelationFilter, SproutInstagramAnalyticsWhereInput>
  }

  export type SproutInstagramFollowersByCityOrderByWithRelationInput = {
    id?: SortOrder
    sproutInstagramAnalyticsId?: SortOrder
    city?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sproutInstagramAnalytics?: SproutInstagramAnalyticsOrderByWithRelationInput
  }

  export type SproutInstagramFollowersByCityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sproutInstagramAnalyticsId_city?: SproutInstagramFollowersByCitySproutInstagramAnalyticsIdCityCompoundUniqueInput
    AND?: SproutInstagramFollowersByCityWhereInput | SproutInstagramFollowersByCityWhereInput[]
    OR?: SproutInstagramFollowersByCityWhereInput[]
    NOT?: SproutInstagramFollowersByCityWhereInput | SproutInstagramFollowersByCityWhereInput[]
    sproutInstagramAnalyticsId?: StringFilter<"SproutInstagramFollowersByCity"> | string
    city?: StringFilter<"SproutInstagramFollowersByCity"> | string
    count?: IntFilter<"SproutInstagramFollowersByCity"> | number
    createdAt?: DateTimeFilter<"SproutInstagramFollowersByCity"> | Date | string
    updatedAt?: DateTimeFilter<"SproutInstagramFollowersByCity"> | Date | string
    sproutInstagramAnalytics?: XOR<SproutInstagramAnalyticsScalarRelationFilter, SproutInstagramAnalyticsWhereInput>
  }, "id" | "sproutInstagramAnalyticsId_city">

  export type SproutInstagramFollowersByCityOrderByWithAggregationInput = {
    id?: SortOrder
    sproutInstagramAnalyticsId?: SortOrder
    city?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SproutInstagramFollowersByCityCountOrderByAggregateInput
    _avg?: SproutInstagramFollowersByCityAvgOrderByAggregateInput
    _max?: SproutInstagramFollowersByCityMaxOrderByAggregateInput
    _min?: SproutInstagramFollowersByCityMinOrderByAggregateInput
    _sum?: SproutInstagramFollowersByCitySumOrderByAggregateInput
  }

  export type SproutInstagramFollowersByCityScalarWhereWithAggregatesInput = {
    AND?: SproutInstagramFollowersByCityScalarWhereWithAggregatesInput | SproutInstagramFollowersByCityScalarWhereWithAggregatesInput[]
    OR?: SproutInstagramFollowersByCityScalarWhereWithAggregatesInput[]
    NOT?: SproutInstagramFollowersByCityScalarWhereWithAggregatesInput | SproutInstagramFollowersByCityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SproutInstagramFollowersByCity"> | string
    sproutInstagramAnalyticsId?: StringWithAggregatesFilter<"SproutInstagramFollowersByCity"> | string
    city?: StringWithAggregatesFilter<"SproutInstagramFollowersByCity"> | string
    count?: IntWithAggregatesFilter<"SproutInstagramFollowersByCity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SproutInstagramFollowersByCity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SproutInstagramFollowersByCity"> | Date | string
  }

  export type SproutInstagramFollowersByCountryWhereInput = {
    AND?: SproutInstagramFollowersByCountryWhereInput | SproutInstagramFollowersByCountryWhereInput[]
    OR?: SproutInstagramFollowersByCountryWhereInput[]
    NOT?: SproutInstagramFollowersByCountryWhereInput | SproutInstagramFollowersByCountryWhereInput[]
    id?: StringFilter<"SproutInstagramFollowersByCountry"> | string
    sproutInstagramAnalyticsId?: StringFilter<"SproutInstagramFollowersByCountry"> | string
    country?: StringFilter<"SproutInstagramFollowersByCountry"> | string
    count?: IntFilter<"SproutInstagramFollowersByCountry"> | number
    createdAt?: DateTimeFilter<"SproutInstagramFollowersByCountry"> | Date | string
    updatedAt?: DateTimeFilter<"SproutInstagramFollowersByCountry"> | Date | string
    sproutInstagramAnalytics?: XOR<SproutInstagramAnalyticsScalarRelationFilter, SproutInstagramAnalyticsWhereInput>
  }

  export type SproutInstagramFollowersByCountryOrderByWithRelationInput = {
    id?: SortOrder
    sproutInstagramAnalyticsId?: SortOrder
    country?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sproutInstagramAnalytics?: SproutInstagramAnalyticsOrderByWithRelationInput
  }

  export type SproutInstagramFollowersByCountryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sproutInstagramAnalyticsId_country?: SproutInstagramFollowersByCountrySproutInstagramAnalyticsIdCountryCompoundUniqueInput
    AND?: SproutInstagramFollowersByCountryWhereInput | SproutInstagramFollowersByCountryWhereInput[]
    OR?: SproutInstagramFollowersByCountryWhereInput[]
    NOT?: SproutInstagramFollowersByCountryWhereInput | SproutInstagramFollowersByCountryWhereInput[]
    sproutInstagramAnalyticsId?: StringFilter<"SproutInstagramFollowersByCountry"> | string
    country?: StringFilter<"SproutInstagramFollowersByCountry"> | string
    count?: IntFilter<"SproutInstagramFollowersByCountry"> | number
    createdAt?: DateTimeFilter<"SproutInstagramFollowersByCountry"> | Date | string
    updatedAt?: DateTimeFilter<"SproutInstagramFollowersByCountry"> | Date | string
    sproutInstagramAnalytics?: XOR<SproutInstagramAnalyticsScalarRelationFilter, SproutInstagramAnalyticsWhereInput>
  }, "id" | "sproutInstagramAnalyticsId_country">

  export type SproutInstagramFollowersByCountryOrderByWithAggregationInput = {
    id?: SortOrder
    sproutInstagramAnalyticsId?: SortOrder
    country?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SproutInstagramFollowersByCountryCountOrderByAggregateInput
    _avg?: SproutInstagramFollowersByCountryAvgOrderByAggregateInput
    _max?: SproutInstagramFollowersByCountryMaxOrderByAggregateInput
    _min?: SproutInstagramFollowersByCountryMinOrderByAggregateInput
    _sum?: SproutInstagramFollowersByCountrySumOrderByAggregateInput
  }

  export type SproutInstagramFollowersByCountryScalarWhereWithAggregatesInput = {
    AND?: SproutInstagramFollowersByCountryScalarWhereWithAggregatesInput | SproutInstagramFollowersByCountryScalarWhereWithAggregatesInput[]
    OR?: SproutInstagramFollowersByCountryScalarWhereWithAggregatesInput[]
    NOT?: SproutInstagramFollowersByCountryScalarWhereWithAggregatesInput | SproutInstagramFollowersByCountryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SproutInstagramFollowersByCountry"> | string
    sproutInstagramAnalyticsId?: StringWithAggregatesFilter<"SproutInstagramFollowersByCountry"> | string
    country?: StringWithAggregatesFilter<"SproutInstagramFollowersByCountry"> | string
    count?: IntWithAggregatesFilter<"SproutInstagramFollowersByCountry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SproutInstagramFollowersByCountry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SproutInstagramFollowersByCountry"> | Date | string
  }

  export type SproutLinkedInAnalyticsWhereInput = {
    AND?: SproutLinkedInAnalyticsWhereInput | SproutLinkedInAnalyticsWhereInput[]
    OR?: SproutLinkedInAnalyticsWhereInput[]
    NOT?: SproutLinkedInAnalyticsWhereInput | SproutLinkedInAnalyticsWhereInput[]
    id?: StringFilter<"SproutLinkedInAnalytics"> | string
    sproutSocialAccountId?: StringFilter<"SproutLinkedInAnalytics"> | string
    customerProfileId?: IntFilter<"SproutLinkedInAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutLinkedInAnalytics"> | Date | string
    engagements?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    impressionsUnique?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    followersCount?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    reactions?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutLinkedInAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutLinkedInAnalytics"> | Date | string
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
  }

  export type SproutLinkedInAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    engagements?: SortOrderInput | SortOrder
    impressions?: SortOrderInput | SortOrder
    impressionsUnique?: SortOrderInput | SortOrder
    followersCount?: SortOrderInput | SortOrder
    reactions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sproutSocialAccount?: SproutSocialAccountOrderByWithRelationInput
  }

  export type SproutLinkedInAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerProfileId_reportingDate?: SproutLinkedInAnalyticsCustomerProfileIdReportingDateCompoundUniqueInput
    AND?: SproutLinkedInAnalyticsWhereInput | SproutLinkedInAnalyticsWhereInput[]
    OR?: SproutLinkedInAnalyticsWhereInput[]
    NOT?: SproutLinkedInAnalyticsWhereInput | SproutLinkedInAnalyticsWhereInput[]
    sproutSocialAccountId?: StringFilter<"SproutLinkedInAnalytics"> | string
    customerProfileId?: IntFilter<"SproutLinkedInAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutLinkedInAnalytics"> | Date | string
    engagements?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    impressionsUnique?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    followersCount?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    reactions?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutLinkedInAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutLinkedInAnalytics"> | Date | string
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
  }, "id" | "customerProfileId_reportingDate">

  export type SproutLinkedInAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    engagements?: SortOrderInput | SortOrder
    impressions?: SortOrderInput | SortOrder
    impressionsUnique?: SortOrderInput | SortOrder
    followersCount?: SortOrderInput | SortOrder
    reactions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SproutLinkedInAnalyticsCountOrderByAggregateInput
    _avg?: SproutLinkedInAnalyticsAvgOrderByAggregateInput
    _max?: SproutLinkedInAnalyticsMaxOrderByAggregateInput
    _min?: SproutLinkedInAnalyticsMinOrderByAggregateInput
    _sum?: SproutLinkedInAnalyticsSumOrderByAggregateInput
  }

  export type SproutLinkedInAnalyticsScalarWhereWithAggregatesInput = {
    AND?: SproutLinkedInAnalyticsScalarWhereWithAggregatesInput | SproutLinkedInAnalyticsScalarWhereWithAggregatesInput[]
    OR?: SproutLinkedInAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: SproutLinkedInAnalyticsScalarWhereWithAggregatesInput | SproutLinkedInAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SproutLinkedInAnalytics"> | string
    sproutSocialAccountId?: StringWithAggregatesFilter<"SproutLinkedInAnalytics"> | string
    customerProfileId?: IntWithAggregatesFilter<"SproutLinkedInAnalytics"> | number
    reportingDate?: DateTimeWithAggregatesFilter<"SproutLinkedInAnalytics"> | Date | string
    engagements?: IntNullableWithAggregatesFilter<"SproutLinkedInAnalytics"> | number | null
    impressions?: IntNullableWithAggregatesFilter<"SproutLinkedInAnalytics"> | number | null
    impressionsUnique?: IntNullableWithAggregatesFilter<"SproutLinkedInAnalytics"> | number | null
    followersCount?: IntNullableWithAggregatesFilter<"SproutLinkedInAnalytics"> | number | null
    reactions?: IntNullableWithAggregatesFilter<"SproutLinkedInAnalytics"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SproutLinkedInAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SproutLinkedInAnalytics"> | Date | string
  }

  export type SproutPinterestAnalyticsWhereInput = {
    AND?: SproutPinterestAnalyticsWhereInput | SproutPinterestAnalyticsWhereInput[]
    OR?: SproutPinterestAnalyticsWhereInput[]
    NOT?: SproutPinterestAnalyticsWhereInput | SproutPinterestAnalyticsWhereInput[]
    id?: StringFilter<"SproutPinterestAnalytics"> | string
    sproutSocialAccountId?: StringFilter<"SproutPinterestAnalytics"> | string
    customerProfileId?: IntFilter<"SproutPinterestAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutPinterestAnalytics"> | Date | string
    followersCount?: IntNullableFilter<"SproutPinterestAnalytics"> | number | null
    followingCount?: IntNullableFilter<"SproutPinterestAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutPinterestAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutPinterestAnalytics"> | Date | string
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
  }

  export type SproutPinterestAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    followersCount?: SortOrderInput | SortOrder
    followingCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sproutSocialAccount?: SproutSocialAccountOrderByWithRelationInput
  }

  export type SproutPinterestAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SproutPinterestAnalyticsWhereInput | SproutPinterestAnalyticsWhereInput[]
    OR?: SproutPinterestAnalyticsWhereInput[]
    NOT?: SproutPinterestAnalyticsWhereInput | SproutPinterestAnalyticsWhereInput[]
    sproutSocialAccountId?: StringFilter<"SproutPinterestAnalytics"> | string
    customerProfileId?: IntFilter<"SproutPinterestAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutPinterestAnalytics"> | Date | string
    followersCount?: IntNullableFilter<"SproutPinterestAnalytics"> | number | null
    followingCount?: IntNullableFilter<"SproutPinterestAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutPinterestAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutPinterestAnalytics"> | Date | string
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
  }, "id">

  export type SproutPinterestAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    followersCount?: SortOrderInput | SortOrder
    followingCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SproutPinterestAnalyticsCountOrderByAggregateInput
    _avg?: SproutPinterestAnalyticsAvgOrderByAggregateInput
    _max?: SproutPinterestAnalyticsMaxOrderByAggregateInput
    _min?: SproutPinterestAnalyticsMinOrderByAggregateInput
    _sum?: SproutPinterestAnalyticsSumOrderByAggregateInput
  }

  export type SproutPinterestAnalyticsScalarWhereWithAggregatesInput = {
    AND?: SproutPinterestAnalyticsScalarWhereWithAggregatesInput | SproutPinterestAnalyticsScalarWhereWithAggregatesInput[]
    OR?: SproutPinterestAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: SproutPinterestAnalyticsScalarWhereWithAggregatesInput | SproutPinterestAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SproutPinterestAnalytics"> | string
    sproutSocialAccountId?: StringWithAggregatesFilter<"SproutPinterestAnalytics"> | string
    customerProfileId?: IntWithAggregatesFilter<"SproutPinterestAnalytics"> | number
    reportingDate?: DateTimeWithAggregatesFilter<"SproutPinterestAnalytics"> | Date | string
    followersCount?: IntNullableWithAggregatesFilter<"SproutPinterestAnalytics"> | number | null
    followingCount?: IntNullableWithAggregatesFilter<"SproutPinterestAnalytics"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SproutPinterestAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SproutPinterestAnalytics"> | Date | string
  }

  export type SproutSocialAccountWhereInput = {
    AND?: SproutSocialAccountWhereInput | SproutSocialAccountWhereInput[]
    OR?: SproutSocialAccountWhereInput[]
    NOT?: SproutSocialAccountWhereInput | SproutSocialAccountWhereInput[]
    id?: StringFilter<"SproutSocialAccount"> | string
    customerProfileId?: IntFilter<"SproutSocialAccount"> | number
    networkType?: StringFilter<"SproutSocialAccount"> | string
    name?: StringFilter<"SproutSocialAccount"> | string
    nativeName?: StringFilter<"SproutSocialAccount"> | string
    link?: StringFilter<"SproutSocialAccount"> | string
    nativeId?: StringFilter<"SproutSocialAccount"> | string
    groups?: IntNullableListFilter<"SproutSocialAccount">
    createdAt?: DateTimeFilter<"SproutSocialAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SproutSocialAccount"> | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsListRelationFilter
    facebookPosts?: SproutFacebookPostListRelationFilter
    facebookPostAnalytics?: SproutFacebookPostAnalyticsListRelationFilter
    instagramAnalytics?: SproutInstagramAnalyticsListRelationFilter
    linkedInAnalytics?: SproutLinkedInAnalyticsListRelationFilter
    pinterestAnalytics?: SproutPinterestAnalyticsListRelationFilter
    users?: UserToSproutSocialAccountListRelationFilter
  }

  export type SproutSocialAccountOrderByWithRelationInput = {
    id?: SortOrder
    customerProfileId?: SortOrder
    networkType?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    link?: SortOrder
    nativeId?: SortOrder
    groups?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facebookAnalytics?: SproutFacebookAnalyticsOrderByRelationAggregateInput
    facebookPosts?: SproutFacebookPostOrderByRelationAggregateInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsOrderByRelationAggregateInput
    instagramAnalytics?: SproutInstagramAnalyticsOrderByRelationAggregateInput
    linkedInAnalytics?: SproutLinkedInAnalyticsOrderByRelationAggregateInput
    pinterestAnalytics?: SproutPinterestAnalyticsOrderByRelationAggregateInput
    users?: UserToSproutSocialAccountOrderByRelationAggregateInput
  }

  export type SproutSocialAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerProfileId?: number
    AND?: SproutSocialAccountWhereInput | SproutSocialAccountWhereInput[]
    OR?: SproutSocialAccountWhereInput[]
    NOT?: SproutSocialAccountWhereInput | SproutSocialAccountWhereInput[]
    networkType?: StringFilter<"SproutSocialAccount"> | string
    name?: StringFilter<"SproutSocialAccount"> | string
    nativeName?: StringFilter<"SproutSocialAccount"> | string
    link?: StringFilter<"SproutSocialAccount"> | string
    nativeId?: StringFilter<"SproutSocialAccount"> | string
    groups?: IntNullableListFilter<"SproutSocialAccount">
    createdAt?: DateTimeFilter<"SproutSocialAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SproutSocialAccount"> | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsListRelationFilter
    facebookPosts?: SproutFacebookPostListRelationFilter
    facebookPostAnalytics?: SproutFacebookPostAnalyticsListRelationFilter
    instagramAnalytics?: SproutInstagramAnalyticsListRelationFilter
    linkedInAnalytics?: SproutLinkedInAnalyticsListRelationFilter
    pinterestAnalytics?: SproutPinterestAnalyticsListRelationFilter
    users?: UserToSproutSocialAccountListRelationFilter
  }, "id" | "customerProfileId">

  export type SproutSocialAccountOrderByWithAggregationInput = {
    id?: SortOrder
    customerProfileId?: SortOrder
    networkType?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    link?: SortOrder
    nativeId?: SortOrder
    groups?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SproutSocialAccountCountOrderByAggregateInput
    _avg?: SproutSocialAccountAvgOrderByAggregateInput
    _max?: SproutSocialAccountMaxOrderByAggregateInput
    _min?: SproutSocialAccountMinOrderByAggregateInput
    _sum?: SproutSocialAccountSumOrderByAggregateInput
  }

  export type SproutSocialAccountScalarWhereWithAggregatesInput = {
    AND?: SproutSocialAccountScalarWhereWithAggregatesInput | SproutSocialAccountScalarWhereWithAggregatesInput[]
    OR?: SproutSocialAccountScalarWhereWithAggregatesInput[]
    NOT?: SproutSocialAccountScalarWhereWithAggregatesInput | SproutSocialAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SproutSocialAccount"> | string
    customerProfileId?: IntWithAggregatesFilter<"SproutSocialAccount"> | number
    networkType?: StringWithAggregatesFilter<"SproutSocialAccount"> | string
    name?: StringWithAggregatesFilter<"SproutSocialAccount"> | string
    nativeName?: StringWithAggregatesFilter<"SproutSocialAccount"> | string
    link?: StringWithAggregatesFilter<"SproutSocialAccount"> | string
    nativeId?: StringWithAggregatesFilter<"SproutSocialAccount"> | string
    groups?: IntNullableListFilter<"SproutSocialAccount">
    createdAt?: DateTimeWithAggregatesFilter<"SproutSocialAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SproutSocialAccount"> | Date | string
  }

  export type UserToSproutSocialAccountWhereInput = {
    AND?: UserToSproutSocialAccountWhereInput | UserToSproutSocialAccountWhereInput[]
    OR?: UserToSproutSocialAccountWhereInput[]
    NOT?: UserToSproutSocialAccountWhereInput | UserToSproutSocialAccountWhereInput[]
    id?: StringFilter<"UserToSproutSocialAccount"> | string
    userId?: StringFilter<"UserToSproutSocialAccount"> | string
    sproutSocialAccountId?: StringFilter<"UserToSproutSocialAccount"> | string
    createdAt?: DateTimeFilter<"UserToSproutSocialAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserToSproutSocialAccount"> | Date | string
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserToSproutSocialAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sproutSocialAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sproutSocialAccount?: SproutSocialAccountOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserToSproutSocialAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_sproutSocialAccountId?: UserToSproutSocialAccountUserIdSproutSocialAccountIdCompoundUniqueInput
    AND?: UserToSproutSocialAccountWhereInput | UserToSproutSocialAccountWhereInput[]
    OR?: UserToSproutSocialAccountWhereInput[]
    NOT?: UserToSproutSocialAccountWhereInput | UserToSproutSocialAccountWhereInput[]
    userId?: StringFilter<"UserToSproutSocialAccount"> | string
    sproutSocialAccountId?: StringFilter<"UserToSproutSocialAccount"> | string
    createdAt?: DateTimeFilter<"UserToSproutSocialAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserToSproutSocialAccount"> | Date | string
    sproutSocialAccount?: XOR<SproutSocialAccountScalarRelationFilter, SproutSocialAccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_sproutSocialAccountId">

  export type UserToSproutSocialAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sproutSocialAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserToSproutSocialAccountCountOrderByAggregateInput
    _max?: UserToSproutSocialAccountMaxOrderByAggregateInput
    _min?: UserToSproutSocialAccountMinOrderByAggregateInput
  }

  export type UserToSproutSocialAccountScalarWhereWithAggregatesInput = {
    AND?: UserToSproutSocialAccountScalarWhereWithAggregatesInput | UserToSproutSocialAccountScalarWhereWithAggregatesInput[]
    OR?: UserToSproutSocialAccountScalarWhereWithAggregatesInput[]
    NOT?: UserToSproutSocialAccountScalarWhereWithAggregatesInput | UserToSproutSocialAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserToSproutSocialAccount"> | string
    userId?: StringWithAggregatesFilter<"UserToSproutSocialAccount"> | string
    sproutSocialAccountId?: StringWithAggregatesFilter<"UserToSproutSocialAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserToSproutSocialAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserToSproutSocialAccount"> | Date | string
  }

  export type UserToGaAccountWhereInput = {
    AND?: UserToGaAccountWhereInput | UserToGaAccountWhereInput[]
    OR?: UserToGaAccountWhereInput[]
    NOT?: UserToGaAccountWhereInput | UserToGaAccountWhereInput[]
    id?: StringFilter<"UserToGaAccount"> | string
    userId?: StringFilter<"UserToGaAccount"> | string
    gaAccountId?: StringFilter<"UserToGaAccount"> | string
    createdAt?: DateTimeFilter<"UserToGaAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserToGaAccount"> | Date | string
    gaAccount?: XOR<GaAccountScalarRelationFilter, GaAccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserToGaAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gaAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gaAccount?: GaAccountOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserToGaAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_gaAccountId?: UserToGaAccountUserIdGaAccountIdCompoundUniqueInput
    AND?: UserToGaAccountWhereInput | UserToGaAccountWhereInput[]
    OR?: UserToGaAccountWhereInput[]
    NOT?: UserToGaAccountWhereInput | UserToGaAccountWhereInput[]
    userId?: StringFilter<"UserToGaAccount"> | string
    gaAccountId?: StringFilter<"UserToGaAccount"> | string
    createdAt?: DateTimeFilter<"UserToGaAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserToGaAccount"> | Date | string
    gaAccount?: XOR<GaAccountScalarRelationFilter, GaAccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_gaAccountId">

  export type UserToGaAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gaAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserToGaAccountCountOrderByAggregateInput
    _max?: UserToGaAccountMaxOrderByAggregateInput
    _min?: UserToGaAccountMinOrderByAggregateInput
  }

  export type UserToGaAccountScalarWhereWithAggregatesInput = {
    AND?: UserToGaAccountScalarWhereWithAggregatesInput | UserToGaAccountScalarWhereWithAggregatesInput[]
    OR?: UserToGaAccountScalarWhereWithAggregatesInput[]
    NOT?: UserToGaAccountScalarWhereWithAggregatesInput | UserToGaAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserToGaAccount"> | string
    userId?: StringWithAggregatesFilter<"UserToGaAccount"> | string
    gaAccountId?: StringWithAggregatesFilter<"UserToGaAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserToGaAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserToGaAccount"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roleId?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    accountRepId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    password?: StringNullableFilter<"User"> | string | null
    deleted?: BoolFilter<"User"> | boolean
    companyId?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    activities?: ClientActivityListRelationFilter
    receivedRatings?: ClientSatisfactionListRelationFilter
    givenRatings?: ClientSatisfactionListRelationFilter
    clientConversations?: ConversationListRelationFilter
    conversations?: ConversationListRelationFilter
    gaImportRuns?: GaImportRunListRelationFilter
    receivedMessages?: MessageListRelationFilter
    sentMessages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    queries?: QueryListRelationFilter
    sessions?: SessionListRelationFilter
    assignedTickets?: TicketListRelationFilter
    clientTickets?: TicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    accountRep?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clients?: UserListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    emailClients?: UserToEmailClientListRelationFilter
    userToGaAccounts?: UserToGaAccountListRelationFilter
    sproutSocialAccounts?: UserToSproutSocialAccountListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    accountRepId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    password?: SortOrderInput | SortOrder
    deleted?: SortOrder
    companyId?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    activities?: ClientActivityOrderByRelationAggregateInput
    receivedRatings?: ClientSatisfactionOrderByRelationAggregateInput
    givenRatings?: ClientSatisfactionOrderByRelationAggregateInput
    clientConversations?: ConversationOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    gaImportRuns?: GaImportRunOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    queries?: QueryOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    assignedTickets?: TicketOrderByRelationAggregateInput
    clientTickets?: TicketOrderByRelationAggregateInput
    ticketComments?: TicketCommentOrderByRelationAggregateInput
    accountRep?: UserOrderByWithRelationInput
    clients?: UserOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    settings?: UserSettingsOrderByWithRelationInput
    emailClients?: UserToEmailClientOrderByRelationAggregateInput
    userToGaAccounts?: UserToGaAccountOrderByRelationAggregateInput
    sproutSocialAccounts?: UserToSproutSocialAccountOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roleId?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    accountRepId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    password?: StringNullableFilter<"User"> | string | null
    deleted?: BoolFilter<"User"> | boolean
    companyId?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    activities?: ClientActivityListRelationFilter
    receivedRatings?: ClientSatisfactionListRelationFilter
    givenRatings?: ClientSatisfactionListRelationFilter
    clientConversations?: ConversationListRelationFilter
    conversations?: ConversationListRelationFilter
    gaImportRuns?: GaImportRunListRelationFilter
    receivedMessages?: MessageListRelationFilter
    sentMessages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    queries?: QueryListRelationFilter
    sessions?: SessionListRelationFilter
    assignedTickets?: TicketListRelationFilter
    clientTickets?: TicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    accountRep?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    clients?: UserListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    emailClients?: UserToEmailClientListRelationFilter
    userToGaAccounts?: UserToGaAccountListRelationFilter
    sproutSocialAccounts?: UserToSproutSocialAccountListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    accountRepId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    password?: SortOrderInput | SortOrder
    deleted?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    roleId?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    accountRepId?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    deleted?: BoolWithAggregatesFilter<"User"> | boolean
    companyId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    emailNotifications?: BoolFilter<"UserSettings"> | boolean
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    theme?: StringNullableFilter<"UserSettings"> | string | null
    apiCredits?: IntFilter<"UserSettings"> | number
    apiCreditsLimit?: IntFilter<"UserSettings"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    theme?: SortOrderInput | SortOrder
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    emailNotifications?: BoolFilter<"UserSettings"> | boolean
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    theme?: StringNullableFilter<"UserSettings"> | string | null
    apiCredits?: IntFilter<"UserSettings"> | number
    apiCreditsLimit?: IntFilter<"UserSettings"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    theme?: SortOrderInput | SortOrder
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _avg?: UserSettingsAvgOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
    _sum?: UserSettingsSumOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    emailNotifications?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    theme?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    apiCredits?: IntWithAggregatesFilter<"UserSettings"> | number
    apiCreditsLimit?: IntWithAggregatesFilter<"UserSettings"> | number
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    assignedToId?: StringNullableFilter<"Ticket"> | string | null
    clientId?: StringFilter<"Ticket"> | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: TicketAttachmentListRelationFilter
    comments?: TicketCommentListRelationFilter
    tags?: TicketTagListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    assignedTo?: UserOrderByWithRelationInput
    client?: UserOrderByWithRelationInput
    attachments?: TicketAttachmentOrderByRelationAggregateInput
    comments?: TicketCommentOrderByRelationAggregateInput
    tags?: TicketTagOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    assignedToId?: StringNullableFilter<"Ticket"> | string | null
    clientId?: StringFilter<"Ticket"> | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: TicketAttachmentListRelationFilter
    comments?: TicketCommentListRelationFilter
    tags?: TicketTagListRelationFilter
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    title?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringWithAggregatesFilter<"Ticket"> | string
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityWithAggregatesFilter<"Ticket"> | $Enums.TicketPriority
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    assignedToId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    clientId?: StringWithAggregatesFilter<"Ticket"> | string
  }

  export type TicketAttachmentWhereInput = {
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    id?: StringFilter<"TicketAttachment"> | string
    name?: StringFilter<"TicketAttachment"> | string
    url?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: StringFilter<"TicketAttachment"> | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }

  export type TicketAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    ticket?: TicketOrderByWithRelationInput
  }

  export type TicketAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    name?: StringFilter<"TicketAttachment"> | string
    url?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: StringFilter<"TicketAttachment"> | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    _count?: TicketAttachmentCountOrderByAggregateInput
    _max?: TicketAttachmentMaxOrderByAggregateInput
    _min?: TicketAttachmentMinOrderByAggregateInput
  }

  export type TicketAttachmentScalarWhereWithAggregatesInput = {
    AND?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    OR?: TicketAttachmentScalarWhereWithAggregatesInput[]
    NOT?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketAttachment"> | string
    name?: StringWithAggregatesFilter<"TicketAttachment"> | string
    url?: StringWithAggregatesFilter<"TicketAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketAttachment"> | Date | string
    ticketId?: StringWithAggregatesFilter<"TicketAttachment"> | string
  }

  export type TicketCommentWhereInput = {
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }

  export type TicketCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    author?: UserOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
  }

  export type TicketCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    _count?: TicketCommentCountOrderByAggregateInput
    _max?: TicketCommentMaxOrderByAggregateInput
    _min?: TicketCommentMinOrderByAggregateInput
  }

  export type TicketCommentScalarWhereWithAggregatesInput = {
    AND?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    OR?: TicketCommentScalarWhereWithAggregatesInput[]
    NOT?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketComment"> | string
    content?: StringWithAggregatesFilter<"TicketComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
    ticketId?: StringWithAggregatesFilter<"TicketComment"> | string
    authorId?: StringWithAggregatesFilter<"TicketComment"> | string
  }

  export type TicketTagWhereInput = {
    AND?: TicketTagWhereInput | TicketTagWhereInput[]
    OR?: TicketTagWhereInput[]
    NOT?: TicketTagWhereInput | TicketTagWhereInput[]
    id?: StringFilter<"TicketTag"> | string
    name?: StringFilter<"TicketTag"> | string
    createdAt?: DateTimeFilter<"TicketTag"> | Date | string
    tickets?: TicketListRelationFilter
  }

  export type TicketTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type TicketTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TicketTagWhereInput | TicketTagWhereInput[]
    OR?: TicketTagWhereInput[]
    NOT?: TicketTagWhereInput | TicketTagWhereInput[]
    createdAt?: DateTimeFilter<"TicketTag"> | Date | string
    tickets?: TicketListRelationFilter
  }, "id" | "name">

  export type TicketTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: TicketTagCountOrderByAggregateInput
    _max?: TicketTagMaxOrderByAggregateInput
    _min?: TicketTagMinOrderByAggregateInput
  }

  export type TicketTagScalarWhereWithAggregatesInput = {
    AND?: TicketTagScalarWhereWithAggregatesInput | TicketTagScalarWhereWithAggregatesInput[]
    OR?: TicketTagScalarWhereWithAggregatesInput[]
    NOT?: TicketTagScalarWhereWithAggregatesInput | TicketTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketTag"> | string
    name?: StringWithAggregatesFilter<"TicketTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketTag"> | Date | string
  }

  export type MessageAttachmentWhereInput = {
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    filename?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    mimeType?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    messageId?: StringFilter<"MessageAttachment"> | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }

  export type MessageAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type MessageAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    filename?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    mimeType?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    messageId?: StringFilter<"MessageAttachment"> | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }, "id">

  export type MessageAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    _count?: MessageAttachmentCountOrderByAggregateInput
    _avg?: MessageAttachmentAvgOrderByAggregateInput
    _max?: MessageAttachmentMaxOrderByAggregateInput
    _min?: MessageAttachmentMinOrderByAggregateInput
    _sum?: MessageAttachmentSumOrderByAggregateInput
  }

  export type MessageAttachmentScalarWhereWithAggregatesInput = {
    AND?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    OR?: MessageAttachmentScalarWhereWithAggregatesInput[]
    NOT?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageAttachment"> | string
    filename?: StringWithAggregatesFilter<"MessageAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"MessageAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"MessageAttachment"> | string
    url?: StringWithAggregatesFilter<"MessageAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageAttachment"> | Date | string
    messageId?: StringWithAggregatesFilter<"MessageAttachment"> | string
  }

  export type ClientActivityWhereInput = {
    AND?: ClientActivityWhereInput | ClientActivityWhereInput[]
    OR?: ClientActivityWhereInput[]
    NOT?: ClientActivityWhereInput | ClientActivityWhereInput[]
    id?: StringFilter<"ClientActivity"> | string
    type?: StringFilter<"ClientActivity"> | string
    description?: StringFilter<"ClientActivity"> | string
    status?: EnumActivityStatusFilter<"ClientActivity"> | $Enums.ActivityStatus
    metadata?: JsonNullableFilter<"ClientActivity">
    createdAt?: DateTimeFilter<"ClientActivity"> | Date | string
    updatedAt?: DateTimeFilter<"ClientActivity"> | Date | string
    userId?: StringFilter<"ClientActivity"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClientActivityOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ClientActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientActivityWhereInput | ClientActivityWhereInput[]
    OR?: ClientActivityWhereInput[]
    NOT?: ClientActivityWhereInput | ClientActivityWhereInput[]
    type?: StringFilter<"ClientActivity"> | string
    description?: StringFilter<"ClientActivity"> | string
    status?: EnumActivityStatusFilter<"ClientActivity"> | $Enums.ActivityStatus
    metadata?: JsonNullableFilter<"ClientActivity">
    createdAt?: DateTimeFilter<"ClientActivity"> | Date | string
    updatedAt?: DateTimeFilter<"ClientActivity"> | Date | string
    userId?: StringFilter<"ClientActivity"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ClientActivityOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: ClientActivityCountOrderByAggregateInput
    _max?: ClientActivityMaxOrderByAggregateInput
    _min?: ClientActivityMinOrderByAggregateInput
  }

  export type ClientActivityScalarWhereWithAggregatesInput = {
    AND?: ClientActivityScalarWhereWithAggregatesInput | ClientActivityScalarWhereWithAggregatesInput[]
    OR?: ClientActivityScalarWhereWithAggregatesInput[]
    NOT?: ClientActivityScalarWhereWithAggregatesInput | ClientActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientActivity"> | string
    type?: StringWithAggregatesFilter<"ClientActivity"> | string
    description?: StringWithAggregatesFilter<"ClientActivity"> | string
    status?: EnumActivityStatusWithAggregatesFilter<"ClientActivity"> | $Enums.ActivityStatus
    metadata?: JsonNullableWithAggregatesFilter<"ClientActivity">
    createdAt?: DateTimeWithAggregatesFilter<"ClientActivity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientActivity"> | Date | string
    userId?: StringWithAggregatesFilter<"ClientActivity"> | string
  }

  export type UserToEmailClientWhereInput = {
    AND?: UserToEmailClientWhereInput | UserToEmailClientWhereInput[]
    OR?: UserToEmailClientWhereInput[]
    NOT?: UserToEmailClientWhereInput | UserToEmailClientWhereInput[]
    id?: StringFilter<"UserToEmailClient"> | string
    userId?: StringFilter<"UserToEmailClient"> | string
    emailClientId?: StringFilter<"UserToEmailClient"> | string
    createdAt?: DateTimeFilter<"UserToEmailClient"> | Date | string
    updatedAt?: DateTimeFilter<"UserToEmailClient"> | Date | string
    emailClient?: XOR<EmailClientScalarRelationFilter, EmailClientWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserToEmailClientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailClientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailClient?: EmailClientOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserToEmailClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_emailClientId?: UserToEmailClientUserIdEmailClientIdCompoundUniqueInput
    AND?: UserToEmailClientWhereInput | UserToEmailClientWhereInput[]
    OR?: UserToEmailClientWhereInput[]
    NOT?: UserToEmailClientWhereInput | UserToEmailClientWhereInput[]
    userId?: StringFilter<"UserToEmailClient"> | string
    emailClientId?: StringFilter<"UserToEmailClient"> | string
    createdAt?: DateTimeFilter<"UserToEmailClient"> | Date | string
    updatedAt?: DateTimeFilter<"UserToEmailClient"> | Date | string
    emailClient?: XOR<EmailClientScalarRelationFilter, EmailClientWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_emailClientId">

  export type UserToEmailClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailClientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserToEmailClientCountOrderByAggregateInput
    _max?: UserToEmailClientMaxOrderByAggregateInput
    _min?: UserToEmailClientMinOrderByAggregateInput
  }

  export type UserToEmailClientScalarWhereWithAggregatesInput = {
    AND?: UserToEmailClientScalarWhereWithAggregatesInput | UserToEmailClientScalarWhereWithAggregatesInput[]
    OR?: UserToEmailClientScalarWhereWithAggregatesInput[]
    NOT?: UserToEmailClientScalarWhereWithAggregatesInput | UserToEmailClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserToEmailClient"> | string
    userId?: StringWithAggregatesFilter<"UserToEmailClient"> | string
    emailClientId?: StringWithAggregatesFilter<"UserToEmailClient"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserToEmailClient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserToEmailClient"> | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSatisfactionCreateInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    accountRep: UserCreateNestedOneWithoutReceivedRatingsInput
    user: UserCreateNestedOneWithoutGivenRatingsInput
  }

  export type ClientSatisfactionUncheckedCreateInput = {
    id?: string
    rating: number
    feedback?: string | null
    userId: string
    accountRepId: string
    createdAt?: Date | string
  }

  export type ClientSatisfactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountRep?: UserUpdateOneRequiredWithoutReceivedRatingsNestedInput
    user?: UserUpdateOneRequiredWithoutGivenRatingsNestedInput
  }

  export type ClientSatisfactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    accountRepId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSatisfactionCreateManyInput = {
    id?: string
    rating: number
    feedback?: string | null
    userId: string
    accountRepId: string
    createdAt?: Date | string
  }

  export type ClientSatisfactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSatisfactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    accountRepId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    client?: UserCreateNestedOneWithoutClientConversationsInput
    gaAccount?: GaAccountCreateNestedOneWithoutConversationsInput
    gaProperty?: GaPropertyCreateNestedOneWithoutConversationsInput
    user: UserCreateNestedOneWithoutConversationsInput
    queries?: QueryCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    description?: string | null
    gaAccountId?: string | null
    gaPropertyId?: string | null
    clientId?: string | null
    queries?: QueryUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    client?: UserUpdateOneWithoutClientConversationsNestedInput
    gaAccount?: GaAccountUpdateOneWithoutConversationsNestedInput
    gaProperty?: GaPropertyUpdateOneWithoutConversationsNestedInput
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    queries?: QueryUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    queries?: QueryUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    description?: string | null
    gaAccountId?: string | null
    gaPropertyId?: string | null
    clientId?: string | null
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailCampaignCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    campaignName: string
    emailClient: EmailClientCreateNestedOneWithoutEmailCampaignsInput
    emailCampaignContents?: EmailCampaignContentCreateNestedOneWithoutEmailCampaignInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsCreateNestedManyWithoutEmailCampaignInput
  }

  export type EmailCampaignUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    campaignName: string
    emailClientId: string
    emailCampaignContents?: EmailCampaignContentUncheckedCreateNestedOneWithoutEmailCampaignInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedCreateNestedManyWithoutEmailCampaignInput
  }

  export type EmailCampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    emailClient?: EmailClientUpdateOneRequiredWithoutEmailCampaignsNestedInput
    emailCampaignContents?: EmailCampaignContentUpdateOneWithoutEmailCampaignNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUpdateManyWithoutEmailCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
    emailCampaignContents?: EmailCampaignContentUncheckedUpdateOneWithoutEmailCampaignNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailCampaignNestedInput
  }

  export type EmailCampaignCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    campaignName: string
    emailClientId: string
  }

  export type EmailCampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCampaignContentCreateInput = {
    id?: string
    subject: string
    type: string
    recipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contentType: string
    createTime: Date | string
    htmlContent: string
    plainContent: string
    sendTime: Date | string
    webId: string
    emailCampaign: EmailCampaignCreateNestedOneWithoutEmailCampaignContentsInput
  }

  export type EmailCampaignContentUncheckedCreateInput = {
    id?: string
    subject: string
    type: string
    recipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contentType: string
    createTime: Date | string
    emailCampaignId: string
    htmlContent: string
    plainContent: string
    sendTime: Date | string
    webId: string
  }

  export type EmailCampaignContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentType?: StringFieldUpdateOperationsInput | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    plainContent?: StringFieldUpdateOperationsInput | string
    sendTime?: DateTimeFieldUpdateOperationsInput | Date | string
    webId?: StringFieldUpdateOperationsInput | string
    emailCampaign?: EmailCampaignUpdateOneRequiredWithoutEmailCampaignContentsNestedInput
  }

  export type EmailCampaignContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentType?: StringFieldUpdateOperationsInput | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    emailCampaignId?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    plainContent?: StringFieldUpdateOperationsInput | string
    sendTime?: DateTimeFieldUpdateOperationsInput | Date | string
    webId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCampaignContentCreateManyInput = {
    id?: string
    subject: string
    type: string
    recipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contentType: string
    createTime: Date | string
    emailCampaignId: string
    htmlContent: string
    plainContent: string
    sendTime: Date | string
    webId: string
  }

  export type EmailCampaignContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentType?: StringFieldUpdateOperationsInput | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    plainContent?: StringFieldUpdateOperationsInput | string
    sendTime?: DateTimeFieldUpdateOperationsInput | Date | string
    webId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCampaignContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentType?: StringFieldUpdateOperationsInput | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    emailCampaignId?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    plainContent?: StringFieldUpdateOperationsInput | string
    sendTime?: DateTimeFieldUpdateOperationsInput | Date | string
    webId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCampaignDailyStatsCreateInput = {
    id?: string
    date: Date | string
    opens?: number
    clicks?: number
    bounces?: number
    unsubscribes?: number
    variation: string
    phase: string
    requests?: number
    delivered?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bounceDrops?: number
    cumulativeBounceRate?: number
    cumulativeSpamReportsRate?: number
    cumulativeTotalClickRate?: number
    cumulativeTotalOpenRate?: number
    cumulativeUniqueClickRate?: number
    cumulativeUniqueOpenRate?: number
    cumulativeUnsubscribeRate?: number
    dailyBounceRate?: number
    dailySpamReportsRate?: number
    dailyTotalClickRate?: number
    dailyTotalClickToOpenRate?: number
    dailyTotalOpenRate?: number
    dailyUniqueClickRate?: number
    dailyUniqueClickToOpenRate?: number
    dailyUniqueOpenRate?: number
    dailyUnsubscribeRate?: number
    singleSendName: string
    spamReportDrops?: number
    spamReports?: number
    totalClicks?: number
    totalOpens?: number
    uniqueClicks?: number
    uniqueOpens?: number
    emailCampaign: EmailCampaignCreateNestedOneWithoutEmailCampaignDailyStatsInput
    emailClient: EmailClientCreateNestedOneWithoutEmailCampaignDailyStatsInput
  }

  export type EmailCampaignDailyStatsUncheckedCreateInput = {
    id?: string
    date: Date | string
    opens?: number
    clicks?: number
    bounces?: number
    unsubscribes?: number
    variation: string
    phase: string
    requests?: number
    delivered?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bounceDrops?: number
    cumulativeBounceRate?: number
    cumulativeSpamReportsRate?: number
    cumulativeTotalClickRate?: number
    cumulativeTotalOpenRate?: number
    cumulativeUniqueClickRate?: number
    cumulativeUniqueOpenRate?: number
    cumulativeUnsubscribeRate?: number
    dailyBounceRate?: number
    dailySpamReportsRate?: number
    dailyTotalClickRate?: number
    dailyTotalClickToOpenRate?: number
    dailyTotalOpenRate?: number
    dailyUniqueClickRate?: number
    dailyUniqueClickToOpenRate?: number
    dailyUniqueOpenRate?: number
    dailyUnsubscribeRate?: number
    emailCampaignId: string
    emailClientId: string
    singleSendName: string
    spamReportDrops?: number
    spamReports?: number
    totalClicks?: number
    totalOpens?: number
    uniqueClicks?: number
    uniqueOpens?: number
  }

  export type EmailCampaignDailyStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    unsubscribes?: IntFieldUpdateOperationsInput | number
    variation?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    requests?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceDrops?: IntFieldUpdateOperationsInput | number
    cumulativeBounceRate?: IntFieldUpdateOperationsInput | number
    cumulativeSpamReportsRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    dailyBounceRate?: IntFieldUpdateOperationsInput | number
    dailySpamReportsRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyTotalOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    singleSendName?: StringFieldUpdateOperationsInput | string
    spamReportDrops?: IntFieldUpdateOperationsInput | number
    spamReports?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalOpens?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
    emailCampaign?: EmailCampaignUpdateOneRequiredWithoutEmailCampaignDailyStatsNestedInput
    emailClient?: EmailClientUpdateOneRequiredWithoutEmailCampaignDailyStatsNestedInput
  }

  export type EmailCampaignDailyStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    unsubscribes?: IntFieldUpdateOperationsInput | number
    variation?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    requests?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceDrops?: IntFieldUpdateOperationsInput | number
    cumulativeBounceRate?: IntFieldUpdateOperationsInput | number
    cumulativeSpamReportsRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    dailyBounceRate?: IntFieldUpdateOperationsInput | number
    dailySpamReportsRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyTotalOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    emailCampaignId?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
    singleSendName?: StringFieldUpdateOperationsInput | string
    spamReportDrops?: IntFieldUpdateOperationsInput | number
    spamReports?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalOpens?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
  }

  export type EmailCampaignDailyStatsCreateManyInput = {
    id?: string
    date: Date | string
    opens?: number
    clicks?: number
    bounces?: number
    unsubscribes?: number
    variation: string
    phase: string
    requests?: number
    delivered?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bounceDrops?: number
    cumulativeBounceRate?: number
    cumulativeSpamReportsRate?: number
    cumulativeTotalClickRate?: number
    cumulativeTotalOpenRate?: number
    cumulativeUniqueClickRate?: number
    cumulativeUniqueOpenRate?: number
    cumulativeUnsubscribeRate?: number
    dailyBounceRate?: number
    dailySpamReportsRate?: number
    dailyTotalClickRate?: number
    dailyTotalClickToOpenRate?: number
    dailyTotalOpenRate?: number
    dailyUniqueClickRate?: number
    dailyUniqueClickToOpenRate?: number
    dailyUniqueOpenRate?: number
    dailyUnsubscribeRate?: number
    emailCampaignId: string
    emailClientId: string
    singleSendName: string
    spamReportDrops?: number
    spamReports?: number
    totalClicks?: number
    totalOpens?: number
    uniqueClicks?: number
    uniqueOpens?: number
  }

  export type EmailCampaignDailyStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    unsubscribes?: IntFieldUpdateOperationsInput | number
    variation?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    requests?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceDrops?: IntFieldUpdateOperationsInput | number
    cumulativeBounceRate?: IntFieldUpdateOperationsInput | number
    cumulativeSpamReportsRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    dailyBounceRate?: IntFieldUpdateOperationsInput | number
    dailySpamReportsRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyTotalOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    singleSendName?: StringFieldUpdateOperationsInput | string
    spamReportDrops?: IntFieldUpdateOperationsInput | number
    spamReports?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalOpens?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
  }

  export type EmailCampaignDailyStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    unsubscribes?: IntFieldUpdateOperationsInput | number
    variation?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    requests?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceDrops?: IntFieldUpdateOperationsInput | number
    cumulativeBounceRate?: IntFieldUpdateOperationsInput | number
    cumulativeSpamReportsRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    dailyBounceRate?: IntFieldUpdateOperationsInput | number
    dailySpamReportsRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyTotalOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    emailCampaignId?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
    singleSendName?: StringFieldUpdateOperationsInput | string
    spamReportDrops?: IntFieldUpdateOperationsInput | number
    spamReports?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalOpens?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
  }

  export type EmailClientCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutEmailClientInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsCreateNestedManyWithoutEmailClientInput
    emailClientCredentials?: EmailClientCredentialsCreateNestedManyWithoutEmailClientInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsCreateNestedManyWithoutEmailClientInput
    users?: UserToEmailClientCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutEmailClientInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput
    emailClientCredentials?: EmailClientCredentialsUncheckedCreateNestedManyWithoutEmailClientInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput
    users?: UserToEmailClientUncheckedCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUpdateManyWithoutEmailClientNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUpdateManyWithoutEmailClientNestedInput
    emailClientCredentials?: EmailClientCredentialsUpdateManyWithoutEmailClientNestedInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUpdateManyWithoutEmailClientNestedInput
    users?: UserToEmailClientUpdateManyWithoutEmailClientNestedInput
  }

  export type EmailClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutEmailClientNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput
    emailClientCredentials?: EmailClientCredentialsUncheckedUpdateManyWithoutEmailClientNestedInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput
    users?: UserToEmailClientUncheckedUpdateManyWithoutEmailClientNestedInput
  }

  export type EmailClientCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
  }

  export type EmailClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
  }

  export type EmailClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
  }

  export type EmailClientCredentialsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKey: string
    platformName: string
    emailClient: EmailClientCreateNestedOneWithoutEmailClientCredentialsInput
  }

  export type EmailClientCredentialsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKey: string
    emailClientId: string
    platformName: string
  }

  export type EmailClientCredentialsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKey?: StringFieldUpdateOperationsInput | string
    platformName?: StringFieldUpdateOperationsInput | string
    emailClient?: EmailClientUpdateOneRequiredWithoutEmailClientCredentialsNestedInput
  }

  export type EmailClientCredentialsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKey?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
    platformName?: StringFieldUpdateOperationsInput | string
  }

  export type EmailClientCredentialsCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKey: string
    emailClientId: string
    platformName: string
  }

  export type EmailClientCredentialsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKey?: StringFieldUpdateOperationsInput | string
    platformName?: StringFieldUpdateOperationsInput | string
  }

  export type EmailClientCredentialsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKey?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
    platformName?: StringFieldUpdateOperationsInput | string
  }

  export type EmailGlobalDailyStatsCreateInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bounces?: number
    clicks?: number
    opens?: number
    unsubs?: number
    emailClient: EmailClientCreateNestedOneWithoutEmailGlobalDailyStatsInput
  }

  export type EmailGlobalDailyStatsUncheckedCreateInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bounces?: number
    clicks?: number
    emailClientId: string
    opens?: number
    unsubs?: number
  }

  export type EmailGlobalDailyStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounces?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    opens?: IntFieldUpdateOperationsInput | number
    unsubs?: IntFieldUpdateOperationsInput | number
    emailClient?: EmailClientUpdateOneRequiredWithoutEmailGlobalDailyStatsNestedInput
  }

  export type EmailGlobalDailyStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounces?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    emailClientId?: StringFieldUpdateOperationsInput | string
    opens?: IntFieldUpdateOperationsInput | number
    unsubs?: IntFieldUpdateOperationsInput | number
  }

  export type EmailGlobalDailyStatsCreateManyInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bounces?: number
    clicks?: number
    emailClientId: string
    opens?: number
    unsubs?: number
  }

  export type EmailGlobalDailyStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounces?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    opens?: IntFieldUpdateOperationsInput | number
    unsubs?: IntFieldUpdateOperationsInput | number
  }

  export type EmailGlobalDailyStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounces?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    emailClientId?: StringFieldUpdateOperationsInput | string
    opens?: IntFieldUpdateOperationsInput | number
    unsubs?: IntFieldUpdateOperationsInput | number
  }

  export type GaAccountCreateInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutGaAccountInput
    gaProperties?: GaPropertyCreateNestedManyWithoutGaAccountInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountUncheckedCreateInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaAccountInput
    gaProperties?: GaPropertyUncheckedCreateNestedManyWithoutGaAccountInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutGaAccountNestedInput
    gaProperties?: GaPropertyUpdateManyWithoutGaAccountNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutGaAccountNestedInput
  }

  export type GaAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaAccountNestedInput
    gaProperties?: GaPropertyUncheckedUpdateManyWithoutGaAccountNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutGaAccountNestedInput
  }

  export type GaAccountCreateManyInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaPropertyCreateInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyCreateManyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaPropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaPropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaImportRunCreateInput = {
    id?: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutImportsInput
    requestedBy: UserCreateNestedOneWithoutGaImportRunsInput
  }

  export type GaImportRunUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    requestedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaImportRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutImportsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutGaImportRunsNestedInput
  }

  export type GaImportRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaImportRunCreateManyInput = {
    id?: string
    gaPropertyId: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    requestedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaImportRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaImportRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyCreateInput = {
    id?: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutKpiDailyInput
  }

  export type GaKpiDailyUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaKpiDailyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutKpiDailyNestedInput
  }

  export type GaKpiDailyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyCreateManyInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaKpiDailyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyCreateInput = {
    id?: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutKpiMonthlyInput
  }

  export type GaKpiMonthlyUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaKpiMonthlyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutKpiMonthlyNestedInput
  }

  export type GaKpiMonthlyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyCreateManyInput = {
    id?: string
    gaPropertyId: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaKpiMonthlyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaChannelDailyCreateInput = {
    id?: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutChannelDailyInput
  }

  export type GaChannelDailyUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaChannelDailyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutChannelDailyNestedInput
  }

  export type GaChannelDailyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaChannelDailyCreateManyInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaChannelDailyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaChannelDailyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyCreateInput = {
    id?: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutSourceDailyInput
  }

  export type GaSourceDailyUncheckedCreateInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaSourceDailyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutSourceDailyNestedInput
  }

  export type GaSourceDailyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyCreateManyInput = {
    id?: string
    gaPropertyId: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaSourceDailyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    expires: Date | string
    sessionToken: string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    expires: Date | string
    sessionToken: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    expires: Date | string
    sessionToken: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parent?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    senderId: string
    recipientId: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    parentId?: string | null
    threadId?: string | null
    replies?: MessageUncheckedCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    senderId: string
    recipientId: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    parentId?: string | null
    threadId?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedPieGraphDataCreateInput = {
    id?: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
    updatedAt?: Date | string
    query: QueryCreateNestedOneWithoutParsedPieDataInput
  }

  export type ParsedPieGraphDataUncheckedCreateInput = {
    id?: string
    queryId: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParsedPieGraphDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: QueryUpdateOneRequiredWithoutParsedPieDataNestedInput
  }

  export type ParsedPieGraphDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedPieGraphDataCreateManyInput = {
    id?: string
    queryId: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParsedPieGraphDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedPieGraphDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQueryDataCreateInput = {
    id?: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    bounceRate?: number | null
    engagedSessions?: number | null
    newUsers?: number | null
    query: QueryCreateNestedOneWithoutParsedDataInput
  }

  export type ParsedQueryDataUncheckedCreateInput = {
    id?: string
    queryId: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    bounceRate?: number | null
    engagedSessions?: number | null
    newUsers?: number | null
  }

  export type ParsedQueryDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
    query?: QueryUpdateOneRequiredWithoutParsedDataNestedInput
  }

  export type ParsedQueryDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedQueryDataCreateManyInput = {
    id?: string
    queryId: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    bounceRate?: number | null
    engagedSessions?: number | null
    newUsers?: number | null
  }

  export type ParsedQueryDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedQueryDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedQuerySummaryCreateInput = {
    id?: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
    query: QueryCreateNestedOneWithoutParsedSummaryInput
  }

  export type ParsedQuerySummaryUncheckedCreateInput = {
    id?: string
    queryId: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
  }

  export type ParsedQuerySummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: QueryUpdateOneRequiredWithoutParsedSummaryNestedInput
  }

  export type ParsedQuerySummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQuerySummaryCreateManyInput = {
    id?: string
    queryId: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
  }

  export type ParsedQuerySummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQuerySummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryCreateInput = {
    id?: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataCreateNestedManyWithoutQueryInput
    parsedData?: ParsedQueryDataCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryCreateNestedManyWithoutQueryInput
    conversation?: ConversationCreateNestedOneWithoutQueriesInput
    user: UserCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateInput = {
    id?: string
    userId: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    conversationId?: string | null
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput
    parsedData?: ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUpdateManyWithoutQueryNestedInput
    parsedData?: ParsedQueryDataUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUpdateManyWithoutQueryNestedInput
    conversation?: ConversationUpdateOneWithoutQueriesNestedInput
    user?: UserUpdateOneRequiredWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedData?: ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryCreateManyInput = {
    id?: string
    userId: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    conversationId?: string | null
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QueryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QueryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SproutFacebookAnalyticsCreateInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postPhotoViewClicks?: number | null
    tabViews?: number | null
    videoViews?: number | null
    videoViews10s?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    videoViewsUnique?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    netFollowerGrowth?: number | null
    sproutSocialAccount: SproutSocialAccountCreateNestedOneWithoutFacebookAnalyticsInput
  }

  export type SproutFacebookAnalyticsUncheckedCreateInput = {
    id?: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postPhotoViewClicks?: number | null
    tabViews?: number | null
    videoViews?: number | null
    videoViews10s?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    videoViewsUnique?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    netFollowerGrowth?: number | null
  }

  export type SproutFacebookAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    tabViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews10s?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netFollowerGrowth?: NullableIntFieldUpdateOperationsInput | number | null
    sproutSocialAccount?: SproutSocialAccountUpdateOneRequiredWithoutFacebookAnalyticsNestedInput
  }

  export type SproutFacebookAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    tabViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews10s?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netFollowerGrowth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SproutFacebookAnalyticsCreateManyInput = {
    id?: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postPhotoViewClicks?: number | null
    tabViews?: number | null
    videoViews?: number | null
    videoViews10s?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    videoViewsUnique?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    netFollowerGrowth?: number | null
  }

  export type SproutFacebookAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    tabViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews10s?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netFollowerGrowth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SproutFacebookAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    tabViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews10s?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netFollowerGrowth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SproutFacebookPostCreateInput = {
    id?: string
    postType: string
    postStatus: string
    postLink: string
    postText: string
    postNativeId: string
    postCreatedTime: Date | string
    postSentTime: Date | string
    postLastUpdated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sproutSocialAccount: SproutSocialAccountCreateNestedOneWithoutFacebookPostsInput
  }

  export type SproutFacebookPostUncheckedCreateInput = {
    id?: string
    sproutSocialAccountId: string
    postType: string
    postStatus: string
    postLink: string
    postText: string
    postNativeId: string
    postCreatedTime: Date | string
    postSentTime: Date | string
    postLastUpdated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutFacebookPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    postStatus?: StringFieldUpdateOperationsInput | string
    postLink?: StringFieldUpdateOperationsInput | string
    postText?: StringFieldUpdateOperationsInput | string
    postNativeId?: StringFieldUpdateOperationsInput | string
    postCreatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postSentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postLastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sproutSocialAccount?: SproutSocialAccountUpdateOneRequiredWithoutFacebookPostsNestedInput
  }

  export type SproutFacebookPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    postStatus?: StringFieldUpdateOperationsInput | string
    postLink?: StringFieldUpdateOperationsInput | string
    postText?: StringFieldUpdateOperationsInput | string
    postNativeId?: StringFieldUpdateOperationsInput | string
    postCreatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postSentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postLastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutFacebookPostCreateManyInput = {
    id?: string
    sproutSocialAccountId: string
    postType: string
    postStatus: string
    postLink: string
    postText: string
    postNativeId: string
    postCreatedTime: Date | string
    postSentTime: Date | string
    postLastUpdated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutFacebookPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    postStatus?: StringFieldUpdateOperationsInput | string
    postLink?: StringFieldUpdateOperationsInput | string
    postText?: StringFieldUpdateOperationsInput | string
    postNativeId?: StringFieldUpdateOperationsInput | string
    postCreatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postSentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postLastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutFacebookPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    postStatus?: StringFieldUpdateOperationsInput | string
    postLink?: StringFieldUpdateOperationsInput | string
    postText?: StringFieldUpdateOperationsInput | string
    postNativeId?: StringFieldUpdateOperationsInput | string
    postCreatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postSentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postLastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutFacebookPostAnalyticsCreateInput = {
    id?: string
    angryReactions?: number | null
    clientNativeId: string
    commentsCount?: number | null
    hahaReactions?: number | null
    impressions?: number | null
    impressionsFollower?: number | null
    impressionsNonFollower?: number | null
    impressionsNonViral?: number | null
    impressionsOrganic?: number | null
    impressionsPaid?: number | null
    impressionsViral?: number | null
    likes?: number | null
    loveReactions?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postNativeId: string
    postPhotoViewClicks?: number | null
    postVideoPlayClicks?: number | null
    questionAnswers?: number | null
    reach?: number | null
    reachFollower?: number | null
    reachNonViral?: number | null
    reachOrganic?: number | null
    reachPaid?: number | null
    reachViral?: number | null
    reactions?: number | null
    reportingDate: Date | string
    sadReactions?: number | null
    sharesCount?: number | null
    videoLength?: number | null
    videoViews?: number | null
    videoViewsAutoplay?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    wowReactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sproutSocialAccount: SproutSocialAccountCreateNestedOneWithoutFacebookPostAnalyticsInput
  }

  export type SproutFacebookPostAnalyticsUncheckedCreateInput = {
    id?: string
    angryReactions?: number | null
    clientNativeId: string
    commentsCount?: number | null
    hahaReactions?: number | null
    impressions?: number | null
    impressionsFollower?: number | null
    impressionsNonFollower?: number | null
    impressionsNonViral?: number | null
    impressionsOrganic?: number | null
    impressionsPaid?: number | null
    impressionsViral?: number | null
    likes?: number | null
    loveReactions?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postNativeId: string
    postPhotoViewClicks?: number | null
    postVideoPlayClicks?: number | null
    questionAnswers?: number | null
    reach?: number | null
    reachFollower?: number | null
    reachNonViral?: number | null
    reachOrganic?: number | null
    reachPaid?: number | null
    reachViral?: number | null
    reactions?: number | null
    reportingDate: Date | string
    sadReactions?: number | null
    sharesCount?: number | null
    sproutSocialAccountId: string
    videoLength?: number | null
    videoViews?: number | null
    videoViewsAutoplay?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    wowReactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutFacebookPostAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    angryReactions?: NullableIntFieldUpdateOperationsInput | number | null
    clientNativeId?: StringFieldUpdateOperationsInput | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    hahaReactions?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsViral?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    loveReactions?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postNativeId?: StringFieldUpdateOperationsInput | string
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postVideoPlayClicks?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswers?: NullableIntFieldUpdateOperationsInput | number | null
    reach?: NullableIntFieldUpdateOperationsInput | number | null
    reachFollower?: NullableIntFieldUpdateOperationsInput | number | null
    reachNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    reachOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    reachPaid?: NullableIntFieldUpdateOperationsInput | number | null
    reachViral?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sadReactions?: NullableIntFieldUpdateOperationsInput | number | null
    sharesCount?: NullableIntFieldUpdateOperationsInput | number | null
    videoLength?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsAutoplay?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    wowReactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sproutSocialAccount?: SproutSocialAccountUpdateOneRequiredWithoutFacebookPostAnalyticsNestedInput
  }

  export type SproutFacebookPostAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    angryReactions?: NullableIntFieldUpdateOperationsInput | number | null
    clientNativeId?: StringFieldUpdateOperationsInput | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    hahaReactions?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsViral?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    loveReactions?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postNativeId?: StringFieldUpdateOperationsInput | string
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postVideoPlayClicks?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswers?: NullableIntFieldUpdateOperationsInput | number | null
    reach?: NullableIntFieldUpdateOperationsInput | number | null
    reachFollower?: NullableIntFieldUpdateOperationsInput | number | null
    reachNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    reachOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    reachPaid?: NullableIntFieldUpdateOperationsInput | number | null
    reachViral?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sadReactions?: NullableIntFieldUpdateOperationsInput | number | null
    sharesCount?: NullableIntFieldUpdateOperationsInput | number | null
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    videoLength?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsAutoplay?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    wowReactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutFacebookPostAnalyticsCreateManyInput = {
    id?: string
    angryReactions?: number | null
    clientNativeId: string
    commentsCount?: number | null
    hahaReactions?: number | null
    impressions?: number | null
    impressionsFollower?: number | null
    impressionsNonFollower?: number | null
    impressionsNonViral?: number | null
    impressionsOrganic?: number | null
    impressionsPaid?: number | null
    impressionsViral?: number | null
    likes?: number | null
    loveReactions?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postNativeId: string
    postPhotoViewClicks?: number | null
    postVideoPlayClicks?: number | null
    questionAnswers?: number | null
    reach?: number | null
    reachFollower?: number | null
    reachNonViral?: number | null
    reachOrganic?: number | null
    reachPaid?: number | null
    reachViral?: number | null
    reactions?: number | null
    reportingDate: Date | string
    sadReactions?: number | null
    sharesCount?: number | null
    sproutSocialAccountId: string
    videoLength?: number | null
    videoViews?: number | null
    videoViewsAutoplay?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    wowReactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutFacebookPostAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    angryReactions?: NullableIntFieldUpdateOperationsInput | number | null
    clientNativeId?: StringFieldUpdateOperationsInput | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    hahaReactions?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsViral?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    loveReactions?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postNativeId?: StringFieldUpdateOperationsInput | string
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postVideoPlayClicks?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswers?: NullableIntFieldUpdateOperationsInput | number | null
    reach?: NullableIntFieldUpdateOperationsInput | number | null
    reachFollower?: NullableIntFieldUpdateOperationsInput | number | null
    reachNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    reachOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    reachPaid?: NullableIntFieldUpdateOperationsInput | number | null
    reachViral?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sadReactions?: NullableIntFieldUpdateOperationsInput | number | null
    sharesCount?: NullableIntFieldUpdateOperationsInput | number | null
    videoLength?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsAutoplay?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    wowReactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutFacebookPostAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    angryReactions?: NullableIntFieldUpdateOperationsInput | number | null
    clientNativeId?: StringFieldUpdateOperationsInput | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    hahaReactions?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsViral?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    loveReactions?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postNativeId?: StringFieldUpdateOperationsInput | string
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postVideoPlayClicks?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswers?: NullableIntFieldUpdateOperationsInput | number | null
    reach?: NullableIntFieldUpdateOperationsInput | number | null
    reachFollower?: NullableIntFieldUpdateOperationsInput | number | null
    reachNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    reachOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    reachPaid?: NullableIntFieldUpdateOperationsInput | number | null
    reachViral?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sadReactions?: NullableIntFieldUpdateOperationsInput | number | null
    sharesCount?: NullableIntFieldUpdateOperationsInput | number | null
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    videoLength?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsAutoplay?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    wowReactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramAnalyticsCreateInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    commentsCount?: number | null
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    likes?: number | null
    saves?: number | null
    videoViews?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailContacts?: number | null
    getDirectionsClicks?: number | null
    phoneCallClicks?: number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: number | null
    profileFollowerAdds?: number | null
    profileFollowers?: number | null
    profileImpressionsUnique?: number | null
    profileReachUnique?: number | null
    profileViews?: number | null
    profileViewsUnique?: number | null
    websiteClicks?: number | null
    sproutSocialAccount: SproutSocialAccountCreateNestedOneWithoutInstagramAnalyticsInput
    followersByCity?: SproutInstagramFollowersByCityCreateNestedManyWithoutSproutInstagramAnalyticsInput
    followersByCountry?: SproutInstagramFollowersByCountryCreateNestedManyWithoutSproutInstagramAnalyticsInput
  }

  export type SproutInstagramAnalyticsUncheckedCreateInput = {
    id?: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date | string
    commentsCount?: number | null
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    likes?: number | null
    saves?: number | null
    videoViews?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailContacts?: number | null
    getDirectionsClicks?: number | null
    phoneCallClicks?: number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: number | null
    profileFollowerAdds?: number | null
    profileFollowers?: number | null
    profileImpressionsUnique?: number | null
    profileReachUnique?: number | null
    profileViews?: number | null
    profileViewsUnique?: number | null
    websiteClicks?: number | null
    followersByCity?: SproutInstagramFollowersByCityUncheckedCreateNestedManyWithoutSproutInstagramAnalyticsInput
    followersByCountry?: SproutInstagramFollowersByCountryUncheckedCreateNestedManyWithoutSproutInstagramAnalyticsInput
  }

  export type SproutInstagramAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    saves?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailContacts?: NullableIntFieldUpdateOperationsInput | number | null
    getDirectionsClicks?: NullableIntFieldUpdateOperationsInput | number | null
    phoneCallClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowerAdds?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    profileImpressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileReachUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileViews?: NullableIntFieldUpdateOperationsInput | number | null
    profileViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    websiteClicks?: NullableIntFieldUpdateOperationsInput | number | null
    sproutSocialAccount?: SproutSocialAccountUpdateOneRequiredWithoutInstagramAnalyticsNestedInput
    followersByCity?: SproutInstagramFollowersByCityUpdateManyWithoutSproutInstagramAnalyticsNestedInput
    followersByCountry?: SproutInstagramFollowersByCountryUpdateManyWithoutSproutInstagramAnalyticsNestedInput
  }

  export type SproutInstagramAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    saves?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailContacts?: NullableIntFieldUpdateOperationsInput | number | null
    getDirectionsClicks?: NullableIntFieldUpdateOperationsInput | number | null
    phoneCallClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowerAdds?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    profileImpressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileReachUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileViews?: NullableIntFieldUpdateOperationsInput | number | null
    profileViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    websiteClicks?: NullableIntFieldUpdateOperationsInput | number | null
    followersByCity?: SproutInstagramFollowersByCityUncheckedUpdateManyWithoutSproutInstagramAnalyticsNestedInput
    followersByCountry?: SproutInstagramFollowersByCountryUncheckedUpdateManyWithoutSproutInstagramAnalyticsNestedInput
  }

  export type SproutInstagramAnalyticsCreateManyInput = {
    id?: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date | string
    commentsCount?: number | null
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    likes?: number | null
    saves?: number | null
    videoViews?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailContacts?: number | null
    getDirectionsClicks?: number | null
    phoneCallClicks?: number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: number | null
    profileFollowerAdds?: number | null
    profileFollowers?: number | null
    profileImpressionsUnique?: number | null
    profileReachUnique?: number | null
    profileViews?: number | null
    profileViewsUnique?: number | null
    websiteClicks?: number | null
  }

  export type SproutInstagramAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    saves?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailContacts?: NullableIntFieldUpdateOperationsInput | number | null
    getDirectionsClicks?: NullableIntFieldUpdateOperationsInput | number | null
    phoneCallClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowerAdds?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    profileImpressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileReachUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileViews?: NullableIntFieldUpdateOperationsInput | number | null
    profileViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    websiteClicks?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SproutInstagramAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    saves?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailContacts?: NullableIntFieldUpdateOperationsInput | number | null
    getDirectionsClicks?: NullableIntFieldUpdateOperationsInput | number | null
    phoneCallClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowerAdds?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    profileImpressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileReachUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileViews?: NullableIntFieldUpdateOperationsInput | number | null
    profileViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    websiteClicks?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SproutInstagramFollowersByCityCreateInput = {
    id?: string
    city: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sproutInstagramAnalytics: SproutInstagramAnalyticsCreateNestedOneWithoutFollowersByCityInput
  }

  export type SproutInstagramFollowersByCityUncheckedCreateInput = {
    id?: string
    sproutInstagramAnalyticsId: string
    city: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutInstagramFollowersByCityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sproutInstagramAnalytics?: SproutInstagramAnalyticsUpdateOneRequiredWithoutFollowersByCityNestedInput
  }

  export type SproutInstagramFollowersByCityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutInstagramAnalyticsId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramFollowersByCityCreateManyInput = {
    id?: string
    sproutInstagramAnalyticsId: string
    city: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutInstagramFollowersByCityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramFollowersByCityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutInstagramAnalyticsId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramFollowersByCountryCreateInput = {
    id?: string
    country: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sproutInstagramAnalytics: SproutInstagramAnalyticsCreateNestedOneWithoutFollowersByCountryInput
  }

  export type SproutInstagramFollowersByCountryUncheckedCreateInput = {
    id?: string
    sproutInstagramAnalyticsId: string
    country: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutInstagramFollowersByCountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sproutInstagramAnalytics?: SproutInstagramAnalyticsUpdateOneRequiredWithoutFollowersByCountryNestedInput
  }

  export type SproutInstagramFollowersByCountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutInstagramAnalyticsId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramFollowersByCountryCreateManyInput = {
    id?: string
    sproutInstagramAnalyticsId: string
    country: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutInstagramFollowersByCountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramFollowersByCountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutInstagramAnalyticsId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutLinkedInAnalyticsCreateInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    reactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sproutSocialAccount: SproutSocialAccountCreateNestedOneWithoutLinkedInAnalyticsInput
  }

  export type SproutLinkedInAnalyticsUncheckedCreateInput = {
    id?: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    reactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutLinkedInAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sproutSocialAccount?: SproutSocialAccountUpdateOneRequiredWithoutLinkedInAnalyticsNestedInput
  }

  export type SproutLinkedInAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutLinkedInAnalyticsCreateManyInput = {
    id?: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    reactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutLinkedInAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutLinkedInAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutPinterestAnalyticsCreateInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    followersCount?: number | null
    followingCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sproutSocialAccount: SproutSocialAccountCreateNestedOneWithoutPinterestAnalyticsInput
  }

  export type SproutPinterestAnalyticsUncheckedCreateInput = {
    id?: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date | string
    followersCount?: number | null
    followingCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutPinterestAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    followingCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sproutSocialAccount?: SproutSocialAccountUpdateOneRequiredWithoutPinterestAnalyticsNestedInput
  }

  export type SproutPinterestAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    followingCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutPinterestAnalyticsCreateManyInput = {
    id?: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date | string
    followersCount?: number | null
    followingCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutPinterestAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    followingCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutPinterestAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    followingCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutSocialAccountCreateInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountUncheckedCreateInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountCreateManyInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutSocialAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutSocialAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToSproutSocialAccountCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sproutSocialAccount: SproutSocialAccountCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutSproutSocialAccountsInput
  }

  export type UserToSproutSocialAccountUncheckedCreateInput = {
    id?: string
    userId: string
    sproutSocialAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToSproutSocialAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sproutSocialAccount?: SproutSocialAccountUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutSproutSocialAccountsNestedInput
  }

  export type UserToSproutSocialAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToSproutSocialAccountCreateManyInput = {
    id?: string
    userId: string
    sproutSocialAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToSproutSocialAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToSproutSocialAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToGaAccountCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gaAccount: GaAccountCreateNestedOneWithoutUserToGaAccountsInput
    user: UserCreateNestedOneWithoutUserToGaAccountsInput
  }

  export type UserToGaAccountUncheckedCreateInput = {
    id?: string
    userId: string
    gaAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToGaAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaAccount?: GaAccountUpdateOneRequiredWithoutUserToGaAccountsNestedInput
    user?: UserUpdateOneRequiredWithoutUserToGaAccountsNestedInput
  }

  export type UserToGaAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToGaAccountCreateManyInput = {
    id?: string
    userId: string
    gaAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToGaAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToGaAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSettingsCreateInput = {
    id?: string
    emailNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    theme?: string | null
    apiCredits?: number
    apiCreditsLimit?: number
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    emailNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    theme?: string | null
    apiCredits?: number
    apiCreditsLimit?: number
  }

  export type UserSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    emailNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    theme?: string | null
    apiCredits?: number
    apiCreditsLimit?: number
  }

  export type UserSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
  }

  export type TicketCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    client: UserCreateNestedOneWithoutClientTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
    tags?: TicketTagCreateNestedManyWithoutTicketsInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    clientId: string
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    tags?: TicketTagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    client?: UserUpdateOneRequiredWithoutClientTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketCreateManyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    clientId: string
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketAttachmentCreateInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutAttachmentsInput
  }

  export type TicketAttachmentUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
    ticketId: string
  }

  export type TicketAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type TicketAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketAttachmentCreateManyInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
    ticketId: string
  }

  export type TicketAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutTicketCommentsInput
    ticket: TicketCreateNestedOneWithoutCommentsInput
  }

  export type TicketCommentUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketId: string
    authorId: string
  }

  export type TicketCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutTicketCommentsNestedInput
    ticket?: TicketUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCommentCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketId: string
    authorId: string
  }

  export type TicketCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketTagCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutTagsInput
  }

  export type TicketTagUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TicketTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutTagsNestedInput
  }

  export type TicketTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TicketTagCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type TicketTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutAttachmentsInput
  }

  export type MessageAttachmentUncheckedCreateInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
    messageId: string
  }

  export type MessageAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type MessageAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageAttachmentCreateManyInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
    messageId: string
  }

  export type MessageAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientActivityCreateInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ClientActivityUncheckedCreateInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ClientActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ClientActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientActivityCreateManyInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ClientActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserToEmailClientCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailClient: EmailClientCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutEmailClientsInput
  }

  export type UserToEmailClientUncheckedCreateInput = {
    id?: string
    userId: string
    emailClientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToEmailClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailClient?: EmailClientUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutEmailClientsNestedInput
  }

  export type UserToEmailClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToEmailClientCreateManyInput = {
    id?: string
    userId: string
    emailClientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToEmailClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToEmailClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ClientSatisfactionCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    userId?: SortOrder
    accountRepId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientSatisfactionAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ClientSatisfactionMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    userId?: SortOrder
    accountRepId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientSatisfactionMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    userId?: SortOrder
    accountRepId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientSatisfactionSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type GaAccountNullableScalarRelationFilter = {
    is?: GaAccountWhereInput | null
    isNot?: GaAccountWhereInput | null
  }

  export type GaPropertyNullableScalarRelationFilter = {
    is?: GaPropertyWhereInput | null
    isNot?: GaPropertyWhereInput | null
  }

  export type QueryListRelationFilter = {
    every?: QueryWhereInput
    some?: QueryWhereInput
    none?: QueryWhereInput
  }

  export type QueryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isStarred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    gaAccountId?: SortOrder
    gaPropertyId?: SortOrder
    clientId?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isStarred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    gaAccountId?: SortOrder
    gaPropertyId?: SortOrder
    clientId?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isStarred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    gaAccountId?: SortOrder
    gaPropertyId?: SortOrder
    clientId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EmailClientScalarRelationFilter = {
    is?: EmailClientWhereInput
    isNot?: EmailClientWhereInput
  }

  export type EmailCampaignContentNullableScalarRelationFilter = {
    is?: EmailCampaignContentWhereInput | null
    isNot?: EmailCampaignContentWhereInput | null
  }

  export type EmailCampaignDailyStatsListRelationFilter = {
    every?: EmailCampaignDailyStatsWhereInput
    some?: EmailCampaignDailyStatsWhereInput
    none?: EmailCampaignDailyStatsWhereInput
  }

  export type EmailCampaignDailyStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    campaignName?: SortOrder
    emailClientId?: SortOrder
  }

  export type EmailCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    campaignName?: SortOrder
    emailClientId?: SortOrder
  }

  export type EmailCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    campaignName?: SortOrder
    emailClientId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EmailCampaignScalarRelationFilter = {
    is?: EmailCampaignWhereInput
    isNot?: EmailCampaignWhereInput
  }

  export type EmailCampaignContentCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    type?: SortOrder
    recipients?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contentType?: SortOrder
    createTime?: SortOrder
    emailCampaignId?: SortOrder
    htmlContent?: SortOrder
    plainContent?: SortOrder
    sendTime?: SortOrder
    webId?: SortOrder
  }

  export type EmailCampaignContentAvgOrderByAggregateInput = {
    recipients?: SortOrder
  }

  export type EmailCampaignContentMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    type?: SortOrder
    recipients?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contentType?: SortOrder
    createTime?: SortOrder
    emailCampaignId?: SortOrder
    htmlContent?: SortOrder
    plainContent?: SortOrder
    sendTime?: SortOrder
    webId?: SortOrder
  }

  export type EmailCampaignContentMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    type?: SortOrder
    recipients?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contentType?: SortOrder
    createTime?: SortOrder
    emailCampaignId?: SortOrder
    htmlContent?: SortOrder
    plainContent?: SortOrder
    sendTime?: SortOrder
    webId?: SortOrder
  }

  export type EmailCampaignContentSumOrderByAggregateInput = {
    recipients?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EmailCampaignDailyStatsEmailCampaignIdDateCompoundUniqueInput = {
    emailCampaignId: string
    date: Date | string
  }

  export type EmailCampaignDailyStatsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    opens?: SortOrder
    clicks?: SortOrder
    bounces?: SortOrder
    unsubscribes?: SortOrder
    variation?: SortOrder
    phase?: SortOrder
    requests?: SortOrder
    delivered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bounceDrops?: SortOrder
    cumulativeBounceRate?: SortOrder
    cumulativeSpamReportsRate?: SortOrder
    cumulativeTotalClickRate?: SortOrder
    cumulativeTotalOpenRate?: SortOrder
    cumulativeUniqueClickRate?: SortOrder
    cumulativeUniqueOpenRate?: SortOrder
    cumulativeUnsubscribeRate?: SortOrder
    dailyBounceRate?: SortOrder
    dailySpamReportsRate?: SortOrder
    dailyTotalClickRate?: SortOrder
    dailyTotalClickToOpenRate?: SortOrder
    dailyTotalOpenRate?: SortOrder
    dailyUniqueClickRate?: SortOrder
    dailyUniqueClickToOpenRate?: SortOrder
    dailyUniqueOpenRate?: SortOrder
    dailyUnsubscribeRate?: SortOrder
    emailCampaignId?: SortOrder
    emailClientId?: SortOrder
    singleSendName?: SortOrder
    spamReportDrops?: SortOrder
    spamReports?: SortOrder
    totalClicks?: SortOrder
    totalOpens?: SortOrder
    uniqueClicks?: SortOrder
    uniqueOpens?: SortOrder
  }

  export type EmailCampaignDailyStatsAvgOrderByAggregateInput = {
    opens?: SortOrder
    clicks?: SortOrder
    bounces?: SortOrder
    unsubscribes?: SortOrder
    requests?: SortOrder
    delivered?: SortOrder
    bounceDrops?: SortOrder
    cumulativeBounceRate?: SortOrder
    cumulativeSpamReportsRate?: SortOrder
    cumulativeTotalClickRate?: SortOrder
    cumulativeTotalOpenRate?: SortOrder
    cumulativeUniqueClickRate?: SortOrder
    cumulativeUniqueOpenRate?: SortOrder
    cumulativeUnsubscribeRate?: SortOrder
    dailyBounceRate?: SortOrder
    dailySpamReportsRate?: SortOrder
    dailyTotalClickRate?: SortOrder
    dailyTotalClickToOpenRate?: SortOrder
    dailyTotalOpenRate?: SortOrder
    dailyUniqueClickRate?: SortOrder
    dailyUniqueClickToOpenRate?: SortOrder
    dailyUniqueOpenRate?: SortOrder
    dailyUnsubscribeRate?: SortOrder
    spamReportDrops?: SortOrder
    spamReports?: SortOrder
    totalClicks?: SortOrder
    totalOpens?: SortOrder
    uniqueClicks?: SortOrder
    uniqueOpens?: SortOrder
  }

  export type EmailCampaignDailyStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    opens?: SortOrder
    clicks?: SortOrder
    bounces?: SortOrder
    unsubscribes?: SortOrder
    variation?: SortOrder
    phase?: SortOrder
    requests?: SortOrder
    delivered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bounceDrops?: SortOrder
    cumulativeBounceRate?: SortOrder
    cumulativeSpamReportsRate?: SortOrder
    cumulativeTotalClickRate?: SortOrder
    cumulativeTotalOpenRate?: SortOrder
    cumulativeUniqueClickRate?: SortOrder
    cumulativeUniqueOpenRate?: SortOrder
    cumulativeUnsubscribeRate?: SortOrder
    dailyBounceRate?: SortOrder
    dailySpamReportsRate?: SortOrder
    dailyTotalClickRate?: SortOrder
    dailyTotalClickToOpenRate?: SortOrder
    dailyTotalOpenRate?: SortOrder
    dailyUniqueClickRate?: SortOrder
    dailyUniqueClickToOpenRate?: SortOrder
    dailyUniqueOpenRate?: SortOrder
    dailyUnsubscribeRate?: SortOrder
    emailCampaignId?: SortOrder
    emailClientId?: SortOrder
    singleSendName?: SortOrder
    spamReportDrops?: SortOrder
    spamReports?: SortOrder
    totalClicks?: SortOrder
    totalOpens?: SortOrder
    uniqueClicks?: SortOrder
    uniqueOpens?: SortOrder
  }

  export type EmailCampaignDailyStatsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    opens?: SortOrder
    clicks?: SortOrder
    bounces?: SortOrder
    unsubscribes?: SortOrder
    variation?: SortOrder
    phase?: SortOrder
    requests?: SortOrder
    delivered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bounceDrops?: SortOrder
    cumulativeBounceRate?: SortOrder
    cumulativeSpamReportsRate?: SortOrder
    cumulativeTotalClickRate?: SortOrder
    cumulativeTotalOpenRate?: SortOrder
    cumulativeUniqueClickRate?: SortOrder
    cumulativeUniqueOpenRate?: SortOrder
    cumulativeUnsubscribeRate?: SortOrder
    dailyBounceRate?: SortOrder
    dailySpamReportsRate?: SortOrder
    dailyTotalClickRate?: SortOrder
    dailyTotalClickToOpenRate?: SortOrder
    dailyTotalOpenRate?: SortOrder
    dailyUniqueClickRate?: SortOrder
    dailyUniqueClickToOpenRate?: SortOrder
    dailyUniqueOpenRate?: SortOrder
    dailyUnsubscribeRate?: SortOrder
    emailCampaignId?: SortOrder
    emailClientId?: SortOrder
    singleSendName?: SortOrder
    spamReportDrops?: SortOrder
    spamReports?: SortOrder
    totalClicks?: SortOrder
    totalOpens?: SortOrder
    uniqueClicks?: SortOrder
    uniqueOpens?: SortOrder
  }

  export type EmailCampaignDailyStatsSumOrderByAggregateInput = {
    opens?: SortOrder
    clicks?: SortOrder
    bounces?: SortOrder
    unsubscribes?: SortOrder
    requests?: SortOrder
    delivered?: SortOrder
    bounceDrops?: SortOrder
    cumulativeBounceRate?: SortOrder
    cumulativeSpamReportsRate?: SortOrder
    cumulativeTotalClickRate?: SortOrder
    cumulativeTotalOpenRate?: SortOrder
    cumulativeUniqueClickRate?: SortOrder
    cumulativeUniqueOpenRate?: SortOrder
    cumulativeUnsubscribeRate?: SortOrder
    dailyBounceRate?: SortOrder
    dailySpamReportsRate?: SortOrder
    dailyTotalClickRate?: SortOrder
    dailyTotalClickToOpenRate?: SortOrder
    dailyTotalOpenRate?: SortOrder
    dailyUniqueClickRate?: SortOrder
    dailyUniqueClickToOpenRate?: SortOrder
    dailyUniqueOpenRate?: SortOrder
    dailyUnsubscribeRate?: SortOrder
    spamReportDrops?: SortOrder
    spamReports?: SortOrder
    totalClicks?: SortOrder
    totalOpens?: SortOrder
    uniqueClicks?: SortOrder
    uniqueOpens?: SortOrder
  }

  export type EmailCampaignListRelationFilter = {
    every?: EmailCampaignWhereInput
    some?: EmailCampaignWhereInput
    none?: EmailCampaignWhereInput
  }

  export type EmailClientCredentialsListRelationFilter = {
    every?: EmailClientCredentialsWhereInput
    some?: EmailClientCredentialsWhereInput
    none?: EmailClientCredentialsWhereInput
  }

  export type EmailGlobalDailyStatsListRelationFilter = {
    every?: EmailGlobalDailyStatsWhereInput
    some?: EmailGlobalDailyStatsWhereInput
    none?: EmailGlobalDailyStatsWhereInput
  }

  export type UserToEmailClientListRelationFilter = {
    every?: UserToEmailClientWhereInput
    some?: UserToEmailClientWhereInput
    none?: UserToEmailClientWhereInput
  }

  export type EmailCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailClientCredentialsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailGlobalDailyStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserToEmailClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailClientCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientName?: SortOrder
  }

  export type EmailClientMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientName?: SortOrder
  }

  export type EmailClientMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientName?: SortOrder
  }

  export type EmailClientCredentialsEmailClientIdPlatformNameCompoundUniqueInput = {
    emailClientId: string
    platformName: string
  }

  export type EmailClientCredentialsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiKey?: SortOrder
    emailClientId?: SortOrder
    platformName?: SortOrder
  }

  export type EmailClientCredentialsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiKey?: SortOrder
    emailClientId?: SortOrder
    platformName?: SortOrder
  }

  export type EmailClientCredentialsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiKey?: SortOrder
    emailClientId?: SortOrder
    platformName?: SortOrder
  }

  export type EmailGlobalDailyStatsEmailClientIdDateCompoundUniqueInput = {
    emailClientId: string
    date: Date | string
  }

  export type EmailGlobalDailyStatsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bounces?: SortOrder
    clicks?: SortOrder
    emailClientId?: SortOrder
    opens?: SortOrder
    unsubs?: SortOrder
  }

  export type EmailGlobalDailyStatsAvgOrderByAggregateInput = {
    bounces?: SortOrder
    clicks?: SortOrder
    opens?: SortOrder
    unsubs?: SortOrder
  }

  export type EmailGlobalDailyStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bounces?: SortOrder
    clicks?: SortOrder
    emailClientId?: SortOrder
    opens?: SortOrder
    unsubs?: SortOrder
  }

  export type EmailGlobalDailyStatsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bounces?: SortOrder
    clicks?: SortOrder
    emailClientId?: SortOrder
    opens?: SortOrder
    unsubs?: SortOrder
  }

  export type EmailGlobalDailyStatsSumOrderByAggregateInput = {
    bounces?: SortOrder
    clicks?: SortOrder
    opens?: SortOrder
    unsubs?: SortOrder
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type GaPropertyListRelationFilter = {
    every?: GaPropertyWhereInput
    some?: GaPropertyWhereInput
    none?: GaPropertyWhereInput
  }

  export type UserToGaAccountListRelationFilter = {
    every?: UserToGaAccountWhereInput
    some?: UserToGaAccountWhereInput
    none?: UserToGaAccountWhereInput
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaPropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserToGaAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaAccountCountOrderByAggregateInput = {
    id?: SortOrder
    gaAccountId?: SortOrder
    gaAccountName?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    gaAccountId?: SortOrder
    gaAccountName?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaAccountMinOrderByAggregateInput = {
    id?: SortOrder
    gaAccountId?: SortOrder
    gaAccountName?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaChannelDailyListRelationFilter = {
    every?: GaChannelDailyWhereInput
    some?: GaChannelDailyWhereInput
    none?: GaChannelDailyWhereInput
  }

  export type GaImportRunListRelationFilter = {
    every?: GaImportRunWhereInput
    some?: GaImportRunWhereInput
    none?: GaImportRunWhereInput
  }

  export type GaKpiDailyListRelationFilter = {
    every?: GaKpiDailyWhereInput
    some?: GaKpiDailyWhereInput
    none?: GaKpiDailyWhereInput
  }

  export type GaKpiMonthlyListRelationFilter = {
    every?: GaKpiMonthlyWhereInput
    some?: GaKpiMonthlyWhereInput
    none?: GaKpiMonthlyWhereInput
  }

  export type GaAccountScalarRelationFilter = {
    is?: GaAccountWhereInput
    isNot?: GaAccountWhereInput
  }

  export type GaSourceDailyListRelationFilter = {
    every?: GaSourceDailyWhereInput
    some?: GaSourceDailyWhereInput
    none?: GaSourceDailyWhereInput
  }

  export type GaChannelDailyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaImportRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaKpiDailyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaKpiMonthlyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaSourceDailyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GaPropertyCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    gaPropertyName?: SortOrder
    gaAccountId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaPropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    gaPropertyName?: SortOrder
    gaAccountId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaPropertyMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    gaPropertyName?: SortOrder
    gaAccountId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }

  export type GaPropertyScalarRelationFilter = {
    is?: GaPropertyWhereInput
    isNot?: GaPropertyWhereInput
  }

  export type GaImportRunCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    requestedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaImportRunMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    requestedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaImportRunMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    requestedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }

  export type GaKpiDailyGaPropertyIdDateCompoundUniqueInput = {
    gaPropertyId: string
    date: Date | string
  }

  export type GaKpiDailyCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaKpiDailyAvgOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaKpiDailyMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaKpiDailyMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaKpiDailySumOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaKpiMonthlyGaPropertyIdMonthCompoundUniqueInput = {
    gaPropertyId: string
    month: number
  }

  export type GaKpiMonthlyCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaKpiMonthlyAvgOrderByAggregateInput = {
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaKpiMonthlyMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaKpiMonthlyMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaKpiMonthlySumOrderByAggregateInput = {
    month?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaChannelDailyGaPropertyIdDateChannelGroupCompoundUniqueInput = {
    gaPropertyId: string
    date: Date | string
    channelGroup: string
  }

  export type GaChannelDailyCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    channelGroup?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaChannelDailyAvgOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaChannelDailyMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    channelGroup?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaChannelDailyMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    channelGroup?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaChannelDailySumOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaSourceDailyGaPropertyIdDateTrafficSourceCompoundUniqueInput = {
    gaPropertyId: string
    date: Date | string
    trafficSource: string
  }

  export type GaSourceDailyCountOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    trafficSource?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaSourceDailyAvgOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type GaSourceDailyMaxOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    trafficSource?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaSourceDailyMinOrderByAggregateInput = {
    id?: SortOrder
    gaPropertyId?: SortOrder
    date?: SortOrder
    trafficSource?: SortOrder
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaSourceDailySumOrderByAggregateInput = {
    sessions?: SortOrder
    screenPageViewsPerSession?: SortOrder
    engagementRate?: SortOrder
    avgSessionDurationSec?: SortOrder
    goalCompletions?: SortOrder
    goalCompletionRate?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageNullableScalarRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageAttachmentListRelationFilter = {
    every?: MessageAttachmentWhereInput
    some?: MessageAttachmentWhereInput
    none?: MessageAttachmentWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    isThreadStart?: SortOrder
    parentId?: SortOrder
    threadId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    isThreadStart?: SortOrder
    parentId?: SortOrder
    threadId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archived?: SortOrder
    isThreadStart?: SortOrder
    parentId?: SortOrder
    threadId?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type QueryScalarRelationFilter = {
    is?: QueryWhereInput
    isNot?: QueryWhereInput
  }

  export type ParsedPieGraphDataCountOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParsedPieGraphDataAvgOrderByAggregateInput = {
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
  }

  export type ParsedPieGraphDataMaxOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParsedPieGraphDataMinOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParsedPieGraphDataSumOrderByAggregateInput = {
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    prevSessionsDiff?: SortOrder
    prevConversionRateDiff?: SortOrder
    prevConversionsDiff?: SortOrder
    prevBouncesDiff?: SortOrder
    yearSessionsDiff?: SortOrder
    yearConversionRateDiff?: SortOrder
    yearConversionsDiff?: SortOrder
    yearBouncesDiff?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ParsedQueryDataCountOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    createdAt?: SortOrder
    bounceRate?: SortOrder
    engagedSessions?: SortOrder
    newUsers?: SortOrder
  }

  export type ParsedQueryDataAvgOrderByAggregateInput = {
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    bounceRate?: SortOrder
    engagedSessions?: SortOrder
    newUsers?: SortOrder
  }

  export type ParsedQueryDataMaxOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    createdAt?: SortOrder
    bounceRate?: SortOrder
    engagedSessions?: SortOrder
    newUsers?: SortOrder
  }

  export type ParsedQueryDataMinOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    channel?: SortOrder
    source?: SortOrder
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    createdAt?: SortOrder
    bounceRate?: SortOrder
    engagedSessions?: SortOrder
    newUsers?: SortOrder
  }

  export type ParsedQueryDataSumOrderByAggregateInput = {
    sessions?: SortOrder
    conversionRate?: SortOrder
    conversions?: SortOrder
    bounces?: SortOrder
    bounceRate?: SortOrder
    engagedSessions?: SortOrder
    newUsers?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ParsedQuerySummaryCountOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
    createdAt?: SortOrder
  }

  export type ParsedQuerySummaryAvgOrderByAggregateInput = {
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
  }

  export type ParsedQuerySummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
    createdAt?: SortOrder
  }

  export type ParsedQuerySummaryMinOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    date?: SortOrder
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
    createdAt?: SortOrder
  }

  export type ParsedQuerySummarySumOrderByAggregateInput = {
    totalEngagedSessions?: SortOrder
    averageBounceRate?: SortOrder
    totalNewUsers?: SortOrder
    totalConversions?: SortOrder
  }

  export type EnumQueryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusFilter<$PrismaModel> | $Enums.QueryStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ParsedPieGraphDataListRelationFilter = {
    every?: ParsedPieGraphDataWhereInput
    some?: ParsedPieGraphDataWhereInput
    none?: ParsedPieGraphDataWhereInput
  }

  export type ParsedQueryDataListRelationFilter = {
    every?: ParsedQueryDataWhereInput
    some?: ParsedQueryDataWhereInput
    none?: ParsedQueryDataWhereInput
  }

  export type ParsedQuerySummaryListRelationFilter = {
    every?: ParsedQuerySummaryWhereInput
    some?: ParsedQuerySummaryWhereInput
    none?: ParsedQuerySummaryWhereInput
  }

  export type ConversationNullableScalarRelationFilter = {
    is?: ConversationWhereInput | null
    isNot?: ConversationWhereInput | null
  }

  export type ParsedPieGraphDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParsedQueryDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParsedQuerySummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    status?: SortOrder
    conversationId?: SortOrder
    rating?: SortOrder
    metadata?: SortOrder
    lineGraphData?: SortOrder
    pieGraphData?: SortOrder
  }

  export type QueryAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type QueryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    status?: SortOrder
    conversationId?: SortOrder
    rating?: SortOrder
  }

  export type QueryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    status?: SortOrder
    conversationId?: SortOrder
    rating?: SortOrder
  }

  export type QuerySumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumQueryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueryStatusFilter<$PrismaModel>
    _max?: NestedEnumQueryStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type SproutSocialAccountScalarRelationFilter = {
    is?: SproutSocialAccountWhereInput
    isNot?: SproutSocialAccountWhereInput
  }

  export type SproutFacebookAnalyticsCustomerProfileIdReportingDateCompoundUniqueInput = {
    customerProfileId: number
    reportingDate: Date | string
  }

  export type SproutFacebookAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    postContentClicks?: SortOrder
    postContentClicksOther?: SortOrder
    postLinkClicks?: SortOrder
    postPhotoViewClicks?: SortOrder
    tabViews?: SortOrder
    videoViews?: SortOrder
    videoViews10s?: SortOrder
    videoViewsOrganic?: SortOrder
    videoViewsPaid?: SortOrder
    videoViewsUnique?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    netFollowerGrowth?: SortOrder
  }

  export type SproutFacebookAnalyticsAvgOrderByAggregateInput = {
    customerProfileId?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    postContentClicks?: SortOrder
    postContentClicksOther?: SortOrder
    postLinkClicks?: SortOrder
    postPhotoViewClicks?: SortOrder
    tabViews?: SortOrder
    videoViews?: SortOrder
    videoViews10s?: SortOrder
    videoViewsOrganic?: SortOrder
    videoViewsPaid?: SortOrder
    videoViewsUnique?: SortOrder
    netFollowerGrowth?: SortOrder
  }

  export type SproutFacebookAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    postContentClicks?: SortOrder
    postContentClicksOther?: SortOrder
    postLinkClicks?: SortOrder
    postPhotoViewClicks?: SortOrder
    tabViews?: SortOrder
    videoViews?: SortOrder
    videoViews10s?: SortOrder
    videoViewsOrganic?: SortOrder
    videoViewsPaid?: SortOrder
    videoViewsUnique?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    netFollowerGrowth?: SortOrder
  }

  export type SproutFacebookAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    postContentClicks?: SortOrder
    postContentClicksOther?: SortOrder
    postLinkClicks?: SortOrder
    postPhotoViewClicks?: SortOrder
    tabViews?: SortOrder
    videoViews?: SortOrder
    videoViews10s?: SortOrder
    videoViewsOrganic?: SortOrder
    videoViewsPaid?: SortOrder
    videoViewsUnique?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    netFollowerGrowth?: SortOrder
  }

  export type SproutFacebookAnalyticsSumOrderByAggregateInput = {
    customerProfileId?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    postContentClicks?: SortOrder
    postContentClicksOther?: SortOrder
    postLinkClicks?: SortOrder
    postPhotoViewClicks?: SortOrder
    tabViews?: SortOrder
    videoViews?: SortOrder
    videoViews10s?: SortOrder
    videoViewsOrganic?: SortOrder
    videoViewsPaid?: SortOrder
    videoViewsUnique?: SortOrder
    netFollowerGrowth?: SortOrder
  }

  export type SproutFacebookPostSproutSocialAccountIdPostNativeIdCompoundUniqueInput = {
    sproutSocialAccountId: string
    postNativeId: string
  }

  export type SproutFacebookPostCountOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    postType?: SortOrder
    postStatus?: SortOrder
    postLink?: SortOrder
    postText?: SortOrder
    postNativeId?: SortOrder
    postCreatedTime?: SortOrder
    postSentTime?: SortOrder
    postLastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutFacebookPostMaxOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    postType?: SortOrder
    postStatus?: SortOrder
    postLink?: SortOrder
    postText?: SortOrder
    postNativeId?: SortOrder
    postCreatedTime?: SortOrder
    postSentTime?: SortOrder
    postLastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutFacebookPostMinOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    postType?: SortOrder
    postStatus?: SortOrder
    postLink?: SortOrder
    postText?: SortOrder
    postNativeId?: SortOrder
    postCreatedTime?: SortOrder
    postSentTime?: SortOrder
    postLastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutFacebookPostAnalyticsPostNativeIdReportingDateCompoundUniqueInput = {
    postNativeId: string
    reportingDate: Date | string
  }

  export type SproutFacebookPostAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    angryReactions?: SortOrder
    clientNativeId?: SortOrder
    commentsCount?: SortOrder
    hahaReactions?: SortOrder
    impressions?: SortOrder
    impressionsFollower?: SortOrder
    impressionsNonFollower?: SortOrder
    impressionsNonViral?: SortOrder
    impressionsOrganic?: SortOrder
    impressionsPaid?: SortOrder
    impressionsViral?: SortOrder
    likes?: SortOrder
    loveReactions?: SortOrder
    postContentClicks?: SortOrder
    postContentClicksOther?: SortOrder
    postLinkClicks?: SortOrder
    postNativeId?: SortOrder
    postPhotoViewClicks?: SortOrder
    postVideoPlayClicks?: SortOrder
    questionAnswers?: SortOrder
    reach?: SortOrder
    reachFollower?: SortOrder
    reachNonViral?: SortOrder
    reachOrganic?: SortOrder
    reachPaid?: SortOrder
    reachViral?: SortOrder
    reactions?: SortOrder
    reportingDate?: SortOrder
    sadReactions?: SortOrder
    sharesCount?: SortOrder
    sproutSocialAccountId?: SortOrder
    videoLength?: SortOrder
    videoViews?: SortOrder
    videoViewsAutoplay?: SortOrder
    videoViewsOrganic?: SortOrder
    videoViewsPaid?: SortOrder
    wowReactions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutFacebookPostAnalyticsAvgOrderByAggregateInput = {
    angryReactions?: SortOrder
    commentsCount?: SortOrder
    hahaReactions?: SortOrder
    impressions?: SortOrder
    impressionsFollower?: SortOrder
    impressionsNonFollower?: SortOrder
    impressionsNonViral?: SortOrder
    impressionsOrganic?: SortOrder
    impressionsPaid?: SortOrder
    impressionsViral?: SortOrder
    likes?: SortOrder
    loveReactions?: SortOrder
    postContentClicks?: SortOrder
    postContentClicksOther?: SortOrder
    postLinkClicks?: SortOrder
    postPhotoViewClicks?: SortOrder
    postVideoPlayClicks?: SortOrder
    questionAnswers?: SortOrder
    reach?: SortOrder
    reachFollower?: SortOrder
    reachNonViral?: SortOrder
    reachOrganic?: SortOrder
    reachPaid?: SortOrder
    reachViral?: SortOrder
    reactions?: SortOrder
    sadReactions?: SortOrder
    sharesCount?: SortOrder
    videoLength?: SortOrder
    videoViews?: SortOrder
    videoViewsAutoplay?: SortOrder
    videoViewsOrganic?: SortOrder
    videoViewsPaid?: SortOrder
    wowReactions?: SortOrder
  }

  export type SproutFacebookPostAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    angryReactions?: SortOrder
    clientNativeId?: SortOrder
    commentsCount?: SortOrder
    hahaReactions?: SortOrder
    impressions?: SortOrder
    impressionsFollower?: SortOrder
    impressionsNonFollower?: SortOrder
    impressionsNonViral?: SortOrder
    impressionsOrganic?: SortOrder
    impressionsPaid?: SortOrder
    impressionsViral?: SortOrder
    likes?: SortOrder
    loveReactions?: SortOrder
    postContentClicks?: SortOrder
    postContentClicksOther?: SortOrder
    postLinkClicks?: SortOrder
    postNativeId?: SortOrder
    postPhotoViewClicks?: SortOrder
    postVideoPlayClicks?: SortOrder
    questionAnswers?: SortOrder
    reach?: SortOrder
    reachFollower?: SortOrder
    reachNonViral?: SortOrder
    reachOrganic?: SortOrder
    reachPaid?: SortOrder
    reachViral?: SortOrder
    reactions?: SortOrder
    reportingDate?: SortOrder
    sadReactions?: SortOrder
    sharesCount?: SortOrder
    sproutSocialAccountId?: SortOrder
    videoLength?: SortOrder
    videoViews?: SortOrder
    videoViewsAutoplay?: SortOrder
    videoViewsOrganic?: SortOrder
    videoViewsPaid?: SortOrder
    wowReactions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutFacebookPostAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    angryReactions?: SortOrder
    clientNativeId?: SortOrder
    commentsCount?: SortOrder
    hahaReactions?: SortOrder
    impressions?: SortOrder
    impressionsFollower?: SortOrder
    impressionsNonFollower?: SortOrder
    impressionsNonViral?: SortOrder
    impressionsOrganic?: SortOrder
    impressionsPaid?: SortOrder
    impressionsViral?: SortOrder
    likes?: SortOrder
    loveReactions?: SortOrder
    postContentClicks?: SortOrder
    postContentClicksOther?: SortOrder
    postLinkClicks?: SortOrder
    postNativeId?: SortOrder
    postPhotoViewClicks?: SortOrder
    postVideoPlayClicks?: SortOrder
    questionAnswers?: SortOrder
    reach?: SortOrder
    reachFollower?: SortOrder
    reachNonViral?: SortOrder
    reachOrganic?: SortOrder
    reachPaid?: SortOrder
    reachViral?: SortOrder
    reactions?: SortOrder
    reportingDate?: SortOrder
    sadReactions?: SortOrder
    sharesCount?: SortOrder
    sproutSocialAccountId?: SortOrder
    videoLength?: SortOrder
    videoViews?: SortOrder
    videoViewsAutoplay?: SortOrder
    videoViewsOrganic?: SortOrder
    videoViewsPaid?: SortOrder
    wowReactions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutFacebookPostAnalyticsSumOrderByAggregateInput = {
    angryReactions?: SortOrder
    commentsCount?: SortOrder
    hahaReactions?: SortOrder
    impressions?: SortOrder
    impressionsFollower?: SortOrder
    impressionsNonFollower?: SortOrder
    impressionsNonViral?: SortOrder
    impressionsOrganic?: SortOrder
    impressionsPaid?: SortOrder
    impressionsViral?: SortOrder
    likes?: SortOrder
    loveReactions?: SortOrder
    postContentClicks?: SortOrder
    postContentClicksOther?: SortOrder
    postLinkClicks?: SortOrder
    postPhotoViewClicks?: SortOrder
    postVideoPlayClicks?: SortOrder
    questionAnswers?: SortOrder
    reach?: SortOrder
    reachFollower?: SortOrder
    reachNonViral?: SortOrder
    reachOrganic?: SortOrder
    reachPaid?: SortOrder
    reachViral?: SortOrder
    reactions?: SortOrder
    sadReactions?: SortOrder
    sharesCount?: SortOrder
    videoLength?: SortOrder
    videoViews?: SortOrder
    videoViewsAutoplay?: SortOrder
    videoViewsOrganic?: SortOrder
    videoViewsPaid?: SortOrder
    wowReactions?: SortOrder
  }

  export type SproutInstagramFollowersByCityListRelationFilter = {
    every?: SproutInstagramFollowersByCityWhereInput
    some?: SproutInstagramFollowersByCityWhereInput
    none?: SproutInstagramFollowersByCityWhereInput
  }

  export type SproutInstagramFollowersByCountryListRelationFilter = {
    every?: SproutInstagramFollowersByCountryWhereInput
    some?: SproutInstagramFollowersByCountryWhereInput
    none?: SproutInstagramFollowersByCountryWhereInput
  }

  export type SproutInstagramFollowersByCityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SproutInstagramFollowersByCountryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SproutInstagramAnalyticsCustomerProfileIdReportingDateCompoundUniqueInput = {
    customerProfileId: number
    reportingDate: Date | string
  }

  export type SproutInstagramAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    commentsCount?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    likes?: SortOrder
    saves?: SortOrder
    videoViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailContacts?: SortOrder
    getDirectionsClicks?: SortOrder
    phoneCallClicks?: SortOrder
    postsSendByContentType?: SortOrder
    postsSentByPostType?: SortOrder
    postsSentCount?: SortOrder
    profileFollowerAdds?: SortOrder
    profileFollowers?: SortOrder
    profileImpressionsUnique?: SortOrder
    profileReachUnique?: SortOrder
    profileViews?: SortOrder
    profileViewsUnique?: SortOrder
    websiteClicks?: SortOrder
  }

  export type SproutInstagramAnalyticsAvgOrderByAggregateInput = {
    customerProfileId?: SortOrder
    commentsCount?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    likes?: SortOrder
    saves?: SortOrder
    videoViews?: SortOrder
    emailContacts?: SortOrder
    getDirectionsClicks?: SortOrder
    phoneCallClicks?: SortOrder
    postsSentCount?: SortOrder
    profileFollowerAdds?: SortOrder
    profileFollowers?: SortOrder
    profileImpressionsUnique?: SortOrder
    profileReachUnique?: SortOrder
    profileViews?: SortOrder
    profileViewsUnique?: SortOrder
    websiteClicks?: SortOrder
  }

  export type SproutInstagramAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    commentsCount?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    likes?: SortOrder
    saves?: SortOrder
    videoViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailContacts?: SortOrder
    getDirectionsClicks?: SortOrder
    phoneCallClicks?: SortOrder
    postsSentCount?: SortOrder
    profileFollowerAdds?: SortOrder
    profileFollowers?: SortOrder
    profileImpressionsUnique?: SortOrder
    profileReachUnique?: SortOrder
    profileViews?: SortOrder
    profileViewsUnique?: SortOrder
    websiteClicks?: SortOrder
  }

  export type SproutInstagramAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    commentsCount?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    likes?: SortOrder
    saves?: SortOrder
    videoViews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailContacts?: SortOrder
    getDirectionsClicks?: SortOrder
    phoneCallClicks?: SortOrder
    postsSentCount?: SortOrder
    profileFollowerAdds?: SortOrder
    profileFollowers?: SortOrder
    profileImpressionsUnique?: SortOrder
    profileReachUnique?: SortOrder
    profileViews?: SortOrder
    profileViewsUnique?: SortOrder
    websiteClicks?: SortOrder
  }

  export type SproutInstagramAnalyticsSumOrderByAggregateInput = {
    customerProfileId?: SortOrder
    commentsCount?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    likes?: SortOrder
    saves?: SortOrder
    videoViews?: SortOrder
    emailContacts?: SortOrder
    getDirectionsClicks?: SortOrder
    phoneCallClicks?: SortOrder
    postsSentCount?: SortOrder
    profileFollowerAdds?: SortOrder
    profileFollowers?: SortOrder
    profileImpressionsUnique?: SortOrder
    profileReachUnique?: SortOrder
    profileViews?: SortOrder
    profileViewsUnique?: SortOrder
    websiteClicks?: SortOrder
  }

  export type SproutInstagramAnalyticsScalarRelationFilter = {
    is?: SproutInstagramAnalyticsWhereInput
    isNot?: SproutInstagramAnalyticsWhereInput
  }

  export type SproutInstagramFollowersByCitySproutInstagramAnalyticsIdCityCompoundUniqueInput = {
    sproutInstagramAnalyticsId: string
    city: string
  }

  export type SproutInstagramFollowersByCityCountOrderByAggregateInput = {
    id?: SortOrder
    sproutInstagramAnalyticsId?: SortOrder
    city?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutInstagramFollowersByCityAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type SproutInstagramFollowersByCityMaxOrderByAggregateInput = {
    id?: SortOrder
    sproutInstagramAnalyticsId?: SortOrder
    city?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutInstagramFollowersByCityMinOrderByAggregateInput = {
    id?: SortOrder
    sproutInstagramAnalyticsId?: SortOrder
    city?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutInstagramFollowersByCitySumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type SproutInstagramFollowersByCountrySproutInstagramAnalyticsIdCountryCompoundUniqueInput = {
    sproutInstagramAnalyticsId: string
    country: string
  }

  export type SproutInstagramFollowersByCountryCountOrderByAggregateInput = {
    id?: SortOrder
    sproutInstagramAnalyticsId?: SortOrder
    country?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutInstagramFollowersByCountryAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type SproutInstagramFollowersByCountryMaxOrderByAggregateInput = {
    id?: SortOrder
    sproutInstagramAnalyticsId?: SortOrder
    country?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutInstagramFollowersByCountryMinOrderByAggregateInput = {
    id?: SortOrder
    sproutInstagramAnalyticsId?: SortOrder
    country?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutInstagramFollowersByCountrySumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type SproutLinkedInAnalyticsCustomerProfileIdReportingDateCompoundUniqueInput = {
    customerProfileId: number
    reportingDate: Date | string
  }

  export type SproutLinkedInAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    reactions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutLinkedInAnalyticsAvgOrderByAggregateInput = {
    customerProfileId?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    reactions?: SortOrder
  }

  export type SproutLinkedInAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    reactions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutLinkedInAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    reactions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutLinkedInAnalyticsSumOrderByAggregateInput = {
    customerProfileId?: SortOrder
    engagements?: SortOrder
    impressions?: SortOrder
    impressionsUnique?: SortOrder
    followersCount?: SortOrder
    reactions?: SortOrder
  }

  export type SproutPinterestAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutPinterestAnalyticsAvgOrderByAggregateInput = {
    customerProfileId?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
  }

  export type SproutPinterestAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutPinterestAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    sproutSocialAccountId?: SortOrder
    customerProfileId?: SortOrder
    reportingDate?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutPinterestAnalyticsSumOrderByAggregateInput = {
    customerProfileId?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SproutFacebookAnalyticsListRelationFilter = {
    every?: SproutFacebookAnalyticsWhereInput
    some?: SproutFacebookAnalyticsWhereInput
    none?: SproutFacebookAnalyticsWhereInput
  }

  export type SproutFacebookPostListRelationFilter = {
    every?: SproutFacebookPostWhereInput
    some?: SproutFacebookPostWhereInput
    none?: SproutFacebookPostWhereInput
  }

  export type SproutFacebookPostAnalyticsListRelationFilter = {
    every?: SproutFacebookPostAnalyticsWhereInput
    some?: SproutFacebookPostAnalyticsWhereInput
    none?: SproutFacebookPostAnalyticsWhereInput
  }

  export type SproutInstagramAnalyticsListRelationFilter = {
    every?: SproutInstagramAnalyticsWhereInput
    some?: SproutInstagramAnalyticsWhereInput
    none?: SproutInstagramAnalyticsWhereInput
  }

  export type SproutLinkedInAnalyticsListRelationFilter = {
    every?: SproutLinkedInAnalyticsWhereInput
    some?: SproutLinkedInAnalyticsWhereInput
    none?: SproutLinkedInAnalyticsWhereInput
  }

  export type SproutPinterestAnalyticsListRelationFilter = {
    every?: SproutPinterestAnalyticsWhereInput
    some?: SproutPinterestAnalyticsWhereInput
    none?: SproutPinterestAnalyticsWhereInput
  }

  export type UserToSproutSocialAccountListRelationFilter = {
    every?: UserToSproutSocialAccountWhereInput
    some?: UserToSproutSocialAccountWhereInput
    none?: UserToSproutSocialAccountWhereInput
  }

  export type SproutFacebookAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SproutFacebookPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SproutFacebookPostAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SproutInstagramAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SproutLinkedInAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SproutPinterestAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserToSproutSocialAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SproutSocialAccountCountOrderByAggregateInput = {
    id?: SortOrder
    customerProfileId?: SortOrder
    networkType?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    link?: SortOrder
    nativeId?: SortOrder
    groups?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutSocialAccountAvgOrderByAggregateInput = {
    customerProfileId?: SortOrder
    groups?: SortOrder
  }

  export type SproutSocialAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    customerProfileId?: SortOrder
    networkType?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    link?: SortOrder
    nativeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutSocialAccountMinOrderByAggregateInput = {
    id?: SortOrder
    customerProfileId?: SortOrder
    networkType?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    link?: SortOrder
    nativeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SproutSocialAccountSumOrderByAggregateInput = {
    customerProfileId?: SortOrder
    groups?: SortOrder
  }

  export type UserToSproutSocialAccountUserIdSproutSocialAccountIdCompoundUniqueInput = {
    userId: string
    sproutSocialAccountId: string
  }

  export type UserToSproutSocialAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sproutSocialAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToSproutSocialAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sproutSocialAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToSproutSocialAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sproutSocialAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToGaAccountUserIdGaAccountIdCompoundUniqueInput = {
    userId: string
    gaAccountId: string
  }

  export type UserToGaAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gaAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToGaAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gaAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToGaAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gaAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ClientActivityListRelationFilter = {
    every?: ClientActivityWhereInput
    some?: ClientActivityWhereInput
    none?: ClientActivityWhereInput
  }

  export type ClientSatisfactionListRelationFilter = {
    every?: ClientSatisfactionWhereInput
    some?: ClientSatisfactionWhereInput
    none?: ClientSatisfactionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type TicketCommentListRelationFilter = {
    every?: TicketCommentWhereInput
    some?: TicketCommentWhereInput
    none?: TicketCommentWhereInput
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientSatisfactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    name?: SortOrder
    accountRepId?: SortOrder
    isActive?: SortOrder
    password?: SortOrder
    deleted?: SortOrder
    companyId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    name?: SortOrder
    accountRepId?: SortOrder
    isActive?: SortOrder
    password?: SortOrder
    deleted?: SortOrder
    companyId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    name?: SortOrder
    accountRepId?: SortOrder
    isActive?: SortOrder
    password?: SortOrder
    deleted?: SortOrder
    companyId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    theme?: SortOrder
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
  }

  export type UserSettingsAvgOrderByAggregateInput = {
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    theme?: SortOrder
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    theme?: SortOrder
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
  }

  export type UserSettingsSumOrderByAggregateInput = {
    apiCredits?: SortOrder
    apiCreditsLimit?: SortOrder
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type TicketAttachmentListRelationFilter = {
    every?: TicketAttachmentWhereInput
    some?: TicketAttachmentWhereInput
    none?: TicketAttachmentWhereInput
  }

  export type TicketTagListRelationFilter = {
    every?: TicketTagWhereInput
    some?: TicketTagWhereInput
    none?: TicketTagWhereInput
  }

  export type TicketAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    clientId?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    clientId?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    clientId?: SortOrder
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type TicketScalarRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type TicketAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
  }

  export type TicketAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
  }

  export type TicketAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
  }

  export type TicketCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
  }

  export type TicketCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
  }

  export type TicketCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
  }

  export type TicketTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
  }

  export type MessageAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type MessageAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
  }

  export type MessageAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
  }

  export type MessageAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumActivityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusFilter<$PrismaModel> | $Enums.ActivityStatus
  }

  export type ClientActivityCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ClientActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ClientActivityMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumActivityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActivityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityStatusFilter<$PrismaModel>
    _max?: NestedEnumActivityStatusFilter<$PrismaModel>
  }

  export type UserToEmailClientUserIdEmailClientIdCompoundUniqueInput = {
    userId: string
    emailClientId: string
  }

  export type UserToEmailClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailClientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToEmailClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailClientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToEmailClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailClientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutReceivedRatingsInput = {
    create?: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGivenRatingsInput = {
    create?: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGivenRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutReceivedRatingsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedRatingsInput
    upsert?: UserUpsertWithoutReceivedRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedRatingsInput, UserUpdateWithoutReceivedRatingsInput>, UserUncheckedUpdateWithoutReceivedRatingsInput>
  }

  export type UserUpdateOneRequiredWithoutGivenRatingsNestedInput = {
    create?: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGivenRatingsInput
    upsert?: UserUpsertWithoutGivenRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGivenRatingsInput, UserUpdateWithoutGivenRatingsInput>, UserUncheckedUpdateWithoutGivenRatingsInput>
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClientConversationsInput = {
    create?: XOR<UserCreateWithoutClientConversationsInput, UserUncheckedCreateWithoutClientConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type GaAccountCreateNestedOneWithoutConversationsInput = {
    create?: XOR<GaAccountCreateWithoutConversationsInput, GaAccountUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: GaAccountCreateOrConnectWithoutConversationsInput
    connect?: GaAccountWhereUniqueInput
  }

  export type GaPropertyCreateNestedOneWithoutConversationsInput = {
    create?: XOR<GaPropertyCreateWithoutConversationsInput, GaPropertyUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutConversationsInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type QueryCreateNestedManyWithoutConversationInput = {
    create?: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput> | QueryCreateWithoutConversationInput[] | QueryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutConversationInput | QueryCreateOrConnectWithoutConversationInput[]
    createMany?: QueryCreateManyConversationInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type QueryUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput> | QueryCreateWithoutConversationInput[] | QueryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutConversationInput | QueryCreateOrConnectWithoutConversationInput[]
    createMany?: QueryCreateManyConversationInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutClientConversationsNestedInput = {
    create?: XOR<UserCreateWithoutClientConversationsInput, UserUncheckedCreateWithoutClientConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientConversationsInput
    upsert?: UserUpsertWithoutClientConversationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientConversationsInput, UserUpdateWithoutClientConversationsInput>, UserUncheckedUpdateWithoutClientConversationsInput>
  }

  export type GaAccountUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<GaAccountCreateWithoutConversationsInput, GaAccountUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: GaAccountCreateOrConnectWithoutConversationsInput
    upsert?: GaAccountUpsertWithoutConversationsInput
    disconnect?: GaAccountWhereInput | boolean
    delete?: GaAccountWhereInput | boolean
    connect?: GaAccountWhereUniqueInput
    update?: XOR<XOR<GaAccountUpdateToOneWithWhereWithoutConversationsInput, GaAccountUpdateWithoutConversationsInput>, GaAccountUncheckedUpdateWithoutConversationsInput>
  }

  export type GaPropertyUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<GaPropertyCreateWithoutConversationsInput, GaPropertyUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutConversationsInput
    upsert?: GaPropertyUpsertWithoutConversationsInput
    disconnect?: GaPropertyWhereInput | boolean
    delete?: GaPropertyWhereInput | boolean
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutConversationsInput, GaPropertyUpdateWithoutConversationsInput>, GaPropertyUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type QueryUpdateManyWithoutConversationNestedInput = {
    create?: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput> | QueryCreateWithoutConversationInput[] | QueryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutConversationInput | QueryCreateOrConnectWithoutConversationInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutConversationInput | QueryUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: QueryCreateManyConversationInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutConversationInput | QueryUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutConversationInput | QueryUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type QueryUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput> | QueryCreateWithoutConversationInput[] | QueryUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutConversationInput | QueryCreateOrConnectWithoutConversationInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutConversationInput | QueryUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: QueryCreateManyConversationInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutConversationInput | QueryUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutConversationInput | QueryUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type EmailClientCreateNestedOneWithoutEmailCampaignsInput = {
    create?: XOR<EmailClientCreateWithoutEmailCampaignsInput, EmailClientUncheckedCreateWithoutEmailCampaignsInput>
    connectOrCreate?: EmailClientCreateOrConnectWithoutEmailCampaignsInput
    connect?: EmailClientWhereUniqueInput
  }

  export type EmailCampaignContentCreateNestedOneWithoutEmailCampaignInput = {
    create?: XOR<EmailCampaignContentCreateWithoutEmailCampaignInput, EmailCampaignContentUncheckedCreateWithoutEmailCampaignInput>
    connectOrCreate?: EmailCampaignContentCreateOrConnectWithoutEmailCampaignInput
    connect?: EmailCampaignContentWhereUniqueInput
  }

  export type EmailCampaignDailyStatsCreateNestedManyWithoutEmailCampaignInput = {
    create?: XOR<EmailCampaignDailyStatsCreateWithoutEmailCampaignInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailCampaignInput> | EmailCampaignDailyStatsCreateWithoutEmailCampaignInput[] | EmailCampaignDailyStatsUncheckedCreateWithoutEmailCampaignInput[]
    connectOrCreate?: EmailCampaignDailyStatsCreateOrConnectWithoutEmailCampaignInput | EmailCampaignDailyStatsCreateOrConnectWithoutEmailCampaignInput[]
    createMany?: EmailCampaignDailyStatsCreateManyEmailCampaignInputEnvelope
    connect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
  }

  export type EmailCampaignContentUncheckedCreateNestedOneWithoutEmailCampaignInput = {
    create?: XOR<EmailCampaignContentCreateWithoutEmailCampaignInput, EmailCampaignContentUncheckedCreateWithoutEmailCampaignInput>
    connectOrCreate?: EmailCampaignContentCreateOrConnectWithoutEmailCampaignInput
    connect?: EmailCampaignContentWhereUniqueInput
  }

  export type EmailCampaignDailyStatsUncheckedCreateNestedManyWithoutEmailCampaignInput = {
    create?: XOR<EmailCampaignDailyStatsCreateWithoutEmailCampaignInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailCampaignInput> | EmailCampaignDailyStatsCreateWithoutEmailCampaignInput[] | EmailCampaignDailyStatsUncheckedCreateWithoutEmailCampaignInput[]
    connectOrCreate?: EmailCampaignDailyStatsCreateOrConnectWithoutEmailCampaignInput | EmailCampaignDailyStatsCreateOrConnectWithoutEmailCampaignInput[]
    createMany?: EmailCampaignDailyStatsCreateManyEmailCampaignInputEnvelope
    connect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
  }

  export type EmailClientUpdateOneRequiredWithoutEmailCampaignsNestedInput = {
    create?: XOR<EmailClientCreateWithoutEmailCampaignsInput, EmailClientUncheckedCreateWithoutEmailCampaignsInput>
    connectOrCreate?: EmailClientCreateOrConnectWithoutEmailCampaignsInput
    upsert?: EmailClientUpsertWithoutEmailCampaignsInput
    connect?: EmailClientWhereUniqueInput
    update?: XOR<XOR<EmailClientUpdateToOneWithWhereWithoutEmailCampaignsInput, EmailClientUpdateWithoutEmailCampaignsInput>, EmailClientUncheckedUpdateWithoutEmailCampaignsInput>
  }

  export type EmailCampaignContentUpdateOneWithoutEmailCampaignNestedInput = {
    create?: XOR<EmailCampaignContentCreateWithoutEmailCampaignInput, EmailCampaignContentUncheckedCreateWithoutEmailCampaignInput>
    connectOrCreate?: EmailCampaignContentCreateOrConnectWithoutEmailCampaignInput
    upsert?: EmailCampaignContentUpsertWithoutEmailCampaignInput
    disconnect?: EmailCampaignContentWhereInput | boolean
    delete?: EmailCampaignContentWhereInput | boolean
    connect?: EmailCampaignContentWhereUniqueInput
    update?: XOR<XOR<EmailCampaignContentUpdateToOneWithWhereWithoutEmailCampaignInput, EmailCampaignContentUpdateWithoutEmailCampaignInput>, EmailCampaignContentUncheckedUpdateWithoutEmailCampaignInput>
  }

  export type EmailCampaignDailyStatsUpdateManyWithoutEmailCampaignNestedInput = {
    create?: XOR<EmailCampaignDailyStatsCreateWithoutEmailCampaignInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailCampaignInput> | EmailCampaignDailyStatsCreateWithoutEmailCampaignInput[] | EmailCampaignDailyStatsUncheckedCreateWithoutEmailCampaignInput[]
    connectOrCreate?: EmailCampaignDailyStatsCreateOrConnectWithoutEmailCampaignInput | EmailCampaignDailyStatsCreateOrConnectWithoutEmailCampaignInput[]
    upsert?: EmailCampaignDailyStatsUpsertWithWhereUniqueWithoutEmailCampaignInput | EmailCampaignDailyStatsUpsertWithWhereUniqueWithoutEmailCampaignInput[]
    createMany?: EmailCampaignDailyStatsCreateManyEmailCampaignInputEnvelope
    set?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    disconnect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    delete?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    connect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    update?: EmailCampaignDailyStatsUpdateWithWhereUniqueWithoutEmailCampaignInput | EmailCampaignDailyStatsUpdateWithWhereUniqueWithoutEmailCampaignInput[]
    updateMany?: EmailCampaignDailyStatsUpdateManyWithWhereWithoutEmailCampaignInput | EmailCampaignDailyStatsUpdateManyWithWhereWithoutEmailCampaignInput[]
    deleteMany?: EmailCampaignDailyStatsScalarWhereInput | EmailCampaignDailyStatsScalarWhereInput[]
  }

  export type EmailCampaignContentUncheckedUpdateOneWithoutEmailCampaignNestedInput = {
    create?: XOR<EmailCampaignContentCreateWithoutEmailCampaignInput, EmailCampaignContentUncheckedCreateWithoutEmailCampaignInput>
    connectOrCreate?: EmailCampaignContentCreateOrConnectWithoutEmailCampaignInput
    upsert?: EmailCampaignContentUpsertWithoutEmailCampaignInput
    disconnect?: EmailCampaignContentWhereInput | boolean
    delete?: EmailCampaignContentWhereInput | boolean
    connect?: EmailCampaignContentWhereUniqueInput
    update?: XOR<XOR<EmailCampaignContentUpdateToOneWithWhereWithoutEmailCampaignInput, EmailCampaignContentUpdateWithoutEmailCampaignInput>, EmailCampaignContentUncheckedUpdateWithoutEmailCampaignInput>
  }

  export type EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailCampaignNestedInput = {
    create?: XOR<EmailCampaignDailyStatsCreateWithoutEmailCampaignInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailCampaignInput> | EmailCampaignDailyStatsCreateWithoutEmailCampaignInput[] | EmailCampaignDailyStatsUncheckedCreateWithoutEmailCampaignInput[]
    connectOrCreate?: EmailCampaignDailyStatsCreateOrConnectWithoutEmailCampaignInput | EmailCampaignDailyStatsCreateOrConnectWithoutEmailCampaignInput[]
    upsert?: EmailCampaignDailyStatsUpsertWithWhereUniqueWithoutEmailCampaignInput | EmailCampaignDailyStatsUpsertWithWhereUniqueWithoutEmailCampaignInput[]
    createMany?: EmailCampaignDailyStatsCreateManyEmailCampaignInputEnvelope
    set?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    disconnect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    delete?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    connect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    update?: EmailCampaignDailyStatsUpdateWithWhereUniqueWithoutEmailCampaignInput | EmailCampaignDailyStatsUpdateWithWhereUniqueWithoutEmailCampaignInput[]
    updateMany?: EmailCampaignDailyStatsUpdateManyWithWhereWithoutEmailCampaignInput | EmailCampaignDailyStatsUpdateManyWithWhereWithoutEmailCampaignInput[]
    deleteMany?: EmailCampaignDailyStatsScalarWhereInput | EmailCampaignDailyStatsScalarWhereInput[]
  }

  export type EmailCampaignCreateNestedOneWithoutEmailCampaignContentsInput = {
    create?: XOR<EmailCampaignCreateWithoutEmailCampaignContentsInput, EmailCampaignUncheckedCreateWithoutEmailCampaignContentsInput>
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutEmailCampaignContentsInput
    connect?: EmailCampaignWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmailCampaignUpdateOneRequiredWithoutEmailCampaignContentsNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutEmailCampaignContentsInput, EmailCampaignUncheckedCreateWithoutEmailCampaignContentsInput>
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutEmailCampaignContentsInput
    upsert?: EmailCampaignUpsertWithoutEmailCampaignContentsInput
    connect?: EmailCampaignWhereUniqueInput
    update?: XOR<XOR<EmailCampaignUpdateToOneWithWhereWithoutEmailCampaignContentsInput, EmailCampaignUpdateWithoutEmailCampaignContentsInput>, EmailCampaignUncheckedUpdateWithoutEmailCampaignContentsInput>
  }

  export type EmailCampaignCreateNestedOneWithoutEmailCampaignDailyStatsInput = {
    create?: XOR<EmailCampaignCreateWithoutEmailCampaignDailyStatsInput, EmailCampaignUncheckedCreateWithoutEmailCampaignDailyStatsInput>
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutEmailCampaignDailyStatsInput
    connect?: EmailCampaignWhereUniqueInput
  }

  export type EmailClientCreateNestedOneWithoutEmailCampaignDailyStatsInput = {
    create?: XOR<EmailClientCreateWithoutEmailCampaignDailyStatsInput, EmailClientUncheckedCreateWithoutEmailCampaignDailyStatsInput>
    connectOrCreate?: EmailClientCreateOrConnectWithoutEmailCampaignDailyStatsInput
    connect?: EmailClientWhereUniqueInput
  }

  export type EmailCampaignUpdateOneRequiredWithoutEmailCampaignDailyStatsNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutEmailCampaignDailyStatsInput, EmailCampaignUncheckedCreateWithoutEmailCampaignDailyStatsInput>
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutEmailCampaignDailyStatsInput
    upsert?: EmailCampaignUpsertWithoutEmailCampaignDailyStatsInput
    connect?: EmailCampaignWhereUniqueInput
    update?: XOR<XOR<EmailCampaignUpdateToOneWithWhereWithoutEmailCampaignDailyStatsInput, EmailCampaignUpdateWithoutEmailCampaignDailyStatsInput>, EmailCampaignUncheckedUpdateWithoutEmailCampaignDailyStatsInput>
  }

  export type EmailClientUpdateOneRequiredWithoutEmailCampaignDailyStatsNestedInput = {
    create?: XOR<EmailClientCreateWithoutEmailCampaignDailyStatsInput, EmailClientUncheckedCreateWithoutEmailCampaignDailyStatsInput>
    connectOrCreate?: EmailClientCreateOrConnectWithoutEmailCampaignDailyStatsInput
    upsert?: EmailClientUpsertWithoutEmailCampaignDailyStatsInput
    connect?: EmailClientWhereUniqueInput
    update?: XOR<XOR<EmailClientUpdateToOneWithWhereWithoutEmailCampaignDailyStatsInput, EmailClientUpdateWithoutEmailCampaignDailyStatsInput>, EmailClientUncheckedUpdateWithoutEmailCampaignDailyStatsInput>
  }

  export type EmailCampaignCreateNestedManyWithoutEmailClientInput = {
    create?: XOR<EmailCampaignCreateWithoutEmailClientInput, EmailCampaignUncheckedCreateWithoutEmailClientInput> | EmailCampaignCreateWithoutEmailClientInput[] | EmailCampaignUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutEmailClientInput | EmailCampaignCreateOrConnectWithoutEmailClientInput[]
    createMany?: EmailCampaignCreateManyEmailClientInputEnvelope
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
  }

  export type EmailCampaignDailyStatsCreateNestedManyWithoutEmailClientInput = {
    create?: XOR<EmailCampaignDailyStatsCreateWithoutEmailClientInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailClientInput> | EmailCampaignDailyStatsCreateWithoutEmailClientInput[] | EmailCampaignDailyStatsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailCampaignDailyStatsCreateOrConnectWithoutEmailClientInput | EmailCampaignDailyStatsCreateOrConnectWithoutEmailClientInput[]
    createMany?: EmailCampaignDailyStatsCreateManyEmailClientInputEnvelope
    connect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
  }

  export type EmailClientCredentialsCreateNestedManyWithoutEmailClientInput = {
    create?: XOR<EmailClientCredentialsCreateWithoutEmailClientInput, EmailClientCredentialsUncheckedCreateWithoutEmailClientInput> | EmailClientCredentialsCreateWithoutEmailClientInput[] | EmailClientCredentialsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailClientCredentialsCreateOrConnectWithoutEmailClientInput | EmailClientCredentialsCreateOrConnectWithoutEmailClientInput[]
    createMany?: EmailClientCredentialsCreateManyEmailClientInputEnvelope
    connect?: EmailClientCredentialsWhereUniqueInput | EmailClientCredentialsWhereUniqueInput[]
  }

  export type EmailGlobalDailyStatsCreateNestedManyWithoutEmailClientInput = {
    create?: XOR<EmailGlobalDailyStatsCreateWithoutEmailClientInput, EmailGlobalDailyStatsUncheckedCreateWithoutEmailClientInput> | EmailGlobalDailyStatsCreateWithoutEmailClientInput[] | EmailGlobalDailyStatsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailGlobalDailyStatsCreateOrConnectWithoutEmailClientInput | EmailGlobalDailyStatsCreateOrConnectWithoutEmailClientInput[]
    createMany?: EmailGlobalDailyStatsCreateManyEmailClientInputEnvelope
    connect?: EmailGlobalDailyStatsWhereUniqueInput | EmailGlobalDailyStatsWhereUniqueInput[]
  }

  export type UserToEmailClientCreateNestedManyWithoutEmailClientInput = {
    create?: XOR<UserToEmailClientCreateWithoutEmailClientInput, UserToEmailClientUncheckedCreateWithoutEmailClientInput> | UserToEmailClientCreateWithoutEmailClientInput[] | UserToEmailClientUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: UserToEmailClientCreateOrConnectWithoutEmailClientInput | UserToEmailClientCreateOrConnectWithoutEmailClientInput[]
    createMany?: UserToEmailClientCreateManyEmailClientInputEnvelope
    connect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
  }

  export type EmailCampaignUncheckedCreateNestedManyWithoutEmailClientInput = {
    create?: XOR<EmailCampaignCreateWithoutEmailClientInput, EmailCampaignUncheckedCreateWithoutEmailClientInput> | EmailCampaignCreateWithoutEmailClientInput[] | EmailCampaignUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutEmailClientInput | EmailCampaignCreateOrConnectWithoutEmailClientInput[]
    createMany?: EmailCampaignCreateManyEmailClientInputEnvelope
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
  }

  export type EmailCampaignDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput = {
    create?: XOR<EmailCampaignDailyStatsCreateWithoutEmailClientInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailClientInput> | EmailCampaignDailyStatsCreateWithoutEmailClientInput[] | EmailCampaignDailyStatsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailCampaignDailyStatsCreateOrConnectWithoutEmailClientInput | EmailCampaignDailyStatsCreateOrConnectWithoutEmailClientInput[]
    createMany?: EmailCampaignDailyStatsCreateManyEmailClientInputEnvelope
    connect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
  }

  export type EmailClientCredentialsUncheckedCreateNestedManyWithoutEmailClientInput = {
    create?: XOR<EmailClientCredentialsCreateWithoutEmailClientInput, EmailClientCredentialsUncheckedCreateWithoutEmailClientInput> | EmailClientCredentialsCreateWithoutEmailClientInput[] | EmailClientCredentialsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailClientCredentialsCreateOrConnectWithoutEmailClientInput | EmailClientCredentialsCreateOrConnectWithoutEmailClientInput[]
    createMany?: EmailClientCredentialsCreateManyEmailClientInputEnvelope
    connect?: EmailClientCredentialsWhereUniqueInput | EmailClientCredentialsWhereUniqueInput[]
  }

  export type EmailGlobalDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput = {
    create?: XOR<EmailGlobalDailyStatsCreateWithoutEmailClientInput, EmailGlobalDailyStatsUncheckedCreateWithoutEmailClientInput> | EmailGlobalDailyStatsCreateWithoutEmailClientInput[] | EmailGlobalDailyStatsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailGlobalDailyStatsCreateOrConnectWithoutEmailClientInput | EmailGlobalDailyStatsCreateOrConnectWithoutEmailClientInput[]
    createMany?: EmailGlobalDailyStatsCreateManyEmailClientInputEnvelope
    connect?: EmailGlobalDailyStatsWhereUniqueInput | EmailGlobalDailyStatsWhereUniqueInput[]
  }

  export type UserToEmailClientUncheckedCreateNestedManyWithoutEmailClientInput = {
    create?: XOR<UserToEmailClientCreateWithoutEmailClientInput, UserToEmailClientUncheckedCreateWithoutEmailClientInput> | UserToEmailClientCreateWithoutEmailClientInput[] | UserToEmailClientUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: UserToEmailClientCreateOrConnectWithoutEmailClientInput | UserToEmailClientCreateOrConnectWithoutEmailClientInput[]
    createMany?: UserToEmailClientCreateManyEmailClientInputEnvelope
    connect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
  }

  export type EmailCampaignUpdateManyWithoutEmailClientNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutEmailClientInput, EmailCampaignUncheckedCreateWithoutEmailClientInput> | EmailCampaignCreateWithoutEmailClientInput[] | EmailCampaignUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutEmailClientInput | EmailCampaignCreateOrConnectWithoutEmailClientInput[]
    upsert?: EmailCampaignUpsertWithWhereUniqueWithoutEmailClientInput | EmailCampaignUpsertWithWhereUniqueWithoutEmailClientInput[]
    createMany?: EmailCampaignCreateManyEmailClientInputEnvelope
    set?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    disconnect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    delete?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    update?: EmailCampaignUpdateWithWhereUniqueWithoutEmailClientInput | EmailCampaignUpdateWithWhereUniqueWithoutEmailClientInput[]
    updateMany?: EmailCampaignUpdateManyWithWhereWithoutEmailClientInput | EmailCampaignUpdateManyWithWhereWithoutEmailClientInput[]
    deleteMany?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
  }

  export type EmailCampaignDailyStatsUpdateManyWithoutEmailClientNestedInput = {
    create?: XOR<EmailCampaignDailyStatsCreateWithoutEmailClientInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailClientInput> | EmailCampaignDailyStatsCreateWithoutEmailClientInput[] | EmailCampaignDailyStatsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailCampaignDailyStatsCreateOrConnectWithoutEmailClientInput | EmailCampaignDailyStatsCreateOrConnectWithoutEmailClientInput[]
    upsert?: EmailCampaignDailyStatsUpsertWithWhereUniqueWithoutEmailClientInput | EmailCampaignDailyStatsUpsertWithWhereUniqueWithoutEmailClientInput[]
    createMany?: EmailCampaignDailyStatsCreateManyEmailClientInputEnvelope
    set?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    disconnect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    delete?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    connect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    update?: EmailCampaignDailyStatsUpdateWithWhereUniqueWithoutEmailClientInput | EmailCampaignDailyStatsUpdateWithWhereUniqueWithoutEmailClientInput[]
    updateMany?: EmailCampaignDailyStatsUpdateManyWithWhereWithoutEmailClientInput | EmailCampaignDailyStatsUpdateManyWithWhereWithoutEmailClientInput[]
    deleteMany?: EmailCampaignDailyStatsScalarWhereInput | EmailCampaignDailyStatsScalarWhereInput[]
  }

  export type EmailClientCredentialsUpdateManyWithoutEmailClientNestedInput = {
    create?: XOR<EmailClientCredentialsCreateWithoutEmailClientInput, EmailClientCredentialsUncheckedCreateWithoutEmailClientInput> | EmailClientCredentialsCreateWithoutEmailClientInput[] | EmailClientCredentialsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailClientCredentialsCreateOrConnectWithoutEmailClientInput | EmailClientCredentialsCreateOrConnectWithoutEmailClientInput[]
    upsert?: EmailClientCredentialsUpsertWithWhereUniqueWithoutEmailClientInput | EmailClientCredentialsUpsertWithWhereUniqueWithoutEmailClientInput[]
    createMany?: EmailClientCredentialsCreateManyEmailClientInputEnvelope
    set?: EmailClientCredentialsWhereUniqueInput | EmailClientCredentialsWhereUniqueInput[]
    disconnect?: EmailClientCredentialsWhereUniqueInput | EmailClientCredentialsWhereUniqueInput[]
    delete?: EmailClientCredentialsWhereUniqueInput | EmailClientCredentialsWhereUniqueInput[]
    connect?: EmailClientCredentialsWhereUniqueInput | EmailClientCredentialsWhereUniqueInput[]
    update?: EmailClientCredentialsUpdateWithWhereUniqueWithoutEmailClientInput | EmailClientCredentialsUpdateWithWhereUniqueWithoutEmailClientInput[]
    updateMany?: EmailClientCredentialsUpdateManyWithWhereWithoutEmailClientInput | EmailClientCredentialsUpdateManyWithWhereWithoutEmailClientInput[]
    deleteMany?: EmailClientCredentialsScalarWhereInput | EmailClientCredentialsScalarWhereInput[]
  }

  export type EmailGlobalDailyStatsUpdateManyWithoutEmailClientNestedInput = {
    create?: XOR<EmailGlobalDailyStatsCreateWithoutEmailClientInput, EmailGlobalDailyStatsUncheckedCreateWithoutEmailClientInput> | EmailGlobalDailyStatsCreateWithoutEmailClientInput[] | EmailGlobalDailyStatsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailGlobalDailyStatsCreateOrConnectWithoutEmailClientInput | EmailGlobalDailyStatsCreateOrConnectWithoutEmailClientInput[]
    upsert?: EmailGlobalDailyStatsUpsertWithWhereUniqueWithoutEmailClientInput | EmailGlobalDailyStatsUpsertWithWhereUniqueWithoutEmailClientInput[]
    createMany?: EmailGlobalDailyStatsCreateManyEmailClientInputEnvelope
    set?: EmailGlobalDailyStatsWhereUniqueInput | EmailGlobalDailyStatsWhereUniqueInput[]
    disconnect?: EmailGlobalDailyStatsWhereUniqueInput | EmailGlobalDailyStatsWhereUniqueInput[]
    delete?: EmailGlobalDailyStatsWhereUniqueInput | EmailGlobalDailyStatsWhereUniqueInput[]
    connect?: EmailGlobalDailyStatsWhereUniqueInput | EmailGlobalDailyStatsWhereUniqueInput[]
    update?: EmailGlobalDailyStatsUpdateWithWhereUniqueWithoutEmailClientInput | EmailGlobalDailyStatsUpdateWithWhereUniqueWithoutEmailClientInput[]
    updateMany?: EmailGlobalDailyStatsUpdateManyWithWhereWithoutEmailClientInput | EmailGlobalDailyStatsUpdateManyWithWhereWithoutEmailClientInput[]
    deleteMany?: EmailGlobalDailyStatsScalarWhereInput | EmailGlobalDailyStatsScalarWhereInput[]
  }

  export type UserToEmailClientUpdateManyWithoutEmailClientNestedInput = {
    create?: XOR<UserToEmailClientCreateWithoutEmailClientInput, UserToEmailClientUncheckedCreateWithoutEmailClientInput> | UserToEmailClientCreateWithoutEmailClientInput[] | UserToEmailClientUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: UserToEmailClientCreateOrConnectWithoutEmailClientInput | UserToEmailClientCreateOrConnectWithoutEmailClientInput[]
    upsert?: UserToEmailClientUpsertWithWhereUniqueWithoutEmailClientInput | UserToEmailClientUpsertWithWhereUniqueWithoutEmailClientInput[]
    createMany?: UserToEmailClientCreateManyEmailClientInputEnvelope
    set?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    disconnect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    delete?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    connect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    update?: UserToEmailClientUpdateWithWhereUniqueWithoutEmailClientInput | UserToEmailClientUpdateWithWhereUniqueWithoutEmailClientInput[]
    updateMany?: UserToEmailClientUpdateManyWithWhereWithoutEmailClientInput | UserToEmailClientUpdateManyWithWhereWithoutEmailClientInput[]
    deleteMany?: UserToEmailClientScalarWhereInput | UserToEmailClientScalarWhereInput[]
  }

  export type EmailCampaignUncheckedUpdateManyWithoutEmailClientNestedInput = {
    create?: XOR<EmailCampaignCreateWithoutEmailClientInput, EmailCampaignUncheckedCreateWithoutEmailClientInput> | EmailCampaignCreateWithoutEmailClientInput[] | EmailCampaignUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailCampaignCreateOrConnectWithoutEmailClientInput | EmailCampaignCreateOrConnectWithoutEmailClientInput[]
    upsert?: EmailCampaignUpsertWithWhereUniqueWithoutEmailClientInput | EmailCampaignUpsertWithWhereUniqueWithoutEmailClientInput[]
    createMany?: EmailCampaignCreateManyEmailClientInputEnvelope
    set?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    disconnect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    delete?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    connect?: EmailCampaignWhereUniqueInput | EmailCampaignWhereUniqueInput[]
    update?: EmailCampaignUpdateWithWhereUniqueWithoutEmailClientInput | EmailCampaignUpdateWithWhereUniqueWithoutEmailClientInput[]
    updateMany?: EmailCampaignUpdateManyWithWhereWithoutEmailClientInput | EmailCampaignUpdateManyWithWhereWithoutEmailClientInput[]
    deleteMany?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
  }

  export type EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput = {
    create?: XOR<EmailCampaignDailyStatsCreateWithoutEmailClientInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailClientInput> | EmailCampaignDailyStatsCreateWithoutEmailClientInput[] | EmailCampaignDailyStatsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailCampaignDailyStatsCreateOrConnectWithoutEmailClientInput | EmailCampaignDailyStatsCreateOrConnectWithoutEmailClientInput[]
    upsert?: EmailCampaignDailyStatsUpsertWithWhereUniqueWithoutEmailClientInput | EmailCampaignDailyStatsUpsertWithWhereUniqueWithoutEmailClientInput[]
    createMany?: EmailCampaignDailyStatsCreateManyEmailClientInputEnvelope
    set?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    disconnect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    delete?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    connect?: EmailCampaignDailyStatsWhereUniqueInput | EmailCampaignDailyStatsWhereUniqueInput[]
    update?: EmailCampaignDailyStatsUpdateWithWhereUniqueWithoutEmailClientInput | EmailCampaignDailyStatsUpdateWithWhereUniqueWithoutEmailClientInput[]
    updateMany?: EmailCampaignDailyStatsUpdateManyWithWhereWithoutEmailClientInput | EmailCampaignDailyStatsUpdateManyWithWhereWithoutEmailClientInput[]
    deleteMany?: EmailCampaignDailyStatsScalarWhereInput | EmailCampaignDailyStatsScalarWhereInput[]
  }

  export type EmailClientCredentialsUncheckedUpdateManyWithoutEmailClientNestedInput = {
    create?: XOR<EmailClientCredentialsCreateWithoutEmailClientInput, EmailClientCredentialsUncheckedCreateWithoutEmailClientInput> | EmailClientCredentialsCreateWithoutEmailClientInput[] | EmailClientCredentialsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailClientCredentialsCreateOrConnectWithoutEmailClientInput | EmailClientCredentialsCreateOrConnectWithoutEmailClientInput[]
    upsert?: EmailClientCredentialsUpsertWithWhereUniqueWithoutEmailClientInput | EmailClientCredentialsUpsertWithWhereUniqueWithoutEmailClientInput[]
    createMany?: EmailClientCredentialsCreateManyEmailClientInputEnvelope
    set?: EmailClientCredentialsWhereUniqueInput | EmailClientCredentialsWhereUniqueInput[]
    disconnect?: EmailClientCredentialsWhereUniqueInput | EmailClientCredentialsWhereUniqueInput[]
    delete?: EmailClientCredentialsWhereUniqueInput | EmailClientCredentialsWhereUniqueInput[]
    connect?: EmailClientCredentialsWhereUniqueInput | EmailClientCredentialsWhereUniqueInput[]
    update?: EmailClientCredentialsUpdateWithWhereUniqueWithoutEmailClientInput | EmailClientCredentialsUpdateWithWhereUniqueWithoutEmailClientInput[]
    updateMany?: EmailClientCredentialsUpdateManyWithWhereWithoutEmailClientInput | EmailClientCredentialsUpdateManyWithWhereWithoutEmailClientInput[]
    deleteMany?: EmailClientCredentialsScalarWhereInput | EmailClientCredentialsScalarWhereInput[]
  }

  export type EmailGlobalDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput = {
    create?: XOR<EmailGlobalDailyStatsCreateWithoutEmailClientInput, EmailGlobalDailyStatsUncheckedCreateWithoutEmailClientInput> | EmailGlobalDailyStatsCreateWithoutEmailClientInput[] | EmailGlobalDailyStatsUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: EmailGlobalDailyStatsCreateOrConnectWithoutEmailClientInput | EmailGlobalDailyStatsCreateOrConnectWithoutEmailClientInput[]
    upsert?: EmailGlobalDailyStatsUpsertWithWhereUniqueWithoutEmailClientInput | EmailGlobalDailyStatsUpsertWithWhereUniqueWithoutEmailClientInput[]
    createMany?: EmailGlobalDailyStatsCreateManyEmailClientInputEnvelope
    set?: EmailGlobalDailyStatsWhereUniqueInput | EmailGlobalDailyStatsWhereUniqueInput[]
    disconnect?: EmailGlobalDailyStatsWhereUniqueInput | EmailGlobalDailyStatsWhereUniqueInput[]
    delete?: EmailGlobalDailyStatsWhereUniqueInput | EmailGlobalDailyStatsWhereUniqueInput[]
    connect?: EmailGlobalDailyStatsWhereUniqueInput | EmailGlobalDailyStatsWhereUniqueInput[]
    update?: EmailGlobalDailyStatsUpdateWithWhereUniqueWithoutEmailClientInput | EmailGlobalDailyStatsUpdateWithWhereUniqueWithoutEmailClientInput[]
    updateMany?: EmailGlobalDailyStatsUpdateManyWithWhereWithoutEmailClientInput | EmailGlobalDailyStatsUpdateManyWithWhereWithoutEmailClientInput[]
    deleteMany?: EmailGlobalDailyStatsScalarWhereInput | EmailGlobalDailyStatsScalarWhereInput[]
  }

  export type UserToEmailClientUncheckedUpdateManyWithoutEmailClientNestedInput = {
    create?: XOR<UserToEmailClientCreateWithoutEmailClientInput, UserToEmailClientUncheckedCreateWithoutEmailClientInput> | UserToEmailClientCreateWithoutEmailClientInput[] | UserToEmailClientUncheckedCreateWithoutEmailClientInput[]
    connectOrCreate?: UserToEmailClientCreateOrConnectWithoutEmailClientInput | UserToEmailClientCreateOrConnectWithoutEmailClientInput[]
    upsert?: UserToEmailClientUpsertWithWhereUniqueWithoutEmailClientInput | UserToEmailClientUpsertWithWhereUniqueWithoutEmailClientInput[]
    createMany?: UserToEmailClientCreateManyEmailClientInputEnvelope
    set?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    disconnect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    delete?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    connect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    update?: UserToEmailClientUpdateWithWhereUniqueWithoutEmailClientInput | UserToEmailClientUpdateWithWhereUniqueWithoutEmailClientInput[]
    updateMany?: UserToEmailClientUpdateManyWithWhereWithoutEmailClientInput | UserToEmailClientUpdateManyWithWhereWithoutEmailClientInput[]
    deleteMany?: UserToEmailClientScalarWhereInput | UserToEmailClientScalarWhereInput[]
  }

  export type EmailClientCreateNestedOneWithoutEmailClientCredentialsInput = {
    create?: XOR<EmailClientCreateWithoutEmailClientCredentialsInput, EmailClientUncheckedCreateWithoutEmailClientCredentialsInput>
    connectOrCreate?: EmailClientCreateOrConnectWithoutEmailClientCredentialsInput
    connect?: EmailClientWhereUniqueInput
  }

  export type EmailClientUpdateOneRequiredWithoutEmailClientCredentialsNestedInput = {
    create?: XOR<EmailClientCreateWithoutEmailClientCredentialsInput, EmailClientUncheckedCreateWithoutEmailClientCredentialsInput>
    connectOrCreate?: EmailClientCreateOrConnectWithoutEmailClientCredentialsInput
    upsert?: EmailClientUpsertWithoutEmailClientCredentialsInput
    connect?: EmailClientWhereUniqueInput
    update?: XOR<XOR<EmailClientUpdateToOneWithWhereWithoutEmailClientCredentialsInput, EmailClientUpdateWithoutEmailClientCredentialsInput>, EmailClientUncheckedUpdateWithoutEmailClientCredentialsInput>
  }

  export type EmailClientCreateNestedOneWithoutEmailGlobalDailyStatsInput = {
    create?: XOR<EmailClientCreateWithoutEmailGlobalDailyStatsInput, EmailClientUncheckedCreateWithoutEmailGlobalDailyStatsInput>
    connectOrCreate?: EmailClientCreateOrConnectWithoutEmailGlobalDailyStatsInput
    connect?: EmailClientWhereUniqueInput
  }

  export type EmailClientUpdateOneRequiredWithoutEmailGlobalDailyStatsNestedInput = {
    create?: XOR<EmailClientCreateWithoutEmailGlobalDailyStatsInput, EmailClientUncheckedCreateWithoutEmailGlobalDailyStatsInput>
    connectOrCreate?: EmailClientCreateOrConnectWithoutEmailGlobalDailyStatsInput
    upsert?: EmailClientUpsertWithoutEmailGlobalDailyStatsInput
    connect?: EmailClientWhereUniqueInput
    update?: XOR<XOR<EmailClientUpdateToOneWithWhereWithoutEmailGlobalDailyStatsInput, EmailClientUpdateWithoutEmailGlobalDailyStatsInput>, EmailClientUncheckedUpdateWithoutEmailGlobalDailyStatsInput>
  }

  export type ConversationCreateNestedManyWithoutGaAccountInput = {
    create?: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput> | ConversationCreateWithoutGaAccountInput[] | ConversationUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaAccountInput | ConversationCreateOrConnectWithoutGaAccountInput[]
    createMany?: ConversationCreateManyGaAccountInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type GaPropertyCreateNestedManyWithoutGaAccountInput = {
    create?: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput> | GaPropertyCreateWithoutGaAccountInput[] | GaPropertyUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: GaPropertyCreateOrConnectWithoutGaAccountInput | GaPropertyCreateOrConnectWithoutGaAccountInput[]
    createMany?: GaPropertyCreateManyGaAccountInputEnvelope
    connect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
  }

  export type UserToGaAccountCreateNestedManyWithoutGaAccountInput = {
    create?: XOR<UserToGaAccountCreateWithoutGaAccountInput, UserToGaAccountUncheckedCreateWithoutGaAccountInput> | UserToGaAccountCreateWithoutGaAccountInput[] | UserToGaAccountUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: UserToGaAccountCreateOrConnectWithoutGaAccountInput | UserToGaAccountCreateOrConnectWithoutGaAccountInput[]
    createMany?: UserToGaAccountCreateManyGaAccountInputEnvelope
    connect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutGaAccountInput = {
    create?: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput> | ConversationCreateWithoutGaAccountInput[] | ConversationUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaAccountInput | ConversationCreateOrConnectWithoutGaAccountInput[]
    createMany?: ConversationCreateManyGaAccountInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type GaPropertyUncheckedCreateNestedManyWithoutGaAccountInput = {
    create?: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput> | GaPropertyCreateWithoutGaAccountInput[] | GaPropertyUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: GaPropertyCreateOrConnectWithoutGaAccountInput | GaPropertyCreateOrConnectWithoutGaAccountInput[]
    createMany?: GaPropertyCreateManyGaAccountInputEnvelope
    connect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
  }

  export type UserToGaAccountUncheckedCreateNestedManyWithoutGaAccountInput = {
    create?: XOR<UserToGaAccountCreateWithoutGaAccountInput, UserToGaAccountUncheckedCreateWithoutGaAccountInput> | UserToGaAccountCreateWithoutGaAccountInput[] | UserToGaAccountUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: UserToGaAccountCreateOrConnectWithoutGaAccountInput | UserToGaAccountCreateOrConnectWithoutGaAccountInput[]
    createMany?: UserToGaAccountCreateManyGaAccountInputEnvelope
    connect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
  }

  export type ConversationUpdateManyWithoutGaAccountNestedInput = {
    create?: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput> | ConversationCreateWithoutGaAccountInput[] | ConversationUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaAccountInput | ConversationCreateOrConnectWithoutGaAccountInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutGaAccountInput | ConversationUpsertWithWhereUniqueWithoutGaAccountInput[]
    createMany?: ConversationCreateManyGaAccountInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutGaAccountInput | ConversationUpdateWithWhereUniqueWithoutGaAccountInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutGaAccountInput | ConversationUpdateManyWithWhereWithoutGaAccountInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GaPropertyUpdateManyWithoutGaAccountNestedInput = {
    create?: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput> | GaPropertyCreateWithoutGaAccountInput[] | GaPropertyUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: GaPropertyCreateOrConnectWithoutGaAccountInput | GaPropertyCreateOrConnectWithoutGaAccountInput[]
    upsert?: GaPropertyUpsertWithWhereUniqueWithoutGaAccountInput | GaPropertyUpsertWithWhereUniqueWithoutGaAccountInput[]
    createMany?: GaPropertyCreateManyGaAccountInputEnvelope
    set?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    disconnect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    delete?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    connect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    update?: GaPropertyUpdateWithWhereUniqueWithoutGaAccountInput | GaPropertyUpdateWithWhereUniqueWithoutGaAccountInput[]
    updateMany?: GaPropertyUpdateManyWithWhereWithoutGaAccountInput | GaPropertyUpdateManyWithWhereWithoutGaAccountInput[]
    deleteMany?: GaPropertyScalarWhereInput | GaPropertyScalarWhereInput[]
  }

  export type UserToGaAccountUpdateManyWithoutGaAccountNestedInput = {
    create?: XOR<UserToGaAccountCreateWithoutGaAccountInput, UserToGaAccountUncheckedCreateWithoutGaAccountInput> | UserToGaAccountCreateWithoutGaAccountInput[] | UserToGaAccountUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: UserToGaAccountCreateOrConnectWithoutGaAccountInput | UserToGaAccountCreateOrConnectWithoutGaAccountInput[]
    upsert?: UserToGaAccountUpsertWithWhereUniqueWithoutGaAccountInput | UserToGaAccountUpsertWithWhereUniqueWithoutGaAccountInput[]
    createMany?: UserToGaAccountCreateManyGaAccountInputEnvelope
    set?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    disconnect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    delete?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    connect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    update?: UserToGaAccountUpdateWithWhereUniqueWithoutGaAccountInput | UserToGaAccountUpdateWithWhereUniqueWithoutGaAccountInput[]
    updateMany?: UserToGaAccountUpdateManyWithWhereWithoutGaAccountInput | UserToGaAccountUpdateManyWithWhereWithoutGaAccountInput[]
    deleteMany?: UserToGaAccountScalarWhereInput | UserToGaAccountScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutGaAccountNestedInput = {
    create?: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput> | ConversationCreateWithoutGaAccountInput[] | ConversationUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaAccountInput | ConversationCreateOrConnectWithoutGaAccountInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutGaAccountInput | ConversationUpsertWithWhereUniqueWithoutGaAccountInput[]
    createMany?: ConversationCreateManyGaAccountInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutGaAccountInput | ConversationUpdateWithWhereUniqueWithoutGaAccountInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutGaAccountInput | ConversationUpdateManyWithWhereWithoutGaAccountInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GaPropertyUncheckedUpdateManyWithoutGaAccountNestedInput = {
    create?: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput> | GaPropertyCreateWithoutGaAccountInput[] | GaPropertyUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: GaPropertyCreateOrConnectWithoutGaAccountInput | GaPropertyCreateOrConnectWithoutGaAccountInput[]
    upsert?: GaPropertyUpsertWithWhereUniqueWithoutGaAccountInput | GaPropertyUpsertWithWhereUniqueWithoutGaAccountInput[]
    createMany?: GaPropertyCreateManyGaAccountInputEnvelope
    set?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    disconnect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    delete?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    connect?: GaPropertyWhereUniqueInput | GaPropertyWhereUniqueInput[]
    update?: GaPropertyUpdateWithWhereUniqueWithoutGaAccountInput | GaPropertyUpdateWithWhereUniqueWithoutGaAccountInput[]
    updateMany?: GaPropertyUpdateManyWithWhereWithoutGaAccountInput | GaPropertyUpdateManyWithWhereWithoutGaAccountInput[]
    deleteMany?: GaPropertyScalarWhereInput | GaPropertyScalarWhereInput[]
  }

  export type UserToGaAccountUncheckedUpdateManyWithoutGaAccountNestedInput = {
    create?: XOR<UserToGaAccountCreateWithoutGaAccountInput, UserToGaAccountUncheckedCreateWithoutGaAccountInput> | UserToGaAccountCreateWithoutGaAccountInput[] | UserToGaAccountUncheckedCreateWithoutGaAccountInput[]
    connectOrCreate?: UserToGaAccountCreateOrConnectWithoutGaAccountInput | UserToGaAccountCreateOrConnectWithoutGaAccountInput[]
    upsert?: UserToGaAccountUpsertWithWhereUniqueWithoutGaAccountInput | UserToGaAccountUpsertWithWhereUniqueWithoutGaAccountInput[]
    createMany?: UserToGaAccountCreateManyGaAccountInputEnvelope
    set?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    disconnect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    delete?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    connect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    update?: UserToGaAccountUpdateWithWhereUniqueWithoutGaAccountInput | UserToGaAccountUpdateWithWhereUniqueWithoutGaAccountInput[]
    updateMany?: UserToGaAccountUpdateManyWithWhereWithoutGaAccountInput | UserToGaAccountUpdateManyWithWhereWithoutGaAccountInput[]
    deleteMany?: UserToGaAccountScalarWhereInput | UserToGaAccountScalarWhereInput[]
  }

  export type ConversationCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput> | ConversationCreateWithoutGaPropertyInput[] | ConversationUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaPropertyInput | ConversationCreateOrConnectWithoutGaPropertyInput[]
    createMany?: ConversationCreateManyGaPropertyInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type GaChannelDailyCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput> | GaChannelDailyCreateWithoutGaPropertyInput[] | GaChannelDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaChannelDailyCreateOrConnectWithoutGaPropertyInput | GaChannelDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaChannelDailyCreateManyGaPropertyInputEnvelope
    connect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
  }

  export type GaImportRunCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput> | GaImportRunCreateWithoutGaPropertyInput[] | GaImportRunUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutGaPropertyInput | GaImportRunCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaImportRunCreateManyGaPropertyInputEnvelope
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
  }

  export type GaKpiDailyCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput> | GaKpiDailyCreateWithoutGaPropertyInput[] | GaKpiDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiDailyCreateOrConnectWithoutGaPropertyInput | GaKpiDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaKpiDailyCreateManyGaPropertyInputEnvelope
    connect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
  }

  export type GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput> | GaKpiMonthlyCreateWithoutGaPropertyInput[] | GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput | GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaKpiMonthlyCreateManyGaPropertyInputEnvelope
    connect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
  }

  export type GaAccountCreateNestedOneWithoutGaPropertiesInput = {
    create?: XOR<GaAccountCreateWithoutGaPropertiesInput, GaAccountUncheckedCreateWithoutGaPropertiesInput>
    connectOrCreate?: GaAccountCreateOrConnectWithoutGaPropertiesInput
    connect?: GaAccountWhereUniqueInput
  }

  export type GaSourceDailyCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput> | GaSourceDailyCreateWithoutGaPropertyInput[] | GaSourceDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaSourceDailyCreateOrConnectWithoutGaPropertyInput | GaSourceDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaSourceDailyCreateManyGaPropertyInputEnvelope
    connect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput> | ConversationCreateWithoutGaPropertyInput[] | ConversationUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaPropertyInput | ConversationCreateOrConnectWithoutGaPropertyInput[]
    createMany?: ConversationCreateManyGaPropertyInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput> | GaChannelDailyCreateWithoutGaPropertyInput[] | GaChannelDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaChannelDailyCreateOrConnectWithoutGaPropertyInput | GaChannelDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaChannelDailyCreateManyGaPropertyInputEnvelope
    connect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
  }

  export type GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput> | GaImportRunCreateWithoutGaPropertyInput[] | GaImportRunUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutGaPropertyInput | GaImportRunCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaImportRunCreateManyGaPropertyInputEnvelope
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
  }

  export type GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput> | GaKpiDailyCreateWithoutGaPropertyInput[] | GaKpiDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiDailyCreateOrConnectWithoutGaPropertyInput | GaKpiDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaKpiDailyCreateManyGaPropertyInputEnvelope
    connect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
  }

  export type GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput> | GaKpiMonthlyCreateWithoutGaPropertyInput[] | GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput | GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaKpiMonthlyCreateManyGaPropertyInputEnvelope
    connect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
  }

  export type GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput = {
    create?: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput> | GaSourceDailyCreateWithoutGaPropertyInput[] | GaSourceDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaSourceDailyCreateOrConnectWithoutGaPropertyInput | GaSourceDailyCreateOrConnectWithoutGaPropertyInput[]
    createMany?: GaSourceDailyCreateManyGaPropertyInputEnvelope
    connect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
  }

  export type ConversationUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput> | ConversationCreateWithoutGaPropertyInput[] | ConversationUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaPropertyInput | ConversationCreateOrConnectWithoutGaPropertyInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutGaPropertyInput | ConversationUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: ConversationCreateManyGaPropertyInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutGaPropertyInput | ConversationUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutGaPropertyInput | ConversationUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GaChannelDailyUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput> | GaChannelDailyCreateWithoutGaPropertyInput[] | GaChannelDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaChannelDailyCreateOrConnectWithoutGaPropertyInput | GaChannelDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaChannelDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaChannelDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaChannelDailyCreateManyGaPropertyInputEnvelope
    set?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    disconnect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    delete?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    connect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    update?: GaChannelDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaChannelDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaChannelDailyUpdateManyWithWhereWithoutGaPropertyInput | GaChannelDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaChannelDailyScalarWhereInput | GaChannelDailyScalarWhereInput[]
  }

  export type GaImportRunUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput> | GaImportRunCreateWithoutGaPropertyInput[] | GaImportRunUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutGaPropertyInput | GaImportRunCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaImportRunUpsertWithWhereUniqueWithoutGaPropertyInput | GaImportRunUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaImportRunCreateManyGaPropertyInputEnvelope
    set?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    disconnect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    delete?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    update?: GaImportRunUpdateWithWhereUniqueWithoutGaPropertyInput | GaImportRunUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaImportRunUpdateManyWithWhereWithoutGaPropertyInput | GaImportRunUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
  }

  export type GaKpiDailyUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput> | GaKpiDailyCreateWithoutGaPropertyInput[] | GaKpiDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiDailyCreateOrConnectWithoutGaPropertyInput | GaKpiDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaKpiDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaKpiDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaKpiDailyCreateManyGaPropertyInputEnvelope
    set?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    disconnect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    delete?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    connect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    update?: GaKpiDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaKpiDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaKpiDailyUpdateManyWithWhereWithoutGaPropertyInput | GaKpiDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaKpiDailyScalarWhereInput | GaKpiDailyScalarWhereInput[]
  }

  export type GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput> | GaKpiMonthlyCreateWithoutGaPropertyInput[] | GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput | GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaKpiMonthlyUpsertWithWhereUniqueWithoutGaPropertyInput | GaKpiMonthlyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaKpiMonthlyCreateManyGaPropertyInputEnvelope
    set?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    disconnect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    delete?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    connect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    update?: GaKpiMonthlyUpdateWithWhereUniqueWithoutGaPropertyInput | GaKpiMonthlyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaKpiMonthlyUpdateManyWithWhereWithoutGaPropertyInput | GaKpiMonthlyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaKpiMonthlyScalarWhereInput | GaKpiMonthlyScalarWhereInput[]
  }

  export type GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput = {
    create?: XOR<GaAccountCreateWithoutGaPropertiesInput, GaAccountUncheckedCreateWithoutGaPropertiesInput>
    connectOrCreate?: GaAccountCreateOrConnectWithoutGaPropertiesInput
    upsert?: GaAccountUpsertWithoutGaPropertiesInput
    connect?: GaAccountWhereUniqueInput
    update?: XOR<XOR<GaAccountUpdateToOneWithWhereWithoutGaPropertiesInput, GaAccountUpdateWithoutGaPropertiesInput>, GaAccountUncheckedUpdateWithoutGaPropertiesInput>
  }

  export type GaSourceDailyUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput> | GaSourceDailyCreateWithoutGaPropertyInput[] | GaSourceDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaSourceDailyCreateOrConnectWithoutGaPropertyInput | GaSourceDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaSourceDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaSourceDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaSourceDailyCreateManyGaPropertyInputEnvelope
    set?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    disconnect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    delete?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    connect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    update?: GaSourceDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaSourceDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaSourceDailyUpdateManyWithWhereWithoutGaPropertyInput | GaSourceDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaSourceDailyScalarWhereInput | GaSourceDailyScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput> | ConversationCreateWithoutGaPropertyInput[] | ConversationUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutGaPropertyInput | ConversationCreateOrConnectWithoutGaPropertyInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutGaPropertyInput | ConversationUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: ConversationCreateManyGaPropertyInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutGaPropertyInput | ConversationUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutGaPropertyInput | ConversationUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput> | GaChannelDailyCreateWithoutGaPropertyInput[] | GaChannelDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaChannelDailyCreateOrConnectWithoutGaPropertyInput | GaChannelDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaChannelDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaChannelDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaChannelDailyCreateManyGaPropertyInputEnvelope
    set?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    disconnect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    delete?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    connect?: GaChannelDailyWhereUniqueInput | GaChannelDailyWhereUniqueInput[]
    update?: GaChannelDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaChannelDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaChannelDailyUpdateManyWithWhereWithoutGaPropertyInput | GaChannelDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaChannelDailyScalarWhereInput | GaChannelDailyScalarWhereInput[]
  }

  export type GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput> | GaImportRunCreateWithoutGaPropertyInput[] | GaImportRunUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutGaPropertyInput | GaImportRunCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaImportRunUpsertWithWhereUniqueWithoutGaPropertyInput | GaImportRunUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaImportRunCreateManyGaPropertyInputEnvelope
    set?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    disconnect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    delete?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    update?: GaImportRunUpdateWithWhereUniqueWithoutGaPropertyInput | GaImportRunUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaImportRunUpdateManyWithWhereWithoutGaPropertyInput | GaImportRunUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
  }

  export type GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput> | GaKpiDailyCreateWithoutGaPropertyInput[] | GaKpiDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiDailyCreateOrConnectWithoutGaPropertyInput | GaKpiDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaKpiDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaKpiDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaKpiDailyCreateManyGaPropertyInputEnvelope
    set?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    disconnect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    delete?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    connect?: GaKpiDailyWhereUniqueInput | GaKpiDailyWhereUniqueInput[]
    update?: GaKpiDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaKpiDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaKpiDailyUpdateManyWithWhereWithoutGaPropertyInput | GaKpiDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaKpiDailyScalarWhereInput | GaKpiDailyScalarWhereInput[]
  }

  export type GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput> | GaKpiMonthlyCreateWithoutGaPropertyInput[] | GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput | GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaKpiMonthlyUpsertWithWhereUniqueWithoutGaPropertyInput | GaKpiMonthlyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaKpiMonthlyCreateManyGaPropertyInputEnvelope
    set?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    disconnect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    delete?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    connect?: GaKpiMonthlyWhereUniqueInput | GaKpiMonthlyWhereUniqueInput[]
    update?: GaKpiMonthlyUpdateWithWhereUniqueWithoutGaPropertyInput | GaKpiMonthlyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaKpiMonthlyUpdateManyWithWhereWithoutGaPropertyInput | GaKpiMonthlyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaKpiMonthlyScalarWhereInput | GaKpiMonthlyScalarWhereInput[]
  }

  export type GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput = {
    create?: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput> | GaSourceDailyCreateWithoutGaPropertyInput[] | GaSourceDailyUncheckedCreateWithoutGaPropertyInput[]
    connectOrCreate?: GaSourceDailyCreateOrConnectWithoutGaPropertyInput | GaSourceDailyCreateOrConnectWithoutGaPropertyInput[]
    upsert?: GaSourceDailyUpsertWithWhereUniqueWithoutGaPropertyInput | GaSourceDailyUpsertWithWhereUniqueWithoutGaPropertyInput[]
    createMany?: GaSourceDailyCreateManyGaPropertyInputEnvelope
    set?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    disconnect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    delete?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    connect?: GaSourceDailyWhereUniqueInput | GaSourceDailyWhereUniqueInput[]
    update?: GaSourceDailyUpdateWithWhereUniqueWithoutGaPropertyInput | GaSourceDailyUpdateWithWhereUniqueWithoutGaPropertyInput[]
    updateMany?: GaSourceDailyUpdateManyWithWhereWithoutGaPropertyInput | GaSourceDailyUpdateManyWithWhereWithoutGaPropertyInput[]
    deleteMany?: GaSourceDailyScalarWhereInput | GaSourceDailyScalarWhereInput[]
  }

  export type GaPropertyCreateNestedOneWithoutImportsInput = {
    create?: XOR<GaPropertyCreateWithoutImportsInput, GaPropertyUncheckedCreateWithoutImportsInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutImportsInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGaImportRunsInput = {
    create?: XOR<UserCreateWithoutGaImportRunsInput, UserUncheckedCreateWithoutGaImportRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGaImportRunsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumImportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImportStatus
  }

  export type GaPropertyUpdateOneRequiredWithoutImportsNestedInput = {
    create?: XOR<GaPropertyCreateWithoutImportsInput, GaPropertyUncheckedCreateWithoutImportsInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutImportsInput
    upsert?: GaPropertyUpsertWithoutImportsInput
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutImportsInput, GaPropertyUpdateWithoutImportsInput>, GaPropertyUncheckedUpdateWithoutImportsInput>
  }

  export type UserUpdateOneRequiredWithoutGaImportRunsNestedInput = {
    create?: XOR<UserCreateWithoutGaImportRunsInput, UserUncheckedCreateWithoutGaImportRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGaImportRunsInput
    upsert?: UserUpsertWithoutGaImportRunsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGaImportRunsInput, UserUpdateWithoutGaImportRunsInput>, UserUncheckedUpdateWithoutGaImportRunsInput>
  }

  export type GaPropertyCreateNestedOneWithoutKpiDailyInput = {
    create?: XOR<GaPropertyCreateWithoutKpiDailyInput, GaPropertyUncheckedCreateWithoutKpiDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutKpiDailyInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type GaPropertyUpdateOneRequiredWithoutKpiDailyNestedInput = {
    create?: XOR<GaPropertyCreateWithoutKpiDailyInput, GaPropertyUncheckedCreateWithoutKpiDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutKpiDailyInput
    upsert?: GaPropertyUpsertWithoutKpiDailyInput
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutKpiDailyInput, GaPropertyUpdateWithoutKpiDailyInput>, GaPropertyUncheckedUpdateWithoutKpiDailyInput>
  }

  export type GaPropertyCreateNestedOneWithoutKpiMonthlyInput = {
    create?: XOR<GaPropertyCreateWithoutKpiMonthlyInput, GaPropertyUncheckedCreateWithoutKpiMonthlyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutKpiMonthlyInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type GaPropertyUpdateOneRequiredWithoutKpiMonthlyNestedInput = {
    create?: XOR<GaPropertyCreateWithoutKpiMonthlyInput, GaPropertyUncheckedCreateWithoutKpiMonthlyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutKpiMonthlyInput
    upsert?: GaPropertyUpsertWithoutKpiMonthlyInput
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutKpiMonthlyInput, GaPropertyUpdateWithoutKpiMonthlyInput>, GaPropertyUncheckedUpdateWithoutKpiMonthlyInput>
  }

  export type GaPropertyCreateNestedOneWithoutChannelDailyInput = {
    create?: XOR<GaPropertyCreateWithoutChannelDailyInput, GaPropertyUncheckedCreateWithoutChannelDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutChannelDailyInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type GaPropertyUpdateOneRequiredWithoutChannelDailyNestedInput = {
    create?: XOR<GaPropertyCreateWithoutChannelDailyInput, GaPropertyUncheckedCreateWithoutChannelDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutChannelDailyInput
    upsert?: GaPropertyUpsertWithoutChannelDailyInput
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutChannelDailyInput, GaPropertyUpdateWithoutChannelDailyInput>, GaPropertyUncheckedUpdateWithoutChannelDailyInput>
  }

  export type GaPropertyCreateNestedOneWithoutSourceDailyInput = {
    create?: XOR<GaPropertyCreateWithoutSourceDailyInput, GaPropertyUncheckedCreateWithoutSourceDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutSourceDailyInput
    connect?: GaPropertyWhereUniqueInput
  }

  export type GaPropertyUpdateOneRequiredWithoutSourceDailyNestedInput = {
    create?: XOR<GaPropertyCreateWithoutSourceDailyInput, GaPropertyUncheckedCreateWithoutSourceDailyInput>
    connectOrCreate?: GaPropertyCreateOrConnectWithoutSourceDailyInput
    upsert?: GaPropertyUpsertWithoutSourceDailyInput
    connect?: GaPropertyWhereUniqueInput
    update?: XOR<XOR<GaPropertyUpdateToOneWithWhereWithoutSourceDailyInput, GaPropertyUpdateWithoutSourceDailyInput>, GaPropertyUncheckedUpdateWithoutSourceDailyInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutRepliesInput = {
    create?: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRepliesInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutParentInput = {
    create?: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput> | MessageCreateWithoutParentInput[] | MessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentInput | MessageCreateOrConnectWithoutParentInput[]
    createMany?: MessageCreateManyParentInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageAttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput> | MessageCreateWithoutParentInput[] | MessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentInput | MessageCreateOrConnectWithoutParentInput[]
    createMany?: MessageCreateManyParentInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type MessageUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRepliesInput
    upsert?: MessageUpsertWithoutRepliesInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutRepliesInput, MessageUpdateWithoutRepliesInput>, MessageUncheckedUpdateWithoutRepliesInput>
  }

  export type MessageUpdateManyWithoutParentNestedInput = {
    create?: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput> | MessageCreateWithoutParentInput[] | MessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentInput | MessageCreateOrConnectWithoutParentInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutParentInput | MessageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MessageCreateManyParentInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutParentInput | MessageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutParentInput | MessageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type MessageAttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput> | MessageCreateWithoutParentInput[] | MessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentInput | MessageCreateOrConnectWithoutParentInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutParentInput | MessageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MessageCreateManyParentInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutParentInput | MessageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutParentInput | MessageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type QueryCreateNestedOneWithoutParsedPieDataInput = {
    create?: XOR<QueryCreateWithoutParsedPieDataInput, QueryUncheckedCreateWithoutParsedPieDataInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedPieDataInput
    connect?: QueryWhereUniqueInput
  }

  export type QueryUpdateOneRequiredWithoutParsedPieDataNestedInput = {
    create?: XOR<QueryCreateWithoutParsedPieDataInput, QueryUncheckedCreateWithoutParsedPieDataInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedPieDataInput
    upsert?: QueryUpsertWithoutParsedPieDataInput
    connect?: QueryWhereUniqueInput
    update?: XOR<XOR<QueryUpdateToOneWithWhereWithoutParsedPieDataInput, QueryUpdateWithoutParsedPieDataInput>, QueryUncheckedUpdateWithoutParsedPieDataInput>
  }

  export type QueryCreateNestedOneWithoutParsedDataInput = {
    create?: XOR<QueryCreateWithoutParsedDataInput, QueryUncheckedCreateWithoutParsedDataInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedDataInput
    connect?: QueryWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QueryUpdateOneRequiredWithoutParsedDataNestedInput = {
    create?: XOR<QueryCreateWithoutParsedDataInput, QueryUncheckedCreateWithoutParsedDataInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedDataInput
    upsert?: QueryUpsertWithoutParsedDataInput
    connect?: QueryWhereUniqueInput
    update?: XOR<XOR<QueryUpdateToOneWithWhereWithoutParsedDataInput, QueryUpdateWithoutParsedDataInput>, QueryUncheckedUpdateWithoutParsedDataInput>
  }

  export type QueryCreateNestedOneWithoutParsedSummaryInput = {
    create?: XOR<QueryCreateWithoutParsedSummaryInput, QueryUncheckedCreateWithoutParsedSummaryInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedSummaryInput
    connect?: QueryWhereUniqueInput
  }

  export type QueryUpdateOneRequiredWithoutParsedSummaryNestedInput = {
    create?: XOR<QueryCreateWithoutParsedSummaryInput, QueryUncheckedCreateWithoutParsedSummaryInput>
    connectOrCreate?: QueryCreateOrConnectWithoutParsedSummaryInput
    upsert?: QueryUpsertWithoutParsedSummaryInput
    connect?: QueryWhereUniqueInput
    update?: XOR<XOR<QueryUpdateToOneWithWhereWithoutParsedSummaryInput, QueryUpdateWithoutParsedSummaryInput>, QueryUncheckedUpdateWithoutParsedSummaryInput>
  }

  export type ParsedPieGraphDataCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput> | ParsedPieGraphDataCreateWithoutQueryInput[] | ParsedPieGraphDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedPieGraphDataCreateOrConnectWithoutQueryInput | ParsedPieGraphDataCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedPieGraphDataCreateManyQueryInputEnvelope
    connect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
  }

  export type ParsedQueryDataCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput> | ParsedQueryDataCreateWithoutQueryInput[] | ParsedQueryDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQueryDataCreateOrConnectWithoutQueryInput | ParsedQueryDataCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedQueryDataCreateManyQueryInputEnvelope
    connect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
  }

  export type ParsedQuerySummaryCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput> | ParsedQuerySummaryCreateWithoutQueryInput[] | ParsedQuerySummaryUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQuerySummaryCreateOrConnectWithoutQueryInput | ParsedQuerySummaryCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedQuerySummaryCreateManyQueryInputEnvelope
    connect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
  }

  export type ConversationCreateNestedOneWithoutQueriesInput = {
    create?: XOR<ConversationCreateWithoutQueriesInput, ConversationUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutQueriesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQueriesInput = {
    create?: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQueriesInput
    connect?: UserWhereUniqueInput
  }

  export type ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput> | ParsedPieGraphDataCreateWithoutQueryInput[] | ParsedPieGraphDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedPieGraphDataCreateOrConnectWithoutQueryInput | ParsedPieGraphDataCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedPieGraphDataCreateManyQueryInputEnvelope
    connect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
  }

  export type ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput> | ParsedQueryDataCreateWithoutQueryInput[] | ParsedQueryDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQueryDataCreateOrConnectWithoutQueryInput | ParsedQueryDataCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedQueryDataCreateManyQueryInputEnvelope
    connect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
  }

  export type ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput> | ParsedQuerySummaryCreateWithoutQueryInput[] | ParsedQuerySummaryUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQuerySummaryCreateOrConnectWithoutQueryInput | ParsedQuerySummaryCreateOrConnectWithoutQueryInput[]
    createMany?: ParsedQuerySummaryCreateManyQueryInputEnvelope
    connect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
  }

  export type EnumQueryStatusFieldUpdateOperationsInput = {
    set?: $Enums.QueryStatus
  }

  export type ParsedPieGraphDataUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput> | ParsedPieGraphDataCreateWithoutQueryInput[] | ParsedPieGraphDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedPieGraphDataCreateOrConnectWithoutQueryInput | ParsedPieGraphDataCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedPieGraphDataUpsertWithWhereUniqueWithoutQueryInput | ParsedPieGraphDataUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedPieGraphDataCreateManyQueryInputEnvelope
    set?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    disconnect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    delete?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    connect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    update?: ParsedPieGraphDataUpdateWithWhereUniqueWithoutQueryInput | ParsedPieGraphDataUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedPieGraphDataUpdateManyWithWhereWithoutQueryInput | ParsedPieGraphDataUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedPieGraphDataScalarWhereInput | ParsedPieGraphDataScalarWhereInput[]
  }

  export type ParsedQueryDataUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput> | ParsedQueryDataCreateWithoutQueryInput[] | ParsedQueryDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQueryDataCreateOrConnectWithoutQueryInput | ParsedQueryDataCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedQueryDataUpsertWithWhereUniqueWithoutQueryInput | ParsedQueryDataUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedQueryDataCreateManyQueryInputEnvelope
    set?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    disconnect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    delete?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    connect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    update?: ParsedQueryDataUpdateWithWhereUniqueWithoutQueryInput | ParsedQueryDataUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedQueryDataUpdateManyWithWhereWithoutQueryInput | ParsedQueryDataUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedQueryDataScalarWhereInput | ParsedQueryDataScalarWhereInput[]
  }

  export type ParsedQuerySummaryUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput> | ParsedQuerySummaryCreateWithoutQueryInput[] | ParsedQuerySummaryUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQuerySummaryCreateOrConnectWithoutQueryInput | ParsedQuerySummaryCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedQuerySummaryUpsertWithWhereUniqueWithoutQueryInput | ParsedQuerySummaryUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedQuerySummaryCreateManyQueryInputEnvelope
    set?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    disconnect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    delete?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    connect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    update?: ParsedQuerySummaryUpdateWithWhereUniqueWithoutQueryInput | ParsedQuerySummaryUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedQuerySummaryUpdateManyWithWhereWithoutQueryInput | ParsedQuerySummaryUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedQuerySummaryScalarWhereInput | ParsedQuerySummaryScalarWhereInput[]
  }

  export type ConversationUpdateOneWithoutQueriesNestedInput = {
    create?: XOR<ConversationCreateWithoutQueriesInput, ConversationUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutQueriesInput
    upsert?: ConversationUpsertWithoutQueriesInput
    disconnect?: ConversationWhereInput | boolean
    delete?: ConversationWhereInput | boolean
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutQueriesInput, ConversationUpdateWithoutQueriesInput>, ConversationUncheckedUpdateWithoutQueriesInput>
  }

  export type UserUpdateOneRequiredWithoutQueriesNestedInput = {
    create?: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQueriesInput
    upsert?: UserUpsertWithoutQueriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQueriesInput, UserUpdateWithoutQueriesInput>, UserUncheckedUpdateWithoutQueriesInput>
  }

  export type ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput> | ParsedPieGraphDataCreateWithoutQueryInput[] | ParsedPieGraphDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedPieGraphDataCreateOrConnectWithoutQueryInput | ParsedPieGraphDataCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedPieGraphDataUpsertWithWhereUniqueWithoutQueryInput | ParsedPieGraphDataUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedPieGraphDataCreateManyQueryInputEnvelope
    set?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    disconnect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    delete?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    connect?: ParsedPieGraphDataWhereUniqueInput | ParsedPieGraphDataWhereUniqueInput[]
    update?: ParsedPieGraphDataUpdateWithWhereUniqueWithoutQueryInput | ParsedPieGraphDataUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedPieGraphDataUpdateManyWithWhereWithoutQueryInput | ParsedPieGraphDataUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedPieGraphDataScalarWhereInput | ParsedPieGraphDataScalarWhereInput[]
  }

  export type ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput> | ParsedQueryDataCreateWithoutQueryInput[] | ParsedQueryDataUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQueryDataCreateOrConnectWithoutQueryInput | ParsedQueryDataCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedQueryDataUpsertWithWhereUniqueWithoutQueryInput | ParsedQueryDataUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedQueryDataCreateManyQueryInputEnvelope
    set?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    disconnect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    delete?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    connect?: ParsedQueryDataWhereUniqueInput | ParsedQueryDataWhereUniqueInput[]
    update?: ParsedQueryDataUpdateWithWhereUniqueWithoutQueryInput | ParsedQueryDataUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedQueryDataUpdateManyWithWhereWithoutQueryInput | ParsedQueryDataUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedQueryDataScalarWhereInput | ParsedQueryDataScalarWhereInput[]
  }

  export type ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput> | ParsedQuerySummaryCreateWithoutQueryInput[] | ParsedQuerySummaryUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ParsedQuerySummaryCreateOrConnectWithoutQueryInput | ParsedQuerySummaryCreateOrConnectWithoutQueryInput[]
    upsert?: ParsedQuerySummaryUpsertWithWhereUniqueWithoutQueryInput | ParsedQuerySummaryUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ParsedQuerySummaryCreateManyQueryInputEnvelope
    set?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    disconnect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    delete?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    connect?: ParsedQuerySummaryWhereUniqueInput | ParsedQuerySummaryWhereUniqueInput[]
    update?: ParsedQuerySummaryUpdateWithWhereUniqueWithoutQueryInput | ParsedQuerySummaryUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ParsedQuerySummaryUpdateManyWithWhereWithoutQueryInput | ParsedQuerySummaryUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ParsedQuerySummaryScalarWhereInput | ParsedQuerySummaryScalarWhereInput[]
  }

  export type SproutSocialAccountCreateNestedOneWithoutFacebookAnalyticsInput = {
    create?: XOR<SproutSocialAccountCreateWithoutFacebookAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutFacebookAnalyticsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutFacebookAnalyticsInput
    connect?: SproutSocialAccountWhereUniqueInput
  }

  export type SproutSocialAccountUpdateOneRequiredWithoutFacebookAnalyticsNestedInput = {
    create?: XOR<SproutSocialAccountCreateWithoutFacebookAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutFacebookAnalyticsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutFacebookAnalyticsInput
    upsert?: SproutSocialAccountUpsertWithoutFacebookAnalyticsInput
    connect?: SproutSocialAccountWhereUniqueInput
    update?: XOR<XOR<SproutSocialAccountUpdateToOneWithWhereWithoutFacebookAnalyticsInput, SproutSocialAccountUpdateWithoutFacebookAnalyticsInput>, SproutSocialAccountUncheckedUpdateWithoutFacebookAnalyticsInput>
  }

  export type SproutSocialAccountCreateNestedOneWithoutFacebookPostsInput = {
    create?: XOR<SproutSocialAccountCreateWithoutFacebookPostsInput, SproutSocialAccountUncheckedCreateWithoutFacebookPostsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutFacebookPostsInput
    connect?: SproutSocialAccountWhereUniqueInput
  }

  export type SproutSocialAccountUpdateOneRequiredWithoutFacebookPostsNestedInput = {
    create?: XOR<SproutSocialAccountCreateWithoutFacebookPostsInput, SproutSocialAccountUncheckedCreateWithoutFacebookPostsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutFacebookPostsInput
    upsert?: SproutSocialAccountUpsertWithoutFacebookPostsInput
    connect?: SproutSocialAccountWhereUniqueInput
    update?: XOR<XOR<SproutSocialAccountUpdateToOneWithWhereWithoutFacebookPostsInput, SproutSocialAccountUpdateWithoutFacebookPostsInput>, SproutSocialAccountUncheckedUpdateWithoutFacebookPostsInput>
  }

  export type SproutSocialAccountCreateNestedOneWithoutFacebookPostAnalyticsInput = {
    create?: XOR<SproutSocialAccountCreateWithoutFacebookPostAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutFacebookPostAnalyticsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutFacebookPostAnalyticsInput
    connect?: SproutSocialAccountWhereUniqueInput
  }

  export type SproutSocialAccountUpdateOneRequiredWithoutFacebookPostAnalyticsNestedInput = {
    create?: XOR<SproutSocialAccountCreateWithoutFacebookPostAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutFacebookPostAnalyticsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutFacebookPostAnalyticsInput
    upsert?: SproutSocialAccountUpsertWithoutFacebookPostAnalyticsInput
    connect?: SproutSocialAccountWhereUniqueInput
    update?: XOR<XOR<SproutSocialAccountUpdateToOneWithWhereWithoutFacebookPostAnalyticsInput, SproutSocialAccountUpdateWithoutFacebookPostAnalyticsInput>, SproutSocialAccountUncheckedUpdateWithoutFacebookPostAnalyticsInput>
  }

  export type SproutSocialAccountCreateNestedOneWithoutInstagramAnalyticsInput = {
    create?: XOR<SproutSocialAccountCreateWithoutInstagramAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutInstagramAnalyticsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutInstagramAnalyticsInput
    connect?: SproutSocialAccountWhereUniqueInput
  }

  export type SproutInstagramFollowersByCityCreateNestedManyWithoutSproutInstagramAnalyticsInput = {
    create?: XOR<SproutInstagramFollowersByCityCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCityUncheckedCreateWithoutSproutInstagramAnalyticsInput> | SproutInstagramFollowersByCityCreateWithoutSproutInstagramAnalyticsInput[] | SproutInstagramFollowersByCityUncheckedCreateWithoutSproutInstagramAnalyticsInput[]
    connectOrCreate?: SproutInstagramFollowersByCityCreateOrConnectWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCityCreateOrConnectWithoutSproutInstagramAnalyticsInput[]
    createMany?: SproutInstagramFollowersByCityCreateManySproutInstagramAnalyticsInputEnvelope
    connect?: SproutInstagramFollowersByCityWhereUniqueInput | SproutInstagramFollowersByCityWhereUniqueInput[]
  }

  export type SproutInstagramFollowersByCountryCreateNestedManyWithoutSproutInstagramAnalyticsInput = {
    create?: XOR<SproutInstagramFollowersByCountryCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCountryUncheckedCreateWithoutSproutInstagramAnalyticsInput> | SproutInstagramFollowersByCountryCreateWithoutSproutInstagramAnalyticsInput[] | SproutInstagramFollowersByCountryUncheckedCreateWithoutSproutInstagramAnalyticsInput[]
    connectOrCreate?: SproutInstagramFollowersByCountryCreateOrConnectWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCountryCreateOrConnectWithoutSproutInstagramAnalyticsInput[]
    createMany?: SproutInstagramFollowersByCountryCreateManySproutInstagramAnalyticsInputEnvelope
    connect?: SproutInstagramFollowersByCountryWhereUniqueInput | SproutInstagramFollowersByCountryWhereUniqueInput[]
  }

  export type SproutInstagramFollowersByCityUncheckedCreateNestedManyWithoutSproutInstagramAnalyticsInput = {
    create?: XOR<SproutInstagramFollowersByCityCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCityUncheckedCreateWithoutSproutInstagramAnalyticsInput> | SproutInstagramFollowersByCityCreateWithoutSproutInstagramAnalyticsInput[] | SproutInstagramFollowersByCityUncheckedCreateWithoutSproutInstagramAnalyticsInput[]
    connectOrCreate?: SproutInstagramFollowersByCityCreateOrConnectWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCityCreateOrConnectWithoutSproutInstagramAnalyticsInput[]
    createMany?: SproutInstagramFollowersByCityCreateManySproutInstagramAnalyticsInputEnvelope
    connect?: SproutInstagramFollowersByCityWhereUniqueInput | SproutInstagramFollowersByCityWhereUniqueInput[]
  }

  export type SproutInstagramFollowersByCountryUncheckedCreateNestedManyWithoutSproutInstagramAnalyticsInput = {
    create?: XOR<SproutInstagramFollowersByCountryCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCountryUncheckedCreateWithoutSproutInstagramAnalyticsInput> | SproutInstagramFollowersByCountryCreateWithoutSproutInstagramAnalyticsInput[] | SproutInstagramFollowersByCountryUncheckedCreateWithoutSproutInstagramAnalyticsInput[]
    connectOrCreate?: SproutInstagramFollowersByCountryCreateOrConnectWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCountryCreateOrConnectWithoutSproutInstagramAnalyticsInput[]
    createMany?: SproutInstagramFollowersByCountryCreateManySproutInstagramAnalyticsInputEnvelope
    connect?: SproutInstagramFollowersByCountryWhereUniqueInput | SproutInstagramFollowersByCountryWhereUniqueInput[]
  }

  export type SproutSocialAccountUpdateOneRequiredWithoutInstagramAnalyticsNestedInput = {
    create?: XOR<SproutSocialAccountCreateWithoutInstagramAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutInstagramAnalyticsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutInstagramAnalyticsInput
    upsert?: SproutSocialAccountUpsertWithoutInstagramAnalyticsInput
    connect?: SproutSocialAccountWhereUniqueInput
    update?: XOR<XOR<SproutSocialAccountUpdateToOneWithWhereWithoutInstagramAnalyticsInput, SproutSocialAccountUpdateWithoutInstagramAnalyticsInput>, SproutSocialAccountUncheckedUpdateWithoutInstagramAnalyticsInput>
  }

  export type SproutInstagramFollowersByCityUpdateManyWithoutSproutInstagramAnalyticsNestedInput = {
    create?: XOR<SproutInstagramFollowersByCityCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCityUncheckedCreateWithoutSproutInstagramAnalyticsInput> | SproutInstagramFollowersByCityCreateWithoutSproutInstagramAnalyticsInput[] | SproutInstagramFollowersByCityUncheckedCreateWithoutSproutInstagramAnalyticsInput[]
    connectOrCreate?: SproutInstagramFollowersByCityCreateOrConnectWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCityCreateOrConnectWithoutSproutInstagramAnalyticsInput[]
    upsert?: SproutInstagramFollowersByCityUpsertWithWhereUniqueWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCityUpsertWithWhereUniqueWithoutSproutInstagramAnalyticsInput[]
    createMany?: SproutInstagramFollowersByCityCreateManySproutInstagramAnalyticsInputEnvelope
    set?: SproutInstagramFollowersByCityWhereUniqueInput | SproutInstagramFollowersByCityWhereUniqueInput[]
    disconnect?: SproutInstagramFollowersByCityWhereUniqueInput | SproutInstagramFollowersByCityWhereUniqueInput[]
    delete?: SproutInstagramFollowersByCityWhereUniqueInput | SproutInstagramFollowersByCityWhereUniqueInput[]
    connect?: SproutInstagramFollowersByCityWhereUniqueInput | SproutInstagramFollowersByCityWhereUniqueInput[]
    update?: SproutInstagramFollowersByCityUpdateWithWhereUniqueWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCityUpdateWithWhereUniqueWithoutSproutInstagramAnalyticsInput[]
    updateMany?: SproutInstagramFollowersByCityUpdateManyWithWhereWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCityUpdateManyWithWhereWithoutSproutInstagramAnalyticsInput[]
    deleteMany?: SproutInstagramFollowersByCityScalarWhereInput | SproutInstagramFollowersByCityScalarWhereInput[]
  }

  export type SproutInstagramFollowersByCountryUpdateManyWithoutSproutInstagramAnalyticsNestedInput = {
    create?: XOR<SproutInstagramFollowersByCountryCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCountryUncheckedCreateWithoutSproutInstagramAnalyticsInput> | SproutInstagramFollowersByCountryCreateWithoutSproutInstagramAnalyticsInput[] | SproutInstagramFollowersByCountryUncheckedCreateWithoutSproutInstagramAnalyticsInput[]
    connectOrCreate?: SproutInstagramFollowersByCountryCreateOrConnectWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCountryCreateOrConnectWithoutSproutInstagramAnalyticsInput[]
    upsert?: SproutInstagramFollowersByCountryUpsertWithWhereUniqueWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCountryUpsertWithWhereUniqueWithoutSproutInstagramAnalyticsInput[]
    createMany?: SproutInstagramFollowersByCountryCreateManySproutInstagramAnalyticsInputEnvelope
    set?: SproutInstagramFollowersByCountryWhereUniqueInput | SproutInstagramFollowersByCountryWhereUniqueInput[]
    disconnect?: SproutInstagramFollowersByCountryWhereUniqueInput | SproutInstagramFollowersByCountryWhereUniqueInput[]
    delete?: SproutInstagramFollowersByCountryWhereUniqueInput | SproutInstagramFollowersByCountryWhereUniqueInput[]
    connect?: SproutInstagramFollowersByCountryWhereUniqueInput | SproutInstagramFollowersByCountryWhereUniqueInput[]
    update?: SproutInstagramFollowersByCountryUpdateWithWhereUniqueWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCountryUpdateWithWhereUniqueWithoutSproutInstagramAnalyticsInput[]
    updateMany?: SproutInstagramFollowersByCountryUpdateManyWithWhereWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCountryUpdateManyWithWhereWithoutSproutInstagramAnalyticsInput[]
    deleteMany?: SproutInstagramFollowersByCountryScalarWhereInput | SproutInstagramFollowersByCountryScalarWhereInput[]
  }

  export type SproutInstagramFollowersByCityUncheckedUpdateManyWithoutSproutInstagramAnalyticsNestedInput = {
    create?: XOR<SproutInstagramFollowersByCityCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCityUncheckedCreateWithoutSproutInstagramAnalyticsInput> | SproutInstagramFollowersByCityCreateWithoutSproutInstagramAnalyticsInput[] | SproutInstagramFollowersByCityUncheckedCreateWithoutSproutInstagramAnalyticsInput[]
    connectOrCreate?: SproutInstagramFollowersByCityCreateOrConnectWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCityCreateOrConnectWithoutSproutInstagramAnalyticsInput[]
    upsert?: SproutInstagramFollowersByCityUpsertWithWhereUniqueWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCityUpsertWithWhereUniqueWithoutSproutInstagramAnalyticsInput[]
    createMany?: SproutInstagramFollowersByCityCreateManySproutInstagramAnalyticsInputEnvelope
    set?: SproutInstagramFollowersByCityWhereUniqueInput | SproutInstagramFollowersByCityWhereUniqueInput[]
    disconnect?: SproutInstagramFollowersByCityWhereUniqueInput | SproutInstagramFollowersByCityWhereUniqueInput[]
    delete?: SproutInstagramFollowersByCityWhereUniqueInput | SproutInstagramFollowersByCityWhereUniqueInput[]
    connect?: SproutInstagramFollowersByCityWhereUniqueInput | SproutInstagramFollowersByCityWhereUniqueInput[]
    update?: SproutInstagramFollowersByCityUpdateWithWhereUniqueWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCityUpdateWithWhereUniqueWithoutSproutInstagramAnalyticsInput[]
    updateMany?: SproutInstagramFollowersByCityUpdateManyWithWhereWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCityUpdateManyWithWhereWithoutSproutInstagramAnalyticsInput[]
    deleteMany?: SproutInstagramFollowersByCityScalarWhereInput | SproutInstagramFollowersByCityScalarWhereInput[]
  }

  export type SproutInstagramFollowersByCountryUncheckedUpdateManyWithoutSproutInstagramAnalyticsNestedInput = {
    create?: XOR<SproutInstagramFollowersByCountryCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCountryUncheckedCreateWithoutSproutInstagramAnalyticsInput> | SproutInstagramFollowersByCountryCreateWithoutSproutInstagramAnalyticsInput[] | SproutInstagramFollowersByCountryUncheckedCreateWithoutSproutInstagramAnalyticsInput[]
    connectOrCreate?: SproutInstagramFollowersByCountryCreateOrConnectWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCountryCreateOrConnectWithoutSproutInstagramAnalyticsInput[]
    upsert?: SproutInstagramFollowersByCountryUpsertWithWhereUniqueWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCountryUpsertWithWhereUniqueWithoutSproutInstagramAnalyticsInput[]
    createMany?: SproutInstagramFollowersByCountryCreateManySproutInstagramAnalyticsInputEnvelope
    set?: SproutInstagramFollowersByCountryWhereUniqueInput | SproutInstagramFollowersByCountryWhereUniqueInput[]
    disconnect?: SproutInstagramFollowersByCountryWhereUniqueInput | SproutInstagramFollowersByCountryWhereUniqueInput[]
    delete?: SproutInstagramFollowersByCountryWhereUniqueInput | SproutInstagramFollowersByCountryWhereUniqueInput[]
    connect?: SproutInstagramFollowersByCountryWhereUniqueInput | SproutInstagramFollowersByCountryWhereUniqueInput[]
    update?: SproutInstagramFollowersByCountryUpdateWithWhereUniqueWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCountryUpdateWithWhereUniqueWithoutSproutInstagramAnalyticsInput[]
    updateMany?: SproutInstagramFollowersByCountryUpdateManyWithWhereWithoutSproutInstagramAnalyticsInput | SproutInstagramFollowersByCountryUpdateManyWithWhereWithoutSproutInstagramAnalyticsInput[]
    deleteMany?: SproutInstagramFollowersByCountryScalarWhereInput | SproutInstagramFollowersByCountryScalarWhereInput[]
  }

  export type SproutInstagramAnalyticsCreateNestedOneWithoutFollowersByCityInput = {
    create?: XOR<SproutInstagramAnalyticsCreateWithoutFollowersByCityInput, SproutInstagramAnalyticsUncheckedCreateWithoutFollowersByCityInput>
    connectOrCreate?: SproutInstagramAnalyticsCreateOrConnectWithoutFollowersByCityInput
    connect?: SproutInstagramAnalyticsWhereUniqueInput
  }

  export type SproutInstagramAnalyticsUpdateOneRequiredWithoutFollowersByCityNestedInput = {
    create?: XOR<SproutInstagramAnalyticsCreateWithoutFollowersByCityInput, SproutInstagramAnalyticsUncheckedCreateWithoutFollowersByCityInput>
    connectOrCreate?: SproutInstagramAnalyticsCreateOrConnectWithoutFollowersByCityInput
    upsert?: SproutInstagramAnalyticsUpsertWithoutFollowersByCityInput
    connect?: SproutInstagramAnalyticsWhereUniqueInput
    update?: XOR<XOR<SproutInstagramAnalyticsUpdateToOneWithWhereWithoutFollowersByCityInput, SproutInstagramAnalyticsUpdateWithoutFollowersByCityInput>, SproutInstagramAnalyticsUncheckedUpdateWithoutFollowersByCityInput>
  }

  export type SproutInstagramAnalyticsCreateNestedOneWithoutFollowersByCountryInput = {
    create?: XOR<SproutInstagramAnalyticsCreateWithoutFollowersByCountryInput, SproutInstagramAnalyticsUncheckedCreateWithoutFollowersByCountryInput>
    connectOrCreate?: SproutInstagramAnalyticsCreateOrConnectWithoutFollowersByCountryInput
    connect?: SproutInstagramAnalyticsWhereUniqueInput
  }

  export type SproutInstagramAnalyticsUpdateOneRequiredWithoutFollowersByCountryNestedInput = {
    create?: XOR<SproutInstagramAnalyticsCreateWithoutFollowersByCountryInput, SproutInstagramAnalyticsUncheckedCreateWithoutFollowersByCountryInput>
    connectOrCreate?: SproutInstagramAnalyticsCreateOrConnectWithoutFollowersByCountryInput
    upsert?: SproutInstagramAnalyticsUpsertWithoutFollowersByCountryInput
    connect?: SproutInstagramAnalyticsWhereUniqueInput
    update?: XOR<XOR<SproutInstagramAnalyticsUpdateToOneWithWhereWithoutFollowersByCountryInput, SproutInstagramAnalyticsUpdateWithoutFollowersByCountryInput>, SproutInstagramAnalyticsUncheckedUpdateWithoutFollowersByCountryInput>
  }

  export type SproutSocialAccountCreateNestedOneWithoutLinkedInAnalyticsInput = {
    create?: XOR<SproutSocialAccountCreateWithoutLinkedInAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutLinkedInAnalyticsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutLinkedInAnalyticsInput
    connect?: SproutSocialAccountWhereUniqueInput
  }

  export type SproutSocialAccountUpdateOneRequiredWithoutLinkedInAnalyticsNestedInput = {
    create?: XOR<SproutSocialAccountCreateWithoutLinkedInAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutLinkedInAnalyticsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutLinkedInAnalyticsInput
    upsert?: SproutSocialAccountUpsertWithoutLinkedInAnalyticsInput
    connect?: SproutSocialAccountWhereUniqueInput
    update?: XOR<XOR<SproutSocialAccountUpdateToOneWithWhereWithoutLinkedInAnalyticsInput, SproutSocialAccountUpdateWithoutLinkedInAnalyticsInput>, SproutSocialAccountUncheckedUpdateWithoutLinkedInAnalyticsInput>
  }

  export type SproutSocialAccountCreateNestedOneWithoutPinterestAnalyticsInput = {
    create?: XOR<SproutSocialAccountCreateWithoutPinterestAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutPinterestAnalyticsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutPinterestAnalyticsInput
    connect?: SproutSocialAccountWhereUniqueInput
  }

  export type SproutSocialAccountUpdateOneRequiredWithoutPinterestAnalyticsNestedInput = {
    create?: XOR<SproutSocialAccountCreateWithoutPinterestAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutPinterestAnalyticsInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutPinterestAnalyticsInput
    upsert?: SproutSocialAccountUpsertWithoutPinterestAnalyticsInput
    connect?: SproutSocialAccountWhereUniqueInput
    update?: XOR<XOR<SproutSocialAccountUpdateToOneWithWhereWithoutPinterestAnalyticsInput, SproutSocialAccountUpdateWithoutPinterestAnalyticsInput>, SproutSocialAccountUncheckedUpdateWithoutPinterestAnalyticsInput>
  }

  export type SproutSocialAccountCreategroupsInput = {
    set: number[]
  }

  export type SproutFacebookAnalyticsCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutFacebookAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutFacebookAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookAnalyticsCreateManySproutSocialAccountInputEnvelope
    connect?: SproutFacebookAnalyticsWhereUniqueInput | SproutFacebookAnalyticsWhereUniqueInput[]
  }

  export type SproutFacebookPostCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutFacebookPostCreateWithoutSproutSocialAccountInput, SproutFacebookPostUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookPostCreateWithoutSproutSocialAccountInput[] | SproutFacebookPostUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookPostCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookPostCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookPostCreateManySproutSocialAccountInputEnvelope
    connect?: SproutFacebookPostWhereUniqueInput | SproutFacebookPostWhereUniqueInput[]
  }

  export type SproutFacebookPostAnalyticsCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutFacebookPostAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookPostAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookPostAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutFacebookPostAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookPostAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookPostAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookPostAnalyticsCreateManySproutSocialAccountInputEnvelope
    connect?: SproutFacebookPostAnalyticsWhereUniqueInput | SproutFacebookPostAnalyticsWhereUniqueInput[]
  }

  export type SproutInstagramAnalyticsCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutInstagramAnalyticsCreateWithoutSproutSocialAccountInput, SproutInstagramAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutInstagramAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutInstagramAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutInstagramAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutInstagramAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutInstagramAnalyticsCreateManySproutSocialAccountInputEnvelope
    connect?: SproutInstagramAnalyticsWhereUniqueInput | SproutInstagramAnalyticsWhereUniqueInput[]
  }

  export type SproutLinkedInAnalyticsCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutLinkedInAnalyticsCreateWithoutSproutSocialAccountInput, SproutLinkedInAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutLinkedInAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutLinkedInAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutLinkedInAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutLinkedInAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutLinkedInAnalyticsCreateManySproutSocialAccountInputEnvelope
    connect?: SproutLinkedInAnalyticsWhereUniqueInput | SproutLinkedInAnalyticsWhereUniqueInput[]
  }

  export type SproutPinterestAnalyticsCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutPinterestAnalyticsCreateWithoutSproutSocialAccountInput, SproutPinterestAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutPinterestAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutPinterestAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutPinterestAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutPinterestAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutPinterestAnalyticsCreateManySproutSocialAccountInputEnvelope
    connect?: SproutPinterestAnalyticsWhereUniqueInput | SproutPinterestAnalyticsWhereUniqueInput[]
  }

  export type UserToSproutSocialAccountCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<UserToSproutSocialAccountCreateWithoutSproutSocialAccountInput, UserToSproutSocialAccountUncheckedCreateWithoutSproutSocialAccountInput> | UserToSproutSocialAccountCreateWithoutSproutSocialAccountInput[] | UserToSproutSocialAccountUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: UserToSproutSocialAccountCreateOrConnectWithoutSproutSocialAccountInput | UserToSproutSocialAccountCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: UserToSproutSocialAccountCreateManySproutSocialAccountInputEnvelope
    connect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
  }

  export type SproutFacebookAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutFacebookAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutFacebookAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookAnalyticsCreateManySproutSocialAccountInputEnvelope
    connect?: SproutFacebookAnalyticsWhereUniqueInput | SproutFacebookAnalyticsWhereUniqueInput[]
  }

  export type SproutFacebookPostUncheckedCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutFacebookPostCreateWithoutSproutSocialAccountInput, SproutFacebookPostUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookPostCreateWithoutSproutSocialAccountInput[] | SproutFacebookPostUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookPostCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookPostCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookPostCreateManySproutSocialAccountInputEnvelope
    connect?: SproutFacebookPostWhereUniqueInput | SproutFacebookPostWhereUniqueInput[]
  }

  export type SproutFacebookPostAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutFacebookPostAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookPostAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookPostAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutFacebookPostAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookPostAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookPostAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookPostAnalyticsCreateManySproutSocialAccountInputEnvelope
    connect?: SproutFacebookPostAnalyticsWhereUniqueInput | SproutFacebookPostAnalyticsWhereUniqueInput[]
  }

  export type SproutInstagramAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutInstagramAnalyticsCreateWithoutSproutSocialAccountInput, SproutInstagramAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutInstagramAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutInstagramAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutInstagramAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutInstagramAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutInstagramAnalyticsCreateManySproutSocialAccountInputEnvelope
    connect?: SproutInstagramAnalyticsWhereUniqueInput | SproutInstagramAnalyticsWhereUniqueInput[]
  }

  export type SproutLinkedInAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutLinkedInAnalyticsCreateWithoutSproutSocialAccountInput, SproutLinkedInAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutLinkedInAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutLinkedInAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutLinkedInAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutLinkedInAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutLinkedInAnalyticsCreateManySproutSocialAccountInputEnvelope
    connect?: SproutLinkedInAnalyticsWhereUniqueInput | SproutLinkedInAnalyticsWhereUniqueInput[]
  }

  export type SproutPinterestAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<SproutPinterestAnalyticsCreateWithoutSproutSocialAccountInput, SproutPinterestAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutPinterestAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutPinterestAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutPinterestAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutPinterestAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: SproutPinterestAnalyticsCreateManySproutSocialAccountInputEnvelope
    connect?: SproutPinterestAnalyticsWhereUniqueInput | SproutPinterestAnalyticsWhereUniqueInput[]
  }

  export type UserToSproutSocialAccountUncheckedCreateNestedManyWithoutSproutSocialAccountInput = {
    create?: XOR<UserToSproutSocialAccountCreateWithoutSproutSocialAccountInput, UserToSproutSocialAccountUncheckedCreateWithoutSproutSocialAccountInput> | UserToSproutSocialAccountCreateWithoutSproutSocialAccountInput[] | UserToSproutSocialAccountUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: UserToSproutSocialAccountCreateOrConnectWithoutSproutSocialAccountInput | UserToSproutSocialAccountCreateOrConnectWithoutSproutSocialAccountInput[]
    createMany?: UserToSproutSocialAccountCreateManySproutSocialAccountInputEnvelope
    connect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
  }

  export type SproutSocialAccountUpdategroupsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type SproutFacebookAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutFacebookAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutFacebookAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutFacebookAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookAnalyticsCreateManySproutSocialAccountInputEnvelope
    set?: SproutFacebookAnalyticsWhereUniqueInput | SproutFacebookAnalyticsWhereUniqueInput[]
    disconnect?: SproutFacebookAnalyticsWhereUniqueInput | SproutFacebookAnalyticsWhereUniqueInput[]
    delete?: SproutFacebookAnalyticsWhereUniqueInput | SproutFacebookAnalyticsWhereUniqueInput[]
    connect?: SproutFacebookAnalyticsWhereUniqueInput | SproutFacebookAnalyticsWhereUniqueInput[]
    update?: SproutFacebookAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutFacebookAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutFacebookAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutFacebookAnalyticsScalarWhereInput | SproutFacebookAnalyticsScalarWhereInput[]
  }

  export type SproutFacebookPostUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutFacebookPostCreateWithoutSproutSocialAccountInput, SproutFacebookPostUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookPostCreateWithoutSproutSocialAccountInput[] | SproutFacebookPostUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookPostCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookPostCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutFacebookPostUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookPostUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookPostCreateManySproutSocialAccountInputEnvelope
    set?: SproutFacebookPostWhereUniqueInput | SproutFacebookPostWhereUniqueInput[]
    disconnect?: SproutFacebookPostWhereUniqueInput | SproutFacebookPostWhereUniqueInput[]
    delete?: SproutFacebookPostWhereUniqueInput | SproutFacebookPostWhereUniqueInput[]
    connect?: SproutFacebookPostWhereUniqueInput | SproutFacebookPostWhereUniqueInput[]
    update?: SproutFacebookPostUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookPostUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutFacebookPostUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutFacebookPostUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutFacebookPostScalarWhereInput | SproutFacebookPostScalarWhereInput[]
  }

  export type SproutFacebookPostAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutFacebookPostAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookPostAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookPostAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutFacebookPostAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookPostAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookPostAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutFacebookPostAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookPostAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookPostAnalyticsCreateManySproutSocialAccountInputEnvelope
    set?: SproutFacebookPostAnalyticsWhereUniqueInput | SproutFacebookPostAnalyticsWhereUniqueInput[]
    disconnect?: SproutFacebookPostAnalyticsWhereUniqueInput | SproutFacebookPostAnalyticsWhereUniqueInput[]
    delete?: SproutFacebookPostAnalyticsWhereUniqueInput | SproutFacebookPostAnalyticsWhereUniqueInput[]
    connect?: SproutFacebookPostAnalyticsWhereUniqueInput | SproutFacebookPostAnalyticsWhereUniqueInput[]
    update?: SproutFacebookPostAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookPostAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutFacebookPostAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutFacebookPostAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutFacebookPostAnalyticsScalarWhereInput | SproutFacebookPostAnalyticsScalarWhereInput[]
  }

  export type SproutInstagramAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutInstagramAnalyticsCreateWithoutSproutSocialAccountInput, SproutInstagramAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutInstagramAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutInstagramAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutInstagramAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutInstagramAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutInstagramAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutInstagramAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutInstagramAnalyticsCreateManySproutSocialAccountInputEnvelope
    set?: SproutInstagramAnalyticsWhereUniqueInput | SproutInstagramAnalyticsWhereUniqueInput[]
    disconnect?: SproutInstagramAnalyticsWhereUniqueInput | SproutInstagramAnalyticsWhereUniqueInput[]
    delete?: SproutInstagramAnalyticsWhereUniqueInput | SproutInstagramAnalyticsWhereUniqueInput[]
    connect?: SproutInstagramAnalyticsWhereUniqueInput | SproutInstagramAnalyticsWhereUniqueInput[]
    update?: SproutInstagramAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutInstagramAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutInstagramAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutInstagramAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutInstagramAnalyticsScalarWhereInput | SproutInstagramAnalyticsScalarWhereInput[]
  }

  export type SproutLinkedInAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutLinkedInAnalyticsCreateWithoutSproutSocialAccountInput, SproutLinkedInAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutLinkedInAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutLinkedInAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutLinkedInAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutLinkedInAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutLinkedInAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutLinkedInAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutLinkedInAnalyticsCreateManySproutSocialAccountInputEnvelope
    set?: SproutLinkedInAnalyticsWhereUniqueInput | SproutLinkedInAnalyticsWhereUniqueInput[]
    disconnect?: SproutLinkedInAnalyticsWhereUniqueInput | SproutLinkedInAnalyticsWhereUniqueInput[]
    delete?: SproutLinkedInAnalyticsWhereUniqueInput | SproutLinkedInAnalyticsWhereUniqueInput[]
    connect?: SproutLinkedInAnalyticsWhereUniqueInput | SproutLinkedInAnalyticsWhereUniqueInput[]
    update?: SproutLinkedInAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutLinkedInAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutLinkedInAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutLinkedInAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutLinkedInAnalyticsScalarWhereInput | SproutLinkedInAnalyticsScalarWhereInput[]
  }

  export type SproutPinterestAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutPinterestAnalyticsCreateWithoutSproutSocialAccountInput, SproutPinterestAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutPinterestAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutPinterestAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutPinterestAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutPinterestAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutPinterestAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutPinterestAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutPinterestAnalyticsCreateManySproutSocialAccountInputEnvelope
    set?: SproutPinterestAnalyticsWhereUniqueInput | SproutPinterestAnalyticsWhereUniqueInput[]
    disconnect?: SproutPinterestAnalyticsWhereUniqueInput | SproutPinterestAnalyticsWhereUniqueInput[]
    delete?: SproutPinterestAnalyticsWhereUniqueInput | SproutPinterestAnalyticsWhereUniqueInput[]
    connect?: SproutPinterestAnalyticsWhereUniqueInput | SproutPinterestAnalyticsWhereUniqueInput[]
    update?: SproutPinterestAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutPinterestAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutPinterestAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutPinterestAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutPinterestAnalyticsScalarWhereInput | SproutPinterestAnalyticsScalarWhereInput[]
  }

  export type UserToSproutSocialAccountUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<UserToSproutSocialAccountCreateWithoutSproutSocialAccountInput, UserToSproutSocialAccountUncheckedCreateWithoutSproutSocialAccountInput> | UserToSproutSocialAccountCreateWithoutSproutSocialAccountInput[] | UserToSproutSocialAccountUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: UserToSproutSocialAccountCreateOrConnectWithoutSproutSocialAccountInput | UserToSproutSocialAccountCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: UserToSproutSocialAccountUpsertWithWhereUniqueWithoutSproutSocialAccountInput | UserToSproutSocialAccountUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: UserToSproutSocialAccountCreateManySproutSocialAccountInputEnvelope
    set?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    disconnect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    delete?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    connect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    update?: UserToSproutSocialAccountUpdateWithWhereUniqueWithoutSproutSocialAccountInput | UserToSproutSocialAccountUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: UserToSproutSocialAccountUpdateManyWithWhereWithoutSproutSocialAccountInput | UserToSproutSocialAccountUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: UserToSproutSocialAccountScalarWhereInput | UserToSproutSocialAccountScalarWhereInput[]
  }

  export type SproutFacebookAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutFacebookAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutFacebookAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutFacebookAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookAnalyticsCreateManySproutSocialAccountInputEnvelope
    set?: SproutFacebookAnalyticsWhereUniqueInput | SproutFacebookAnalyticsWhereUniqueInput[]
    disconnect?: SproutFacebookAnalyticsWhereUniqueInput | SproutFacebookAnalyticsWhereUniqueInput[]
    delete?: SproutFacebookAnalyticsWhereUniqueInput | SproutFacebookAnalyticsWhereUniqueInput[]
    connect?: SproutFacebookAnalyticsWhereUniqueInput | SproutFacebookAnalyticsWhereUniqueInput[]
    update?: SproutFacebookAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutFacebookAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutFacebookAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutFacebookAnalyticsScalarWhereInput | SproutFacebookAnalyticsScalarWhereInput[]
  }

  export type SproutFacebookPostUncheckedUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutFacebookPostCreateWithoutSproutSocialAccountInput, SproutFacebookPostUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookPostCreateWithoutSproutSocialAccountInput[] | SproutFacebookPostUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookPostCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookPostCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutFacebookPostUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookPostUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookPostCreateManySproutSocialAccountInputEnvelope
    set?: SproutFacebookPostWhereUniqueInput | SproutFacebookPostWhereUniqueInput[]
    disconnect?: SproutFacebookPostWhereUniqueInput | SproutFacebookPostWhereUniqueInput[]
    delete?: SproutFacebookPostWhereUniqueInput | SproutFacebookPostWhereUniqueInput[]
    connect?: SproutFacebookPostWhereUniqueInput | SproutFacebookPostWhereUniqueInput[]
    update?: SproutFacebookPostUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookPostUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutFacebookPostUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutFacebookPostUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutFacebookPostScalarWhereInput | SproutFacebookPostScalarWhereInput[]
  }

  export type SproutFacebookPostAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutFacebookPostAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookPostAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutFacebookPostAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutFacebookPostAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutFacebookPostAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutFacebookPostAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutFacebookPostAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookPostAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutFacebookPostAnalyticsCreateManySproutSocialAccountInputEnvelope
    set?: SproutFacebookPostAnalyticsWhereUniqueInput | SproutFacebookPostAnalyticsWhereUniqueInput[]
    disconnect?: SproutFacebookPostAnalyticsWhereUniqueInput | SproutFacebookPostAnalyticsWhereUniqueInput[]
    delete?: SproutFacebookPostAnalyticsWhereUniqueInput | SproutFacebookPostAnalyticsWhereUniqueInput[]
    connect?: SproutFacebookPostAnalyticsWhereUniqueInput | SproutFacebookPostAnalyticsWhereUniqueInput[]
    update?: SproutFacebookPostAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutFacebookPostAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutFacebookPostAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutFacebookPostAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutFacebookPostAnalyticsScalarWhereInput | SproutFacebookPostAnalyticsScalarWhereInput[]
  }

  export type SproutInstagramAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutInstagramAnalyticsCreateWithoutSproutSocialAccountInput, SproutInstagramAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutInstagramAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutInstagramAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutInstagramAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutInstagramAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutInstagramAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutInstagramAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutInstagramAnalyticsCreateManySproutSocialAccountInputEnvelope
    set?: SproutInstagramAnalyticsWhereUniqueInput | SproutInstagramAnalyticsWhereUniqueInput[]
    disconnect?: SproutInstagramAnalyticsWhereUniqueInput | SproutInstagramAnalyticsWhereUniqueInput[]
    delete?: SproutInstagramAnalyticsWhereUniqueInput | SproutInstagramAnalyticsWhereUniqueInput[]
    connect?: SproutInstagramAnalyticsWhereUniqueInput | SproutInstagramAnalyticsWhereUniqueInput[]
    update?: SproutInstagramAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutInstagramAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutInstagramAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutInstagramAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutInstagramAnalyticsScalarWhereInput | SproutInstagramAnalyticsScalarWhereInput[]
  }

  export type SproutLinkedInAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutLinkedInAnalyticsCreateWithoutSproutSocialAccountInput, SproutLinkedInAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutLinkedInAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutLinkedInAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutLinkedInAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutLinkedInAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutLinkedInAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutLinkedInAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutLinkedInAnalyticsCreateManySproutSocialAccountInputEnvelope
    set?: SproutLinkedInAnalyticsWhereUniqueInput | SproutLinkedInAnalyticsWhereUniqueInput[]
    disconnect?: SproutLinkedInAnalyticsWhereUniqueInput | SproutLinkedInAnalyticsWhereUniqueInput[]
    delete?: SproutLinkedInAnalyticsWhereUniqueInput | SproutLinkedInAnalyticsWhereUniqueInput[]
    connect?: SproutLinkedInAnalyticsWhereUniqueInput | SproutLinkedInAnalyticsWhereUniqueInput[]
    update?: SproutLinkedInAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutLinkedInAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutLinkedInAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutLinkedInAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutLinkedInAnalyticsScalarWhereInput | SproutLinkedInAnalyticsScalarWhereInput[]
  }

  export type SproutPinterestAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<SproutPinterestAnalyticsCreateWithoutSproutSocialAccountInput, SproutPinterestAnalyticsUncheckedCreateWithoutSproutSocialAccountInput> | SproutPinterestAnalyticsCreateWithoutSproutSocialAccountInput[] | SproutPinterestAnalyticsUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: SproutPinterestAnalyticsCreateOrConnectWithoutSproutSocialAccountInput | SproutPinterestAnalyticsCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: SproutPinterestAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput | SproutPinterestAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: SproutPinterestAnalyticsCreateManySproutSocialAccountInputEnvelope
    set?: SproutPinterestAnalyticsWhereUniqueInput | SproutPinterestAnalyticsWhereUniqueInput[]
    disconnect?: SproutPinterestAnalyticsWhereUniqueInput | SproutPinterestAnalyticsWhereUniqueInput[]
    delete?: SproutPinterestAnalyticsWhereUniqueInput | SproutPinterestAnalyticsWhereUniqueInput[]
    connect?: SproutPinterestAnalyticsWhereUniqueInput | SproutPinterestAnalyticsWhereUniqueInput[]
    update?: SproutPinterestAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput | SproutPinterestAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: SproutPinterestAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput | SproutPinterestAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: SproutPinterestAnalyticsScalarWhereInput | SproutPinterestAnalyticsScalarWhereInput[]
  }

  export type UserToSproutSocialAccountUncheckedUpdateManyWithoutSproutSocialAccountNestedInput = {
    create?: XOR<UserToSproutSocialAccountCreateWithoutSproutSocialAccountInput, UserToSproutSocialAccountUncheckedCreateWithoutSproutSocialAccountInput> | UserToSproutSocialAccountCreateWithoutSproutSocialAccountInput[] | UserToSproutSocialAccountUncheckedCreateWithoutSproutSocialAccountInput[]
    connectOrCreate?: UserToSproutSocialAccountCreateOrConnectWithoutSproutSocialAccountInput | UserToSproutSocialAccountCreateOrConnectWithoutSproutSocialAccountInput[]
    upsert?: UserToSproutSocialAccountUpsertWithWhereUniqueWithoutSproutSocialAccountInput | UserToSproutSocialAccountUpsertWithWhereUniqueWithoutSproutSocialAccountInput[]
    createMany?: UserToSproutSocialAccountCreateManySproutSocialAccountInputEnvelope
    set?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    disconnect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    delete?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    connect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    update?: UserToSproutSocialAccountUpdateWithWhereUniqueWithoutSproutSocialAccountInput | UserToSproutSocialAccountUpdateWithWhereUniqueWithoutSproutSocialAccountInput[]
    updateMany?: UserToSproutSocialAccountUpdateManyWithWhereWithoutSproutSocialAccountInput | UserToSproutSocialAccountUpdateManyWithWhereWithoutSproutSocialAccountInput[]
    deleteMany?: UserToSproutSocialAccountScalarWhereInput | UserToSproutSocialAccountScalarWhereInput[]
  }

  export type SproutSocialAccountCreateNestedOneWithoutUsersInput = {
    create?: XOR<SproutSocialAccountCreateWithoutUsersInput, SproutSocialAccountUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutUsersInput
    connect?: SproutSocialAccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSproutSocialAccountsInput = {
    create?: XOR<UserCreateWithoutSproutSocialAccountsInput, UserUncheckedCreateWithoutSproutSocialAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSproutSocialAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type SproutSocialAccountUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SproutSocialAccountCreateWithoutUsersInput, SproutSocialAccountUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SproutSocialAccountCreateOrConnectWithoutUsersInput
    upsert?: SproutSocialAccountUpsertWithoutUsersInput
    connect?: SproutSocialAccountWhereUniqueInput
    update?: XOR<XOR<SproutSocialAccountUpdateToOneWithWhereWithoutUsersInput, SproutSocialAccountUpdateWithoutUsersInput>, SproutSocialAccountUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutSproutSocialAccountsNestedInput = {
    create?: XOR<UserCreateWithoutSproutSocialAccountsInput, UserUncheckedCreateWithoutSproutSocialAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSproutSocialAccountsInput
    upsert?: UserUpsertWithoutSproutSocialAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSproutSocialAccountsInput, UserUpdateWithoutSproutSocialAccountsInput>, UserUncheckedUpdateWithoutSproutSocialAccountsInput>
  }

  export type GaAccountCreateNestedOneWithoutUserToGaAccountsInput = {
    create?: XOR<GaAccountCreateWithoutUserToGaAccountsInput, GaAccountUncheckedCreateWithoutUserToGaAccountsInput>
    connectOrCreate?: GaAccountCreateOrConnectWithoutUserToGaAccountsInput
    connect?: GaAccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserToGaAccountsInput = {
    create?: XOR<UserCreateWithoutUserToGaAccountsInput, UserUncheckedCreateWithoutUserToGaAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserToGaAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type GaAccountUpdateOneRequiredWithoutUserToGaAccountsNestedInput = {
    create?: XOR<GaAccountCreateWithoutUserToGaAccountsInput, GaAccountUncheckedCreateWithoutUserToGaAccountsInput>
    connectOrCreate?: GaAccountCreateOrConnectWithoutUserToGaAccountsInput
    upsert?: GaAccountUpsertWithoutUserToGaAccountsInput
    connect?: GaAccountWhereUniqueInput
    update?: XOR<XOR<GaAccountUpdateToOneWithWhereWithoutUserToGaAccountsInput, GaAccountUpdateWithoutUserToGaAccountsInput>, GaAccountUncheckedUpdateWithoutUserToGaAccountsInput>
  }

  export type UserUpdateOneRequiredWithoutUserToGaAccountsNestedInput = {
    create?: XOR<UserCreateWithoutUserToGaAccountsInput, UserUncheckedCreateWithoutUserToGaAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserToGaAccountsInput
    upsert?: UserUpsertWithoutUserToGaAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserToGaAccountsInput, UserUpdateWithoutUserToGaAccountsInput>, UserUncheckedUpdateWithoutUserToGaAccountsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ClientActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput> | ClientActivityCreateWithoutUserInput[] | ClientActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientActivityCreateOrConnectWithoutUserInput | ClientActivityCreateOrConnectWithoutUserInput[]
    createMany?: ClientActivityCreateManyUserInputEnvelope
    connect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
  }

  export type ClientSatisfactionCreateNestedManyWithoutAccountRepInput = {
    create?: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput> | ClientSatisfactionCreateWithoutAccountRepInput[] | ClientSatisfactionUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutAccountRepInput | ClientSatisfactionCreateOrConnectWithoutAccountRepInput[]
    createMany?: ClientSatisfactionCreateManyAccountRepInputEnvelope
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
  }

  export type ClientSatisfactionCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput> | ClientSatisfactionCreateWithoutUserInput[] | ClientSatisfactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutUserInput | ClientSatisfactionCreateOrConnectWithoutUserInput[]
    createMany?: ClientSatisfactionCreateManyUserInputEnvelope
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutClientInput = {
    create?: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput> | ConversationCreateWithoutClientInput[] | ConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutClientInput | ConversationCreateOrConnectWithoutClientInput[]
    createMany?: ConversationCreateManyClientInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type GaImportRunCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput> | GaImportRunCreateWithoutRequestedByInput[] | GaImportRunUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutRequestedByInput | GaImportRunCreateOrConnectWithoutRequestedByInput[]
    createMany?: GaImportRunCreateManyRequestedByInputEnvelope
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type QueryCreateNestedManyWithoutUserInput = {
    create?: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput> | QueryCreateWithoutUserInput[] | QueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutUserInput | QueryCreateOrConnectWithoutUserInput[]
    createMany?: QueryCreateManyUserInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutClientInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutClientsInput = {
    create?: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutAccountRepInput = {
    create?: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput> | UserCreateWithoutAccountRepInput[] | UserUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountRepInput | UserCreateOrConnectWithoutAccountRepInput[]
    createMany?: UserCreateManyAccountRepInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type UserToEmailClientCreateNestedManyWithoutUserInput = {
    create?: XOR<UserToEmailClientCreateWithoutUserInput, UserToEmailClientUncheckedCreateWithoutUserInput> | UserToEmailClientCreateWithoutUserInput[] | UserToEmailClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToEmailClientCreateOrConnectWithoutUserInput | UserToEmailClientCreateOrConnectWithoutUserInput[]
    createMany?: UserToEmailClientCreateManyUserInputEnvelope
    connect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
  }

  export type UserToGaAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<UserToGaAccountCreateWithoutUserInput, UserToGaAccountUncheckedCreateWithoutUserInput> | UserToGaAccountCreateWithoutUserInput[] | UserToGaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToGaAccountCreateOrConnectWithoutUserInput | UserToGaAccountCreateOrConnectWithoutUserInput[]
    createMany?: UserToGaAccountCreateManyUserInputEnvelope
    connect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
  }

  export type UserToSproutSocialAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<UserToSproutSocialAccountCreateWithoutUserInput, UserToSproutSocialAccountUncheckedCreateWithoutUserInput> | UserToSproutSocialAccountCreateWithoutUserInput[] | UserToSproutSocialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToSproutSocialAccountCreateOrConnectWithoutUserInput | UserToSproutSocialAccountCreateOrConnectWithoutUserInput[]
    createMany?: UserToSproutSocialAccountCreateManyUserInputEnvelope
    connect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ClientActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput> | ClientActivityCreateWithoutUserInput[] | ClientActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientActivityCreateOrConnectWithoutUserInput | ClientActivityCreateOrConnectWithoutUserInput[]
    createMany?: ClientActivityCreateManyUserInputEnvelope
    connect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
  }

  export type ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput = {
    create?: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput> | ClientSatisfactionCreateWithoutAccountRepInput[] | ClientSatisfactionUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutAccountRepInput | ClientSatisfactionCreateOrConnectWithoutAccountRepInput[]
    createMany?: ClientSatisfactionCreateManyAccountRepInputEnvelope
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
  }

  export type ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput> | ClientSatisfactionCreateWithoutUserInput[] | ClientSatisfactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutUserInput | ClientSatisfactionCreateOrConnectWithoutUserInput[]
    createMany?: ClientSatisfactionCreateManyUserInputEnvelope
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput> | ConversationCreateWithoutClientInput[] | ConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutClientInput | ConversationCreateOrConnectWithoutClientInput[]
    createMany?: ConversationCreateManyClientInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput> | GaImportRunCreateWithoutRequestedByInput[] | GaImportRunUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutRequestedByInput | GaImportRunCreateOrConnectWithoutRequestedByInput[]
    createMany?: GaImportRunCreateManyRequestedByInputEnvelope
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type QueryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput> | QueryCreateWithoutUserInput[] | QueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutUserInput | QueryCreateOrConnectWithoutUserInput[]
    createMany?: QueryCreateManyUserInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAccountRepInput = {
    create?: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput> | UserCreateWithoutAccountRepInput[] | UserUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountRepInput | UserCreateOrConnectWithoutAccountRepInput[]
    createMany?: UserCreateManyAccountRepInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type UserToEmailClientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserToEmailClientCreateWithoutUserInput, UserToEmailClientUncheckedCreateWithoutUserInput> | UserToEmailClientCreateWithoutUserInput[] | UserToEmailClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToEmailClientCreateOrConnectWithoutUserInput | UserToEmailClientCreateOrConnectWithoutUserInput[]
    createMany?: UserToEmailClientCreateManyUserInputEnvelope
    connect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
  }

  export type UserToGaAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserToGaAccountCreateWithoutUserInput, UserToGaAccountUncheckedCreateWithoutUserInput> | UserToGaAccountCreateWithoutUserInput[] | UserToGaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToGaAccountCreateOrConnectWithoutUserInput | UserToGaAccountCreateOrConnectWithoutUserInput[]
    createMany?: UserToGaAccountCreateManyUserInputEnvelope
    connect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
  }

  export type UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserToSproutSocialAccountCreateWithoutUserInput, UserToSproutSocialAccountUncheckedCreateWithoutUserInput> | UserToSproutSocialAccountCreateWithoutUserInput[] | UserToSproutSocialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToSproutSocialAccountCreateOrConnectWithoutUserInput | UserToSproutSocialAccountCreateOrConnectWithoutUserInput[]
    createMany?: UserToSproutSocialAccountCreateManyUserInputEnvelope
    connect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ClientActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput> | ClientActivityCreateWithoutUserInput[] | ClientActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientActivityCreateOrConnectWithoutUserInput | ClientActivityCreateOrConnectWithoutUserInput[]
    upsert?: ClientActivityUpsertWithWhereUniqueWithoutUserInput | ClientActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientActivityCreateManyUserInputEnvelope
    set?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    disconnect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    delete?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    connect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    update?: ClientActivityUpdateWithWhereUniqueWithoutUserInput | ClientActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientActivityUpdateManyWithWhereWithoutUserInput | ClientActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientActivityScalarWhereInput | ClientActivityScalarWhereInput[]
  }

  export type ClientSatisfactionUpdateManyWithoutAccountRepNestedInput = {
    create?: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput> | ClientSatisfactionCreateWithoutAccountRepInput[] | ClientSatisfactionUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutAccountRepInput | ClientSatisfactionCreateOrConnectWithoutAccountRepInput[]
    upsert?: ClientSatisfactionUpsertWithWhereUniqueWithoutAccountRepInput | ClientSatisfactionUpsertWithWhereUniqueWithoutAccountRepInput[]
    createMany?: ClientSatisfactionCreateManyAccountRepInputEnvelope
    set?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    disconnect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    delete?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    update?: ClientSatisfactionUpdateWithWhereUniqueWithoutAccountRepInput | ClientSatisfactionUpdateWithWhereUniqueWithoutAccountRepInput[]
    updateMany?: ClientSatisfactionUpdateManyWithWhereWithoutAccountRepInput | ClientSatisfactionUpdateManyWithWhereWithoutAccountRepInput[]
    deleteMany?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
  }

  export type ClientSatisfactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput> | ClientSatisfactionCreateWithoutUserInput[] | ClientSatisfactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutUserInput | ClientSatisfactionCreateOrConnectWithoutUserInput[]
    upsert?: ClientSatisfactionUpsertWithWhereUniqueWithoutUserInput | ClientSatisfactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientSatisfactionCreateManyUserInputEnvelope
    set?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    disconnect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    delete?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    update?: ClientSatisfactionUpdateWithWhereUniqueWithoutUserInput | ClientSatisfactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientSatisfactionUpdateManyWithWhereWithoutUserInput | ClientSatisfactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutClientNestedInput = {
    create?: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput> | ConversationCreateWithoutClientInput[] | ConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutClientInput | ConversationCreateOrConnectWithoutClientInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutClientInput | ConversationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ConversationCreateManyClientInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutClientInput | ConversationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutClientInput | ConversationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GaImportRunUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput> | GaImportRunCreateWithoutRequestedByInput[] | GaImportRunUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutRequestedByInput | GaImportRunCreateOrConnectWithoutRequestedByInput[]
    upsert?: GaImportRunUpsertWithWhereUniqueWithoutRequestedByInput | GaImportRunUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: GaImportRunCreateManyRequestedByInputEnvelope
    set?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    disconnect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    delete?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    update?: GaImportRunUpdateWithWhereUniqueWithoutRequestedByInput | GaImportRunUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: GaImportRunUpdateManyWithWhereWithoutRequestedByInput | GaImportRunUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type QueryUpdateManyWithoutUserNestedInput = {
    create?: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput> | QueryCreateWithoutUserInput[] | QueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutUserInput | QueryCreateOrConnectWithoutUserInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutUserInput | QueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QueryCreateManyUserInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutUserInput | QueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutUserInput | QueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedToInput | TicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedToInput | TicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedToInput | TicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutClientNestedInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClientInput | TicketUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClientInput | TicketUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClientInput | TicketUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutAuthorInput | TicketCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutAuthorInput | TicketCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutAuthorInput | TicketCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type UserUpdateOneWithoutClientsNestedInput = {
    create?: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsInput
    upsert?: UserUpsertWithoutClientsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientsInput, UserUpdateWithoutClientsInput>, UserUncheckedUpdateWithoutClientsInput>
  }

  export type UserUpdateManyWithoutAccountRepNestedInput = {
    create?: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput> | UserCreateWithoutAccountRepInput[] | UserUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountRepInput | UserCreateOrConnectWithoutAccountRepInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAccountRepInput | UserUpsertWithWhereUniqueWithoutAccountRepInput[]
    createMany?: UserCreateManyAccountRepInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAccountRepInput | UserUpdateWithWhereUniqueWithoutAccountRepInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAccountRepInput | UserUpdateManyWithWhereWithoutAccountRepInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserToEmailClientUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserToEmailClientCreateWithoutUserInput, UserToEmailClientUncheckedCreateWithoutUserInput> | UserToEmailClientCreateWithoutUserInput[] | UserToEmailClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToEmailClientCreateOrConnectWithoutUserInput | UserToEmailClientCreateOrConnectWithoutUserInput[]
    upsert?: UserToEmailClientUpsertWithWhereUniqueWithoutUserInput | UserToEmailClientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserToEmailClientCreateManyUserInputEnvelope
    set?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    disconnect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    delete?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    connect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    update?: UserToEmailClientUpdateWithWhereUniqueWithoutUserInput | UserToEmailClientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserToEmailClientUpdateManyWithWhereWithoutUserInput | UserToEmailClientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserToEmailClientScalarWhereInput | UserToEmailClientScalarWhereInput[]
  }

  export type UserToGaAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserToGaAccountCreateWithoutUserInput, UserToGaAccountUncheckedCreateWithoutUserInput> | UserToGaAccountCreateWithoutUserInput[] | UserToGaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToGaAccountCreateOrConnectWithoutUserInput | UserToGaAccountCreateOrConnectWithoutUserInput[]
    upsert?: UserToGaAccountUpsertWithWhereUniqueWithoutUserInput | UserToGaAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserToGaAccountCreateManyUserInputEnvelope
    set?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    disconnect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    delete?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    connect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    update?: UserToGaAccountUpdateWithWhereUniqueWithoutUserInput | UserToGaAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserToGaAccountUpdateManyWithWhereWithoutUserInput | UserToGaAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserToGaAccountScalarWhereInput | UserToGaAccountScalarWhereInput[]
  }

  export type UserToSproutSocialAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserToSproutSocialAccountCreateWithoutUserInput, UserToSproutSocialAccountUncheckedCreateWithoutUserInput> | UserToSproutSocialAccountCreateWithoutUserInput[] | UserToSproutSocialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToSproutSocialAccountCreateOrConnectWithoutUserInput | UserToSproutSocialAccountCreateOrConnectWithoutUserInput[]
    upsert?: UserToSproutSocialAccountUpsertWithWhereUniqueWithoutUserInput | UserToSproutSocialAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserToSproutSocialAccountCreateManyUserInputEnvelope
    set?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    disconnect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    delete?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    connect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    update?: UserToSproutSocialAccountUpdateWithWhereUniqueWithoutUserInput | UserToSproutSocialAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserToSproutSocialAccountUpdateManyWithWhereWithoutUserInput | UserToSproutSocialAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserToSproutSocialAccountScalarWhereInput | UserToSproutSocialAccountScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ClientActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput> | ClientActivityCreateWithoutUserInput[] | ClientActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientActivityCreateOrConnectWithoutUserInput | ClientActivityCreateOrConnectWithoutUserInput[]
    upsert?: ClientActivityUpsertWithWhereUniqueWithoutUserInput | ClientActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientActivityCreateManyUserInputEnvelope
    set?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    disconnect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    delete?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    connect?: ClientActivityWhereUniqueInput | ClientActivityWhereUniqueInput[]
    update?: ClientActivityUpdateWithWhereUniqueWithoutUserInput | ClientActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientActivityUpdateManyWithWhereWithoutUserInput | ClientActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientActivityScalarWhereInput | ClientActivityScalarWhereInput[]
  }

  export type ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput = {
    create?: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput> | ClientSatisfactionCreateWithoutAccountRepInput[] | ClientSatisfactionUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutAccountRepInput | ClientSatisfactionCreateOrConnectWithoutAccountRepInput[]
    upsert?: ClientSatisfactionUpsertWithWhereUniqueWithoutAccountRepInput | ClientSatisfactionUpsertWithWhereUniqueWithoutAccountRepInput[]
    createMany?: ClientSatisfactionCreateManyAccountRepInputEnvelope
    set?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    disconnect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    delete?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    update?: ClientSatisfactionUpdateWithWhereUniqueWithoutAccountRepInput | ClientSatisfactionUpdateWithWhereUniqueWithoutAccountRepInput[]
    updateMany?: ClientSatisfactionUpdateManyWithWhereWithoutAccountRepInput | ClientSatisfactionUpdateManyWithWhereWithoutAccountRepInput[]
    deleteMany?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
  }

  export type ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput> | ClientSatisfactionCreateWithoutUserInput[] | ClientSatisfactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientSatisfactionCreateOrConnectWithoutUserInput | ClientSatisfactionCreateOrConnectWithoutUserInput[]
    upsert?: ClientSatisfactionUpsertWithWhereUniqueWithoutUserInput | ClientSatisfactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientSatisfactionCreateManyUserInputEnvelope
    set?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    disconnect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    delete?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    connect?: ClientSatisfactionWhereUniqueInput | ClientSatisfactionWhereUniqueInput[]
    update?: ClientSatisfactionUpdateWithWhereUniqueWithoutUserInput | ClientSatisfactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientSatisfactionUpdateManyWithWhereWithoutUserInput | ClientSatisfactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput> | ConversationCreateWithoutClientInput[] | ConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutClientInput | ConversationCreateOrConnectWithoutClientInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutClientInput | ConversationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ConversationCreateManyClientInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutClientInput | ConversationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutClientInput | ConversationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput> | GaImportRunCreateWithoutRequestedByInput[] | GaImportRunUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: GaImportRunCreateOrConnectWithoutRequestedByInput | GaImportRunCreateOrConnectWithoutRequestedByInput[]
    upsert?: GaImportRunUpsertWithWhereUniqueWithoutRequestedByInput | GaImportRunUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: GaImportRunCreateManyRequestedByInputEnvelope
    set?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    disconnect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    delete?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    connect?: GaImportRunWhereUniqueInput | GaImportRunWhereUniqueInput[]
    update?: GaImportRunUpdateWithWhereUniqueWithoutRequestedByInput | GaImportRunUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: GaImportRunUpdateManyWithWhereWithoutRequestedByInput | GaImportRunUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type QueryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput> | QueryCreateWithoutUserInput[] | QueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutUserInput | QueryCreateOrConnectWithoutUserInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutUserInput | QueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QueryCreateManyUserInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutUserInput | QueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutUserInput | QueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedToInput | TicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedToInput | TicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedToInput | TicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClientInput | TicketUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClientInput | TicketUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClientInput | TicketUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutAuthorInput | TicketCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutAuthorInput | TicketCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutAuthorInput | TicketCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAccountRepNestedInput = {
    create?: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput> | UserCreateWithoutAccountRepInput[] | UserUncheckedCreateWithoutAccountRepInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountRepInput | UserCreateOrConnectWithoutAccountRepInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAccountRepInput | UserUpsertWithWhereUniqueWithoutAccountRepInput[]
    createMany?: UserCreateManyAccountRepInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAccountRepInput | UserUpdateWithWhereUniqueWithoutAccountRepInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAccountRepInput | UserUpdateManyWithWhereWithoutAccountRepInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserToEmailClientCreateWithoutUserInput, UserToEmailClientUncheckedCreateWithoutUserInput> | UserToEmailClientCreateWithoutUserInput[] | UserToEmailClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToEmailClientCreateOrConnectWithoutUserInput | UserToEmailClientCreateOrConnectWithoutUserInput[]
    upsert?: UserToEmailClientUpsertWithWhereUniqueWithoutUserInput | UserToEmailClientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserToEmailClientCreateManyUserInputEnvelope
    set?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    disconnect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    delete?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    connect?: UserToEmailClientWhereUniqueInput | UserToEmailClientWhereUniqueInput[]
    update?: UserToEmailClientUpdateWithWhereUniqueWithoutUserInput | UserToEmailClientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserToEmailClientUpdateManyWithWhereWithoutUserInput | UserToEmailClientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserToEmailClientScalarWhereInput | UserToEmailClientScalarWhereInput[]
  }

  export type UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserToGaAccountCreateWithoutUserInput, UserToGaAccountUncheckedCreateWithoutUserInput> | UserToGaAccountCreateWithoutUserInput[] | UserToGaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToGaAccountCreateOrConnectWithoutUserInput | UserToGaAccountCreateOrConnectWithoutUserInput[]
    upsert?: UserToGaAccountUpsertWithWhereUniqueWithoutUserInput | UserToGaAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserToGaAccountCreateManyUserInputEnvelope
    set?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    disconnect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    delete?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    connect?: UserToGaAccountWhereUniqueInput | UserToGaAccountWhereUniqueInput[]
    update?: UserToGaAccountUpdateWithWhereUniqueWithoutUserInput | UserToGaAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserToGaAccountUpdateManyWithWhereWithoutUserInput | UserToGaAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserToGaAccountScalarWhereInput | UserToGaAccountScalarWhereInput[]
  }

  export type UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserToSproutSocialAccountCreateWithoutUserInput, UserToSproutSocialAccountUncheckedCreateWithoutUserInput> | UserToSproutSocialAccountCreateWithoutUserInput[] | UserToSproutSocialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToSproutSocialAccountCreateOrConnectWithoutUserInput | UserToSproutSocialAccountCreateOrConnectWithoutUserInput[]
    upsert?: UserToSproutSocialAccountUpsertWithWhereUniqueWithoutUserInput | UserToSproutSocialAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserToSproutSocialAccountCreateManyUserInputEnvelope
    set?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    disconnect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    delete?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    connect?: UserToSproutSocialAccountWhereUniqueInput | UserToSproutSocialAccountWhereUniqueInput[]
    update?: UserToSproutSocialAccountUpdateWithWhereUniqueWithoutUserInput | UserToSproutSocialAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserToSproutSocialAccountUpdateManyWithWhereWithoutUserInput | UserToSproutSocialAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserToSproutSocialAccountScalarWhereInput | UserToSproutSocialAccountScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutAssignedTicketsInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClientTicketsInput = {
    create?: XOR<UserCreateWithoutClientTicketsInput, UserUncheckedCreateWithoutClientTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketAttachmentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketTagCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput> | TicketTagCreateWithoutTicketsInput[] | TicketTagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketsInput | TicketTagCreateOrConnectWithoutTicketsInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
  }

  export type TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketTagUncheckedCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput> | TicketTagCreateWithoutTicketsInput[] | TicketTagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketsInput | TicketTagCreateOrConnectWithoutTicketsInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type UserUpdateOneWithoutAssignedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    upsert?: UserUpsertWithoutAssignedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTicketsInput, UserUpdateWithoutAssignedTicketsInput>, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateOneRequiredWithoutClientTicketsNestedInput = {
    create?: XOR<UserCreateWithoutClientTicketsInput, UserUncheckedCreateWithoutClientTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientTicketsInput
    upsert?: UserUpsertWithoutClientTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientTicketsInput, UserUpdateWithoutClientTicketsInput>, UserUncheckedUpdateWithoutClientTicketsInput>
  }

  export type TicketAttachmentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketTagUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput> | TicketTagCreateWithoutTicketsInput[] | TicketTagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketsInput | TicketTagCreateOrConnectWithoutTicketsInput[]
    upsert?: TicketTagUpsertWithWhereUniqueWithoutTicketsInput | TicketTagUpsertWithWhereUniqueWithoutTicketsInput[]
    set?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    disconnect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    delete?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    update?: TicketTagUpdateWithWhereUniqueWithoutTicketsInput | TicketTagUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TicketTagUpdateManyWithWhereWithoutTicketsInput | TicketTagUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketTagUncheckedUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput> | TicketTagCreateWithoutTicketsInput[] | TicketTagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketsInput | TicketTagCreateOrConnectWithoutTicketsInput[]
    upsert?: TicketTagUpsertWithWhereUniqueWithoutTicketsInput | TicketTagUpsertWithWhereUniqueWithoutTicketsInput[]
    set?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    disconnect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    delete?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    update?: TicketTagUpdateWithWhereUniqueWithoutTicketsInput | TicketTagUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TicketTagUpdateManyWithWhereWithoutTicketsInput | TicketTagUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
  }

  export type TicketCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAttachmentsInput
    connect?: TicketWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAttachmentsInput
    upsert?: TicketUpsertWithoutAttachmentsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutAttachmentsInput, TicketUpdateWithoutAttachmentsInput>, TicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserCreateNestedOneWithoutTicketCommentsInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCommentsInput
    connect?: TicketWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTicketCommentsNestedInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    upsert?: UserUpsertWithoutTicketCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketCommentsInput, UserUpdateWithoutTicketCommentsInput>, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type TicketUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCommentsInput
    upsert?: TicketUpsertWithoutCommentsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutCommentsInput, TicketUpdateWithoutCommentsInput>, TicketUncheckedUpdateWithoutCommentsInput>
  }

  export type TicketCreateNestedManyWithoutTagsInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUpdateManyWithoutTagsNestedInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTagsInput | TicketUpsertWithWhereUniqueWithoutTagsInput[]
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTagsInput | TicketUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTagsInput | TicketUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTagsInput | TicketUpsertWithWhereUniqueWithoutTagsInput[]
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTagsInput | TicketUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTagsInput | TicketUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    upsert?: MessageUpsertWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAttachmentsInput, MessageUpdateWithoutAttachmentsInput>, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActivityStatusFieldUpdateOperationsInput = {
    set?: $Enums.ActivityStatus
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type EmailClientCreateNestedOneWithoutUsersInput = {
    create?: XOR<EmailClientCreateWithoutUsersInput, EmailClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: EmailClientCreateOrConnectWithoutUsersInput
    connect?: EmailClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmailClientsInput = {
    create?: XOR<UserCreateWithoutEmailClientsInput, UserUncheckedCreateWithoutEmailClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailClientsInput
    connect?: UserWhereUniqueInput
  }

  export type EmailClientUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<EmailClientCreateWithoutUsersInput, EmailClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: EmailClientCreateOrConnectWithoutUsersInput
    upsert?: EmailClientUpsertWithoutUsersInput
    connect?: EmailClientWhereUniqueInput
    update?: XOR<XOR<EmailClientUpdateToOneWithWhereWithoutUsersInput, EmailClientUpdateWithoutUsersInput>, EmailClientUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutEmailClientsNestedInput = {
    create?: XOR<UserCreateWithoutEmailClientsInput, UserUncheckedCreateWithoutEmailClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailClientsInput
    upsert?: UserUpsertWithoutEmailClientsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailClientsInput, UserUpdateWithoutEmailClientsInput>, UserUncheckedUpdateWithoutEmailClientsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }

  export type NestedEnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumQueryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusFilter<$PrismaModel> | $Enums.QueryStatus
  }

  export type NestedEnumQueryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueryStatusFilter<$PrismaModel>
    _max?: NestedEnumQueryStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedEnumActivityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusFilter<$PrismaModel> | $Enums.ActivityStatus
  }

  export type NestedEnumActivityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActivityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityStatusFilter<$PrismaModel>
    _max?: NestedEnumActivityStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReceivedRatingsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedRatingsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
  }

  export type UserCreateWithoutGivenRatingsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGivenRatingsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGivenRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
  }

  export type UserUpsertWithoutReceivedRatingsInput = {
    update: XOR<UserUpdateWithoutReceivedRatingsInput, UserUncheckedUpdateWithoutReceivedRatingsInput>
    create: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedRatingsInput, UserUncheckedUpdateWithoutReceivedRatingsInput>
  }

  export type UserUpdateWithoutReceivedRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutGivenRatingsInput = {
    update: XOR<UserUpdateWithoutGivenRatingsInput, UserUncheckedUpdateWithoutGivenRatingsInput>
    create: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGivenRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGivenRatingsInput, UserUncheckedUpdateWithoutGivenRatingsInput>
  }

  export type UserUpdateWithoutGivenRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGivenRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roleId?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    accountRepId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    password?: StringNullableFilter<"User"> | string | null
    deleted?: BoolFilter<"User"> | boolean
    companyId?: StringNullableFilter<"User"> | string | null
  }

  export type UserCreateWithoutClientConversationsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientConversationsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientConversationsInput, UserUncheckedCreateWithoutClientConversationsInput>
  }

  export type GaAccountCreateWithoutConversationsInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gaProperties?: GaPropertyCreateNestedManyWithoutGaAccountInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountUncheckedCreateWithoutConversationsInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    gaProperties?: GaPropertyUncheckedCreateNestedManyWithoutGaAccountInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountCreateOrConnectWithoutConversationsInput = {
    where: GaAccountWhereUniqueInput
    create: XOR<GaAccountCreateWithoutConversationsInput, GaAccountUncheckedCreateWithoutConversationsInput>
  }

  export type GaPropertyCreateWithoutConversationsInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutConversationsInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutConversationsInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutConversationsInput, GaPropertyUncheckedCreateWithoutConversationsInput>
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type QueryCreateWithoutConversationInput = {
    id?: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataCreateNestedManyWithoutQueryInput
    parsedData?: ParsedQueryDataCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryCreateNestedManyWithoutQueryInput
    user: UserCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateWithoutConversationInput = {
    id?: string
    userId: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput
    parsedData?: ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutConversationInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput>
  }

  export type QueryCreateManyConversationInputEnvelope = {
    data: QueryCreateManyConversationInput | QueryCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientConversationsInput = {
    update: XOR<UserUpdateWithoutClientConversationsInput, UserUncheckedUpdateWithoutClientConversationsInput>
    create: XOR<UserCreateWithoutClientConversationsInput, UserUncheckedCreateWithoutClientConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientConversationsInput, UserUncheckedUpdateWithoutClientConversationsInput>
  }

  export type UserUpdateWithoutClientConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GaAccountUpsertWithoutConversationsInput = {
    update: XOR<GaAccountUpdateWithoutConversationsInput, GaAccountUncheckedUpdateWithoutConversationsInput>
    create: XOR<GaAccountCreateWithoutConversationsInput, GaAccountUncheckedCreateWithoutConversationsInput>
    where?: GaAccountWhereInput
  }

  export type GaAccountUpdateToOneWithWhereWithoutConversationsInput = {
    where?: GaAccountWhereInput
    data: XOR<GaAccountUpdateWithoutConversationsInput, GaAccountUncheckedUpdateWithoutConversationsInput>
  }

  export type GaAccountUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperties?: GaPropertyUpdateManyWithoutGaAccountNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutGaAccountNestedInput
  }

  export type GaAccountUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperties?: GaPropertyUncheckedUpdateManyWithoutGaAccountNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutGaAccountNestedInput
  }

  export type GaPropertyUpsertWithoutConversationsInput = {
    update: XOR<GaPropertyUpdateWithoutConversationsInput, GaPropertyUncheckedUpdateWithoutConversationsInput>
    create: XOR<GaPropertyCreateWithoutConversationsInput, GaPropertyUncheckedCreateWithoutConversationsInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutConversationsInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutConversationsInput, GaPropertyUncheckedUpdateWithoutConversationsInput>
  }

  export type GaPropertyUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QueryUpsertWithWhereUniqueWithoutConversationInput = {
    where: QueryWhereUniqueInput
    update: XOR<QueryUpdateWithoutConversationInput, QueryUncheckedUpdateWithoutConversationInput>
    create: XOR<QueryCreateWithoutConversationInput, QueryUncheckedCreateWithoutConversationInput>
  }

  export type QueryUpdateWithWhereUniqueWithoutConversationInput = {
    where: QueryWhereUniqueInput
    data: XOR<QueryUpdateWithoutConversationInput, QueryUncheckedUpdateWithoutConversationInput>
  }

  export type QueryUpdateManyWithWhereWithoutConversationInput = {
    where: QueryScalarWhereInput
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyWithoutConversationInput>
  }

  export type QueryScalarWhereInput = {
    AND?: QueryScalarWhereInput | QueryScalarWhereInput[]
    OR?: QueryScalarWhereInput[]
    NOT?: QueryScalarWhereInput | QueryScalarWhereInput[]
    id?: StringFilter<"Query"> | string
    userId?: StringFilter<"Query"> | string
    response?: StringNullableFilter<"Query"> | string | null
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
    content?: StringFilter<"Query"> | string
    status?: EnumQueryStatusFilter<"Query"> | $Enums.QueryStatus
    conversationId?: StringNullableFilter<"Query"> | string | null
    rating?: IntFilter<"Query"> | number
    metadata?: JsonNullableFilter<"Query">
    lineGraphData?: JsonNullableFilter<"Query">
    pieGraphData?: JsonNullableFilter<"Query">
  }

  export type EmailClientCreateWithoutEmailCampaignsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaignDailyStats?: EmailCampaignDailyStatsCreateNestedManyWithoutEmailClientInput
    emailClientCredentials?: EmailClientCredentialsCreateNestedManyWithoutEmailClientInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsCreateNestedManyWithoutEmailClientInput
    users?: UserToEmailClientCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientUncheckedCreateWithoutEmailCampaignsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput
    emailClientCredentials?: EmailClientCredentialsUncheckedCreateNestedManyWithoutEmailClientInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput
    users?: UserToEmailClientUncheckedCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientCreateOrConnectWithoutEmailCampaignsInput = {
    where: EmailClientWhereUniqueInput
    create: XOR<EmailClientCreateWithoutEmailCampaignsInput, EmailClientUncheckedCreateWithoutEmailCampaignsInput>
  }

  export type EmailCampaignContentCreateWithoutEmailCampaignInput = {
    id?: string
    subject: string
    type: string
    recipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contentType: string
    createTime: Date | string
    htmlContent: string
    plainContent: string
    sendTime: Date | string
    webId: string
  }

  export type EmailCampaignContentUncheckedCreateWithoutEmailCampaignInput = {
    id?: string
    subject: string
    type: string
    recipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contentType: string
    createTime: Date | string
    htmlContent: string
    plainContent: string
    sendTime: Date | string
    webId: string
  }

  export type EmailCampaignContentCreateOrConnectWithoutEmailCampaignInput = {
    where: EmailCampaignContentWhereUniqueInput
    create: XOR<EmailCampaignContentCreateWithoutEmailCampaignInput, EmailCampaignContentUncheckedCreateWithoutEmailCampaignInput>
  }

  export type EmailCampaignDailyStatsCreateWithoutEmailCampaignInput = {
    id?: string
    date: Date | string
    opens?: number
    clicks?: number
    bounces?: number
    unsubscribes?: number
    variation: string
    phase: string
    requests?: number
    delivered?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bounceDrops?: number
    cumulativeBounceRate?: number
    cumulativeSpamReportsRate?: number
    cumulativeTotalClickRate?: number
    cumulativeTotalOpenRate?: number
    cumulativeUniqueClickRate?: number
    cumulativeUniqueOpenRate?: number
    cumulativeUnsubscribeRate?: number
    dailyBounceRate?: number
    dailySpamReportsRate?: number
    dailyTotalClickRate?: number
    dailyTotalClickToOpenRate?: number
    dailyTotalOpenRate?: number
    dailyUniqueClickRate?: number
    dailyUniqueClickToOpenRate?: number
    dailyUniqueOpenRate?: number
    dailyUnsubscribeRate?: number
    singleSendName: string
    spamReportDrops?: number
    spamReports?: number
    totalClicks?: number
    totalOpens?: number
    uniqueClicks?: number
    uniqueOpens?: number
    emailClient: EmailClientCreateNestedOneWithoutEmailCampaignDailyStatsInput
  }

  export type EmailCampaignDailyStatsUncheckedCreateWithoutEmailCampaignInput = {
    id?: string
    date: Date | string
    opens?: number
    clicks?: number
    bounces?: number
    unsubscribes?: number
    variation: string
    phase: string
    requests?: number
    delivered?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bounceDrops?: number
    cumulativeBounceRate?: number
    cumulativeSpamReportsRate?: number
    cumulativeTotalClickRate?: number
    cumulativeTotalOpenRate?: number
    cumulativeUniqueClickRate?: number
    cumulativeUniqueOpenRate?: number
    cumulativeUnsubscribeRate?: number
    dailyBounceRate?: number
    dailySpamReportsRate?: number
    dailyTotalClickRate?: number
    dailyTotalClickToOpenRate?: number
    dailyTotalOpenRate?: number
    dailyUniqueClickRate?: number
    dailyUniqueClickToOpenRate?: number
    dailyUniqueOpenRate?: number
    dailyUnsubscribeRate?: number
    emailClientId: string
    singleSendName: string
    spamReportDrops?: number
    spamReports?: number
    totalClicks?: number
    totalOpens?: number
    uniqueClicks?: number
    uniqueOpens?: number
  }

  export type EmailCampaignDailyStatsCreateOrConnectWithoutEmailCampaignInput = {
    where: EmailCampaignDailyStatsWhereUniqueInput
    create: XOR<EmailCampaignDailyStatsCreateWithoutEmailCampaignInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailCampaignInput>
  }

  export type EmailCampaignDailyStatsCreateManyEmailCampaignInputEnvelope = {
    data: EmailCampaignDailyStatsCreateManyEmailCampaignInput | EmailCampaignDailyStatsCreateManyEmailCampaignInput[]
    skipDuplicates?: boolean
  }

  export type EmailClientUpsertWithoutEmailCampaignsInput = {
    update: XOR<EmailClientUpdateWithoutEmailCampaignsInput, EmailClientUncheckedUpdateWithoutEmailCampaignsInput>
    create: XOR<EmailClientCreateWithoutEmailCampaignsInput, EmailClientUncheckedCreateWithoutEmailCampaignsInput>
    where?: EmailClientWhereInput
  }

  export type EmailClientUpdateToOneWithWhereWithoutEmailCampaignsInput = {
    where?: EmailClientWhereInput
    data: XOR<EmailClientUpdateWithoutEmailCampaignsInput, EmailClientUncheckedUpdateWithoutEmailCampaignsInput>
  }

  export type EmailClientUpdateWithoutEmailCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaignDailyStats?: EmailCampaignDailyStatsUpdateManyWithoutEmailClientNestedInput
    emailClientCredentials?: EmailClientCredentialsUpdateManyWithoutEmailClientNestedInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUpdateManyWithoutEmailClientNestedInput
    users?: UserToEmailClientUpdateManyWithoutEmailClientNestedInput
  }

  export type EmailClientUncheckedUpdateWithoutEmailCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput
    emailClientCredentials?: EmailClientCredentialsUncheckedUpdateManyWithoutEmailClientNestedInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput
    users?: UserToEmailClientUncheckedUpdateManyWithoutEmailClientNestedInput
  }

  export type EmailCampaignContentUpsertWithoutEmailCampaignInput = {
    update: XOR<EmailCampaignContentUpdateWithoutEmailCampaignInput, EmailCampaignContentUncheckedUpdateWithoutEmailCampaignInput>
    create: XOR<EmailCampaignContentCreateWithoutEmailCampaignInput, EmailCampaignContentUncheckedCreateWithoutEmailCampaignInput>
    where?: EmailCampaignContentWhereInput
  }

  export type EmailCampaignContentUpdateToOneWithWhereWithoutEmailCampaignInput = {
    where?: EmailCampaignContentWhereInput
    data: XOR<EmailCampaignContentUpdateWithoutEmailCampaignInput, EmailCampaignContentUncheckedUpdateWithoutEmailCampaignInput>
  }

  export type EmailCampaignContentUpdateWithoutEmailCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentType?: StringFieldUpdateOperationsInput | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    plainContent?: StringFieldUpdateOperationsInput | string
    sendTime?: DateTimeFieldUpdateOperationsInput | Date | string
    webId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCampaignContentUncheckedUpdateWithoutEmailCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentType?: StringFieldUpdateOperationsInput | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    plainContent?: StringFieldUpdateOperationsInput | string
    sendTime?: DateTimeFieldUpdateOperationsInput | Date | string
    webId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCampaignDailyStatsUpsertWithWhereUniqueWithoutEmailCampaignInput = {
    where: EmailCampaignDailyStatsWhereUniqueInput
    update: XOR<EmailCampaignDailyStatsUpdateWithoutEmailCampaignInput, EmailCampaignDailyStatsUncheckedUpdateWithoutEmailCampaignInput>
    create: XOR<EmailCampaignDailyStatsCreateWithoutEmailCampaignInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailCampaignInput>
  }

  export type EmailCampaignDailyStatsUpdateWithWhereUniqueWithoutEmailCampaignInput = {
    where: EmailCampaignDailyStatsWhereUniqueInput
    data: XOR<EmailCampaignDailyStatsUpdateWithoutEmailCampaignInput, EmailCampaignDailyStatsUncheckedUpdateWithoutEmailCampaignInput>
  }

  export type EmailCampaignDailyStatsUpdateManyWithWhereWithoutEmailCampaignInput = {
    where: EmailCampaignDailyStatsScalarWhereInput
    data: XOR<EmailCampaignDailyStatsUpdateManyMutationInput, EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailCampaignInput>
  }

  export type EmailCampaignDailyStatsScalarWhereInput = {
    AND?: EmailCampaignDailyStatsScalarWhereInput | EmailCampaignDailyStatsScalarWhereInput[]
    OR?: EmailCampaignDailyStatsScalarWhereInput[]
    NOT?: EmailCampaignDailyStatsScalarWhereInput | EmailCampaignDailyStatsScalarWhereInput[]
    id?: StringFilter<"EmailCampaignDailyStats"> | string
    date?: DateTimeFilter<"EmailCampaignDailyStats"> | Date | string
    opens?: IntFilter<"EmailCampaignDailyStats"> | number
    clicks?: IntFilter<"EmailCampaignDailyStats"> | number
    bounces?: IntFilter<"EmailCampaignDailyStats"> | number
    unsubscribes?: IntFilter<"EmailCampaignDailyStats"> | number
    variation?: StringFilter<"EmailCampaignDailyStats"> | string
    phase?: StringFilter<"EmailCampaignDailyStats"> | string
    requests?: IntFilter<"EmailCampaignDailyStats"> | number
    delivered?: IntFilter<"EmailCampaignDailyStats"> | number
    createdAt?: DateTimeFilter<"EmailCampaignDailyStats"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCampaignDailyStats"> | Date | string
    bounceDrops?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeBounceRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeSpamReportsRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeTotalClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeTotalOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeUniqueClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeUniqueOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    cumulativeUnsubscribeRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyBounceRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailySpamReportsRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyTotalClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyTotalClickToOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyTotalOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueClickRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueClickToOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUniqueOpenRate?: IntFilter<"EmailCampaignDailyStats"> | number
    dailyUnsubscribeRate?: IntFilter<"EmailCampaignDailyStats"> | number
    emailCampaignId?: StringFilter<"EmailCampaignDailyStats"> | string
    emailClientId?: StringFilter<"EmailCampaignDailyStats"> | string
    singleSendName?: StringFilter<"EmailCampaignDailyStats"> | string
    spamReportDrops?: IntFilter<"EmailCampaignDailyStats"> | number
    spamReports?: IntFilter<"EmailCampaignDailyStats"> | number
    totalClicks?: IntFilter<"EmailCampaignDailyStats"> | number
    totalOpens?: IntFilter<"EmailCampaignDailyStats"> | number
    uniqueClicks?: IntFilter<"EmailCampaignDailyStats"> | number
    uniqueOpens?: IntFilter<"EmailCampaignDailyStats"> | number
  }

  export type EmailCampaignCreateWithoutEmailCampaignContentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    campaignName: string
    emailClient: EmailClientCreateNestedOneWithoutEmailCampaignsInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsCreateNestedManyWithoutEmailCampaignInput
  }

  export type EmailCampaignUncheckedCreateWithoutEmailCampaignContentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    campaignName: string
    emailClientId: string
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedCreateNestedManyWithoutEmailCampaignInput
  }

  export type EmailCampaignCreateOrConnectWithoutEmailCampaignContentsInput = {
    where: EmailCampaignWhereUniqueInput
    create: XOR<EmailCampaignCreateWithoutEmailCampaignContentsInput, EmailCampaignUncheckedCreateWithoutEmailCampaignContentsInput>
  }

  export type EmailCampaignUpsertWithoutEmailCampaignContentsInput = {
    update: XOR<EmailCampaignUpdateWithoutEmailCampaignContentsInput, EmailCampaignUncheckedUpdateWithoutEmailCampaignContentsInput>
    create: XOR<EmailCampaignCreateWithoutEmailCampaignContentsInput, EmailCampaignUncheckedCreateWithoutEmailCampaignContentsInput>
    where?: EmailCampaignWhereInput
  }

  export type EmailCampaignUpdateToOneWithWhereWithoutEmailCampaignContentsInput = {
    where?: EmailCampaignWhereInput
    data: XOR<EmailCampaignUpdateWithoutEmailCampaignContentsInput, EmailCampaignUncheckedUpdateWithoutEmailCampaignContentsInput>
  }

  export type EmailCampaignUpdateWithoutEmailCampaignContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    emailClient?: EmailClientUpdateOneRequiredWithoutEmailCampaignsNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUpdateManyWithoutEmailCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateWithoutEmailCampaignContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailCampaignNestedInput
  }

  export type EmailCampaignCreateWithoutEmailCampaignDailyStatsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    campaignName: string
    emailClient: EmailClientCreateNestedOneWithoutEmailCampaignsInput
    emailCampaignContents?: EmailCampaignContentCreateNestedOneWithoutEmailCampaignInput
  }

  export type EmailCampaignUncheckedCreateWithoutEmailCampaignDailyStatsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    campaignName: string
    emailClientId: string
    emailCampaignContents?: EmailCampaignContentUncheckedCreateNestedOneWithoutEmailCampaignInput
  }

  export type EmailCampaignCreateOrConnectWithoutEmailCampaignDailyStatsInput = {
    where: EmailCampaignWhereUniqueInput
    create: XOR<EmailCampaignCreateWithoutEmailCampaignDailyStatsInput, EmailCampaignUncheckedCreateWithoutEmailCampaignDailyStatsInput>
  }

  export type EmailClientCreateWithoutEmailCampaignDailyStatsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutEmailClientInput
    emailClientCredentials?: EmailClientCredentialsCreateNestedManyWithoutEmailClientInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsCreateNestedManyWithoutEmailClientInput
    users?: UserToEmailClientCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientUncheckedCreateWithoutEmailCampaignDailyStatsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutEmailClientInput
    emailClientCredentials?: EmailClientCredentialsUncheckedCreateNestedManyWithoutEmailClientInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput
    users?: UserToEmailClientUncheckedCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientCreateOrConnectWithoutEmailCampaignDailyStatsInput = {
    where: EmailClientWhereUniqueInput
    create: XOR<EmailClientCreateWithoutEmailCampaignDailyStatsInput, EmailClientUncheckedCreateWithoutEmailCampaignDailyStatsInput>
  }

  export type EmailCampaignUpsertWithoutEmailCampaignDailyStatsInput = {
    update: XOR<EmailCampaignUpdateWithoutEmailCampaignDailyStatsInput, EmailCampaignUncheckedUpdateWithoutEmailCampaignDailyStatsInput>
    create: XOR<EmailCampaignCreateWithoutEmailCampaignDailyStatsInput, EmailCampaignUncheckedCreateWithoutEmailCampaignDailyStatsInput>
    where?: EmailCampaignWhereInput
  }

  export type EmailCampaignUpdateToOneWithWhereWithoutEmailCampaignDailyStatsInput = {
    where?: EmailCampaignWhereInput
    data: XOR<EmailCampaignUpdateWithoutEmailCampaignDailyStatsInput, EmailCampaignUncheckedUpdateWithoutEmailCampaignDailyStatsInput>
  }

  export type EmailCampaignUpdateWithoutEmailCampaignDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    emailClient?: EmailClientUpdateOneRequiredWithoutEmailCampaignsNestedInput
    emailCampaignContents?: EmailCampaignContentUpdateOneWithoutEmailCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateWithoutEmailCampaignDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
    emailCampaignContents?: EmailCampaignContentUncheckedUpdateOneWithoutEmailCampaignNestedInput
  }

  export type EmailClientUpsertWithoutEmailCampaignDailyStatsInput = {
    update: XOR<EmailClientUpdateWithoutEmailCampaignDailyStatsInput, EmailClientUncheckedUpdateWithoutEmailCampaignDailyStatsInput>
    create: XOR<EmailClientCreateWithoutEmailCampaignDailyStatsInput, EmailClientUncheckedCreateWithoutEmailCampaignDailyStatsInput>
    where?: EmailClientWhereInput
  }

  export type EmailClientUpdateToOneWithWhereWithoutEmailCampaignDailyStatsInput = {
    where?: EmailClientWhereInput
    data: XOR<EmailClientUpdateWithoutEmailCampaignDailyStatsInput, EmailClientUncheckedUpdateWithoutEmailCampaignDailyStatsInput>
  }

  export type EmailClientUpdateWithoutEmailCampaignDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUpdateManyWithoutEmailClientNestedInput
    emailClientCredentials?: EmailClientCredentialsUpdateManyWithoutEmailClientNestedInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUpdateManyWithoutEmailClientNestedInput
    users?: UserToEmailClientUpdateManyWithoutEmailClientNestedInput
  }

  export type EmailClientUncheckedUpdateWithoutEmailCampaignDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutEmailClientNestedInput
    emailClientCredentials?: EmailClientCredentialsUncheckedUpdateManyWithoutEmailClientNestedInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput
    users?: UserToEmailClientUncheckedUpdateManyWithoutEmailClientNestedInput
  }

  export type EmailCampaignCreateWithoutEmailClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    campaignName: string
    emailCampaignContents?: EmailCampaignContentCreateNestedOneWithoutEmailCampaignInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsCreateNestedManyWithoutEmailCampaignInput
  }

  export type EmailCampaignUncheckedCreateWithoutEmailClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    campaignName: string
    emailCampaignContents?: EmailCampaignContentUncheckedCreateNestedOneWithoutEmailCampaignInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedCreateNestedManyWithoutEmailCampaignInput
  }

  export type EmailCampaignCreateOrConnectWithoutEmailClientInput = {
    where: EmailCampaignWhereUniqueInput
    create: XOR<EmailCampaignCreateWithoutEmailClientInput, EmailCampaignUncheckedCreateWithoutEmailClientInput>
  }

  export type EmailCampaignCreateManyEmailClientInputEnvelope = {
    data: EmailCampaignCreateManyEmailClientInput | EmailCampaignCreateManyEmailClientInput[]
    skipDuplicates?: boolean
  }

  export type EmailCampaignDailyStatsCreateWithoutEmailClientInput = {
    id?: string
    date: Date | string
    opens?: number
    clicks?: number
    bounces?: number
    unsubscribes?: number
    variation: string
    phase: string
    requests?: number
    delivered?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bounceDrops?: number
    cumulativeBounceRate?: number
    cumulativeSpamReportsRate?: number
    cumulativeTotalClickRate?: number
    cumulativeTotalOpenRate?: number
    cumulativeUniqueClickRate?: number
    cumulativeUniqueOpenRate?: number
    cumulativeUnsubscribeRate?: number
    dailyBounceRate?: number
    dailySpamReportsRate?: number
    dailyTotalClickRate?: number
    dailyTotalClickToOpenRate?: number
    dailyTotalOpenRate?: number
    dailyUniqueClickRate?: number
    dailyUniqueClickToOpenRate?: number
    dailyUniqueOpenRate?: number
    dailyUnsubscribeRate?: number
    singleSendName: string
    spamReportDrops?: number
    spamReports?: number
    totalClicks?: number
    totalOpens?: number
    uniqueClicks?: number
    uniqueOpens?: number
    emailCampaign: EmailCampaignCreateNestedOneWithoutEmailCampaignDailyStatsInput
  }

  export type EmailCampaignDailyStatsUncheckedCreateWithoutEmailClientInput = {
    id?: string
    date: Date | string
    opens?: number
    clicks?: number
    bounces?: number
    unsubscribes?: number
    variation: string
    phase: string
    requests?: number
    delivered?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bounceDrops?: number
    cumulativeBounceRate?: number
    cumulativeSpamReportsRate?: number
    cumulativeTotalClickRate?: number
    cumulativeTotalOpenRate?: number
    cumulativeUniqueClickRate?: number
    cumulativeUniqueOpenRate?: number
    cumulativeUnsubscribeRate?: number
    dailyBounceRate?: number
    dailySpamReportsRate?: number
    dailyTotalClickRate?: number
    dailyTotalClickToOpenRate?: number
    dailyTotalOpenRate?: number
    dailyUniqueClickRate?: number
    dailyUniqueClickToOpenRate?: number
    dailyUniqueOpenRate?: number
    dailyUnsubscribeRate?: number
    emailCampaignId: string
    singleSendName: string
    spamReportDrops?: number
    spamReports?: number
    totalClicks?: number
    totalOpens?: number
    uniqueClicks?: number
    uniqueOpens?: number
  }

  export type EmailCampaignDailyStatsCreateOrConnectWithoutEmailClientInput = {
    where: EmailCampaignDailyStatsWhereUniqueInput
    create: XOR<EmailCampaignDailyStatsCreateWithoutEmailClientInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailClientInput>
  }

  export type EmailCampaignDailyStatsCreateManyEmailClientInputEnvelope = {
    data: EmailCampaignDailyStatsCreateManyEmailClientInput | EmailCampaignDailyStatsCreateManyEmailClientInput[]
    skipDuplicates?: boolean
  }

  export type EmailClientCredentialsCreateWithoutEmailClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKey: string
    platformName: string
  }

  export type EmailClientCredentialsUncheckedCreateWithoutEmailClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKey: string
    platformName: string
  }

  export type EmailClientCredentialsCreateOrConnectWithoutEmailClientInput = {
    where: EmailClientCredentialsWhereUniqueInput
    create: XOR<EmailClientCredentialsCreateWithoutEmailClientInput, EmailClientCredentialsUncheckedCreateWithoutEmailClientInput>
  }

  export type EmailClientCredentialsCreateManyEmailClientInputEnvelope = {
    data: EmailClientCredentialsCreateManyEmailClientInput | EmailClientCredentialsCreateManyEmailClientInput[]
    skipDuplicates?: boolean
  }

  export type EmailGlobalDailyStatsCreateWithoutEmailClientInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bounces?: number
    clicks?: number
    opens?: number
    unsubs?: number
  }

  export type EmailGlobalDailyStatsUncheckedCreateWithoutEmailClientInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bounces?: number
    clicks?: number
    opens?: number
    unsubs?: number
  }

  export type EmailGlobalDailyStatsCreateOrConnectWithoutEmailClientInput = {
    where: EmailGlobalDailyStatsWhereUniqueInput
    create: XOR<EmailGlobalDailyStatsCreateWithoutEmailClientInput, EmailGlobalDailyStatsUncheckedCreateWithoutEmailClientInput>
  }

  export type EmailGlobalDailyStatsCreateManyEmailClientInputEnvelope = {
    data: EmailGlobalDailyStatsCreateManyEmailClientInput | EmailGlobalDailyStatsCreateManyEmailClientInput[]
    skipDuplicates?: boolean
  }

  export type UserToEmailClientCreateWithoutEmailClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmailClientsInput
  }

  export type UserToEmailClientUncheckedCreateWithoutEmailClientInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToEmailClientCreateOrConnectWithoutEmailClientInput = {
    where: UserToEmailClientWhereUniqueInput
    create: XOR<UserToEmailClientCreateWithoutEmailClientInput, UserToEmailClientUncheckedCreateWithoutEmailClientInput>
  }

  export type UserToEmailClientCreateManyEmailClientInputEnvelope = {
    data: UserToEmailClientCreateManyEmailClientInput | UserToEmailClientCreateManyEmailClientInput[]
    skipDuplicates?: boolean
  }

  export type EmailCampaignUpsertWithWhereUniqueWithoutEmailClientInput = {
    where: EmailCampaignWhereUniqueInput
    update: XOR<EmailCampaignUpdateWithoutEmailClientInput, EmailCampaignUncheckedUpdateWithoutEmailClientInput>
    create: XOR<EmailCampaignCreateWithoutEmailClientInput, EmailCampaignUncheckedCreateWithoutEmailClientInput>
  }

  export type EmailCampaignUpdateWithWhereUniqueWithoutEmailClientInput = {
    where: EmailCampaignWhereUniqueInput
    data: XOR<EmailCampaignUpdateWithoutEmailClientInput, EmailCampaignUncheckedUpdateWithoutEmailClientInput>
  }

  export type EmailCampaignUpdateManyWithWhereWithoutEmailClientInput = {
    where: EmailCampaignScalarWhereInput
    data: XOR<EmailCampaignUpdateManyMutationInput, EmailCampaignUncheckedUpdateManyWithoutEmailClientInput>
  }

  export type EmailCampaignScalarWhereInput = {
    AND?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
    OR?: EmailCampaignScalarWhereInput[]
    NOT?: EmailCampaignScalarWhereInput | EmailCampaignScalarWhereInput[]
    id?: StringFilter<"EmailCampaign"> | string
    createdAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"EmailCampaign"> | Date | string
    campaignId?: StringFilter<"EmailCampaign"> | string
    campaignName?: StringFilter<"EmailCampaign"> | string
    emailClientId?: StringFilter<"EmailCampaign"> | string
  }

  export type EmailCampaignDailyStatsUpsertWithWhereUniqueWithoutEmailClientInput = {
    where: EmailCampaignDailyStatsWhereUniqueInput
    update: XOR<EmailCampaignDailyStatsUpdateWithoutEmailClientInput, EmailCampaignDailyStatsUncheckedUpdateWithoutEmailClientInput>
    create: XOR<EmailCampaignDailyStatsCreateWithoutEmailClientInput, EmailCampaignDailyStatsUncheckedCreateWithoutEmailClientInput>
  }

  export type EmailCampaignDailyStatsUpdateWithWhereUniqueWithoutEmailClientInput = {
    where: EmailCampaignDailyStatsWhereUniqueInput
    data: XOR<EmailCampaignDailyStatsUpdateWithoutEmailClientInput, EmailCampaignDailyStatsUncheckedUpdateWithoutEmailClientInput>
  }

  export type EmailCampaignDailyStatsUpdateManyWithWhereWithoutEmailClientInput = {
    where: EmailCampaignDailyStatsScalarWhereInput
    data: XOR<EmailCampaignDailyStatsUpdateManyMutationInput, EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailClientInput>
  }

  export type EmailClientCredentialsUpsertWithWhereUniqueWithoutEmailClientInput = {
    where: EmailClientCredentialsWhereUniqueInput
    update: XOR<EmailClientCredentialsUpdateWithoutEmailClientInput, EmailClientCredentialsUncheckedUpdateWithoutEmailClientInput>
    create: XOR<EmailClientCredentialsCreateWithoutEmailClientInput, EmailClientCredentialsUncheckedCreateWithoutEmailClientInput>
  }

  export type EmailClientCredentialsUpdateWithWhereUniqueWithoutEmailClientInput = {
    where: EmailClientCredentialsWhereUniqueInput
    data: XOR<EmailClientCredentialsUpdateWithoutEmailClientInput, EmailClientCredentialsUncheckedUpdateWithoutEmailClientInput>
  }

  export type EmailClientCredentialsUpdateManyWithWhereWithoutEmailClientInput = {
    where: EmailClientCredentialsScalarWhereInput
    data: XOR<EmailClientCredentialsUpdateManyMutationInput, EmailClientCredentialsUncheckedUpdateManyWithoutEmailClientInput>
  }

  export type EmailClientCredentialsScalarWhereInput = {
    AND?: EmailClientCredentialsScalarWhereInput | EmailClientCredentialsScalarWhereInput[]
    OR?: EmailClientCredentialsScalarWhereInput[]
    NOT?: EmailClientCredentialsScalarWhereInput | EmailClientCredentialsScalarWhereInput[]
    id?: StringFilter<"EmailClientCredentials"> | string
    createdAt?: DateTimeFilter<"EmailClientCredentials"> | Date | string
    updatedAt?: DateTimeFilter<"EmailClientCredentials"> | Date | string
    apiKey?: StringFilter<"EmailClientCredentials"> | string
    emailClientId?: StringFilter<"EmailClientCredentials"> | string
    platformName?: StringFilter<"EmailClientCredentials"> | string
  }

  export type EmailGlobalDailyStatsUpsertWithWhereUniqueWithoutEmailClientInput = {
    where: EmailGlobalDailyStatsWhereUniqueInput
    update: XOR<EmailGlobalDailyStatsUpdateWithoutEmailClientInput, EmailGlobalDailyStatsUncheckedUpdateWithoutEmailClientInput>
    create: XOR<EmailGlobalDailyStatsCreateWithoutEmailClientInput, EmailGlobalDailyStatsUncheckedCreateWithoutEmailClientInput>
  }

  export type EmailGlobalDailyStatsUpdateWithWhereUniqueWithoutEmailClientInput = {
    where: EmailGlobalDailyStatsWhereUniqueInput
    data: XOR<EmailGlobalDailyStatsUpdateWithoutEmailClientInput, EmailGlobalDailyStatsUncheckedUpdateWithoutEmailClientInput>
  }

  export type EmailGlobalDailyStatsUpdateManyWithWhereWithoutEmailClientInput = {
    where: EmailGlobalDailyStatsScalarWhereInput
    data: XOR<EmailGlobalDailyStatsUpdateManyMutationInput, EmailGlobalDailyStatsUncheckedUpdateManyWithoutEmailClientInput>
  }

  export type EmailGlobalDailyStatsScalarWhereInput = {
    AND?: EmailGlobalDailyStatsScalarWhereInput | EmailGlobalDailyStatsScalarWhereInput[]
    OR?: EmailGlobalDailyStatsScalarWhereInput[]
    NOT?: EmailGlobalDailyStatsScalarWhereInput | EmailGlobalDailyStatsScalarWhereInput[]
    id?: StringFilter<"EmailGlobalDailyStats"> | string
    date?: DateTimeFilter<"EmailGlobalDailyStats"> | Date | string
    createdAt?: DateTimeFilter<"EmailGlobalDailyStats"> | Date | string
    updatedAt?: DateTimeFilter<"EmailGlobalDailyStats"> | Date | string
    bounces?: IntFilter<"EmailGlobalDailyStats"> | number
    clicks?: IntFilter<"EmailGlobalDailyStats"> | number
    emailClientId?: StringFilter<"EmailGlobalDailyStats"> | string
    opens?: IntFilter<"EmailGlobalDailyStats"> | number
    unsubs?: IntFilter<"EmailGlobalDailyStats"> | number
  }

  export type UserToEmailClientUpsertWithWhereUniqueWithoutEmailClientInput = {
    where: UserToEmailClientWhereUniqueInput
    update: XOR<UserToEmailClientUpdateWithoutEmailClientInput, UserToEmailClientUncheckedUpdateWithoutEmailClientInput>
    create: XOR<UserToEmailClientCreateWithoutEmailClientInput, UserToEmailClientUncheckedCreateWithoutEmailClientInput>
  }

  export type UserToEmailClientUpdateWithWhereUniqueWithoutEmailClientInput = {
    where: UserToEmailClientWhereUniqueInput
    data: XOR<UserToEmailClientUpdateWithoutEmailClientInput, UserToEmailClientUncheckedUpdateWithoutEmailClientInput>
  }

  export type UserToEmailClientUpdateManyWithWhereWithoutEmailClientInput = {
    where: UserToEmailClientScalarWhereInput
    data: XOR<UserToEmailClientUpdateManyMutationInput, UserToEmailClientUncheckedUpdateManyWithoutEmailClientInput>
  }

  export type UserToEmailClientScalarWhereInput = {
    AND?: UserToEmailClientScalarWhereInput | UserToEmailClientScalarWhereInput[]
    OR?: UserToEmailClientScalarWhereInput[]
    NOT?: UserToEmailClientScalarWhereInput | UserToEmailClientScalarWhereInput[]
    id?: StringFilter<"UserToEmailClient"> | string
    userId?: StringFilter<"UserToEmailClient"> | string
    emailClientId?: StringFilter<"UserToEmailClient"> | string
    createdAt?: DateTimeFilter<"UserToEmailClient"> | Date | string
    updatedAt?: DateTimeFilter<"UserToEmailClient"> | Date | string
  }

  export type EmailClientCreateWithoutEmailClientCredentialsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutEmailClientInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsCreateNestedManyWithoutEmailClientInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsCreateNestedManyWithoutEmailClientInput
    users?: UserToEmailClientCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientUncheckedCreateWithoutEmailClientCredentialsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutEmailClientInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput
    users?: UserToEmailClientUncheckedCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientCreateOrConnectWithoutEmailClientCredentialsInput = {
    where: EmailClientWhereUniqueInput
    create: XOR<EmailClientCreateWithoutEmailClientCredentialsInput, EmailClientUncheckedCreateWithoutEmailClientCredentialsInput>
  }

  export type EmailClientUpsertWithoutEmailClientCredentialsInput = {
    update: XOR<EmailClientUpdateWithoutEmailClientCredentialsInput, EmailClientUncheckedUpdateWithoutEmailClientCredentialsInput>
    create: XOR<EmailClientCreateWithoutEmailClientCredentialsInput, EmailClientUncheckedCreateWithoutEmailClientCredentialsInput>
    where?: EmailClientWhereInput
  }

  export type EmailClientUpdateToOneWithWhereWithoutEmailClientCredentialsInput = {
    where?: EmailClientWhereInput
    data: XOR<EmailClientUpdateWithoutEmailClientCredentialsInput, EmailClientUncheckedUpdateWithoutEmailClientCredentialsInput>
  }

  export type EmailClientUpdateWithoutEmailClientCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUpdateManyWithoutEmailClientNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUpdateManyWithoutEmailClientNestedInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUpdateManyWithoutEmailClientNestedInput
    users?: UserToEmailClientUpdateManyWithoutEmailClientNestedInput
  }

  export type EmailClientUncheckedUpdateWithoutEmailClientCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutEmailClientNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput
    users?: UserToEmailClientUncheckedUpdateManyWithoutEmailClientNestedInput
  }

  export type EmailClientCreateWithoutEmailGlobalDailyStatsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutEmailClientInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsCreateNestedManyWithoutEmailClientInput
    emailClientCredentials?: EmailClientCredentialsCreateNestedManyWithoutEmailClientInput
    users?: UserToEmailClientCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientUncheckedCreateWithoutEmailGlobalDailyStatsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutEmailClientInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput
    emailClientCredentials?: EmailClientCredentialsUncheckedCreateNestedManyWithoutEmailClientInput
    users?: UserToEmailClientUncheckedCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientCreateOrConnectWithoutEmailGlobalDailyStatsInput = {
    where: EmailClientWhereUniqueInput
    create: XOR<EmailClientCreateWithoutEmailGlobalDailyStatsInput, EmailClientUncheckedCreateWithoutEmailGlobalDailyStatsInput>
  }

  export type EmailClientUpsertWithoutEmailGlobalDailyStatsInput = {
    update: XOR<EmailClientUpdateWithoutEmailGlobalDailyStatsInput, EmailClientUncheckedUpdateWithoutEmailGlobalDailyStatsInput>
    create: XOR<EmailClientCreateWithoutEmailGlobalDailyStatsInput, EmailClientUncheckedCreateWithoutEmailGlobalDailyStatsInput>
    where?: EmailClientWhereInput
  }

  export type EmailClientUpdateToOneWithWhereWithoutEmailGlobalDailyStatsInput = {
    where?: EmailClientWhereInput
    data: XOR<EmailClientUpdateWithoutEmailGlobalDailyStatsInput, EmailClientUncheckedUpdateWithoutEmailGlobalDailyStatsInput>
  }

  export type EmailClientUpdateWithoutEmailGlobalDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUpdateManyWithoutEmailClientNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUpdateManyWithoutEmailClientNestedInput
    emailClientCredentials?: EmailClientCredentialsUpdateManyWithoutEmailClientNestedInput
    users?: UserToEmailClientUpdateManyWithoutEmailClientNestedInput
  }

  export type EmailClientUncheckedUpdateWithoutEmailGlobalDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutEmailClientNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput
    emailClientCredentials?: EmailClientCredentialsUncheckedUpdateManyWithoutEmailClientNestedInput
    users?: UserToEmailClientUncheckedUpdateManyWithoutEmailClientNestedInput
  }

  export type ConversationCreateWithoutGaAccountInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    client?: UserCreateNestedOneWithoutClientConversationsInput
    gaProperty?: GaPropertyCreateNestedOneWithoutConversationsInput
    user: UserCreateNestedOneWithoutConversationsInput
    queries?: QueryCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutGaAccountInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    description?: string | null
    gaPropertyId?: string | null
    clientId?: string | null
    queries?: QueryUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutGaAccountInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput>
  }

  export type ConversationCreateManyGaAccountInputEnvelope = {
    data: ConversationCreateManyGaAccountInput | ConversationCreateManyGaAccountInput[]
    skipDuplicates?: boolean
  }

  export type GaPropertyCreateWithoutGaAccountInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutGaAccountInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutGaAccountInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput>
  }

  export type GaPropertyCreateManyGaAccountInputEnvelope = {
    data: GaPropertyCreateManyGaAccountInput | GaPropertyCreateManyGaAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserToGaAccountCreateWithoutGaAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserToGaAccountsInput
  }

  export type UserToGaAccountUncheckedCreateWithoutGaAccountInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToGaAccountCreateOrConnectWithoutGaAccountInput = {
    where: UserToGaAccountWhereUniqueInput
    create: XOR<UserToGaAccountCreateWithoutGaAccountInput, UserToGaAccountUncheckedCreateWithoutGaAccountInput>
  }

  export type UserToGaAccountCreateManyGaAccountInputEnvelope = {
    data: UserToGaAccountCreateManyGaAccountInput | UserToGaAccountCreateManyGaAccountInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithWhereUniqueWithoutGaAccountInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutGaAccountInput, ConversationUncheckedUpdateWithoutGaAccountInput>
    create: XOR<ConversationCreateWithoutGaAccountInput, ConversationUncheckedCreateWithoutGaAccountInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutGaAccountInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutGaAccountInput, ConversationUncheckedUpdateWithoutGaAccountInput>
  }

  export type ConversationUpdateManyWithWhereWithoutGaAccountInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutGaAccountInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    isStarred?: BoolFilter<"Conversation"> | boolean
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    userId?: StringFilter<"Conversation"> | string
    description?: StringNullableFilter<"Conversation"> | string | null
    gaAccountId?: StringNullableFilter<"Conversation"> | string | null
    gaPropertyId?: StringNullableFilter<"Conversation"> | string | null
    clientId?: StringNullableFilter<"Conversation"> | string | null
  }

  export type GaPropertyUpsertWithWhereUniqueWithoutGaAccountInput = {
    where: GaPropertyWhereUniqueInput
    update: XOR<GaPropertyUpdateWithoutGaAccountInput, GaPropertyUncheckedUpdateWithoutGaAccountInput>
    create: XOR<GaPropertyCreateWithoutGaAccountInput, GaPropertyUncheckedCreateWithoutGaAccountInput>
  }

  export type GaPropertyUpdateWithWhereUniqueWithoutGaAccountInput = {
    where: GaPropertyWhereUniqueInput
    data: XOR<GaPropertyUpdateWithoutGaAccountInput, GaPropertyUncheckedUpdateWithoutGaAccountInput>
  }

  export type GaPropertyUpdateManyWithWhereWithoutGaAccountInput = {
    where: GaPropertyScalarWhereInput
    data: XOR<GaPropertyUpdateManyMutationInput, GaPropertyUncheckedUpdateManyWithoutGaAccountInput>
  }

  export type GaPropertyScalarWhereInput = {
    AND?: GaPropertyScalarWhereInput | GaPropertyScalarWhereInput[]
    OR?: GaPropertyScalarWhereInput[]
    NOT?: GaPropertyScalarWhereInput | GaPropertyScalarWhereInput[]
    id?: StringFilter<"GaProperty"> | string
    gaPropertyId?: StringFilter<"GaProperty"> | string
    gaPropertyName?: StringFilter<"GaProperty"> | string
    gaAccountId?: StringFilter<"GaProperty"> | string
    deleted?: BoolFilter<"GaProperty"> | boolean
    createdAt?: DateTimeFilter<"GaProperty"> | Date | string
    updatedAt?: DateTimeFilter<"GaProperty"> | Date | string
  }

  export type UserToGaAccountUpsertWithWhereUniqueWithoutGaAccountInput = {
    where: UserToGaAccountWhereUniqueInput
    update: XOR<UserToGaAccountUpdateWithoutGaAccountInput, UserToGaAccountUncheckedUpdateWithoutGaAccountInput>
    create: XOR<UserToGaAccountCreateWithoutGaAccountInput, UserToGaAccountUncheckedCreateWithoutGaAccountInput>
  }

  export type UserToGaAccountUpdateWithWhereUniqueWithoutGaAccountInput = {
    where: UserToGaAccountWhereUniqueInput
    data: XOR<UserToGaAccountUpdateWithoutGaAccountInput, UserToGaAccountUncheckedUpdateWithoutGaAccountInput>
  }

  export type UserToGaAccountUpdateManyWithWhereWithoutGaAccountInput = {
    where: UserToGaAccountScalarWhereInput
    data: XOR<UserToGaAccountUpdateManyMutationInput, UserToGaAccountUncheckedUpdateManyWithoutGaAccountInput>
  }

  export type UserToGaAccountScalarWhereInput = {
    AND?: UserToGaAccountScalarWhereInput | UserToGaAccountScalarWhereInput[]
    OR?: UserToGaAccountScalarWhereInput[]
    NOT?: UserToGaAccountScalarWhereInput | UserToGaAccountScalarWhereInput[]
    id?: StringFilter<"UserToGaAccount"> | string
    userId?: StringFilter<"UserToGaAccount"> | string
    gaAccountId?: StringFilter<"UserToGaAccount"> | string
    createdAt?: DateTimeFilter<"UserToGaAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserToGaAccount"> | Date | string
  }

  export type ConversationCreateWithoutGaPropertyInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    client?: UserCreateNestedOneWithoutClientConversationsInput
    gaAccount?: GaAccountCreateNestedOneWithoutConversationsInput
    user: UserCreateNestedOneWithoutConversationsInput
    queries?: QueryCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    description?: string | null
    gaAccountId?: string | null
    clientId?: string | null
    queries?: QueryUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutGaPropertyInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput>
  }

  export type ConversationCreateManyGaPropertyInputEnvelope = {
    data: ConversationCreateManyGaPropertyInput | ConversationCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type GaChannelDailyCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaChannelDailyUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaChannelDailyCreateOrConnectWithoutGaPropertyInput = {
    where: GaChannelDailyWhereUniqueInput
    create: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaChannelDailyCreateManyGaPropertyInputEnvelope = {
    data: GaChannelDailyCreateManyGaPropertyInput | GaChannelDailyCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type GaImportRunCreateWithoutGaPropertyInput = {
    id?: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedBy: UserCreateNestedOneWithoutGaImportRunsInput
  }

  export type GaImportRunUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    requestedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaImportRunCreateOrConnectWithoutGaPropertyInput = {
    where: GaImportRunWhereUniqueInput
    create: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaImportRunCreateManyGaPropertyInputEnvelope = {
    data: GaImportRunCreateManyGaPropertyInput | GaImportRunCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type GaKpiDailyCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaKpiDailyUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaKpiDailyCreateOrConnectWithoutGaPropertyInput = {
    where: GaKpiDailyWhereUniqueInput
    create: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaKpiDailyCreateManyGaPropertyInputEnvelope = {
    data: GaKpiDailyCreateManyGaPropertyInput | GaKpiDailyCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type GaKpiMonthlyCreateWithoutGaPropertyInput = {
    id?: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaKpiMonthlyCreateOrConnectWithoutGaPropertyInput = {
    where: GaKpiMonthlyWhereUniqueInput
    create: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaKpiMonthlyCreateManyGaPropertyInputEnvelope = {
    data: GaKpiMonthlyCreateManyGaPropertyInput | GaKpiMonthlyCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type GaAccountCreateWithoutGaPropertiesInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutGaAccountInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountUncheckedCreateWithoutGaPropertiesInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaAccountInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountCreateOrConnectWithoutGaPropertiesInput = {
    where: GaAccountWhereUniqueInput
    create: XOR<GaAccountCreateWithoutGaPropertiesInput, GaAccountUncheckedCreateWithoutGaPropertiesInput>
  }

  export type GaSourceDailyCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaSourceDailyUncheckedCreateWithoutGaPropertyInput = {
    id?: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaSourceDailyCreateOrConnectWithoutGaPropertyInput = {
    where: GaSourceDailyWhereUniqueInput
    create: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaSourceDailyCreateManyGaPropertyInputEnvelope = {
    data: GaSourceDailyCreateManyGaPropertyInput | GaSourceDailyCreateManyGaPropertyInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutGaPropertyInput, ConversationUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<ConversationCreateWithoutGaPropertyInput, ConversationUncheckedCreateWithoutGaPropertyInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutGaPropertyInput, ConversationUncheckedUpdateWithoutGaPropertyInput>
  }

  export type ConversationUpdateManyWithWhereWithoutGaPropertyInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaChannelDailyUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: GaChannelDailyWhereUniqueInput
    update: XOR<GaChannelDailyUpdateWithoutGaPropertyInput, GaChannelDailyUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<GaChannelDailyCreateWithoutGaPropertyInput, GaChannelDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaChannelDailyUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: GaChannelDailyWhereUniqueInput
    data: XOR<GaChannelDailyUpdateWithoutGaPropertyInput, GaChannelDailyUncheckedUpdateWithoutGaPropertyInput>
  }

  export type GaChannelDailyUpdateManyWithWhereWithoutGaPropertyInput = {
    where: GaChannelDailyScalarWhereInput
    data: XOR<GaChannelDailyUpdateManyMutationInput, GaChannelDailyUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaChannelDailyScalarWhereInput = {
    AND?: GaChannelDailyScalarWhereInput | GaChannelDailyScalarWhereInput[]
    OR?: GaChannelDailyScalarWhereInput[]
    NOT?: GaChannelDailyScalarWhereInput | GaChannelDailyScalarWhereInput[]
    id?: StringFilter<"GaChannelDaily"> | string
    gaPropertyId?: StringFilter<"GaChannelDaily"> | string
    date?: DateTimeFilter<"GaChannelDaily"> | Date | string
    channelGroup?: StringFilter<"GaChannelDaily"> | string
    sessions?: IntFilter<"GaChannelDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaChannelDaily"> | number
    engagementRate?: FloatFilter<"GaChannelDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaChannelDaily"> | number
    goalCompletions?: IntFilter<"GaChannelDaily"> | number
    goalCompletionRate?: FloatFilter<"GaChannelDaily"> | number
    createdAt?: DateTimeFilter<"GaChannelDaily"> | Date | string
    updatedAt?: DateTimeFilter<"GaChannelDaily"> | Date | string
  }

  export type GaImportRunUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: GaImportRunWhereUniqueInput
    update: XOR<GaImportRunUpdateWithoutGaPropertyInput, GaImportRunUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<GaImportRunCreateWithoutGaPropertyInput, GaImportRunUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaImportRunUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: GaImportRunWhereUniqueInput
    data: XOR<GaImportRunUpdateWithoutGaPropertyInput, GaImportRunUncheckedUpdateWithoutGaPropertyInput>
  }

  export type GaImportRunUpdateManyWithWhereWithoutGaPropertyInput = {
    where: GaImportRunScalarWhereInput
    data: XOR<GaImportRunUpdateManyMutationInput, GaImportRunUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaImportRunScalarWhereInput = {
    AND?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
    OR?: GaImportRunScalarWhereInput[]
    NOT?: GaImportRunScalarWhereInput | GaImportRunScalarWhereInput[]
    id?: StringFilter<"GaImportRun"> | string
    gaPropertyId?: StringFilter<"GaImportRun"> | string
    dateStart?: DateTimeFilter<"GaImportRun"> | Date | string
    dateEnd?: DateTimeFilter<"GaImportRun"> | Date | string
    status?: EnumImportStatusFilter<"GaImportRun"> | $Enums.ImportStatus
    errorMessage?: StringNullableFilter<"GaImportRun"> | string | null
    requestedByUserId?: StringFilter<"GaImportRun"> | string
    createdAt?: DateTimeFilter<"GaImportRun"> | Date | string
    updatedAt?: DateTimeFilter<"GaImportRun"> | Date | string
  }

  export type GaKpiDailyUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: GaKpiDailyWhereUniqueInput
    update: XOR<GaKpiDailyUpdateWithoutGaPropertyInput, GaKpiDailyUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<GaKpiDailyCreateWithoutGaPropertyInput, GaKpiDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaKpiDailyUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: GaKpiDailyWhereUniqueInput
    data: XOR<GaKpiDailyUpdateWithoutGaPropertyInput, GaKpiDailyUncheckedUpdateWithoutGaPropertyInput>
  }

  export type GaKpiDailyUpdateManyWithWhereWithoutGaPropertyInput = {
    where: GaKpiDailyScalarWhereInput
    data: XOR<GaKpiDailyUpdateManyMutationInput, GaKpiDailyUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaKpiDailyScalarWhereInput = {
    AND?: GaKpiDailyScalarWhereInput | GaKpiDailyScalarWhereInput[]
    OR?: GaKpiDailyScalarWhereInput[]
    NOT?: GaKpiDailyScalarWhereInput | GaKpiDailyScalarWhereInput[]
    id?: StringFilter<"GaKpiDaily"> | string
    gaPropertyId?: StringFilter<"GaKpiDaily"> | string
    date?: DateTimeFilter<"GaKpiDaily"> | Date | string
    sessions?: IntFilter<"GaKpiDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiDaily"> | number
    engagementRate?: FloatFilter<"GaKpiDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiDaily"> | number
    goalCompletions?: IntFilter<"GaKpiDaily"> | number
    goalCompletionRate?: FloatFilter<"GaKpiDaily"> | number
    createdAt?: DateTimeFilter<"GaKpiDaily"> | Date | string
    updatedAt?: DateTimeFilter<"GaKpiDaily"> | Date | string
  }

  export type GaKpiMonthlyUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: GaKpiMonthlyWhereUniqueInput
    update: XOR<GaKpiMonthlyUpdateWithoutGaPropertyInput, GaKpiMonthlyUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<GaKpiMonthlyCreateWithoutGaPropertyInput, GaKpiMonthlyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaKpiMonthlyUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: GaKpiMonthlyWhereUniqueInput
    data: XOR<GaKpiMonthlyUpdateWithoutGaPropertyInput, GaKpiMonthlyUncheckedUpdateWithoutGaPropertyInput>
  }

  export type GaKpiMonthlyUpdateManyWithWhereWithoutGaPropertyInput = {
    where: GaKpiMonthlyScalarWhereInput
    data: XOR<GaKpiMonthlyUpdateManyMutationInput, GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaKpiMonthlyScalarWhereInput = {
    AND?: GaKpiMonthlyScalarWhereInput | GaKpiMonthlyScalarWhereInput[]
    OR?: GaKpiMonthlyScalarWhereInput[]
    NOT?: GaKpiMonthlyScalarWhereInput | GaKpiMonthlyScalarWhereInput[]
    id?: StringFilter<"GaKpiMonthly"> | string
    gaPropertyId?: StringFilter<"GaKpiMonthly"> | string
    month?: IntFilter<"GaKpiMonthly"> | number
    sessions?: IntFilter<"GaKpiMonthly"> | number
    screenPageViewsPerSession?: FloatFilter<"GaKpiMonthly"> | number
    engagementRate?: FloatFilter<"GaKpiMonthly"> | number
    avgSessionDurationSec?: IntFilter<"GaKpiMonthly"> | number
    goalCompletions?: IntFilter<"GaKpiMonthly"> | number
    goalCompletionRate?: FloatFilter<"GaKpiMonthly"> | number
    createdAt?: DateTimeFilter<"GaKpiMonthly"> | Date | string
    updatedAt?: DateTimeFilter<"GaKpiMonthly"> | Date | string
  }

  export type GaAccountUpsertWithoutGaPropertiesInput = {
    update: XOR<GaAccountUpdateWithoutGaPropertiesInput, GaAccountUncheckedUpdateWithoutGaPropertiesInput>
    create: XOR<GaAccountCreateWithoutGaPropertiesInput, GaAccountUncheckedCreateWithoutGaPropertiesInput>
    where?: GaAccountWhereInput
  }

  export type GaAccountUpdateToOneWithWhereWithoutGaPropertiesInput = {
    where?: GaAccountWhereInput
    data: XOR<GaAccountUpdateWithoutGaPropertiesInput, GaAccountUncheckedUpdateWithoutGaPropertiesInput>
  }

  export type GaAccountUpdateWithoutGaPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutGaAccountNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutGaAccountNestedInput
  }

  export type GaAccountUncheckedUpdateWithoutGaPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaAccountNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutGaAccountNestedInput
  }

  export type GaSourceDailyUpsertWithWhereUniqueWithoutGaPropertyInput = {
    where: GaSourceDailyWhereUniqueInput
    update: XOR<GaSourceDailyUpdateWithoutGaPropertyInput, GaSourceDailyUncheckedUpdateWithoutGaPropertyInput>
    create: XOR<GaSourceDailyCreateWithoutGaPropertyInput, GaSourceDailyUncheckedCreateWithoutGaPropertyInput>
  }

  export type GaSourceDailyUpdateWithWhereUniqueWithoutGaPropertyInput = {
    where: GaSourceDailyWhereUniqueInput
    data: XOR<GaSourceDailyUpdateWithoutGaPropertyInput, GaSourceDailyUncheckedUpdateWithoutGaPropertyInput>
  }

  export type GaSourceDailyUpdateManyWithWhereWithoutGaPropertyInput = {
    where: GaSourceDailyScalarWhereInput
    data: XOR<GaSourceDailyUpdateManyMutationInput, GaSourceDailyUncheckedUpdateManyWithoutGaPropertyInput>
  }

  export type GaSourceDailyScalarWhereInput = {
    AND?: GaSourceDailyScalarWhereInput | GaSourceDailyScalarWhereInput[]
    OR?: GaSourceDailyScalarWhereInput[]
    NOT?: GaSourceDailyScalarWhereInput | GaSourceDailyScalarWhereInput[]
    id?: StringFilter<"GaSourceDaily"> | string
    gaPropertyId?: StringFilter<"GaSourceDaily"> | string
    date?: DateTimeFilter<"GaSourceDaily"> | Date | string
    trafficSource?: StringFilter<"GaSourceDaily"> | string
    sessions?: IntFilter<"GaSourceDaily"> | number
    screenPageViewsPerSession?: FloatFilter<"GaSourceDaily"> | number
    engagementRate?: FloatFilter<"GaSourceDaily"> | number
    avgSessionDurationSec?: IntFilter<"GaSourceDaily"> | number
    goalCompletions?: IntFilter<"GaSourceDaily"> | number
    goalCompletionRate?: FloatFilter<"GaSourceDaily"> | number
    createdAt?: DateTimeFilter<"GaSourceDaily"> | Date | string
    updatedAt?: DateTimeFilter<"GaSourceDaily"> | Date | string
  }

  export type GaPropertyCreateWithoutImportsInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutImportsInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutImportsInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutImportsInput, GaPropertyUncheckedCreateWithoutImportsInput>
  }

  export type UserCreateWithoutGaImportRunsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGaImportRunsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGaImportRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGaImportRunsInput, UserUncheckedCreateWithoutGaImportRunsInput>
  }

  export type GaPropertyUpsertWithoutImportsInput = {
    update: XOR<GaPropertyUpdateWithoutImportsInput, GaPropertyUncheckedUpdateWithoutImportsInput>
    create: XOR<GaPropertyCreateWithoutImportsInput, GaPropertyUncheckedCreateWithoutImportsInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutImportsInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutImportsInput, GaPropertyUncheckedUpdateWithoutImportsInput>
  }

  export type GaPropertyUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type UserUpsertWithoutGaImportRunsInput = {
    update: XOR<UserUpdateWithoutGaImportRunsInput, UserUncheckedUpdateWithoutGaImportRunsInput>
    create: XOR<UserCreateWithoutGaImportRunsInput, UserUncheckedCreateWithoutGaImportRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGaImportRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGaImportRunsInput, UserUncheckedUpdateWithoutGaImportRunsInput>
  }

  export type UserUpdateWithoutGaImportRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGaImportRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GaPropertyCreateWithoutKpiDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutKpiDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutKpiDailyInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutKpiDailyInput, GaPropertyUncheckedCreateWithoutKpiDailyInput>
  }

  export type GaPropertyUpsertWithoutKpiDailyInput = {
    update: XOR<GaPropertyUpdateWithoutKpiDailyInput, GaPropertyUncheckedUpdateWithoutKpiDailyInput>
    create: XOR<GaPropertyCreateWithoutKpiDailyInput, GaPropertyUncheckedCreateWithoutKpiDailyInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutKpiDailyInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutKpiDailyInput, GaPropertyUncheckedUpdateWithoutKpiDailyInput>
  }

  export type GaPropertyUpdateWithoutKpiDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutKpiDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyCreateWithoutKpiMonthlyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutKpiMonthlyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutKpiMonthlyInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutKpiMonthlyInput, GaPropertyUncheckedCreateWithoutKpiMonthlyInput>
  }

  export type GaPropertyUpsertWithoutKpiMonthlyInput = {
    update: XOR<GaPropertyUpdateWithoutKpiMonthlyInput, GaPropertyUncheckedUpdateWithoutKpiMonthlyInput>
    create: XOR<GaPropertyCreateWithoutKpiMonthlyInput, GaPropertyUncheckedCreateWithoutKpiMonthlyInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutKpiMonthlyInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutKpiMonthlyInput, GaPropertyUncheckedUpdateWithoutKpiMonthlyInput>
  }

  export type GaPropertyUpdateWithoutKpiMonthlyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutKpiMonthlyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyCreateWithoutChannelDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
    sourceDaily?: GaSourceDailyCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyUncheckedCreateWithoutChannelDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
    sourceDaily?: GaSourceDailyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutChannelDailyInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutChannelDailyInput, GaPropertyUncheckedCreateWithoutChannelDailyInput>
  }

  export type GaPropertyUpsertWithoutChannelDailyInput = {
    update: XOR<GaPropertyUpdateWithoutChannelDailyInput, GaPropertyUncheckedUpdateWithoutChannelDailyInput>
    create: XOR<GaPropertyCreateWithoutChannelDailyInput, GaPropertyUncheckedCreateWithoutChannelDailyInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutChannelDailyInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutChannelDailyInput, GaPropertyUncheckedUpdateWithoutChannelDailyInput>
  }

  export type GaPropertyUpdateWithoutChannelDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutChannelDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyCreateWithoutSourceDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyCreateNestedManyWithoutGaPropertyInput
    gaAccount: GaAccountCreateNestedOneWithoutGaPropertiesInput
  }

  export type GaPropertyUncheckedCreateWithoutSourceDailyInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    gaAccountId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaPropertyInput
    channelDaily?: GaChannelDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    imports?: GaImportRunUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiDaily?: GaKpiDailyUncheckedCreateNestedManyWithoutGaPropertyInput
    kpiMonthly?: GaKpiMonthlyUncheckedCreateNestedManyWithoutGaPropertyInput
  }

  export type GaPropertyCreateOrConnectWithoutSourceDailyInput = {
    where: GaPropertyWhereUniqueInput
    create: XOR<GaPropertyCreateWithoutSourceDailyInput, GaPropertyUncheckedCreateWithoutSourceDailyInput>
  }

  export type GaPropertyUpsertWithoutSourceDailyInput = {
    update: XOR<GaPropertyUpdateWithoutSourceDailyInput, GaPropertyUncheckedUpdateWithoutSourceDailyInput>
    create: XOR<GaPropertyCreateWithoutSourceDailyInput, GaPropertyUncheckedCreateWithoutSourceDailyInput>
    where?: GaPropertyWhereInput
  }

  export type GaPropertyUpdateToOneWithWhereWithoutSourceDailyInput = {
    where?: GaPropertyWhereInput
    data: XOR<GaPropertyUpdateWithoutSourceDailyInput, GaPropertyUncheckedUpdateWithoutSourceDailyInput>
  }

  export type GaPropertyUpdateWithoutSourceDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    gaAccount?: GaAccountUpdateOneRequiredWithoutGaPropertiesNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutSourceDailyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type MessageCreateWithoutRepliesInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parent?: MessageCreateNestedOneWithoutRepliesInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutRepliesInput = {
    id?: string
    content: string
    senderId: string
    recipientId: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    parentId?: string | null
    threadId?: string | null
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutRepliesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
  }

  export type MessageCreateWithoutParentInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    replies?: MessageCreateNestedManyWithoutParentInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutParentInput = {
    id?: string
    content: string
    senderId: string
    recipientId: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    replies?: MessageUncheckedCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutParentInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput>
  }

  export type MessageCreateManyParentInputEnvelope = {
    data: MessageCreateManyParentInput | MessageCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type MessageAttachmentCreateWithoutMessageInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
  }

  export type MessageAttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
  }

  export type MessageAttachmentCreateOrConnectWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentCreateManyMessageInputEnvelope = {
    data: MessageAttachmentCreateManyMessageInput | MessageAttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithoutRepliesInput = {
    update: XOR<MessageUpdateWithoutRepliesInput, MessageUncheckedUpdateWithoutRepliesInput>
    create: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutRepliesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutRepliesInput, MessageUncheckedUpdateWithoutRepliesInput>
  }

  export type MessageUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: MessageUpdateOneWithoutRepliesNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutParentInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutParentInput, MessageUncheckedUpdateWithoutParentInput>
    create: XOR<MessageCreateWithoutParentInput, MessageUncheckedCreateWithoutParentInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutParentInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutParentInput, MessageUncheckedUpdateWithoutParentInput>
  }

  export type MessageUpdateManyWithWhereWithoutParentInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutParentInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    archived?: BoolFilter<"Message"> | boolean
    isThreadStart?: BoolFilter<"Message"> | boolean
    parentId?: StringNullableFilter<"Message"> | string | null
    threadId?: StringNullableFilter<"Message"> | string | null
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    update: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    data: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: MessageAttachmentScalarWhereInput
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageAttachmentScalarWhereInput = {
    AND?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    OR?: MessageAttachmentScalarWhereInput[]
    NOT?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    filename?: StringFilter<"MessageAttachment"> | string
    fileSize?: IntFilter<"MessageAttachment"> | number
    mimeType?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    messageId?: StringFilter<"MessageAttachment"> | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QueryCreateWithoutParsedPieDataInput = {
    id?: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedData?: ParsedQueryDataCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryCreateNestedManyWithoutQueryInput
    conversation?: ConversationCreateNestedOneWithoutQueriesInput
    user: UserCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateWithoutParsedPieDataInput = {
    id?: string
    userId: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    conversationId?: string | null
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedData?: ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutParsedPieDataInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutParsedPieDataInput, QueryUncheckedCreateWithoutParsedPieDataInput>
  }

  export type QueryUpsertWithoutParsedPieDataInput = {
    update: XOR<QueryUpdateWithoutParsedPieDataInput, QueryUncheckedUpdateWithoutParsedPieDataInput>
    create: XOR<QueryCreateWithoutParsedPieDataInput, QueryUncheckedCreateWithoutParsedPieDataInput>
    where?: QueryWhereInput
  }

  export type QueryUpdateToOneWithWhereWithoutParsedPieDataInput = {
    where?: QueryWhereInput
    data: XOR<QueryUpdateWithoutParsedPieDataInput, QueryUncheckedUpdateWithoutParsedPieDataInput>
  }

  export type QueryUpdateWithoutParsedPieDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedData?: ParsedQueryDataUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUpdateManyWithoutQueryNestedInput
    conversation?: ConversationUpdateOneWithoutQueriesNestedInput
    user?: UserUpdateOneRequiredWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateWithoutParsedPieDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedData?: ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryCreateWithoutParsedDataInput = {
    id?: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryCreateNestedManyWithoutQueryInput
    conversation?: ConversationCreateNestedOneWithoutQueriesInput
    user: UserCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateWithoutParsedDataInput = {
    id?: string
    userId: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    conversationId?: string | null
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutParsedDataInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutParsedDataInput, QueryUncheckedCreateWithoutParsedDataInput>
  }

  export type QueryUpsertWithoutParsedDataInput = {
    update: XOR<QueryUpdateWithoutParsedDataInput, QueryUncheckedUpdateWithoutParsedDataInput>
    create: XOR<QueryCreateWithoutParsedDataInput, QueryUncheckedCreateWithoutParsedDataInput>
    where?: QueryWhereInput
  }

  export type QueryUpdateToOneWithWhereWithoutParsedDataInput = {
    where?: QueryWhereInput
    data: XOR<QueryUpdateWithoutParsedDataInput, QueryUncheckedUpdateWithoutParsedDataInput>
  }

  export type QueryUpdateWithoutParsedDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUpdateManyWithoutQueryNestedInput
    conversation?: ConversationUpdateOneWithoutQueriesNestedInput
    user?: UserUpdateOneRequiredWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateWithoutParsedDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryCreateWithoutParsedSummaryInput = {
    id?: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataCreateNestedManyWithoutQueryInput
    parsedData?: ParsedQueryDataCreateNestedManyWithoutQueryInput
    conversation?: ConversationCreateNestedOneWithoutQueriesInput
    user: UserCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateWithoutParsedSummaryInput = {
    id?: string
    userId: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    conversationId?: string | null
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput
    parsedData?: ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutParsedSummaryInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutParsedSummaryInput, QueryUncheckedCreateWithoutParsedSummaryInput>
  }

  export type QueryUpsertWithoutParsedSummaryInput = {
    update: XOR<QueryUpdateWithoutParsedSummaryInput, QueryUncheckedUpdateWithoutParsedSummaryInput>
    create: XOR<QueryCreateWithoutParsedSummaryInput, QueryUncheckedCreateWithoutParsedSummaryInput>
    where?: QueryWhereInput
  }

  export type QueryUpdateToOneWithWhereWithoutParsedSummaryInput = {
    where?: QueryWhereInput
    data: XOR<QueryUpdateWithoutParsedSummaryInput, QueryUncheckedUpdateWithoutParsedSummaryInput>
  }

  export type QueryUpdateWithoutParsedSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUpdateManyWithoutQueryNestedInput
    parsedData?: ParsedQueryDataUpdateManyWithoutQueryNestedInput
    conversation?: ConversationUpdateOneWithoutQueriesNestedInput
    user?: UserUpdateOneRequiredWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateWithoutParsedSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedData?: ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type ParsedPieGraphDataCreateWithoutQueryInput = {
    id?: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParsedPieGraphDataUncheckedCreateWithoutQueryInput = {
    id?: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParsedPieGraphDataCreateOrConnectWithoutQueryInput = {
    where: ParsedPieGraphDataWhereUniqueInput
    create: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput>
  }

  export type ParsedPieGraphDataCreateManyQueryInputEnvelope = {
    data: ParsedPieGraphDataCreateManyQueryInput | ParsedPieGraphDataCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type ParsedQueryDataCreateWithoutQueryInput = {
    id?: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    bounceRate?: number | null
    engagedSessions?: number | null
    newUsers?: number | null
  }

  export type ParsedQueryDataUncheckedCreateWithoutQueryInput = {
    id?: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    bounceRate?: number | null
    engagedSessions?: number | null
    newUsers?: number | null
  }

  export type ParsedQueryDataCreateOrConnectWithoutQueryInput = {
    where: ParsedQueryDataWhereUniqueInput
    create: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput>
  }

  export type ParsedQueryDataCreateManyQueryInputEnvelope = {
    data: ParsedQueryDataCreateManyQueryInput | ParsedQueryDataCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type ParsedQuerySummaryCreateWithoutQueryInput = {
    id?: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
  }

  export type ParsedQuerySummaryUncheckedCreateWithoutQueryInput = {
    id?: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
  }

  export type ParsedQuerySummaryCreateOrConnectWithoutQueryInput = {
    where: ParsedQuerySummaryWhereUniqueInput
    create: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput>
  }

  export type ParsedQuerySummaryCreateManyQueryInputEnvelope = {
    data: ParsedQuerySummaryCreateManyQueryInput | ParsedQuerySummaryCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutQueriesInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    client?: UserCreateNestedOneWithoutClientConversationsInput
    gaAccount?: GaAccountCreateNestedOneWithoutConversationsInput
    gaProperty?: GaPropertyCreateNestedOneWithoutConversationsInput
    user: UserCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutQueriesInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    description?: string | null
    gaAccountId?: string | null
    gaPropertyId?: string | null
    clientId?: string | null
  }

  export type ConversationCreateOrConnectWithoutQueriesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutQueriesInput, ConversationUncheckedCreateWithoutQueriesInput>
  }

  export type UserCreateWithoutQueriesInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQueriesInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQueriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
  }

  export type ParsedPieGraphDataUpsertWithWhereUniqueWithoutQueryInput = {
    where: ParsedPieGraphDataWhereUniqueInput
    update: XOR<ParsedPieGraphDataUpdateWithoutQueryInput, ParsedPieGraphDataUncheckedUpdateWithoutQueryInput>
    create: XOR<ParsedPieGraphDataCreateWithoutQueryInput, ParsedPieGraphDataUncheckedCreateWithoutQueryInput>
  }

  export type ParsedPieGraphDataUpdateWithWhereUniqueWithoutQueryInput = {
    where: ParsedPieGraphDataWhereUniqueInput
    data: XOR<ParsedPieGraphDataUpdateWithoutQueryInput, ParsedPieGraphDataUncheckedUpdateWithoutQueryInput>
  }

  export type ParsedPieGraphDataUpdateManyWithWhereWithoutQueryInput = {
    where: ParsedPieGraphDataScalarWhereInput
    data: XOR<ParsedPieGraphDataUpdateManyMutationInput, ParsedPieGraphDataUncheckedUpdateManyWithoutQueryInput>
  }

  export type ParsedPieGraphDataScalarWhereInput = {
    AND?: ParsedPieGraphDataScalarWhereInput | ParsedPieGraphDataScalarWhereInput[]
    OR?: ParsedPieGraphDataScalarWhereInput[]
    NOT?: ParsedPieGraphDataScalarWhereInput | ParsedPieGraphDataScalarWhereInput[]
    id?: StringFilter<"ParsedPieGraphData"> | string
    queryId?: StringFilter<"ParsedPieGraphData"> | string
    channel?: StringFilter<"ParsedPieGraphData"> | string
    source?: StringFilter<"ParsedPieGraphData"> | string
    sessions?: IntFilter<"ParsedPieGraphData"> | number
    conversionRate?: FloatFilter<"ParsedPieGraphData"> | number
    conversions?: IntFilter<"ParsedPieGraphData"> | number
    bounces?: IntFilter<"ParsedPieGraphData"> | number
    prevSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    prevBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearSessionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionRateDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearConversionsDiff?: FloatFilter<"ParsedPieGraphData"> | number
    yearBouncesDiff?: FloatFilter<"ParsedPieGraphData"> | number
    createdAt?: DateTimeFilter<"ParsedPieGraphData"> | Date | string
    updatedAt?: DateTimeFilter<"ParsedPieGraphData"> | Date | string
  }

  export type ParsedQueryDataUpsertWithWhereUniqueWithoutQueryInput = {
    where: ParsedQueryDataWhereUniqueInput
    update: XOR<ParsedQueryDataUpdateWithoutQueryInput, ParsedQueryDataUncheckedUpdateWithoutQueryInput>
    create: XOR<ParsedQueryDataCreateWithoutQueryInput, ParsedQueryDataUncheckedCreateWithoutQueryInput>
  }

  export type ParsedQueryDataUpdateWithWhereUniqueWithoutQueryInput = {
    where: ParsedQueryDataWhereUniqueInput
    data: XOR<ParsedQueryDataUpdateWithoutQueryInput, ParsedQueryDataUncheckedUpdateWithoutQueryInput>
  }

  export type ParsedQueryDataUpdateManyWithWhereWithoutQueryInput = {
    where: ParsedQueryDataScalarWhereInput
    data: XOR<ParsedQueryDataUpdateManyMutationInput, ParsedQueryDataUncheckedUpdateManyWithoutQueryInput>
  }

  export type ParsedQueryDataScalarWhereInput = {
    AND?: ParsedQueryDataScalarWhereInput | ParsedQueryDataScalarWhereInput[]
    OR?: ParsedQueryDataScalarWhereInput[]
    NOT?: ParsedQueryDataScalarWhereInput | ParsedQueryDataScalarWhereInput[]
    id?: StringFilter<"ParsedQueryData"> | string
    queryId?: StringFilter<"ParsedQueryData"> | string
    date?: DateTimeFilter<"ParsedQueryData"> | Date | string
    channel?: StringFilter<"ParsedQueryData"> | string
    source?: StringFilter<"ParsedQueryData"> | string
    sessions?: IntFilter<"ParsedQueryData"> | number
    conversionRate?: FloatFilter<"ParsedQueryData"> | number
    conversions?: IntFilter<"ParsedQueryData"> | number
    bounces?: IntFilter<"ParsedQueryData"> | number
    createdAt?: DateTimeFilter<"ParsedQueryData"> | Date | string
    bounceRate?: FloatNullableFilter<"ParsedQueryData"> | number | null
    engagedSessions?: IntNullableFilter<"ParsedQueryData"> | number | null
    newUsers?: IntNullableFilter<"ParsedQueryData"> | number | null
  }

  export type ParsedQuerySummaryUpsertWithWhereUniqueWithoutQueryInput = {
    where: ParsedQuerySummaryWhereUniqueInput
    update: XOR<ParsedQuerySummaryUpdateWithoutQueryInput, ParsedQuerySummaryUncheckedUpdateWithoutQueryInput>
    create: XOR<ParsedQuerySummaryCreateWithoutQueryInput, ParsedQuerySummaryUncheckedCreateWithoutQueryInput>
  }

  export type ParsedQuerySummaryUpdateWithWhereUniqueWithoutQueryInput = {
    where: ParsedQuerySummaryWhereUniqueInput
    data: XOR<ParsedQuerySummaryUpdateWithoutQueryInput, ParsedQuerySummaryUncheckedUpdateWithoutQueryInput>
  }

  export type ParsedQuerySummaryUpdateManyWithWhereWithoutQueryInput = {
    where: ParsedQuerySummaryScalarWhereInput
    data: XOR<ParsedQuerySummaryUpdateManyMutationInput, ParsedQuerySummaryUncheckedUpdateManyWithoutQueryInput>
  }

  export type ParsedQuerySummaryScalarWhereInput = {
    AND?: ParsedQuerySummaryScalarWhereInput | ParsedQuerySummaryScalarWhereInput[]
    OR?: ParsedQuerySummaryScalarWhereInput[]
    NOT?: ParsedQuerySummaryScalarWhereInput | ParsedQuerySummaryScalarWhereInput[]
    id?: StringFilter<"ParsedQuerySummary"> | string
    queryId?: StringFilter<"ParsedQuerySummary"> | string
    date?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
    totalEngagedSessions?: IntFilter<"ParsedQuerySummary"> | number
    averageBounceRate?: FloatFilter<"ParsedQuerySummary"> | number
    totalNewUsers?: IntFilter<"ParsedQuerySummary"> | number
    totalConversions?: IntFilter<"ParsedQuerySummary"> | number
    createdAt?: DateTimeFilter<"ParsedQuerySummary"> | Date | string
  }

  export type ConversationUpsertWithoutQueriesInput = {
    update: XOR<ConversationUpdateWithoutQueriesInput, ConversationUncheckedUpdateWithoutQueriesInput>
    create: XOR<ConversationCreateWithoutQueriesInput, ConversationUncheckedCreateWithoutQueriesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutQueriesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutQueriesInput, ConversationUncheckedUpdateWithoutQueriesInput>
  }

  export type ConversationUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    client?: UserUpdateOneWithoutClientConversationsNestedInput
    gaAccount?: GaAccountUpdateOneWithoutConversationsNestedInput
    gaProperty?: GaPropertyUpdateOneWithoutConversationsNestedInput
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutQueriesInput = {
    update: XOR<UserUpdateWithoutQueriesInput, UserUncheckedUpdateWithoutQueriesInput>
    create: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQueriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQueriesInput, UserUncheckedUpdateWithoutQueriesInput>
  }

  export type UserUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SproutSocialAccountCreateWithoutFacebookAnalyticsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookPosts?: SproutFacebookPostCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountUncheckedCreateWithoutFacebookAnalyticsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookPosts?: SproutFacebookPostUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountCreateOrConnectWithoutFacebookAnalyticsInput = {
    where: SproutSocialAccountWhereUniqueInput
    create: XOR<SproutSocialAccountCreateWithoutFacebookAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutFacebookAnalyticsInput>
  }

  export type SproutSocialAccountUpsertWithoutFacebookAnalyticsInput = {
    update: XOR<SproutSocialAccountUpdateWithoutFacebookAnalyticsInput, SproutSocialAccountUncheckedUpdateWithoutFacebookAnalyticsInput>
    create: XOR<SproutSocialAccountCreateWithoutFacebookAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutFacebookAnalyticsInput>
    where?: SproutSocialAccountWhereInput
  }

  export type SproutSocialAccountUpdateToOneWithWhereWithoutFacebookAnalyticsInput = {
    where?: SproutSocialAccountWhereInput
    data: XOR<SproutSocialAccountUpdateWithoutFacebookAnalyticsInput, SproutSocialAccountUncheckedUpdateWithoutFacebookAnalyticsInput>
  }

  export type SproutSocialAccountUpdateWithoutFacebookAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookPosts?: SproutFacebookPostUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountUncheckedUpdateWithoutFacebookAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookPosts?: SproutFacebookPostUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountCreateWithoutFacebookPostsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountUncheckedCreateWithoutFacebookPostsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountCreateOrConnectWithoutFacebookPostsInput = {
    where: SproutSocialAccountWhereUniqueInput
    create: XOR<SproutSocialAccountCreateWithoutFacebookPostsInput, SproutSocialAccountUncheckedCreateWithoutFacebookPostsInput>
  }

  export type SproutSocialAccountUpsertWithoutFacebookPostsInput = {
    update: XOR<SproutSocialAccountUpdateWithoutFacebookPostsInput, SproutSocialAccountUncheckedUpdateWithoutFacebookPostsInput>
    create: XOR<SproutSocialAccountCreateWithoutFacebookPostsInput, SproutSocialAccountUncheckedCreateWithoutFacebookPostsInput>
    where?: SproutSocialAccountWhereInput
  }

  export type SproutSocialAccountUpdateToOneWithWhereWithoutFacebookPostsInput = {
    where?: SproutSocialAccountWhereInput
    data: XOR<SproutSocialAccountUpdateWithoutFacebookPostsInput, SproutSocialAccountUncheckedUpdateWithoutFacebookPostsInput>
  }

  export type SproutSocialAccountUpdateWithoutFacebookPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountUncheckedUpdateWithoutFacebookPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountCreateWithoutFacebookPostAnalyticsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountUncheckedCreateWithoutFacebookPostAnalyticsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountCreateOrConnectWithoutFacebookPostAnalyticsInput = {
    where: SproutSocialAccountWhereUniqueInput
    create: XOR<SproutSocialAccountCreateWithoutFacebookPostAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutFacebookPostAnalyticsInput>
  }

  export type SproutSocialAccountUpsertWithoutFacebookPostAnalyticsInput = {
    update: XOR<SproutSocialAccountUpdateWithoutFacebookPostAnalyticsInput, SproutSocialAccountUncheckedUpdateWithoutFacebookPostAnalyticsInput>
    create: XOR<SproutSocialAccountCreateWithoutFacebookPostAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutFacebookPostAnalyticsInput>
    where?: SproutSocialAccountWhereInput
  }

  export type SproutSocialAccountUpdateToOneWithWhereWithoutFacebookPostAnalyticsInput = {
    where?: SproutSocialAccountWhereInput
    data: XOR<SproutSocialAccountUpdateWithoutFacebookPostAnalyticsInput, SproutSocialAccountUncheckedUpdateWithoutFacebookPostAnalyticsInput>
  }

  export type SproutSocialAccountUpdateWithoutFacebookPostAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountUncheckedUpdateWithoutFacebookPostAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountCreateWithoutInstagramAnalyticsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountUncheckedCreateWithoutInstagramAnalyticsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountCreateOrConnectWithoutInstagramAnalyticsInput = {
    where: SproutSocialAccountWhereUniqueInput
    create: XOR<SproutSocialAccountCreateWithoutInstagramAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutInstagramAnalyticsInput>
  }

  export type SproutInstagramFollowersByCityCreateWithoutSproutInstagramAnalyticsInput = {
    id?: string
    city: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutInstagramFollowersByCityUncheckedCreateWithoutSproutInstagramAnalyticsInput = {
    id?: string
    city: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutInstagramFollowersByCityCreateOrConnectWithoutSproutInstagramAnalyticsInput = {
    where: SproutInstagramFollowersByCityWhereUniqueInput
    create: XOR<SproutInstagramFollowersByCityCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCityUncheckedCreateWithoutSproutInstagramAnalyticsInput>
  }

  export type SproutInstagramFollowersByCityCreateManySproutInstagramAnalyticsInputEnvelope = {
    data: SproutInstagramFollowersByCityCreateManySproutInstagramAnalyticsInput | SproutInstagramFollowersByCityCreateManySproutInstagramAnalyticsInput[]
    skipDuplicates?: boolean
  }

  export type SproutInstagramFollowersByCountryCreateWithoutSproutInstagramAnalyticsInput = {
    id?: string
    country: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutInstagramFollowersByCountryUncheckedCreateWithoutSproutInstagramAnalyticsInput = {
    id?: string
    country: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutInstagramFollowersByCountryCreateOrConnectWithoutSproutInstagramAnalyticsInput = {
    where: SproutInstagramFollowersByCountryWhereUniqueInput
    create: XOR<SproutInstagramFollowersByCountryCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCountryUncheckedCreateWithoutSproutInstagramAnalyticsInput>
  }

  export type SproutInstagramFollowersByCountryCreateManySproutInstagramAnalyticsInputEnvelope = {
    data: SproutInstagramFollowersByCountryCreateManySproutInstagramAnalyticsInput | SproutInstagramFollowersByCountryCreateManySproutInstagramAnalyticsInput[]
    skipDuplicates?: boolean
  }

  export type SproutSocialAccountUpsertWithoutInstagramAnalyticsInput = {
    update: XOR<SproutSocialAccountUpdateWithoutInstagramAnalyticsInput, SproutSocialAccountUncheckedUpdateWithoutInstagramAnalyticsInput>
    create: XOR<SproutSocialAccountCreateWithoutInstagramAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutInstagramAnalyticsInput>
    where?: SproutSocialAccountWhereInput
  }

  export type SproutSocialAccountUpdateToOneWithWhereWithoutInstagramAnalyticsInput = {
    where?: SproutSocialAccountWhereInput
    data: XOR<SproutSocialAccountUpdateWithoutInstagramAnalyticsInput, SproutSocialAccountUncheckedUpdateWithoutInstagramAnalyticsInput>
  }

  export type SproutSocialAccountUpdateWithoutInstagramAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountUncheckedUpdateWithoutInstagramAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutInstagramFollowersByCityUpsertWithWhereUniqueWithoutSproutInstagramAnalyticsInput = {
    where: SproutInstagramFollowersByCityWhereUniqueInput
    update: XOR<SproutInstagramFollowersByCityUpdateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCityUncheckedUpdateWithoutSproutInstagramAnalyticsInput>
    create: XOR<SproutInstagramFollowersByCityCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCityUncheckedCreateWithoutSproutInstagramAnalyticsInput>
  }

  export type SproutInstagramFollowersByCityUpdateWithWhereUniqueWithoutSproutInstagramAnalyticsInput = {
    where: SproutInstagramFollowersByCityWhereUniqueInput
    data: XOR<SproutInstagramFollowersByCityUpdateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCityUncheckedUpdateWithoutSproutInstagramAnalyticsInput>
  }

  export type SproutInstagramFollowersByCityUpdateManyWithWhereWithoutSproutInstagramAnalyticsInput = {
    where: SproutInstagramFollowersByCityScalarWhereInput
    data: XOR<SproutInstagramFollowersByCityUpdateManyMutationInput, SproutInstagramFollowersByCityUncheckedUpdateManyWithoutSproutInstagramAnalyticsInput>
  }

  export type SproutInstagramFollowersByCityScalarWhereInput = {
    AND?: SproutInstagramFollowersByCityScalarWhereInput | SproutInstagramFollowersByCityScalarWhereInput[]
    OR?: SproutInstagramFollowersByCityScalarWhereInput[]
    NOT?: SproutInstagramFollowersByCityScalarWhereInput | SproutInstagramFollowersByCityScalarWhereInput[]
    id?: StringFilter<"SproutInstagramFollowersByCity"> | string
    sproutInstagramAnalyticsId?: StringFilter<"SproutInstagramFollowersByCity"> | string
    city?: StringFilter<"SproutInstagramFollowersByCity"> | string
    count?: IntFilter<"SproutInstagramFollowersByCity"> | number
    createdAt?: DateTimeFilter<"SproutInstagramFollowersByCity"> | Date | string
    updatedAt?: DateTimeFilter<"SproutInstagramFollowersByCity"> | Date | string
  }

  export type SproutInstagramFollowersByCountryUpsertWithWhereUniqueWithoutSproutInstagramAnalyticsInput = {
    where: SproutInstagramFollowersByCountryWhereUniqueInput
    update: XOR<SproutInstagramFollowersByCountryUpdateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCountryUncheckedUpdateWithoutSproutInstagramAnalyticsInput>
    create: XOR<SproutInstagramFollowersByCountryCreateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCountryUncheckedCreateWithoutSproutInstagramAnalyticsInput>
  }

  export type SproutInstagramFollowersByCountryUpdateWithWhereUniqueWithoutSproutInstagramAnalyticsInput = {
    where: SproutInstagramFollowersByCountryWhereUniqueInput
    data: XOR<SproutInstagramFollowersByCountryUpdateWithoutSproutInstagramAnalyticsInput, SproutInstagramFollowersByCountryUncheckedUpdateWithoutSproutInstagramAnalyticsInput>
  }

  export type SproutInstagramFollowersByCountryUpdateManyWithWhereWithoutSproutInstagramAnalyticsInput = {
    where: SproutInstagramFollowersByCountryScalarWhereInput
    data: XOR<SproutInstagramFollowersByCountryUpdateManyMutationInput, SproutInstagramFollowersByCountryUncheckedUpdateManyWithoutSproutInstagramAnalyticsInput>
  }

  export type SproutInstagramFollowersByCountryScalarWhereInput = {
    AND?: SproutInstagramFollowersByCountryScalarWhereInput | SproutInstagramFollowersByCountryScalarWhereInput[]
    OR?: SproutInstagramFollowersByCountryScalarWhereInput[]
    NOT?: SproutInstagramFollowersByCountryScalarWhereInput | SproutInstagramFollowersByCountryScalarWhereInput[]
    id?: StringFilter<"SproutInstagramFollowersByCountry"> | string
    sproutInstagramAnalyticsId?: StringFilter<"SproutInstagramFollowersByCountry"> | string
    country?: StringFilter<"SproutInstagramFollowersByCountry"> | string
    count?: IntFilter<"SproutInstagramFollowersByCountry"> | number
    createdAt?: DateTimeFilter<"SproutInstagramFollowersByCountry"> | Date | string
    updatedAt?: DateTimeFilter<"SproutInstagramFollowersByCountry"> | Date | string
  }

  export type SproutInstagramAnalyticsCreateWithoutFollowersByCityInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    commentsCount?: number | null
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    likes?: number | null
    saves?: number | null
    videoViews?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailContacts?: number | null
    getDirectionsClicks?: number | null
    phoneCallClicks?: number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: number | null
    profileFollowerAdds?: number | null
    profileFollowers?: number | null
    profileImpressionsUnique?: number | null
    profileReachUnique?: number | null
    profileViews?: number | null
    profileViewsUnique?: number | null
    websiteClicks?: number | null
    sproutSocialAccount: SproutSocialAccountCreateNestedOneWithoutInstagramAnalyticsInput
    followersByCountry?: SproutInstagramFollowersByCountryCreateNestedManyWithoutSproutInstagramAnalyticsInput
  }

  export type SproutInstagramAnalyticsUncheckedCreateWithoutFollowersByCityInput = {
    id?: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date | string
    commentsCount?: number | null
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    likes?: number | null
    saves?: number | null
    videoViews?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailContacts?: number | null
    getDirectionsClicks?: number | null
    phoneCallClicks?: number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: number | null
    profileFollowerAdds?: number | null
    profileFollowers?: number | null
    profileImpressionsUnique?: number | null
    profileReachUnique?: number | null
    profileViews?: number | null
    profileViewsUnique?: number | null
    websiteClicks?: number | null
    followersByCountry?: SproutInstagramFollowersByCountryUncheckedCreateNestedManyWithoutSproutInstagramAnalyticsInput
  }

  export type SproutInstagramAnalyticsCreateOrConnectWithoutFollowersByCityInput = {
    where: SproutInstagramAnalyticsWhereUniqueInput
    create: XOR<SproutInstagramAnalyticsCreateWithoutFollowersByCityInput, SproutInstagramAnalyticsUncheckedCreateWithoutFollowersByCityInput>
  }

  export type SproutInstagramAnalyticsUpsertWithoutFollowersByCityInput = {
    update: XOR<SproutInstagramAnalyticsUpdateWithoutFollowersByCityInput, SproutInstagramAnalyticsUncheckedUpdateWithoutFollowersByCityInput>
    create: XOR<SproutInstagramAnalyticsCreateWithoutFollowersByCityInput, SproutInstagramAnalyticsUncheckedCreateWithoutFollowersByCityInput>
    where?: SproutInstagramAnalyticsWhereInput
  }

  export type SproutInstagramAnalyticsUpdateToOneWithWhereWithoutFollowersByCityInput = {
    where?: SproutInstagramAnalyticsWhereInput
    data: XOR<SproutInstagramAnalyticsUpdateWithoutFollowersByCityInput, SproutInstagramAnalyticsUncheckedUpdateWithoutFollowersByCityInput>
  }

  export type SproutInstagramAnalyticsUpdateWithoutFollowersByCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    saves?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailContacts?: NullableIntFieldUpdateOperationsInput | number | null
    getDirectionsClicks?: NullableIntFieldUpdateOperationsInput | number | null
    phoneCallClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowerAdds?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    profileImpressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileReachUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileViews?: NullableIntFieldUpdateOperationsInput | number | null
    profileViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    websiteClicks?: NullableIntFieldUpdateOperationsInput | number | null
    sproutSocialAccount?: SproutSocialAccountUpdateOneRequiredWithoutInstagramAnalyticsNestedInput
    followersByCountry?: SproutInstagramFollowersByCountryUpdateManyWithoutSproutInstagramAnalyticsNestedInput
  }

  export type SproutInstagramAnalyticsUncheckedUpdateWithoutFollowersByCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    saves?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailContacts?: NullableIntFieldUpdateOperationsInput | number | null
    getDirectionsClicks?: NullableIntFieldUpdateOperationsInput | number | null
    phoneCallClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowerAdds?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    profileImpressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileReachUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileViews?: NullableIntFieldUpdateOperationsInput | number | null
    profileViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    websiteClicks?: NullableIntFieldUpdateOperationsInput | number | null
    followersByCountry?: SproutInstagramFollowersByCountryUncheckedUpdateManyWithoutSproutInstagramAnalyticsNestedInput
  }

  export type SproutInstagramAnalyticsCreateWithoutFollowersByCountryInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    commentsCount?: number | null
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    likes?: number | null
    saves?: number | null
    videoViews?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailContacts?: number | null
    getDirectionsClicks?: number | null
    phoneCallClicks?: number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: number | null
    profileFollowerAdds?: number | null
    profileFollowers?: number | null
    profileImpressionsUnique?: number | null
    profileReachUnique?: number | null
    profileViews?: number | null
    profileViewsUnique?: number | null
    websiteClicks?: number | null
    sproutSocialAccount: SproutSocialAccountCreateNestedOneWithoutInstagramAnalyticsInput
    followersByCity?: SproutInstagramFollowersByCityCreateNestedManyWithoutSproutInstagramAnalyticsInput
  }

  export type SproutInstagramAnalyticsUncheckedCreateWithoutFollowersByCountryInput = {
    id?: string
    sproutSocialAccountId: string
    customerProfileId: number
    reportingDate: Date | string
    commentsCount?: number | null
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    likes?: number | null
    saves?: number | null
    videoViews?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailContacts?: number | null
    getDirectionsClicks?: number | null
    phoneCallClicks?: number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: number | null
    profileFollowerAdds?: number | null
    profileFollowers?: number | null
    profileImpressionsUnique?: number | null
    profileReachUnique?: number | null
    profileViews?: number | null
    profileViewsUnique?: number | null
    websiteClicks?: number | null
    followersByCity?: SproutInstagramFollowersByCityUncheckedCreateNestedManyWithoutSproutInstagramAnalyticsInput
  }

  export type SproutInstagramAnalyticsCreateOrConnectWithoutFollowersByCountryInput = {
    where: SproutInstagramAnalyticsWhereUniqueInput
    create: XOR<SproutInstagramAnalyticsCreateWithoutFollowersByCountryInput, SproutInstagramAnalyticsUncheckedCreateWithoutFollowersByCountryInput>
  }

  export type SproutInstagramAnalyticsUpsertWithoutFollowersByCountryInput = {
    update: XOR<SproutInstagramAnalyticsUpdateWithoutFollowersByCountryInput, SproutInstagramAnalyticsUncheckedUpdateWithoutFollowersByCountryInput>
    create: XOR<SproutInstagramAnalyticsCreateWithoutFollowersByCountryInput, SproutInstagramAnalyticsUncheckedCreateWithoutFollowersByCountryInput>
    where?: SproutInstagramAnalyticsWhereInput
  }

  export type SproutInstagramAnalyticsUpdateToOneWithWhereWithoutFollowersByCountryInput = {
    where?: SproutInstagramAnalyticsWhereInput
    data: XOR<SproutInstagramAnalyticsUpdateWithoutFollowersByCountryInput, SproutInstagramAnalyticsUncheckedUpdateWithoutFollowersByCountryInput>
  }

  export type SproutInstagramAnalyticsUpdateWithoutFollowersByCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    saves?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailContacts?: NullableIntFieldUpdateOperationsInput | number | null
    getDirectionsClicks?: NullableIntFieldUpdateOperationsInput | number | null
    phoneCallClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowerAdds?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    profileImpressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileReachUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileViews?: NullableIntFieldUpdateOperationsInput | number | null
    profileViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    websiteClicks?: NullableIntFieldUpdateOperationsInput | number | null
    sproutSocialAccount?: SproutSocialAccountUpdateOneRequiredWithoutInstagramAnalyticsNestedInput
    followersByCity?: SproutInstagramFollowersByCityUpdateManyWithoutSproutInstagramAnalyticsNestedInput
  }

  export type SproutInstagramAnalyticsUncheckedUpdateWithoutFollowersByCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    saves?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailContacts?: NullableIntFieldUpdateOperationsInput | number | null
    getDirectionsClicks?: NullableIntFieldUpdateOperationsInput | number | null
    phoneCallClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowerAdds?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    profileImpressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileReachUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileViews?: NullableIntFieldUpdateOperationsInput | number | null
    profileViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    websiteClicks?: NullableIntFieldUpdateOperationsInput | number | null
    followersByCity?: SproutInstagramFollowersByCityUncheckedUpdateManyWithoutSproutInstagramAnalyticsNestedInput
  }

  export type SproutSocialAccountCreateWithoutLinkedInAnalyticsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountUncheckedCreateWithoutLinkedInAnalyticsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountCreateOrConnectWithoutLinkedInAnalyticsInput = {
    where: SproutSocialAccountWhereUniqueInput
    create: XOR<SproutSocialAccountCreateWithoutLinkedInAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutLinkedInAnalyticsInput>
  }

  export type SproutSocialAccountUpsertWithoutLinkedInAnalyticsInput = {
    update: XOR<SproutSocialAccountUpdateWithoutLinkedInAnalyticsInput, SproutSocialAccountUncheckedUpdateWithoutLinkedInAnalyticsInput>
    create: XOR<SproutSocialAccountCreateWithoutLinkedInAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutLinkedInAnalyticsInput>
    where?: SproutSocialAccountWhereInput
  }

  export type SproutSocialAccountUpdateToOneWithWhereWithoutLinkedInAnalyticsInput = {
    where?: SproutSocialAccountWhereInput
    data: XOR<SproutSocialAccountUpdateWithoutLinkedInAnalyticsInput, SproutSocialAccountUncheckedUpdateWithoutLinkedInAnalyticsInput>
  }

  export type SproutSocialAccountUpdateWithoutLinkedInAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountUncheckedUpdateWithoutLinkedInAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountCreateWithoutPinterestAnalyticsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountUncheckedCreateWithoutPinterestAnalyticsInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    users?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountCreateOrConnectWithoutPinterestAnalyticsInput = {
    where: SproutSocialAccountWhereUniqueInput
    create: XOR<SproutSocialAccountCreateWithoutPinterestAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutPinterestAnalyticsInput>
  }

  export type SproutSocialAccountUpsertWithoutPinterestAnalyticsInput = {
    update: XOR<SproutSocialAccountUpdateWithoutPinterestAnalyticsInput, SproutSocialAccountUncheckedUpdateWithoutPinterestAnalyticsInput>
    create: XOR<SproutSocialAccountCreateWithoutPinterestAnalyticsInput, SproutSocialAccountUncheckedCreateWithoutPinterestAnalyticsInput>
    where?: SproutSocialAccountWhereInput
  }

  export type SproutSocialAccountUpdateToOneWithWhereWithoutPinterestAnalyticsInput = {
    where?: SproutSocialAccountWhereInput
    data: XOR<SproutSocialAccountUpdateWithoutPinterestAnalyticsInput, SproutSocialAccountUncheckedUpdateWithoutPinterestAnalyticsInput>
  }

  export type SproutSocialAccountUpdateWithoutPinterestAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountUncheckedUpdateWithoutPinterestAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    users?: UserToSproutSocialAccountUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutFacebookAnalyticsCreateWithoutSproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postPhotoViewClicks?: number | null
    tabViews?: number | null
    videoViews?: number | null
    videoViews10s?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    videoViewsUnique?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    netFollowerGrowth?: number | null
  }

  export type SproutFacebookAnalyticsUncheckedCreateWithoutSproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postPhotoViewClicks?: number | null
    tabViews?: number | null
    videoViews?: number | null
    videoViews10s?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    videoViewsUnique?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    netFollowerGrowth?: number | null
  }

  export type SproutFacebookAnalyticsCreateOrConnectWithoutSproutSocialAccountInput = {
    where: SproutFacebookAnalyticsWhereUniqueInput
    create: XOR<SproutFacebookAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookAnalyticsUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookAnalyticsCreateManySproutSocialAccountInputEnvelope = {
    data: SproutFacebookAnalyticsCreateManySproutSocialAccountInput | SproutFacebookAnalyticsCreateManySproutSocialAccountInput[]
    skipDuplicates?: boolean
  }

  export type SproutFacebookPostCreateWithoutSproutSocialAccountInput = {
    id?: string
    postType: string
    postStatus: string
    postLink: string
    postText: string
    postNativeId: string
    postCreatedTime: Date | string
    postSentTime: Date | string
    postLastUpdated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutFacebookPostUncheckedCreateWithoutSproutSocialAccountInput = {
    id?: string
    postType: string
    postStatus: string
    postLink: string
    postText: string
    postNativeId: string
    postCreatedTime: Date | string
    postSentTime: Date | string
    postLastUpdated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutFacebookPostCreateOrConnectWithoutSproutSocialAccountInput = {
    where: SproutFacebookPostWhereUniqueInput
    create: XOR<SproutFacebookPostCreateWithoutSproutSocialAccountInput, SproutFacebookPostUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookPostCreateManySproutSocialAccountInputEnvelope = {
    data: SproutFacebookPostCreateManySproutSocialAccountInput | SproutFacebookPostCreateManySproutSocialAccountInput[]
    skipDuplicates?: boolean
  }

  export type SproutFacebookPostAnalyticsCreateWithoutSproutSocialAccountInput = {
    id?: string
    angryReactions?: number | null
    clientNativeId: string
    commentsCount?: number | null
    hahaReactions?: number | null
    impressions?: number | null
    impressionsFollower?: number | null
    impressionsNonFollower?: number | null
    impressionsNonViral?: number | null
    impressionsOrganic?: number | null
    impressionsPaid?: number | null
    impressionsViral?: number | null
    likes?: number | null
    loveReactions?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postNativeId: string
    postPhotoViewClicks?: number | null
    postVideoPlayClicks?: number | null
    questionAnswers?: number | null
    reach?: number | null
    reachFollower?: number | null
    reachNonViral?: number | null
    reachOrganic?: number | null
    reachPaid?: number | null
    reachViral?: number | null
    reactions?: number | null
    reportingDate: Date | string
    sadReactions?: number | null
    sharesCount?: number | null
    videoLength?: number | null
    videoViews?: number | null
    videoViewsAutoplay?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    wowReactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutFacebookPostAnalyticsUncheckedCreateWithoutSproutSocialAccountInput = {
    id?: string
    angryReactions?: number | null
    clientNativeId: string
    commentsCount?: number | null
    hahaReactions?: number | null
    impressions?: number | null
    impressionsFollower?: number | null
    impressionsNonFollower?: number | null
    impressionsNonViral?: number | null
    impressionsOrganic?: number | null
    impressionsPaid?: number | null
    impressionsViral?: number | null
    likes?: number | null
    loveReactions?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postNativeId: string
    postPhotoViewClicks?: number | null
    postVideoPlayClicks?: number | null
    questionAnswers?: number | null
    reach?: number | null
    reachFollower?: number | null
    reachNonViral?: number | null
    reachOrganic?: number | null
    reachPaid?: number | null
    reachViral?: number | null
    reactions?: number | null
    reportingDate: Date | string
    sadReactions?: number | null
    sharesCount?: number | null
    videoLength?: number | null
    videoViews?: number | null
    videoViewsAutoplay?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    wowReactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutFacebookPostAnalyticsCreateOrConnectWithoutSproutSocialAccountInput = {
    where: SproutFacebookPostAnalyticsWhereUniqueInput
    create: XOR<SproutFacebookPostAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookPostAnalyticsUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookPostAnalyticsCreateManySproutSocialAccountInputEnvelope = {
    data: SproutFacebookPostAnalyticsCreateManySproutSocialAccountInput | SproutFacebookPostAnalyticsCreateManySproutSocialAccountInput[]
    skipDuplicates?: boolean
  }

  export type SproutInstagramAnalyticsCreateWithoutSproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    commentsCount?: number | null
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    likes?: number | null
    saves?: number | null
    videoViews?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailContacts?: number | null
    getDirectionsClicks?: number | null
    phoneCallClicks?: number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: number | null
    profileFollowerAdds?: number | null
    profileFollowers?: number | null
    profileImpressionsUnique?: number | null
    profileReachUnique?: number | null
    profileViews?: number | null
    profileViewsUnique?: number | null
    websiteClicks?: number | null
    followersByCity?: SproutInstagramFollowersByCityCreateNestedManyWithoutSproutInstagramAnalyticsInput
    followersByCountry?: SproutInstagramFollowersByCountryCreateNestedManyWithoutSproutInstagramAnalyticsInput
  }

  export type SproutInstagramAnalyticsUncheckedCreateWithoutSproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    commentsCount?: number | null
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    likes?: number | null
    saves?: number | null
    videoViews?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailContacts?: number | null
    getDirectionsClicks?: number | null
    phoneCallClicks?: number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: number | null
    profileFollowerAdds?: number | null
    profileFollowers?: number | null
    profileImpressionsUnique?: number | null
    profileReachUnique?: number | null
    profileViews?: number | null
    profileViewsUnique?: number | null
    websiteClicks?: number | null
    followersByCity?: SproutInstagramFollowersByCityUncheckedCreateNestedManyWithoutSproutInstagramAnalyticsInput
    followersByCountry?: SproutInstagramFollowersByCountryUncheckedCreateNestedManyWithoutSproutInstagramAnalyticsInput
  }

  export type SproutInstagramAnalyticsCreateOrConnectWithoutSproutSocialAccountInput = {
    where: SproutInstagramAnalyticsWhereUniqueInput
    create: XOR<SproutInstagramAnalyticsCreateWithoutSproutSocialAccountInput, SproutInstagramAnalyticsUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutInstagramAnalyticsCreateManySproutSocialAccountInputEnvelope = {
    data: SproutInstagramAnalyticsCreateManySproutSocialAccountInput | SproutInstagramAnalyticsCreateManySproutSocialAccountInput[]
    skipDuplicates?: boolean
  }

  export type SproutLinkedInAnalyticsCreateWithoutSproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    reactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutLinkedInAnalyticsUncheckedCreateWithoutSproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    reactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutLinkedInAnalyticsCreateOrConnectWithoutSproutSocialAccountInput = {
    where: SproutLinkedInAnalyticsWhereUniqueInput
    create: XOR<SproutLinkedInAnalyticsCreateWithoutSproutSocialAccountInput, SproutLinkedInAnalyticsUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutLinkedInAnalyticsCreateManySproutSocialAccountInputEnvelope = {
    data: SproutLinkedInAnalyticsCreateManySproutSocialAccountInput | SproutLinkedInAnalyticsCreateManySproutSocialAccountInput[]
    skipDuplicates?: boolean
  }

  export type SproutPinterestAnalyticsCreateWithoutSproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    followersCount?: number | null
    followingCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutPinterestAnalyticsUncheckedCreateWithoutSproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    followersCount?: number | null
    followingCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutPinterestAnalyticsCreateOrConnectWithoutSproutSocialAccountInput = {
    where: SproutPinterestAnalyticsWhereUniqueInput
    create: XOR<SproutPinterestAnalyticsCreateWithoutSproutSocialAccountInput, SproutPinterestAnalyticsUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutPinterestAnalyticsCreateManySproutSocialAccountInputEnvelope = {
    data: SproutPinterestAnalyticsCreateManySproutSocialAccountInput | SproutPinterestAnalyticsCreateManySproutSocialAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserToSproutSocialAccountCreateWithoutSproutSocialAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSproutSocialAccountsInput
  }

  export type UserToSproutSocialAccountUncheckedCreateWithoutSproutSocialAccountInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToSproutSocialAccountCreateOrConnectWithoutSproutSocialAccountInput = {
    where: UserToSproutSocialAccountWhereUniqueInput
    create: XOR<UserToSproutSocialAccountCreateWithoutSproutSocialAccountInput, UserToSproutSocialAccountUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type UserToSproutSocialAccountCreateManySproutSocialAccountInputEnvelope = {
    data: UserToSproutSocialAccountCreateManySproutSocialAccountInput | UserToSproutSocialAccountCreateManySproutSocialAccountInput[]
    skipDuplicates?: boolean
  }

  export type SproutFacebookAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutFacebookAnalyticsWhereUniqueInput
    update: XOR<SproutFacebookAnalyticsUpdateWithoutSproutSocialAccountInput, SproutFacebookAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput>
    create: XOR<SproutFacebookAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookAnalyticsUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutFacebookAnalyticsWhereUniqueInput
    data: XOR<SproutFacebookAnalyticsUpdateWithoutSproutSocialAccountInput, SproutFacebookAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput = {
    where: SproutFacebookAnalyticsScalarWhereInput
    data: XOR<SproutFacebookAnalyticsUpdateManyMutationInput, SproutFacebookAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookAnalyticsScalarWhereInput = {
    AND?: SproutFacebookAnalyticsScalarWhereInput | SproutFacebookAnalyticsScalarWhereInput[]
    OR?: SproutFacebookAnalyticsScalarWhereInput[]
    NOT?: SproutFacebookAnalyticsScalarWhereInput | SproutFacebookAnalyticsScalarWhereInput[]
    id?: StringFilter<"SproutFacebookAnalytics"> | string
    sproutSocialAccountId?: StringFilter<"SproutFacebookAnalytics"> | string
    customerProfileId?: IntFilter<"SproutFacebookAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutFacebookAnalytics"> | Date | string
    engagements?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    impressionsUnique?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    followersCount?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postContentClicks?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postContentClicksOther?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postLinkClicks?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    postPhotoViewClicks?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    tabViews?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViews?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViews10s?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsOrganic?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsPaid?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    videoViewsUnique?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutFacebookAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutFacebookAnalytics"> | Date | string
    netFollowerGrowth?: IntNullableFilter<"SproutFacebookAnalytics"> | number | null
  }

  export type SproutFacebookPostUpsertWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutFacebookPostWhereUniqueInput
    update: XOR<SproutFacebookPostUpdateWithoutSproutSocialAccountInput, SproutFacebookPostUncheckedUpdateWithoutSproutSocialAccountInput>
    create: XOR<SproutFacebookPostCreateWithoutSproutSocialAccountInput, SproutFacebookPostUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookPostUpdateWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutFacebookPostWhereUniqueInput
    data: XOR<SproutFacebookPostUpdateWithoutSproutSocialAccountInput, SproutFacebookPostUncheckedUpdateWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookPostUpdateManyWithWhereWithoutSproutSocialAccountInput = {
    where: SproutFacebookPostScalarWhereInput
    data: XOR<SproutFacebookPostUpdateManyMutationInput, SproutFacebookPostUncheckedUpdateManyWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookPostScalarWhereInput = {
    AND?: SproutFacebookPostScalarWhereInput | SproutFacebookPostScalarWhereInput[]
    OR?: SproutFacebookPostScalarWhereInput[]
    NOT?: SproutFacebookPostScalarWhereInput | SproutFacebookPostScalarWhereInput[]
    id?: StringFilter<"SproutFacebookPost"> | string
    sproutSocialAccountId?: StringFilter<"SproutFacebookPost"> | string
    postType?: StringFilter<"SproutFacebookPost"> | string
    postStatus?: StringFilter<"SproutFacebookPost"> | string
    postLink?: StringFilter<"SproutFacebookPost"> | string
    postText?: StringFilter<"SproutFacebookPost"> | string
    postNativeId?: StringFilter<"SproutFacebookPost"> | string
    postCreatedTime?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    postSentTime?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    postLastUpdated?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    createdAt?: DateTimeFilter<"SproutFacebookPost"> | Date | string
    updatedAt?: DateTimeFilter<"SproutFacebookPost"> | Date | string
  }

  export type SproutFacebookPostAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutFacebookPostAnalyticsWhereUniqueInput
    update: XOR<SproutFacebookPostAnalyticsUpdateWithoutSproutSocialAccountInput, SproutFacebookPostAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput>
    create: XOR<SproutFacebookPostAnalyticsCreateWithoutSproutSocialAccountInput, SproutFacebookPostAnalyticsUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookPostAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutFacebookPostAnalyticsWhereUniqueInput
    data: XOR<SproutFacebookPostAnalyticsUpdateWithoutSproutSocialAccountInput, SproutFacebookPostAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookPostAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput = {
    where: SproutFacebookPostAnalyticsScalarWhereInput
    data: XOR<SproutFacebookPostAnalyticsUpdateManyMutationInput, SproutFacebookPostAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountInput>
  }

  export type SproutFacebookPostAnalyticsScalarWhereInput = {
    AND?: SproutFacebookPostAnalyticsScalarWhereInput | SproutFacebookPostAnalyticsScalarWhereInput[]
    OR?: SproutFacebookPostAnalyticsScalarWhereInput[]
    NOT?: SproutFacebookPostAnalyticsScalarWhereInput | SproutFacebookPostAnalyticsScalarWhereInput[]
    id?: StringFilter<"SproutFacebookPostAnalytics"> | string
    angryReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    clientNativeId?: StringFilter<"SproutFacebookPostAnalytics"> | string
    commentsCount?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    hahaReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsFollower?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsNonFollower?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsNonViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsOrganic?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsPaid?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    impressionsViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    likes?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    loveReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postContentClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postContentClicksOther?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postLinkClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postNativeId?: StringFilter<"SproutFacebookPostAnalytics"> | string
    postPhotoViewClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    postVideoPlayClicks?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    questionAnswers?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reach?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachFollower?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachNonViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachOrganic?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachPaid?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reachViral?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    reportingDate?: DateTimeFilter<"SproutFacebookPostAnalytics"> | Date | string
    sadReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    sharesCount?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    sproutSocialAccountId?: StringFilter<"SproutFacebookPostAnalytics"> | string
    videoLength?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViews?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsAutoplay?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsOrganic?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    videoViewsPaid?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    wowReactions?: IntNullableFilter<"SproutFacebookPostAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutFacebookPostAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutFacebookPostAnalytics"> | Date | string
  }

  export type SproutInstagramAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutInstagramAnalyticsWhereUniqueInput
    update: XOR<SproutInstagramAnalyticsUpdateWithoutSproutSocialAccountInput, SproutInstagramAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput>
    create: XOR<SproutInstagramAnalyticsCreateWithoutSproutSocialAccountInput, SproutInstagramAnalyticsUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutInstagramAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutInstagramAnalyticsWhereUniqueInput
    data: XOR<SproutInstagramAnalyticsUpdateWithoutSproutSocialAccountInput, SproutInstagramAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput>
  }

  export type SproutInstagramAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput = {
    where: SproutInstagramAnalyticsScalarWhereInput
    data: XOR<SproutInstagramAnalyticsUpdateManyMutationInput, SproutInstagramAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountInput>
  }

  export type SproutInstagramAnalyticsScalarWhereInput = {
    AND?: SproutInstagramAnalyticsScalarWhereInput | SproutInstagramAnalyticsScalarWhereInput[]
    OR?: SproutInstagramAnalyticsScalarWhereInput[]
    NOT?: SproutInstagramAnalyticsScalarWhereInput | SproutInstagramAnalyticsScalarWhereInput[]
    id?: StringFilter<"SproutInstagramAnalytics"> | string
    sproutSocialAccountId?: StringFilter<"SproutInstagramAnalytics"> | string
    customerProfileId?: IntFilter<"SproutInstagramAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutInstagramAnalytics"> | Date | string
    commentsCount?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    engagements?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    impressionsUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    followersCount?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    likes?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    saves?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    videoViews?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutInstagramAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutInstagramAnalytics"> | Date | string
    emailContacts?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    getDirectionsClicks?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    phoneCallClicks?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    postsSendByContentType?: JsonNullableFilter<"SproutInstagramAnalytics">
    postsSentByPostType?: JsonNullableFilter<"SproutInstagramAnalytics">
    postsSentCount?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileFollowerAdds?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileFollowers?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileImpressionsUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileReachUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileViews?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    profileViewsUnique?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
    websiteClicks?: IntNullableFilter<"SproutInstagramAnalytics"> | number | null
  }

  export type SproutLinkedInAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutLinkedInAnalyticsWhereUniqueInput
    update: XOR<SproutLinkedInAnalyticsUpdateWithoutSproutSocialAccountInput, SproutLinkedInAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput>
    create: XOR<SproutLinkedInAnalyticsCreateWithoutSproutSocialAccountInput, SproutLinkedInAnalyticsUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutLinkedInAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutLinkedInAnalyticsWhereUniqueInput
    data: XOR<SproutLinkedInAnalyticsUpdateWithoutSproutSocialAccountInput, SproutLinkedInAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput>
  }

  export type SproutLinkedInAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput = {
    where: SproutLinkedInAnalyticsScalarWhereInput
    data: XOR<SproutLinkedInAnalyticsUpdateManyMutationInput, SproutLinkedInAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountInput>
  }

  export type SproutLinkedInAnalyticsScalarWhereInput = {
    AND?: SproutLinkedInAnalyticsScalarWhereInput | SproutLinkedInAnalyticsScalarWhereInput[]
    OR?: SproutLinkedInAnalyticsScalarWhereInput[]
    NOT?: SproutLinkedInAnalyticsScalarWhereInput | SproutLinkedInAnalyticsScalarWhereInput[]
    id?: StringFilter<"SproutLinkedInAnalytics"> | string
    sproutSocialAccountId?: StringFilter<"SproutLinkedInAnalytics"> | string
    customerProfileId?: IntFilter<"SproutLinkedInAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutLinkedInAnalytics"> | Date | string
    engagements?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    impressions?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    impressionsUnique?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    followersCount?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    reactions?: IntNullableFilter<"SproutLinkedInAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutLinkedInAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutLinkedInAnalytics"> | Date | string
  }

  export type SproutPinterestAnalyticsUpsertWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutPinterestAnalyticsWhereUniqueInput
    update: XOR<SproutPinterestAnalyticsUpdateWithoutSproutSocialAccountInput, SproutPinterestAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput>
    create: XOR<SproutPinterestAnalyticsCreateWithoutSproutSocialAccountInput, SproutPinterestAnalyticsUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type SproutPinterestAnalyticsUpdateWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: SproutPinterestAnalyticsWhereUniqueInput
    data: XOR<SproutPinterestAnalyticsUpdateWithoutSproutSocialAccountInput, SproutPinterestAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput>
  }

  export type SproutPinterestAnalyticsUpdateManyWithWhereWithoutSproutSocialAccountInput = {
    where: SproutPinterestAnalyticsScalarWhereInput
    data: XOR<SproutPinterestAnalyticsUpdateManyMutationInput, SproutPinterestAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountInput>
  }

  export type SproutPinterestAnalyticsScalarWhereInput = {
    AND?: SproutPinterestAnalyticsScalarWhereInput | SproutPinterestAnalyticsScalarWhereInput[]
    OR?: SproutPinterestAnalyticsScalarWhereInput[]
    NOT?: SproutPinterestAnalyticsScalarWhereInput | SproutPinterestAnalyticsScalarWhereInput[]
    id?: StringFilter<"SproutPinterestAnalytics"> | string
    sproutSocialAccountId?: StringFilter<"SproutPinterestAnalytics"> | string
    customerProfileId?: IntFilter<"SproutPinterestAnalytics"> | number
    reportingDate?: DateTimeFilter<"SproutPinterestAnalytics"> | Date | string
    followersCount?: IntNullableFilter<"SproutPinterestAnalytics"> | number | null
    followingCount?: IntNullableFilter<"SproutPinterestAnalytics"> | number | null
    createdAt?: DateTimeFilter<"SproutPinterestAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"SproutPinterestAnalytics"> | Date | string
  }

  export type UserToSproutSocialAccountUpsertWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: UserToSproutSocialAccountWhereUniqueInput
    update: XOR<UserToSproutSocialAccountUpdateWithoutSproutSocialAccountInput, UserToSproutSocialAccountUncheckedUpdateWithoutSproutSocialAccountInput>
    create: XOR<UserToSproutSocialAccountCreateWithoutSproutSocialAccountInput, UserToSproutSocialAccountUncheckedCreateWithoutSproutSocialAccountInput>
  }

  export type UserToSproutSocialAccountUpdateWithWhereUniqueWithoutSproutSocialAccountInput = {
    where: UserToSproutSocialAccountWhereUniqueInput
    data: XOR<UserToSproutSocialAccountUpdateWithoutSproutSocialAccountInput, UserToSproutSocialAccountUncheckedUpdateWithoutSproutSocialAccountInput>
  }

  export type UserToSproutSocialAccountUpdateManyWithWhereWithoutSproutSocialAccountInput = {
    where: UserToSproutSocialAccountScalarWhereInput
    data: XOR<UserToSproutSocialAccountUpdateManyMutationInput, UserToSproutSocialAccountUncheckedUpdateManyWithoutSproutSocialAccountInput>
  }

  export type UserToSproutSocialAccountScalarWhereInput = {
    AND?: UserToSproutSocialAccountScalarWhereInput | UserToSproutSocialAccountScalarWhereInput[]
    OR?: UserToSproutSocialAccountScalarWhereInput[]
    NOT?: UserToSproutSocialAccountScalarWhereInput | UserToSproutSocialAccountScalarWhereInput[]
    id?: StringFilter<"UserToSproutSocialAccount"> | string
    userId?: StringFilter<"UserToSproutSocialAccount"> | string
    sproutSocialAccountId?: StringFilter<"UserToSproutSocialAccount"> | string
    createdAt?: DateTimeFilter<"UserToSproutSocialAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserToSproutSocialAccount"> | Date | string
  }

  export type SproutSocialAccountCreateWithoutUsersInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountUncheckedCreateWithoutUsersInput = {
    id?: string
    customerProfileId: number
    networkType: string
    name: string
    nativeName: string
    link: string
    nativeId: string
    groups?: SproutSocialAccountCreategroupsInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPosts?: SproutFacebookPostUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedCreateNestedManyWithoutSproutSocialAccountInput
  }

  export type SproutSocialAccountCreateOrConnectWithoutUsersInput = {
    where: SproutSocialAccountWhereUniqueInput
    create: XOR<SproutSocialAccountCreateWithoutUsersInput, SproutSocialAccountUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutSproutSocialAccountsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSproutSocialAccountsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSproutSocialAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSproutSocialAccountsInput, UserUncheckedCreateWithoutSproutSocialAccountsInput>
  }

  export type SproutSocialAccountUpsertWithoutUsersInput = {
    update: XOR<SproutSocialAccountUpdateWithoutUsersInput, SproutSocialAccountUncheckedUpdateWithoutUsersInput>
    create: XOR<SproutSocialAccountCreateWithoutUsersInput, SproutSocialAccountUncheckedCreateWithoutUsersInput>
    where?: SproutSocialAccountWhereInput
  }

  export type SproutSocialAccountUpdateToOneWithWhereWithoutUsersInput = {
    where?: SproutSocialAccountWhereInput
    data: XOR<SproutSocialAccountUpdateWithoutUsersInput, SproutSocialAccountUncheckedUpdateWithoutUsersInput>
  }

  export type SproutSocialAccountUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type SproutSocialAccountUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    networkType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    nativeId?: StringFieldUpdateOperationsInput | string
    groups?: SproutSocialAccountUpdategroupsInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facebookAnalytics?: SproutFacebookAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPosts?: SproutFacebookPostUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    facebookPostAnalytics?: SproutFacebookPostAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    instagramAnalytics?: SproutInstagramAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    linkedInAnalytics?: SproutLinkedInAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
    pinterestAnalytics?: SproutPinterestAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountNestedInput
  }

  export type UserUpsertWithoutSproutSocialAccountsInput = {
    update: XOR<UserUpdateWithoutSproutSocialAccountsInput, UserUncheckedUpdateWithoutSproutSocialAccountsInput>
    create: XOR<UserCreateWithoutSproutSocialAccountsInput, UserUncheckedCreateWithoutSproutSocialAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSproutSocialAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSproutSocialAccountsInput, UserUncheckedUpdateWithoutSproutSocialAccountsInput>
  }

  export type UserUpdateWithoutSproutSocialAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSproutSocialAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GaAccountCreateWithoutUserToGaAccountsInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutGaAccountInput
    gaProperties?: GaPropertyCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountUncheckedCreateWithoutUserToGaAccountsInput = {
    id?: string
    gaAccountId: string
    gaAccountName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutGaAccountInput
    gaProperties?: GaPropertyUncheckedCreateNestedManyWithoutGaAccountInput
  }

  export type GaAccountCreateOrConnectWithoutUserToGaAccountsInput = {
    where: GaAccountWhereUniqueInput
    create: XOR<GaAccountCreateWithoutUserToGaAccountsInput, GaAccountUncheckedCreateWithoutUserToGaAccountsInput>
  }

  export type UserCreateWithoutUserToGaAccountsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserToGaAccountsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserToGaAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserToGaAccountsInput, UserUncheckedCreateWithoutUserToGaAccountsInput>
  }

  export type GaAccountUpsertWithoutUserToGaAccountsInput = {
    update: XOR<GaAccountUpdateWithoutUserToGaAccountsInput, GaAccountUncheckedUpdateWithoutUserToGaAccountsInput>
    create: XOR<GaAccountCreateWithoutUserToGaAccountsInput, GaAccountUncheckedCreateWithoutUserToGaAccountsInput>
    where?: GaAccountWhereInput
  }

  export type GaAccountUpdateToOneWithWhereWithoutUserToGaAccountsInput = {
    where?: GaAccountWhereInput
    data: XOR<GaAccountUpdateWithoutUserToGaAccountsInput, GaAccountUncheckedUpdateWithoutUserToGaAccountsInput>
  }

  export type GaAccountUpdateWithoutUserToGaAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutGaAccountNestedInput
    gaProperties?: GaPropertyUpdateManyWithoutGaAccountNestedInput
  }

  export type GaAccountUncheckedUpdateWithoutUserToGaAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    gaAccountName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaAccountNestedInput
    gaProperties?: GaPropertyUncheckedUpdateManyWithoutGaAccountNestedInput
  }

  export type UserUpsertWithoutUserToGaAccountsInput = {
    update: XOR<UserUpdateWithoutUserToGaAccountsInput, UserUncheckedUpdateWithoutUserToGaAccountsInput>
    create: XOR<UserCreateWithoutUserToGaAccountsInput, UserUncheckedCreateWithoutUserToGaAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserToGaAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserToGaAccountsInput, UserUncheckedUpdateWithoutUserToGaAccountsInput>
  }

  export type UserUpdateWithoutUserToGaAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserToGaAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClientActivityCreateWithoutUserInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientActivityUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientActivityCreateOrConnectWithoutUserInput = {
    where: ClientActivityWhereUniqueInput
    create: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput>
  }

  export type ClientActivityCreateManyUserInputEnvelope = {
    data: ClientActivityCreateManyUserInput | ClientActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClientSatisfactionCreateWithoutAccountRepInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutGivenRatingsInput
  }

  export type ClientSatisfactionUncheckedCreateWithoutAccountRepInput = {
    id?: string
    rating: number
    feedback?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type ClientSatisfactionCreateOrConnectWithoutAccountRepInput = {
    where: ClientSatisfactionWhereUniqueInput
    create: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput>
  }

  export type ClientSatisfactionCreateManyAccountRepInputEnvelope = {
    data: ClientSatisfactionCreateManyAccountRepInput | ClientSatisfactionCreateManyAccountRepInput[]
    skipDuplicates?: boolean
  }

  export type ClientSatisfactionCreateWithoutUserInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    accountRep: UserCreateNestedOneWithoutReceivedRatingsInput
  }

  export type ClientSatisfactionUncheckedCreateWithoutUserInput = {
    id?: string
    rating: number
    feedback?: string | null
    accountRepId: string
    createdAt?: Date | string
  }

  export type ClientSatisfactionCreateOrConnectWithoutUserInput = {
    where: ClientSatisfactionWhereUniqueInput
    create: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput>
  }

  export type ClientSatisfactionCreateManyUserInputEnvelope = {
    data: ClientSatisfactionCreateManyUserInput | ClientSatisfactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutClientInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    gaAccount?: GaAccountCreateNestedOneWithoutConversationsInput
    gaProperty?: GaPropertyCreateNestedOneWithoutConversationsInput
    user: UserCreateNestedOneWithoutConversationsInput
    queries?: QueryCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    description?: string | null
    gaAccountId?: string | null
    gaPropertyId?: string | null
    queries?: QueryUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutClientInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput>
  }

  export type ConversationCreateManyClientInputEnvelope = {
    data: ConversationCreateManyClientInput | ConversationCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUserInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    client?: UserCreateNestedOneWithoutClientConversationsInput
    gaAccount?: GaAccountCreateNestedOneWithoutConversationsInput
    gaProperty?: GaPropertyCreateNestedOneWithoutConversationsInput
    queries?: QueryCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    gaAccountId?: string | null
    gaPropertyId?: string | null
    clientId?: string | null
    queries?: QueryUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: ConversationCreateManyUserInput | ConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GaImportRunCreateWithoutRequestedByInput = {
    id?: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gaProperty: GaPropertyCreateNestedOneWithoutImportsInput
  }

  export type GaImportRunUncheckedCreateWithoutRequestedByInput = {
    id?: string
    gaPropertyId: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaImportRunCreateOrConnectWithoutRequestedByInput = {
    where: GaImportRunWhereUniqueInput
    create: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput>
  }

  export type GaImportRunCreateManyRequestedByInputEnvelope = {
    data: GaImportRunCreateManyRequestedByInput | GaImportRunCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutRecipientInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parent?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutRecipientInput = {
    id?: string
    content: string
    senderId: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    parentId?: string | null
    threadId?: string | null
    replies?: MessageUncheckedCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageCreateManyRecipientInputEnvelope = {
    data: MessageCreateManyRecipientInput | MessageCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parent?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    content: string
    recipientId: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    parentId?: string | null
    threadId?: string | null
    replies?: MessageUncheckedCreateNestedManyWithoutParentInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QueryCreateWithoutUserInput = {
    id?: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataCreateNestedManyWithoutQueryInput
    parsedData?: ParsedQueryDataCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryCreateNestedManyWithoutQueryInput
    conversation?: ConversationCreateNestedOneWithoutQueriesInput
  }

  export type QueryUncheckedCreateWithoutUserInput = {
    id?: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    conversationId?: string | null
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUncheckedCreateNestedManyWithoutQueryInput
    parsedData?: ParsedQueryDataUncheckedCreateNestedManyWithoutQueryInput
    parsedSummary?: ParsedQuerySummaryUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutUserInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput>
  }

  export type QueryCreateManyUserInputEnvelope = {
    data: QueryCreateManyUserInput | QueryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    expires: Date | string
    sessionToken: string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    expires: Date | string
    sessionToken: string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    client: UserCreateNestedOneWithoutClientTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
    tags?: TicketTagCreateNestedManyWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    tags?: TicketTagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketCreateOrConnectWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput>
  }

  export type TicketCreateManyAssignedToInputEnvelope = {
    data: TicketCreateManyAssignedToInput | TicketCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
    tags?: TicketTagCreateNestedManyWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    tags?: TicketTagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketCreateOrConnectWithoutClientInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput>
  }

  export type TicketCreateManyClientInputEnvelope = {
    data: TicketCreateManyClientInput | TicketCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type TicketCommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketId: string
  }

  export type TicketCommentCreateOrConnectWithoutAuthorInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput>
  }

  export type TicketCommentCreateManyAuthorInputEnvelope = {
    data: TicketCommentCreateManyAuthorInput | TicketCommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutClientsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
  }

  export type UserCreateWithoutAccountRepInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountRepInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountRepInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput>
  }

  export type UserCreateManyAccountRepInputEnvelope = {
    data: UserCreateManyAccountRepInput | UserCreateManyAccountRepInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    emailNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    theme?: string | null
    apiCredits?: number
    apiCreditsLimit?: number
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    emailNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    theme?: string | null
    apiCredits?: number
    apiCreditsLimit?: number
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type UserToEmailClientCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailClient: EmailClientCreateNestedOneWithoutUsersInput
  }

  export type UserToEmailClientUncheckedCreateWithoutUserInput = {
    id?: string
    emailClientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToEmailClientCreateOrConnectWithoutUserInput = {
    where: UserToEmailClientWhereUniqueInput
    create: XOR<UserToEmailClientCreateWithoutUserInput, UserToEmailClientUncheckedCreateWithoutUserInput>
  }

  export type UserToEmailClientCreateManyUserInputEnvelope = {
    data: UserToEmailClientCreateManyUserInput | UserToEmailClientCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserToGaAccountCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gaAccount: GaAccountCreateNestedOneWithoutUserToGaAccountsInput
  }

  export type UserToGaAccountUncheckedCreateWithoutUserInput = {
    id?: string
    gaAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToGaAccountCreateOrConnectWithoutUserInput = {
    where: UserToGaAccountWhereUniqueInput
    create: XOR<UserToGaAccountCreateWithoutUserInput, UserToGaAccountUncheckedCreateWithoutUserInput>
  }

  export type UserToGaAccountCreateManyUserInputEnvelope = {
    data: UserToGaAccountCreateManyUserInput | UserToGaAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserToSproutSocialAccountCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sproutSocialAccount: SproutSocialAccountCreateNestedOneWithoutUsersInput
  }

  export type UserToSproutSocialAccountUncheckedCreateWithoutUserInput = {
    id?: string
    sproutSocialAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToSproutSocialAccountCreateOrConnectWithoutUserInput = {
    where: UserToSproutSocialAccountWhereUniqueInput
    create: XOR<UserToSproutSocialAccountCreateWithoutUserInput, UserToSproutSocialAccountUncheckedCreateWithoutUserInput>
  }

  export type UserToSproutSocialAccountCreateManyUserInputEnvelope = {
    data: UserToSproutSocialAccountCreateManyUserInput | UserToSproutSocialAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type ClientActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ClientActivityWhereUniqueInput
    update: XOR<ClientActivityUpdateWithoutUserInput, ClientActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ClientActivityCreateWithoutUserInput, ClientActivityUncheckedCreateWithoutUserInput>
  }

  export type ClientActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ClientActivityWhereUniqueInput
    data: XOR<ClientActivityUpdateWithoutUserInput, ClientActivityUncheckedUpdateWithoutUserInput>
  }

  export type ClientActivityUpdateManyWithWhereWithoutUserInput = {
    where: ClientActivityScalarWhereInput
    data: XOR<ClientActivityUpdateManyMutationInput, ClientActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ClientActivityScalarWhereInput = {
    AND?: ClientActivityScalarWhereInput | ClientActivityScalarWhereInput[]
    OR?: ClientActivityScalarWhereInput[]
    NOT?: ClientActivityScalarWhereInput | ClientActivityScalarWhereInput[]
    id?: StringFilter<"ClientActivity"> | string
    type?: StringFilter<"ClientActivity"> | string
    description?: StringFilter<"ClientActivity"> | string
    status?: EnumActivityStatusFilter<"ClientActivity"> | $Enums.ActivityStatus
    metadata?: JsonNullableFilter<"ClientActivity">
    createdAt?: DateTimeFilter<"ClientActivity"> | Date | string
    updatedAt?: DateTimeFilter<"ClientActivity"> | Date | string
    userId?: StringFilter<"ClientActivity"> | string
  }

  export type ClientSatisfactionUpsertWithWhereUniqueWithoutAccountRepInput = {
    where: ClientSatisfactionWhereUniqueInput
    update: XOR<ClientSatisfactionUpdateWithoutAccountRepInput, ClientSatisfactionUncheckedUpdateWithoutAccountRepInput>
    create: XOR<ClientSatisfactionCreateWithoutAccountRepInput, ClientSatisfactionUncheckedCreateWithoutAccountRepInput>
  }

  export type ClientSatisfactionUpdateWithWhereUniqueWithoutAccountRepInput = {
    where: ClientSatisfactionWhereUniqueInput
    data: XOR<ClientSatisfactionUpdateWithoutAccountRepInput, ClientSatisfactionUncheckedUpdateWithoutAccountRepInput>
  }

  export type ClientSatisfactionUpdateManyWithWhereWithoutAccountRepInput = {
    where: ClientSatisfactionScalarWhereInput
    data: XOR<ClientSatisfactionUpdateManyMutationInput, ClientSatisfactionUncheckedUpdateManyWithoutAccountRepInput>
  }

  export type ClientSatisfactionScalarWhereInput = {
    AND?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
    OR?: ClientSatisfactionScalarWhereInput[]
    NOT?: ClientSatisfactionScalarWhereInput | ClientSatisfactionScalarWhereInput[]
    id?: StringFilter<"ClientSatisfaction"> | string
    rating?: FloatFilter<"ClientSatisfaction"> | number
    feedback?: StringNullableFilter<"ClientSatisfaction"> | string | null
    userId?: StringFilter<"ClientSatisfaction"> | string
    accountRepId?: StringFilter<"ClientSatisfaction"> | string
    createdAt?: DateTimeFilter<"ClientSatisfaction"> | Date | string
  }

  export type ClientSatisfactionUpsertWithWhereUniqueWithoutUserInput = {
    where: ClientSatisfactionWhereUniqueInput
    update: XOR<ClientSatisfactionUpdateWithoutUserInput, ClientSatisfactionUncheckedUpdateWithoutUserInput>
    create: XOR<ClientSatisfactionCreateWithoutUserInput, ClientSatisfactionUncheckedCreateWithoutUserInput>
  }

  export type ClientSatisfactionUpdateWithWhereUniqueWithoutUserInput = {
    where: ClientSatisfactionWhereUniqueInput
    data: XOR<ClientSatisfactionUpdateWithoutUserInput, ClientSatisfactionUncheckedUpdateWithoutUserInput>
  }

  export type ClientSatisfactionUpdateManyWithWhereWithoutUserInput = {
    where: ClientSatisfactionScalarWhereInput
    data: XOR<ClientSatisfactionUpdateManyMutationInput, ClientSatisfactionUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutClientInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutClientInput, ConversationUncheckedUpdateWithoutClientInput>
    create: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutClientInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutClientInput, ConversationUncheckedUpdateWithoutClientInput>
  }

  export type ConversationUpdateManyWithWhereWithoutClientInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutClientInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type GaImportRunUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: GaImportRunWhereUniqueInput
    update: XOR<GaImportRunUpdateWithoutRequestedByInput, GaImportRunUncheckedUpdateWithoutRequestedByInput>
    create: XOR<GaImportRunCreateWithoutRequestedByInput, GaImportRunUncheckedCreateWithoutRequestedByInput>
  }

  export type GaImportRunUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: GaImportRunWhereUniqueInput
    data: XOR<GaImportRunUpdateWithoutRequestedByInput, GaImportRunUncheckedUpdateWithoutRequestedByInput>
  }

  export type GaImportRunUpdateManyWithWhereWithoutRequestedByInput = {
    where: GaImportRunScalarWhereInput
    data: XOR<GaImportRunUpdateManyMutationInput, GaImportRunUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
  }

  export type MessageUpdateManyWithWhereWithoutRecipientInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutRecipientInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type QueryUpsertWithWhereUniqueWithoutUserInput = {
    where: QueryWhereUniqueInput
    update: XOR<QueryUpdateWithoutUserInput, QueryUncheckedUpdateWithoutUserInput>
    create: XOR<QueryCreateWithoutUserInput, QueryUncheckedCreateWithoutUserInput>
  }

  export type QueryUpdateWithWhereUniqueWithoutUserInput = {
    where: QueryWhereUniqueInput
    data: XOR<QueryUpdateWithoutUserInput, QueryUncheckedUpdateWithoutUserInput>
  }

  export type QueryUpdateManyWithWhereWithoutUserInput = {
    where: QueryScalarWhereInput
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    sessionToken?: StringFilter<"Session"> | string
  }

  export type TicketUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAssignedToInput, TicketUncheckedUpdateWithoutAssignedToInput>
    create: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAssignedToInput, TicketUncheckedUpdateWithoutAssignedToInput>
  }

  export type TicketUpdateManyWithWhereWithoutAssignedToInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    assignedToId?: StringNullableFilter<"Ticket"> | string | null
    clientId?: StringFilter<"Ticket"> | string
  }

  export type TicketUpsertWithWhereUniqueWithoutClientInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutClientInput, TicketUncheckedUpdateWithoutClientInput>
    create: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutClientInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutClientInput, TicketUncheckedUpdateWithoutClientInput>
  }

  export type TicketUpdateManyWithWhereWithoutClientInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutClientInput>
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutAuthorInput, TicketCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutAuthorInput, TicketCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type TicketCommentScalarWhereInput = {
    AND?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    OR?: TicketCommentScalarWhereInput[]
    NOT?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
  }

  export type UserUpsertWithoutClientsInput = {
    update: XOR<UserUpdateWithoutClientsInput, UserUncheckedUpdateWithoutClientsInput>
    create: XOR<UserCreateWithoutClientsInput, UserUncheckedCreateWithoutClientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientsInput, UserUncheckedUpdateWithoutClientsInput>
  }

  export type UserUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutAccountRepInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAccountRepInput, UserUncheckedUpdateWithoutAccountRepInput>
    create: XOR<UserCreateWithoutAccountRepInput, UserUncheckedCreateWithoutAccountRepInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAccountRepInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAccountRepInput, UserUncheckedUpdateWithoutAccountRepInput>
  }

  export type UserUpdateManyWithWhereWithoutAccountRepInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAccountRepInput>
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    apiCredits?: IntFieldUpdateOperationsInput | number
    apiCreditsLimit?: IntFieldUpdateOperationsInput | number
  }

  export type UserToEmailClientUpsertWithWhereUniqueWithoutUserInput = {
    where: UserToEmailClientWhereUniqueInput
    update: XOR<UserToEmailClientUpdateWithoutUserInput, UserToEmailClientUncheckedUpdateWithoutUserInput>
    create: XOR<UserToEmailClientCreateWithoutUserInput, UserToEmailClientUncheckedCreateWithoutUserInput>
  }

  export type UserToEmailClientUpdateWithWhereUniqueWithoutUserInput = {
    where: UserToEmailClientWhereUniqueInput
    data: XOR<UserToEmailClientUpdateWithoutUserInput, UserToEmailClientUncheckedUpdateWithoutUserInput>
  }

  export type UserToEmailClientUpdateManyWithWhereWithoutUserInput = {
    where: UserToEmailClientScalarWhereInput
    data: XOR<UserToEmailClientUpdateManyMutationInput, UserToEmailClientUncheckedUpdateManyWithoutUserInput>
  }

  export type UserToGaAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: UserToGaAccountWhereUniqueInput
    update: XOR<UserToGaAccountUpdateWithoutUserInput, UserToGaAccountUncheckedUpdateWithoutUserInput>
    create: XOR<UserToGaAccountCreateWithoutUserInput, UserToGaAccountUncheckedCreateWithoutUserInput>
  }

  export type UserToGaAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: UserToGaAccountWhereUniqueInput
    data: XOR<UserToGaAccountUpdateWithoutUserInput, UserToGaAccountUncheckedUpdateWithoutUserInput>
  }

  export type UserToGaAccountUpdateManyWithWhereWithoutUserInput = {
    where: UserToGaAccountScalarWhereInput
    data: XOR<UserToGaAccountUpdateManyMutationInput, UserToGaAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type UserToSproutSocialAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: UserToSproutSocialAccountWhereUniqueInput
    update: XOR<UserToSproutSocialAccountUpdateWithoutUserInput, UserToSproutSocialAccountUncheckedUpdateWithoutUserInput>
    create: XOR<UserToSproutSocialAccountCreateWithoutUserInput, UserToSproutSocialAccountUncheckedCreateWithoutUserInput>
  }

  export type UserToSproutSocialAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: UserToSproutSocialAccountWhereUniqueInput
    data: XOR<UserToSproutSocialAccountUpdateWithoutUserInput, UserToSproutSocialAccountUncheckedUpdateWithoutUserInput>
  }

  export type UserToSproutSocialAccountUpdateManyWithWhereWithoutUserInput = {
    where: UserToSproutSocialAccountScalarWhereInput
    data: XOR<UserToSproutSocialAccountUpdateManyMutationInput, UserToSproutSocialAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAssignedTicketsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedTicketsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
  }

  export type UserCreateWithoutClientTicketsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientTicketsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientTicketsInput, UserUncheckedCreateWithoutClientTicketsInput>
  }

  export type TicketAttachmentCreateWithoutTicketInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
  }

  export type TicketAttachmentUncheckedCreateWithoutTicketInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
  }

  export type TicketAttachmentCreateOrConnectWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentCreateManyTicketInputEnvelope = {
    data: TicketAttachmentCreateManyTicketInput | TicketAttachmentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketCommentCreateWithoutTicketInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutTicketInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
  }

  export type TicketCommentCreateOrConnectWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentCreateManyTicketInputEnvelope = {
    data: TicketCommentCreateManyTicketInput | TicketCommentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketTagCreateWithoutTicketsInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type TicketTagUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type TicketTagCreateOrConnectWithoutTicketsInput = {
    where: TicketTagWhereUniqueInput
    create: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput>
  }

  export type UserUpsertWithoutAssignedTicketsInput = {
    update: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutClientTicketsInput = {
    update: XOR<UserUpdateWithoutClientTicketsInput, UserUncheckedUpdateWithoutClientTicketsInput>
    create: XOR<UserCreateWithoutClientTicketsInput, UserUncheckedCreateWithoutClientTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientTicketsInput, UserUncheckedUpdateWithoutClientTicketsInput>
  }

  export type UserUpdateWithoutClientTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    update: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    data: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketAttachmentScalarWhereInput
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketAttachmentScalarWhereInput = {
    AND?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    OR?: TicketAttachmentScalarWhereInput[]
    NOT?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    id?: StringFilter<"TicketAttachment"> | string
    name?: StringFilter<"TicketAttachment"> | string
    url?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: StringFilter<"TicketAttachment"> | string
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketTagUpsertWithWhereUniqueWithoutTicketsInput = {
    where: TicketTagWhereUniqueInput
    update: XOR<TicketTagUpdateWithoutTicketsInput, TicketTagUncheckedUpdateWithoutTicketsInput>
    create: XOR<TicketTagCreateWithoutTicketsInput, TicketTagUncheckedCreateWithoutTicketsInput>
  }

  export type TicketTagUpdateWithWhereUniqueWithoutTicketsInput = {
    where: TicketTagWhereUniqueInput
    data: XOR<TicketTagUpdateWithoutTicketsInput, TicketTagUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketTagUpdateManyWithWhereWithoutTicketsInput = {
    where: TicketTagScalarWhereInput
    data: XOR<TicketTagUpdateManyMutationInput, TicketTagUncheckedUpdateManyWithoutTicketsInput>
  }

  export type TicketTagScalarWhereInput = {
    AND?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
    OR?: TicketTagScalarWhereInput[]
    NOT?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
    id?: StringFilter<"TicketTag"> | string
    name?: StringFilter<"TicketTag"> | string
    createdAt?: DateTimeFilter<"TicketTag"> | Date | string
  }

  export type TicketCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    client: UserCreateNestedOneWithoutClientTicketsInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
    tags?: TicketTagCreateNestedManyWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    clientId: string
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    tags?: TicketTagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketCreateOrConnectWithoutAttachmentsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
  }

  export type TicketUpsertWithoutAttachmentsInput = {
    update: XOR<TicketUpdateWithoutAttachmentsInput, TicketUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutAttachmentsInput, TicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TicketUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    client?: UserUpdateOneRequiredWithoutClientTicketsNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type UserCreateWithoutTicketCommentsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketCommentsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
  }

  export type TicketCreateWithoutCommentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    client: UserCreateNestedOneWithoutClientTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    tags?: TicketTagCreateNestedManyWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    clientId: string
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    tags?: TicketTagUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketCreateOrConnectWithoutCommentsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutTicketCommentsInput = {
    update: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type UserUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketUpsertWithoutCommentsInput = {
    update: XOR<TicketUpdateWithoutCommentsInput, TicketUncheckedUpdateWithoutCommentsInput>
    create: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutCommentsInput, TicketUncheckedUpdateWithoutCommentsInput>
  }

  export type TicketUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    client?: UserUpdateOneRequiredWithoutClientTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketCreateWithoutTagsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    client: UserCreateNestedOneWithoutClientTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    clientId: string
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTagsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutTagsInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutTagsInput, TicketUncheckedUpdateWithoutTagsInput>
    create: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutTagsInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutTagsInput, TicketUncheckedUpdateWithoutTagsInput>
  }

  export type TicketUpdateManyWithWhereWithoutTagsInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutTagsInput>
  }

  export type MessageCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
    parent?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentInput
    recipient: UserCreateNestedOneWithoutReceivedMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    senderId: string
    recipientId: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    parentId?: string | null
    threadId?: string | null
    replies?: MessageUncheckedCreateNestedManyWithoutParentInput
  }

  export type MessageCreateOrConnectWithoutAttachmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type MessageUpsertWithoutAttachmentsInput = {
    update: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    emailClients?: UserToEmailClientUncheckedCreateNestedManyWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailClientCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaigns?: EmailCampaignCreateNestedManyWithoutEmailClientInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsCreateNestedManyWithoutEmailClientInput
    emailClientCredentials?: EmailClientCredentialsCreateNestedManyWithoutEmailClientInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientUncheckedCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    emailCampaigns?: EmailCampaignUncheckedCreateNestedManyWithoutEmailClientInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput
    emailClientCredentials?: EmailClientCredentialsUncheckedCreateNestedManyWithoutEmailClientInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUncheckedCreateNestedManyWithoutEmailClientInput
  }

  export type EmailClientCreateOrConnectWithoutUsersInput = {
    where: EmailClientWhereUniqueInput
    create: XOR<EmailClientCreateWithoutUsersInput, EmailClientUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutEmailClientsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ClientActivityCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionCreateNestedManyWithoutUserInput
    clientConversations?: ConversationCreateNestedManyWithoutClientInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    queries?: QueryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    accountRep?: UserCreateNestedOneWithoutClientsInput
    clients?: UserCreateNestedManyWithoutAccountRepInput
    company?: CompanyCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    userToGaAccounts?: UserToGaAccountCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailClientsInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ClientActivityUncheckedCreateNestedManyWithoutUserInput
    receivedRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutAccountRepInput
    givenRatings?: ClientSatisfactionUncheckedCreateNestedManyWithoutUserInput
    clientConversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    gaImportRuns?: GaImportRunUncheckedCreateNestedManyWithoutRequestedByInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    queries?: QueryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    clientTickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    clients?: UserUncheckedCreateNestedManyWithoutAccountRepInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    userToGaAccounts?: UserToGaAccountUncheckedCreateNestedManyWithoutUserInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailClientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailClientsInput, UserUncheckedCreateWithoutEmailClientsInput>
  }

  export type EmailClientUpsertWithoutUsersInput = {
    update: XOR<EmailClientUpdateWithoutUsersInput, EmailClientUncheckedUpdateWithoutUsersInput>
    create: XOR<EmailClientCreateWithoutUsersInput, EmailClientUncheckedCreateWithoutUsersInput>
    where?: EmailClientWhereInput
  }

  export type EmailClientUpdateToOneWithWhereWithoutUsersInput = {
    where?: EmailClientWhereInput
    data: XOR<EmailClientUpdateWithoutUsersInput, EmailClientUncheckedUpdateWithoutUsersInput>
  }

  export type EmailClientUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUpdateManyWithoutEmailClientNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUpdateManyWithoutEmailClientNestedInput
    emailClientCredentials?: EmailClientCredentialsUpdateManyWithoutEmailClientNestedInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUpdateManyWithoutEmailClientNestedInput
  }

  export type EmailClientUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    emailCampaigns?: EmailCampaignUncheckedUpdateManyWithoutEmailClientNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput
    emailClientCredentials?: EmailClientCredentialsUncheckedUpdateManyWithoutEmailClientNestedInput
    emailGlobalDailyStats?: EmailGlobalDailyStatsUncheckedUpdateManyWithoutEmailClientNestedInput
  }

  export type UserUpsertWithoutEmailClientsInput = {
    update: XOR<UserUpdateWithoutEmailClientsInput, UserUncheckedUpdateWithoutEmailClientsInput>
    create: XOR<UserCreateWithoutEmailClientsInput, UserUncheckedCreateWithoutEmailClientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailClientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailClientsInput, UserUncheckedUpdateWithoutEmailClientsInput>
  }

  export type UserUpdateWithoutEmailClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QueryCreateManyConversationInput = {
    id?: string
    userId: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QueryUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUpdateManyWithoutQueryNestedInput
    parsedData?: ParsedQueryDataUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUpdateManyWithoutQueryNestedInput
    user?: UserUpdateOneRequiredWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedData?: ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EmailCampaignDailyStatsCreateManyEmailCampaignInput = {
    id?: string
    date: Date | string
    opens?: number
    clicks?: number
    bounces?: number
    unsubscribes?: number
    variation: string
    phase: string
    requests?: number
    delivered?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bounceDrops?: number
    cumulativeBounceRate?: number
    cumulativeSpamReportsRate?: number
    cumulativeTotalClickRate?: number
    cumulativeTotalOpenRate?: number
    cumulativeUniqueClickRate?: number
    cumulativeUniqueOpenRate?: number
    cumulativeUnsubscribeRate?: number
    dailyBounceRate?: number
    dailySpamReportsRate?: number
    dailyTotalClickRate?: number
    dailyTotalClickToOpenRate?: number
    dailyTotalOpenRate?: number
    dailyUniqueClickRate?: number
    dailyUniqueClickToOpenRate?: number
    dailyUniqueOpenRate?: number
    dailyUnsubscribeRate?: number
    emailClientId: string
    singleSendName: string
    spamReportDrops?: number
    spamReports?: number
    totalClicks?: number
    totalOpens?: number
    uniqueClicks?: number
    uniqueOpens?: number
  }

  export type EmailCampaignDailyStatsUpdateWithoutEmailCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    unsubscribes?: IntFieldUpdateOperationsInput | number
    variation?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    requests?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceDrops?: IntFieldUpdateOperationsInput | number
    cumulativeBounceRate?: IntFieldUpdateOperationsInput | number
    cumulativeSpamReportsRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    dailyBounceRate?: IntFieldUpdateOperationsInput | number
    dailySpamReportsRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyTotalOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    singleSendName?: StringFieldUpdateOperationsInput | string
    spamReportDrops?: IntFieldUpdateOperationsInput | number
    spamReports?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalOpens?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
    emailClient?: EmailClientUpdateOneRequiredWithoutEmailCampaignDailyStatsNestedInput
  }

  export type EmailCampaignDailyStatsUncheckedUpdateWithoutEmailCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    unsubscribes?: IntFieldUpdateOperationsInput | number
    variation?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    requests?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceDrops?: IntFieldUpdateOperationsInput | number
    cumulativeBounceRate?: IntFieldUpdateOperationsInput | number
    cumulativeSpamReportsRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    dailyBounceRate?: IntFieldUpdateOperationsInput | number
    dailySpamReportsRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyTotalOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    emailClientId?: StringFieldUpdateOperationsInput | string
    singleSendName?: StringFieldUpdateOperationsInput | string
    spamReportDrops?: IntFieldUpdateOperationsInput | number
    spamReports?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalOpens?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
  }

  export type EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    unsubscribes?: IntFieldUpdateOperationsInput | number
    variation?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    requests?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceDrops?: IntFieldUpdateOperationsInput | number
    cumulativeBounceRate?: IntFieldUpdateOperationsInput | number
    cumulativeSpamReportsRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    dailyBounceRate?: IntFieldUpdateOperationsInput | number
    dailySpamReportsRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyTotalOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    emailClientId?: StringFieldUpdateOperationsInput | string
    singleSendName?: StringFieldUpdateOperationsInput | string
    spamReportDrops?: IntFieldUpdateOperationsInput | number
    spamReports?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalOpens?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
  }

  export type EmailCampaignCreateManyEmailClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    campaignName: string
  }

  export type EmailCampaignDailyStatsCreateManyEmailClientInput = {
    id?: string
    date: Date | string
    opens?: number
    clicks?: number
    bounces?: number
    unsubscribes?: number
    variation: string
    phase: string
    requests?: number
    delivered?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bounceDrops?: number
    cumulativeBounceRate?: number
    cumulativeSpamReportsRate?: number
    cumulativeTotalClickRate?: number
    cumulativeTotalOpenRate?: number
    cumulativeUniqueClickRate?: number
    cumulativeUniqueOpenRate?: number
    cumulativeUnsubscribeRate?: number
    dailyBounceRate?: number
    dailySpamReportsRate?: number
    dailyTotalClickRate?: number
    dailyTotalClickToOpenRate?: number
    dailyTotalOpenRate?: number
    dailyUniqueClickRate?: number
    dailyUniqueClickToOpenRate?: number
    dailyUniqueOpenRate?: number
    dailyUnsubscribeRate?: number
    emailCampaignId: string
    singleSendName: string
    spamReportDrops?: number
    spamReports?: number
    totalClicks?: number
    totalOpens?: number
    uniqueClicks?: number
    uniqueOpens?: number
  }

  export type EmailClientCredentialsCreateManyEmailClientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKey: string
    platformName: string
  }

  export type EmailGlobalDailyStatsCreateManyEmailClientInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bounces?: number
    clicks?: number
    opens?: number
    unsubs?: number
  }

  export type UserToEmailClientCreateManyEmailClientInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailCampaignUpdateWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    emailCampaignContents?: EmailCampaignContentUpdateOneWithoutEmailCampaignNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUpdateManyWithoutEmailCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
    emailCampaignContents?: EmailCampaignContentUncheckedUpdateOneWithoutEmailCampaignNestedInput
    emailCampaignDailyStats?: EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailCampaignNestedInput
  }

  export type EmailCampaignUncheckedUpdateManyWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignName?: StringFieldUpdateOperationsInput | string
  }

  export type EmailCampaignDailyStatsUpdateWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    unsubscribes?: IntFieldUpdateOperationsInput | number
    variation?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    requests?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceDrops?: IntFieldUpdateOperationsInput | number
    cumulativeBounceRate?: IntFieldUpdateOperationsInput | number
    cumulativeSpamReportsRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    dailyBounceRate?: IntFieldUpdateOperationsInput | number
    dailySpamReportsRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyTotalOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    singleSendName?: StringFieldUpdateOperationsInput | string
    spamReportDrops?: IntFieldUpdateOperationsInput | number
    spamReports?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalOpens?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
    emailCampaign?: EmailCampaignUpdateOneRequiredWithoutEmailCampaignDailyStatsNestedInput
  }

  export type EmailCampaignDailyStatsUncheckedUpdateWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    unsubscribes?: IntFieldUpdateOperationsInput | number
    variation?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    requests?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceDrops?: IntFieldUpdateOperationsInput | number
    cumulativeBounceRate?: IntFieldUpdateOperationsInput | number
    cumulativeSpamReportsRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    dailyBounceRate?: IntFieldUpdateOperationsInput | number
    dailySpamReportsRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyTotalOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    emailCampaignId?: StringFieldUpdateOperationsInput | string
    singleSendName?: StringFieldUpdateOperationsInput | string
    spamReportDrops?: IntFieldUpdateOperationsInput | number
    spamReports?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalOpens?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
  }

  export type EmailCampaignDailyStatsUncheckedUpdateManyWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    unsubscribes?: IntFieldUpdateOperationsInput | number
    variation?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    requests?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceDrops?: IntFieldUpdateOperationsInput | number
    cumulativeBounceRate?: IntFieldUpdateOperationsInput | number
    cumulativeSpamReportsRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeTotalOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueClickRate?: IntFieldUpdateOperationsInput | number
    cumulativeUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    cumulativeUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    dailyBounceRate?: IntFieldUpdateOperationsInput | number
    dailySpamReportsRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickRate?: IntFieldUpdateOperationsInput | number
    dailyTotalClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyTotalOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueClickToOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUniqueOpenRate?: IntFieldUpdateOperationsInput | number
    dailyUnsubscribeRate?: IntFieldUpdateOperationsInput | number
    emailCampaignId?: StringFieldUpdateOperationsInput | string
    singleSendName?: StringFieldUpdateOperationsInput | string
    spamReportDrops?: IntFieldUpdateOperationsInput | number
    spamReports?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalOpens?: IntFieldUpdateOperationsInput | number
    uniqueClicks?: IntFieldUpdateOperationsInput | number
    uniqueOpens?: IntFieldUpdateOperationsInput | number
  }

  export type EmailClientCredentialsUpdateWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKey?: StringFieldUpdateOperationsInput | string
    platformName?: StringFieldUpdateOperationsInput | string
  }

  export type EmailClientCredentialsUncheckedUpdateWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKey?: StringFieldUpdateOperationsInput | string
    platformName?: StringFieldUpdateOperationsInput | string
  }

  export type EmailClientCredentialsUncheckedUpdateManyWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKey?: StringFieldUpdateOperationsInput | string
    platformName?: StringFieldUpdateOperationsInput | string
  }

  export type EmailGlobalDailyStatsUpdateWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounces?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    opens?: IntFieldUpdateOperationsInput | number
    unsubs?: IntFieldUpdateOperationsInput | number
  }

  export type EmailGlobalDailyStatsUncheckedUpdateWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounces?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    opens?: IntFieldUpdateOperationsInput | number
    unsubs?: IntFieldUpdateOperationsInput | number
  }

  export type EmailGlobalDailyStatsUncheckedUpdateManyWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounces?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    opens?: IntFieldUpdateOperationsInput | number
    unsubs?: IntFieldUpdateOperationsInput | number
  }

  export type UserToEmailClientUpdateWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailClientsNestedInput
  }

  export type UserToEmailClientUncheckedUpdateWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToEmailClientUncheckedUpdateManyWithoutEmailClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateManyGaAccountInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    description?: string | null
    gaPropertyId?: string | null
    clientId?: string | null
  }

  export type GaPropertyCreateManyGaAccountInput = {
    id?: string
    gaPropertyId: string
    gaPropertyName: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToGaAccountCreateManyGaAccountInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    client?: UserUpdateOneWithoutClientConversationsNestedInput
    gaProperty?: GaPropertyUpdateOneWithoutConversationsNestedInput
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    queries?: QueryUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    queries?: QueryUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GaPropertyUpdateWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutGaPropertyNestedInput
    channelDaily?: GaChannelDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    imports?: GaImportRunUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiDaily?: GaKpiDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
    kpiMonthly?: GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyNestedInput
    sourceDaily?: GaSourceDailyUncheckedUpdateManyWithoutGaPropertyNestedInput
  }

  export type GaPropertyUncheckedUpdateManyWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    gaPropertyName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToGaAccountUpdateWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserToGaAccountsNestedInput
  }

  export type UserToGaAccountUncheckedUpdateWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToGaAccountUncheckedUpdateManyWithoutGaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateManyGaPropertyInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    description?: string | null
    gaAccountId?: string | null
    clientId?: string | null
  }

  export type GaChannelDailyCreateManyGaPropertyInput = {
    id?: string
    date: Date | string
    channelGroup: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaImportRunCreateManyGaPropertyInput = {
    id?: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    requestedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaKpiDailyCreateManyGaPropertyInput = {
    id?: string
    date: Date | string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaKpiMonthlyCreateManyGaPropertyInput = {
    id?: string
    month: number
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaSourceDailyCreateManyGaPropertyInput = {
    id?: string
    date: Date | string
    trafficSource: string
    sessions: number
    screenPageViewsPerSession: number
    engagementRate: number
    avgSessionDurationSec: number
    goalCompletions: number
    goalCompletionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    client?: UserUpdateOneWithoutClientConversationsNestedInput
    gaAccount?: GaAccountUpdateOneWithoutConversationsNestedInput
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    queries?: QueryUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    queries?: QueryUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GaChannelDailyUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaChannelDailyUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaChannelDailyUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channelGroup?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaImportRunUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: UserUpdateOneRequiredWithoutGaImportRunsNestedInput
  }

  export type GaImportRunUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaImportRunUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiDailyUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaKpiMonthlyUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyUncheckedUpdateWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaSourceDailyUncheckedUpdateManyWithoutGaPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    trafficSource?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    screenPageViewsPerSession?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    avgSessionDurationSec?: IntFieldUpdateOperationsInput | number
    goalCompletions?: IntFieldUpdateOperationsInput | number
    goalCompletionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    accountRepId?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    accountRep?: UserUpdateOneWithoutClientsNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManyParentInput = {
    id?: string
    content: string
    senderId: string
    recipientId: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    threadId?: string | null
  }

  export type MessageAttachmentCreateManyMessageInput = {
    id?: string
    filename: string
    fileSize: number
    mimeType: string
    url: string
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUpdateManyWithoutParentNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageAttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedPieGraphDataCreateManyQueryInput = {
    id?: string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    prevSessionsDiff: number
    prevConversionRateDiff: number
    prevConversionsDiff: number
    prevBouncesDiff: number
    yearSessionsDiff: number
    yearConversionRateDiff: number
    yearConversionsDiff: number
    yearBouncesDiff: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParsedQueryDataCreateManyQueryInput = {
    id?: string
    date: Date | string
    channel: string
    source: string
    sessions: number
    conversionRate: number
    conversions: number
    bounces: number
    createdAt?: Date | string
    bounceRate?: number | null
    engagedSessions?: number | null
    newUsers?: number | null
  }

  export type ParsedQuerySummaryCreateManyQueryInput = {
    id?: string
    date: Date | string
    totalEngagedSessions: number
    averageBounceRate: number
    totalNewUsers: number
    totalConversions: number
    createdAt?: Date | string
  }

  export type ParsedPieGraphDataUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedPieGraphDataUncheckedUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedPieGraphDataUncheckedUpdateManyWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    prevSessionsDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    prevConversionsDiff?: FloatFieldUpdateOperationsInput | number
    prevBouncesDiff?: FloatFieldUpdateOperationsInput | number
    yearSessionsDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionRateDiff?: FloatFieldUpdateOperationsInput | number
    yearConversionsDiff?: FloatFieldUpdateOperationsInput | number
    yearBouncesDiff?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQueryDataUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedQueryDataUncheckedUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedQueryDataUncheckedUpdateManyWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sessions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    bounces?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    engagedSessions?: NullableIntFieldUpdateOperationsInput | number | null
    newUsers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParsedQuerySummaryUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQuerySummaryUncheckedUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedQuerySummaryUncheckedUpdateManyWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEngagedSessions?: IntFieldUpdateOperationsInput | number
    averageBounceRate?: FloatFieldUpdateOperationsInput | number
    totalNewUsers?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramFollowersByCityCreateManySproutInstagramAnalyticsInput = {
    id?: string
    city: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutInstagramFollowersByCountryCreateManySproutInstagramAnalyticsInput = {
    id?: string
    country: string
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutInstagramFollowersByCityUpdateWithoutSproutInstagramAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramFollowersByCityUncheckedUpdateWithoutSproutInstagramAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramFollowersByCityUncheckedUpdateManyWithoutSproutInstagramAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramFollowersByCountryUpdateWithoutSproutInstagramAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramFollowersByCountryUncheckedUpdateWithoutSproutInstagramAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramFollowersByCountryUncheckedUpdateManyWithoutSproutInstagramAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutFacebookAnalyticsCreateManySproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postPhotoViewClicks?: number | null
    tabViews?: number | null
    videoViews?: number | null
    videoViews10s?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    videoViewsUnique?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    netFollowerGrowth?: number | null
  }

  export type SproutFacebookPostCreateManySproutSocialAccountInput = {
    id?: string
    postType: string
    postStatus: string
    postLink: string
    postText: string
    postNativeId: string
    postCreatedTime: Date | string
    postSentTime: Date | string
    postLastUpdated: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutFacebookPostAnalyticsCreateManySproutSocialAccountInput = {
    id?: string
    angryReactions?: number | null
    clientNativeId: string
    commentsCount?: number | null
    hahaReactions?: number | null
    impressions?: number | null
    impressionsFollower?: number | null
    impressionsNonFollower?: number | null
    impressionsNonViral?: number | null
    impressionsOrganic?: number | null
    impressionsPaid?: number | null
    impressionsViral?: number | null
    likes?: number | null
    loveReactions?: number | null
    postContentClicks?: number | null
    postContentClicksOther?: number | null
    postLinkClicks?: number | null
    postNativeId: string
    postPhotoViewClicks?: number | null
    postVideoPlayClicks?: number | null
    questionAnswers?: number | null
    reach?: number | null
    reachFollower?: number | null
    reachNonViral?: number | null
    reachOrganic?: number | null
    reachPaid?: number | null
    reachViral?: number | null
    reactions?: number | null
    reportingDate: Date | string
    sadReactions?: number | null
    sharesCount?: number | null
    videoLength?: number | null
    videoViews?: number | null
    videoViewsAutoplay?: number | null
    videoViewsOrganic?: number | null
    videoViewsPaid?: number | null
    wowReactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutInstagramAnalyticsCreateManySproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    commentsCount?: number | null
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    likes?: number | null
    saves?: number | null
    videoViews?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailContacts?: number | null
    getDirectionsClicks?: number | null
    phoneCallClicks?: number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: number | null
    profileFollowerAdds?: number | null
    profileFollowers?: number | null
    profileImpressionsUnique?: number | null
    profileReachUnique?: number | null
    profileViews?: number | null
    profileViewsUnique?: number | null
    websiteClicks?: number | null
  }

  export type SproutLinkedInAnalyticsCreateManySproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    engagements?: number | null
    impressions?: number | null
    impressionsUnique?: number | null
    followersCount?: number | null
    reactions?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutPinterestAnalyticsCreateManySproutSocialAccountInput = {
    id?: string
    customerProfileId: number
    reportingDate: Date | string
    followersCount?: number | null
    followingCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToSproutSocialAccountCreateManySproutSocialAccountInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SproutFacebookAnalyticsUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    tabViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews10s?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netFollowerGrowth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SproutFacebookAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    tabViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews10s?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netFollowerGrowth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SproutFacebookAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    tabViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews10s?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    netFollowerGrowth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SproutFacebookPostUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    postStatus?: StringFieldUpdateOperationsInput | string
    postLink?: StringFieldUpdateOperationsInput | string
    postText?: StringFieldUpdateOperationsInput | string
    postNativeId?: StringFieldUpdateOperationsInput | string
    postCreatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postSentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postLastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutFacebookPostUncheckedUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    postStatus?: StringFieldUpdateOperationsInput | string
    postLink?: StringFieldUpdateOperationsInput | string
    postText?: StringFieldUpdateOperationsInput | string
    postNativeId?: StringFieldUpdateOperationsInput | string
    postCreatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postSentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postLastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutFacebookPostUncheckedUpdateManyWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    postStatus?: StringFieldUpdateOperationsInput | string
    postLink?: StringFieldUpdateOperationsInput | string
    postText?: StringFieldUpdateOperationsInput | string
    postNativeId?: StringFieldUpdateOperationsInput | string
    postCreatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postSentTime?: DateTimeFieldUpdateOperationsInput | Date | string
    postLastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutFacebookPostAnalyticsUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    angryReactions?: NullableIntFieldUpdateOperationsInput | number | null
    clientNativeId?: StringFieldUpdateOperationsInput | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    hahaReactions?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsViral?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    loveReactions?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postNativeId?: StringFieldUpdateOperationsInput | string
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postVideoPlayClicks?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswers?: NullableIntFieldUpdateOperationsInput | number | null
    reach?: NullableIntFieldUpdateOperationsInput | number | null
    reachFollower?: NullableIntFieldUpdateOperationsInput | number | null
    reachNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    reachOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    reachPaid?: NullableIntFieldUpdateOperationsInput | number | null
    reachViral?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sadReactions?: NullableIntFieldUpdateOperationsInput | number | null
    sharesCount?: NullableIntFieldUpdateOperationsInput | number | null
    videoLength?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsAutoplay?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    wowReactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutFacebookPostAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    angryReactions?: NullableIntFieldUpdateOperationsInput | number | null
    clientNativeId?: StringFieldUpdateOperationsInput | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    hahaReactions?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsViral?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    loveReactions?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postNativeId?: StringFieldUpdateOperationsInput | string
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postVideoPlayClicks?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswers?: NullableIntFieldUpdateOperationsInput | number | null
    reach?: NullableIntFieldUpdateOperationsInput | number | null
    reachFollower?: NullableIntFieldUpdateOperationsInput | number | null
    reachNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    reachOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    reachPaid?: NullableIntFieldUpdateOperationsInput | number | null
    reachViral?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sadReactions?: NullableIntFieldUpdateOperationsInput | number | null
    sharesCount?: NullableIntFieldUpdateOperationsInput | number | null
    videoLength?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsAutoplay?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    wowReactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutFacebookPostAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    angryReactions?: NullableIntFieldUpdateOperationsInput | number | null
    clientNativeId?: StringFieldUpdateOperationsInput | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    hahaReactions?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonFollower?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsViral?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    loveReactions?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postContentClicksOther?: NullableIntFieldUpdateOperationsInput | number | null
    postLinkClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postNativeId?: StringFieldUpdateOperationsInput | string
    postPhotoViewClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postVideoPlayClicks?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswers?: NullableIntFieldUpdateOperationsInput | number | null
    reach?: NullableIntFieldUpdateOperationsInput | number | null
    reachFollower?: NullableIntFieldUpdateOperationsInput | number | null
    reachNonViral?: NullableIntFieldUpdateOperationsInput | number | null
    reachOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    reachPaid?: NullableIntFieldUpdateOperationsInput | number | null
    reachViral?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sadReactions?: NullableIntFieldUpdateOperationsInput | number | null
    sharesCount?: NullableIntFieldUpdateOperationsInput | number | null
    videoLength?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsAutoplay?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsOrganic?: NullableIntFieldUpdateOperationsInput | number | null
    videoViewsPaid?: NullableIntFieldUpdateOperationsInput | number | null
    wowReactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutInstagramAnalyticsUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    saves?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailContacts?: NullableIntFieldUpdateOperationsInput | number | null
    getDirectionsClicks?: NullableIntFieldUpdateOperationsInput | number | null
    phoneCallClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowerAdds?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    profileImpressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileReachUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileViews?: NullableIntFieldUpdateOperationsInput | number | null
    profileViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    websiteClicks?: NullableIntFieldUpdateOperationsInput | number | null
    followersByCity?: SproutInstagramFollowersByCityUpdateManyWithoutSproutInstagramAnalyticsNestedInput
    followersByCountry?: SproutInstagramFollowersByCountryUpdateManyWithoutSproutInstagramAnalyticsNestedInput
  }

  export type SproutInstagramAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    saves?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailContacts?: NullableIntFieldUpdateOperationsInput | number | null
    getDirectionsClicks?: NullableIntFieldUpdateOperationsInput | number | null
    phoneCallClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowerAdds?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    profileImpressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileReachUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileViews?: NullableIntFieldUpdateOperationsInput | number | null
    profileViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    websiteClicks?: NullableIntFieldUpdateOperationsInput | number | null
    followersByCity?: SproutInstagramFollowersByCityUncheckedUpdateManyWithoutSproutInstagramAnalyticsNestedInput
    followersByCountry?: SproutInstagramFollowersByCountryUncheckedUpdateManyWithoutSproutInstagramAnalyticsNestedInput
  }

  export type SproutInstagramAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    saves?: NullableIntFieldUpdateOperationsInput | number | null
    videoViews?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailContacts?: NullableIntFieldUpdateOperationsInput | number | null
    getDirectionsClicks?: NullableIntFieldUpdateOperationsInput | number | null
    phoneCallClicks?: NullableIntFieldUpdateOperationsInput | number | null
    postsSendByContentType?: NullableJsonNullValueInput | InputJsonValue
    postsSentByPostType?: NullableJsonNullValueInput | InputJsonValue
    postsSentCount?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowerAdds?: NullableIntFieldUpdateOperationsInput | number | null
    profileFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    profileImpressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileReachUnique?: NullableIntFieldUpdateOperationsInput | number | null
    profileViews?: NullableIntFieldUpdateOperationsInput | number | null
    profileViewsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    websiteClicks?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SproutLinkedInAnalyticsUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutLinkedInAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutLinkedInAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: NullableIntFieldUpdateOperationsInput | number | null
    impressions?: NullableIntFieldUpdateOperationsInput | number | null
    impressionsUnique?: NullableIntFieldUpdateOperationsInput | number | null
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    reactions?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutPinterestAnalyticsUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    followingCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutPinterestAnalyticsUncheckedUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    followingCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SproutPinterestAnalyticsUncheckedUpdateManyWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: IntFieldUpdateOperationsInput | number
    reportingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    followersCount?: NullableIntFieldUpdateOperationsInput | number | null
    followingCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToSproutSocialAccountUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSproutSocialAccountsNestedInput
  }

  export type UserToSproutSocialAccountUncheckedUpdateWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToSproutSocialAccountUncheckedUpdateManyWithoutSproutSocialAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientActivityCreateManyUserInput = {
    id?: string
    type: string
    description: string
    status?: $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientSatisfactionCreateManyAccountRepInput = {
    id?: string
    rating: number
    feedback?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type ClientSatisfactionCreateManyUserInput = {
    id?: string
    rating: number
    feedback?: string | null
    accountRepId: string
    createdAt?: Date | string
  }

  export type ConversationCreateManyClientInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    description?: string | null
    gaAccountId?: string | null
    gaPropertyId?: string | null
  }

  export type ConversationCreateManyUserInput = {
    id?: string
    title: string
    isStarred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    gaAccountId?: string | null
    gaPropertyId?: string | null
    clientId?: string | null
  }

  export type GaImportRunCreateManyRequestedByInput = {
    id?: string
    gaPropertyId: string
    dateStart: Date | string
    dateEnd: Date | string
    status?: $Enums.ImportStatus
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyRecipientInput = {
    id?: string
    content: string
    senderId: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    parentId?: string | null
    threadId?: string | null
  }

  export type MessageCreateManySenderInput = {
    id?: string
    content: string
    recipientId: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    archived?: boolean
    isThreadStart?: boolean
    parentId?: string | null
    threadId?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueryCreateManyUserInput = {
    id?: string
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: string
    status?: $Enums.QueryStatus
    conversationId?: string | null
    rating?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionCreateManyUserInput = {
    id?: string
    expires: Date | string
    sessionToken: string
  }

  export type TicketCreateManyAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
  }

  export type TicketCreateManyClientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
  }

  export type TicketCommentCreateManyAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketId: string
  }

  export type UserCreateManyAccountRepInput = {
    id?: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    emailVerified?: Date | string | null
    image?: string | null
    name?: string | null
    isActive?: boolean
    password?: string | null
    deleted?: boolean
    companyId?: string | null
  }

  export type UserToEmailClientCreateManyUserInput = {
    id?: string
    emailClientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToGaAccountCreateManyUserInput = {
    id?: string
    gaAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToSproutSocialAccountCreateManyUserInput = {
    id?: string
    sproutSocialAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSatisfactionUpdateWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGivenRatingsNestedInput
  }

  export type ClientSatisfactionUncheckedUpdateWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSatisfactionUncheckedUpdateManyWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSatisfactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountRep?: UserUpdateOneRequiredWithoutReceivedRatingsNestedInput
  }

  export type ClientSatisfactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSatisfactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    accountRepId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaAccount?: GaAccountUpdateOneWithoutConversationsNestedInput
    gaProperty?: GaPropertyUpdateOneWithoutConversationsNestedInput
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    queries?: QueryUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    queries?: QueryUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    client?: UserUpdateOneWithoutClientConversationsNestedInput
    gaAccount?: GaAccountUpdateOneWithoutConversationsNestedInput
    gaProperty?: GaPropertyUpdateOneWithoutConversationsNestedInput
    queries?: QueryUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    queries?: QueryUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    gaPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GaImportRunUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaProperty?: GaPropertyUpdateOneRequiredWithoutImportsNestedInput
  }

  export type GaImportRunUncheckedUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaImportRunUncheckedUpdateManyWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaPropertyId?: StringFieldUpdateOperationsInput | string
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    isThreadStart?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUpdateManyWithoutQueryNestedInput
    parsedData?: ParsedQueryDataUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUpdateManyWithoutQueryNestedInput
    conversation?: ConversationUpdateOneWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
    parsedPieData?: ParsedPieGraphDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedData?: ParsedQueryDataUncheckedUpdateManyWithoutQueryNestedInput
    parsedSummary?: ParsedQuerySummaryUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lineGraphData?: NullableJsonNullValueInput | InputJsonValue
    pieGraphData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
  }

  export type TicketUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutClientTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TicketTagUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketCommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUpdateManyWithoutClientNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    queries?: QueryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    clients?: UserUpdateManyWithoutAccountRepNestedInput
    company?: CompanyUpdateOneWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ClientActivityUncheckedUpdateManyWithoutUserNestedInput
    receivedRatings?: ClientSatisfactionUncheckedUpdateManyWithoutAccountRepNestedInput
    givenRatings?: ClientSatisfactionUncheckedUpdateManyWithoutUserNestedInput
    clientConversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    gaImportRuns?: GaImportRunUncheckedUpdateManyWithoutRequestedByNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    queries?: QueryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    clientTickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    clients?: UserUncheckedUpdateManyWithoutAccountRepNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    emailClients?: UserToEmailClientUncheckedUpdateManyWithoutUserNestedInput
    userToGaAccounts?: UserToGaAccountUncheckedUpdateManyWithoutUserNestedInput
    sproutSocialAccounts?: UserToSproutSocialAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAccountRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserToEmailClientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailClient?: EmailClientUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserToEmailClientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToEmailClientUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailClientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToGaAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gaAccount?: GaAccountUpdateOneRequiredWithoutUserToGaAccountsNestedInput
  }

  export type UserToGaAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToGaAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gaAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToSproutSocialAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sproutSocialAccount?: SproutSocialAccountUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserToSproutSocialAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToSproutSocialAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sproutSocialAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentCreateManyTicketInput = {
    id?: string
    name: string
    url: string
    createdAt?: Date | string
  }

  export type TicketCommentCreateManyTicketInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
  }

  export type TicketAttachmentUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketTagUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTagUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTagUncheckedUpdateManyWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    client?: UserUpdateOneRequiredWithoutClientTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}